quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security,"erator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. .. _alpha-cplusplus-MismatchedIterator:. alpha.cplusplus.MismatchedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of iterators of different containers where iterators of the same container are expected. .. code-block:: cpp. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. .. _alpha-cplusplus-MisusedMovedObject:. alpha.cplusplus.MisusedMovedObject (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Method calls on a moved-from object and copying a moved-from object will be reported. .. code-block:: cpp. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. .. _alpha-cplusplus-SmartPtr:. alpha.cplusplus.SmartPtr (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereference of null smart pointers. .. code-block:: cpp. void deref_smart_ptr() {; std::unique_ptr<int> P;; *P; // warn: dereference of a default constr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:54900,access,accessed,54900,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['access'],['accessed']
Security,"ere are no matches. In the; case of debuggers we optimized for lookups that fail most of the time. Each table that is defined should have strict rules on exactly what is in the; accelerator tables and documented so clients can rely on the content. Hash Tables; ^^^^^^^^^^^. Standard Hash Tables; """""""""""""""""""""""""""""""""""""""". Typical hash tables have a header, buckets, and each bucket points to the; bucket contents:. .. code-block:: none. .------------.; | HEADER |; |------------|; | BUCKETS |; |------------|; | DATA |; `------------'. The BUCKETS are an array of offsets to DATA for each hash:. .. code-block:: none. .------------.; | 0x00001000 | BUCKETS[0]; | 0x00002000 | BUCKETS[1]; | 0x00002200 | BUCKETS[2]; | 0x000034f0 | BUCKETS[3]; | | ...; | 0xXXXXXXXX | BUCKETS[n_buckets]; '------------'. So for ``bucket[3]`` in the example above, we have an offset into the table; 0x000034f0 which points to a chain of entries for the bucket. Each bucket must; contain a next pointer, full 32 bit hash value, the string itself, and the data; for the current string value. .. code-block:: none. .------------.; 0x000034f0: | 0x00003500 | next pointer; | 0x12345678 | 32 bit hash; | ""erase"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003500: | 0x00003550 | next pointer; | 0x29273623 | 32 bit hash; | ""dump"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003550: | 0x00000000 | next pointer; | 0x82638293 | 32 bit hash; | ""main"" | string value; | data[n] | HashData for this bucket; `------------'. The problem with this layout for debuggers is that we need to optimize for the; negative lookup case where the symbol we're searching for is not present. So; if we were to lookup ""``printf``"" in the table above, we would make a 32-bit; hash for ""``printf``"", it might match ``bucket[3]``. We would need to go to; the offset 0x000034f0 and start looking to see if our 32 bit hash matches. To; do so, we need to read the next pointer, then read the hash,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:61544,hash,hash,61544,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"ere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78325,sanitiz,sanitizers,78325,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitizers']
Security,"erefore, the vector; and scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different SAs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is; required to ensure synchronization between vector memory operations of; different SAs. It ensures a previous vector memory operation has completed; before executing a subsequent vector memory and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L2 cache can be kept coherent with other agents on some targets, or ranges; of virtual addresses can be set up to bypass it to ensure system coherence.; * On GFX10.3 and GFX11 a memory attached last level (MALL) cache exists for GPU memory.; The MALL cache is fully coherent with GPU memory and has no impact on system; coherence. All agents (GPU and CPU) access GPU memory through the MALL cache. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:340007,access,access,340007,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"erenceable_or_null`` (if the pointer is non-null) and the; ``sret``, ``byval``, ``byref``, ``inalloca``, ``preallocated`` family of; attributes. Note that not all of these combinations are useful, e.g.; ``byval`` arguments are known to be writable even without this attribute. The ``writable`` attribute cannot be combined with ``readnone``,; ``readonly`` or a ``memory`` attribute that does not contain; ``argmem: write``. ``dead_on_unwind``; At a high level, this attribute indicates that the pointer argument is dead; if the call unwinds, in the sense that the caller will not depend on the; contents of the memory. Stores that would only be visible on the unwind; path can be elided. More precisely, the behavior is as-if any memory written through the; pointer during the execution of the function is overwritten with a poison; value on unwind. This includes memory written by the implicit write implied; by the ``writable`` attribute. The caller is allowed to access the affected; memory, but all loads that are not preceded by a store will return poison. This attribute cannot be applied to return values. .. _gc:. Garbage Collector Strategy Names; --------------------------------. Each function may specify a garbage collector strategy name, which is simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow fronte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:71585,access,access,71585,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"erencing implicit location; descriptions created by the ``DW_OP_implicit_pointer`` and; ``DW_OP_LLVM_aspace_implicit_pointer`` operations. Note: Since location descriptions are allowed on the stack, the; ``DW_OP_stack_value`` operation no longer terminates the DWARF operation; expression execution as in DWARF Version 5. 3. ``DW_OP_implicit_pointer``. *An optimizing compiler may eliminate a pointer, while still retaining the; value that the pointer addressed.* ``DW_OP_implicit_pointer`` *allows a; producer to describe this value.*. ``DW_OP_implicit_pointer`` *specifies an object is a pointer to the target; architecture default address space that cannot be represented as a real; pointer, even though the value it would point to can be described. In this; form, the location description specifies a debugging information entry that; represents the actual location description of the object to which the; pointer would point. Thus, a consumer of the debug information would be able; to access the dereferenced pointer, even when it cannot access the pointer; itself.*. ``DW_OP_implicit_pointer`` has two operands. The first operand is a 4-byte; unsigned value in the 32-bit DWARF format, or an 8-byte unsigned value in; the 64-bit DWARF format, that represents the byte offset DR of a debugging; information entry D relative to the beginning of the ``.debug_info`` section; that contains the current compilation unit. The second operand is a signed; LEB128 integer that represents a byte displacement B. *Note that D might not be in the current compilation unit.*. *The first operand interpretation is exactly like that for*; ``DW_FORM_ref_addr``\ *.*. The address space identifier AS is defined as the one corresponding to the; target architecture specific default address space. The address size S is defined as the address bit size of the target; architecture specific address space corresponding to AS. An implicit location storage LS is created with the debugging information; entry D, addre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:123115,access,access,123115,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['access'],['access']
Security,"erformed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_wbinvl1_vol`` is required as described in; the following item. * A ``buffer_wbinvl1_vol`` is required for coherence between wavefronts; executing in different work-groups as they may be executing on different; CUs. * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a group of CUs. The scalar and vector L1 caches are not coherent. However,; scalar operations are used in a restricted way so do not impact the memory; model. See :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory operations use an L2 cache shared by all CUs on; the same agent. * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each CU has a separate request queue per channel. Therefore, the vector and; scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different CUs), or the same; work-group if executing in tgsplit mode, of an agent can be reordered; relative to each other. A ``s_waitcnt vmcnt(0)`` is required to ensure; synchronization between vector memory operations of different CUs. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to mee",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:236536,access,access,236536,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"eric class will be used if the ``-disable-cb``; flag is used or if a target specific CustomBehaviour class doesn't exist for; that target. (The generic class does nothing.) Currently, the CustomBehaviour; class is only a part of the in-order pipeline, but there are plans to add it; to the out-of-order pipeline in the future. CustomBehaviour's main method is `checkCustomHazard()` which uses the; current instruction and a list of all instructions still executing within; the pipeline to determine if the current instruction should be dispatched.; As output, the method returns an integer representing the number of cycles; that the current instruction must stall for (this can be an underestimate; if you don't know the exact number and a value of 0 represents no stall). If you'd like to add a CustomBehaviour class for a target that doesn't; already have one, refer to an existing implementation to see how to set it; up. The classes are implemented within the target specific backend (for; example `/llvm/lib/Target/AMDGPU/MCA/`) so that they can access backend symbols. Instrument Manager; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; On certain architectures, scheduling information for certain instructions; do not contain all of the information required to identify the most precise; schedule class. For example, data that can have an impact on scheduling can; be stored in CSR registers. One example of this is on RISCV, where values in registers such as `vtype`; and `vl` change the scheduling behaviour of vector instructions. Since MCA; does not keep track of the values in registers, instrument comments can; be used to specify these values. InstrumentManager's main function is `getSchedClassID()` which has access; to the MCInst and all of the instruments that are active for that MCInst.; This function can use the instruments to override the schedule class of; the MCInst. On RISCV, instrument comments containing LMUL information are used; by `getSchedClassID()` to map a vector instructi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:45624,access,access,45624,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['access'],['access']
Security,"ering in headless web browser (Chrome or Firefox) and; creates png or jpeg image out of it. ## Database Libraries. ## Networking Libraries. ### THttpServer. - upgrade civetweb code to version 1.15, supports SSL version 3.0; - resolve problem with symbolic links usage on Windows; - let disable/enable directory files listing via THttpServer (default is off); - enable usage of unix sockets, used by `rootssh` script for tunnel to remote session. ## GUI Libraries. - Provide web-based TTree viewer, integrated with RBrowser; - Support Edge browser on Windows for all kinds of web widgets; - Provide `rootssh` shell script to simplify use of web-based widgets on remote nodes:; ```; [localnode] rootssh user@remotenode; [remotenode] root --web -e 'new TBrowser'; ```; Script automatically configures ssh tunnel between local and remote nodes, one the remote node; unix socket with strict 0700 mode is used. When ROOT running on remote node wants to display; new web widget, script will automatically start web browser on local node with appropriate URL,; accessing widget via configured ssh tunnel. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - Major JSROOT upgrade to version 7, using ES6 modules and classes. ## Tutorials. - Several new tutorials have been added in both C++ and Python in the `tutorial/tmva` directory.; Tutorials like `TMVA_Higgs_Classification.py` shows the new pythonizations available in TMVA and; new `TMVA_SOFIE_...` tutorials show th eusage of SOFIE in both C++ or Python. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - Building external applications that use ROOT oftentimes fail if there is a mismatch in the C++ standard between ROOT and the application. As of v6.28, suchs builds will issue a warning if the C++ standard does not match ROOT's, i.e. if there is a mismatch in the value of the `__cplusplus` preprocessor macro w.r.t. when ROOT was configured. ## PyROOT. - A `.rootlogon.py` file wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:32695,access,accessing,32695,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['access'],['accessing']
Security,"ernel executing on a GPU. 1. A pointer to an AQL queue for the kernel agent on which the kernel is to be; executed is obtained.; 2. A pointer to the kernel descriptor (see; :ref:`amdgpu-amdhsa-kernel-descriptor`) of the kernel to execute is obtained.; It must be for a kernel that is contained in a code object that was loaded; by an HSA compatible runtime on the kernel agent with which the AQL queue is; associated.; 3. Space is allocated for the kernel arguments using the HSA compatible runtime; allocator for a memory region with the kernarg property for the kernel agent; that will execute the kernel. It must be at least 16-byte aligned.; 4. Kernel argument values are assigned to the kernel argument memory; allocation. The layout is defined in the *HSA Programmer's Language; Reference* [HSA]_. For AMDGPU the kernel execution directly accesses the; kernel argument memory in the same way constant memory is accessed. (Note; that the HSA specification allows an implementation to copy the kernel; argument contents to another location that is accessed by the kernel.); 5. An AQL kernel dispatch packet is created on the AQL queue. The HSA compatible; runtime api uses 64-bit atomic operations to reserve space in the AQL queue; for the packet. The packet must be set up, and the final write must use an; atomic store release to set the packet kind to ensure the packet contents are; visible to the kernel agent. AQL defines a doorbell signal mechanism to; notify the kernel agent that the AQL queue has been updated. These rules, and; the layout of the AQL queue and kernel dispatch packet is defined in the *HSA; System Architecture Specification* [HSA]_.; 6. A kernel dispatch packet includes information about the actual dispatch,; such as grid and work-group size, together with information from the code; object about the kernel, such as segment sizes. The HSA compatible runtime; queries on the kernel symbol can be used to obtain the code object values; which are recorded in the :ref:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:150943,access,accessed,150943,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"erride {; OS << Path << "" is malformed"";; }. std::error_code convertToErrorCode() const override {; return make_error_code(object_error::parse_failed);; }; };. char BadFileFormat::ID; // This should be declared in the C++ file. Error printFormattedFile(StringRef Path) {; if (<check for valid format>); return make_error<BadFileFormat>(Path);; // print file contents.; return Error::success();; }. Error values can be implicitly converted to bool: true for error, false for; success, enabling the following idiom:. .. code-block:: c++. Error mayFail();. Error foo() {; if (auto Err = mayFail()); return Err;; // Success! We can proceed.; ... For functions that can fail but need to return a value the ``Expected<T>``; utility can be used. Values of this type can be constructed with either a; ``T``, or an ``Error``. Expected<T> values are also implicitly convertible to; boolean, but with the opposite convention to ``Error``: true for success, false; for error. If success, the ``T`` value can be accessed via the dereference; operator. If failure, the ``Error`` value can be extracted using the; ``takeError()`` method. Idiomatic usage looks like:. .. code-block:: c++. Expected<FormattedFile> openFormattedFile(StringRef Path) {; // If badly formatted, return an error.; if (auto Err = checkFormat(Path)); return std::move(Err);; // Otherwise return a FormattedFile instance.; return FormattedFile(Path);; }. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; if (auto FileOrErr = openFormattedFile(Path)) {; // On success, grab a reference to the file and continue.; auto &File = *FileOrErr;; ...; } else; // On error, extract the Error value and return it.; return FileOrErr.takeError();; }. If an ``Expected<T>`` value is in success mode then the ``takeError()`` method; will return a success value. Using this fact, the above function can be; rewritten as:. .. code-block:: c++. Error processFormattedFile(StringRef Path) {; // Try to open a formatted file; auto Fi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:20515,access,accessed,20515,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security,"error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent statistical treatment to extract the; model parameters from purely statistical distributions. Simulation of expected data is another important aspect in data; analysis. By repeated generation of ""pseudo-data"", which are analysed in; the same manner as intended for the real data, analysis procedures can; be validated or compared. In many cases, the distribution of the; measurement errors is not precisely known, and simulation offers the; possibility to test the effects of different assumptions. A powerful software framework addressing all of the above requirements; is ROOT, an open source project coordinated by the European Organisation for; Nuclear Research, CERN in Geneva. ROOT is very flexible and provides both a programming interface to use in own; applications and a graphical user interface for interactive data analysis. The; purpose of this document is to serve as a beginners guide and provides extendable; examples for your own use cases, based on typical problems addressed in; student labs. This guide will hopefully lay the ground for more complex; applications in your future scientific work building on a modern,; state-of the art tool for data analysis. This guide in form of a tutorial is intended to introduce you quickly ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:2775,validat,validated,2775,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['validat'],['validated']
Security,"ers to [specify; their](https://root.cern.ch/doc/master/classTArrow.html) shapes. Do not; underestimate the role of lines and arrows in your plots. Since each; plot should contain a message, it is convenient to stress it with; additional graphics primitives. ### Text. Also text plays a fundamental role in making the plots self-explanatory.; A possibility to add text in your plot is provided by the `TLatex`; class. The objects of this class are constructed with the coordinates of; the bottom-left corner of the text and a string which contains the text; itself. The real twist is that ordinary; [Latex mathematical symbols](https://root.cern.ch/doc/master/classTLatex.html#L5); are automatically interpreted, you just need to replace the ""\\"" by a ""\#"". If; [""\\"" is used as control character](https://root.cern.ch/doc/master/classTLatex.html#L14); , then the; [TMathText interface](https://root.cern.ch/doc/master/classTMathText.html); is invoked. It provides the plain TeX syntax and allow to access character's; set like Russian and Japanese. ## Interpretation and Compilation. As you observed, up to now we heavily exploited the capabilities of ROOT; for interpreting our code, more than compiling and then executing. This; is sufficient for a wide range of applications, but you might have; already asked yourself ""how can this code be compiled ?"". There are two; answers. ### Compile a Macro with ACLiC. ACLiC will create for you a compiled dynamic library for your macro,; without any effort from your side, except the insertion of the; appropriate header files in lines *5--11*. In this example, they are; already included. To generate an object library from the macro code, from inside the; interpreter type (please note the ""+""):. ``` {.cpp}; root [1] .L macro1.C+; ```. Once this operation is accomplished, the macro symbols will be available; in memory and you will be able to execute it simply by calling from; inside the interpreter:. ``` {.cpp}; root [2] macro1(); ```. ### Compile ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:8906,access,access,8906,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['access'],['access']
Security,"ers. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source, and; the third is the number of counters associated with ``name``. It is an; error if ``hash`` or ``num-counters`` differ between two instances of; ``instrprof.increment`` that refer to the same name. The last argument refers to which of the counters for ``name`` should; be incremented. It should be a value between 0 and ``num-counters``. Semantics:; """""""""""""""""""". This intrinsic represents an increment of a profiling counter. It will; cause the ``-instrprof`` pass to generate the appropriate data; structures and the code to increment the appropriate value, in a; format that can be written out by a compiler runtime and consumed via; the ``llvm-profdata`` tool. '``llvm.instrprof.increment.step``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.increment.step(ptr <name>, i64 <hash>,; i32 <num-counters>,; i32 <index>, i64 <step>). Overview:; """""""""""""""""". The '``llvm.instrprof.increment.step``' intrinsic is an extension to; the '``llvm.instrprof.increment``' intrinsic with an additional fifth; argument to specify the step of the increment. Arguments:; """"""""""""""""""""; The first four arguments are the same as '``llvm.instrprof.increment``'; intrinsic. The last argument specifies the value of the increment of the counter variable. Semantics:; """"""""""""""""""""; See description of '``llvm.instrprof.increment``' intrinsic. '``llvm.instrprof.timestamp``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.timestamp(i8* <name>, i64 <hash>,; i32 <num-counters>, i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.timestamp``' intrinsic is used to implement temporal; profiling. Arguments:; """"""""""""""""""""; The arguments are the same as '``llvm.instrprof.increment``'. The ``index`` is; expected to always be zero. Semantics:; """"""""""""""""""""; Simi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:528426,hash,hash,528426,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security,"ersion To |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. The combination of type version from/to, type name, and content identifier should be unique in the list.; However, not every type needs to provide additional type information. The following kinds of content are supported:. | Content identifier | Meaning of content |; |---------------------|-----------------------------------------------------|; | 0x00 | Serialized ROOT streamer info; see notes |. The serialized ROOT streamer info is not bound to a specific type.; It is the combined streamer information from all fields serialized by the ROOT streamer.; Writers set version from/to to zero and use an empty type name.; Readers should ignore the type-specific information.; The format of the content is a ROOT streamed `TList` of `TStreamerInfo` objects. ### Footer Envelope. The footer envelope has the following structure:. - Feature flags; - Header checksum (XxHash-3 64bit); - Schema extension record frame; - List frame of column group record frames; - List frame of cluster group record frames. The header checksum can be used to cross-check that header and footer belong together.; The meaning of the feature flags is the same as for the header.; The header flags do not need to be repeated.; Readers should combine (logical `or` of the bits) the feature flags from header and footer for the full set of flags. #### Schema Extension Record Frame. The schema extension record frame contains an additional schema description that is incremental; with respect to the schema contained in the header (see Section Header Envelope).; Specifically, it is a record frame with the following four fields; (identical to the last four fields in Header Envelope):. - List frame: list of field record frames; - List frame: list of column record frames; - List frame: list of alias column record frames; - List frame: list of extra type information. In general, a schema extension is optional, and thus this record frame m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:28331,checksum,checksum,28331,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['checksum'],['checksum']
Security,"ert between a private or group address space address (termed a segment; address) and a flat address the base address of the corresponding aperture; can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline; constant registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``.; In 64-bit address mode the aperture sizes are 2^32 bytes and the base is; aligned to 2^32 which makes it easier to convert from flat to segment or; segment to flat. A global address space address has the same value when used as a flat address; so no conversion is needed. **Global and Constant**; The global and constant address spaces both use global virtual addresses,; which are the same virtual address space used by the CPU. However, some; virtual addresses may only be accessible to the CPU, some only accessible; by the GPU, and some by both. Using the constant address space indicates that the data will not change; during the execution of the kernel. This allows scalar read instructions to; be used. As the constant address space could only be modified on the host; side, a generic pointer loaded from the constant address space is safe to be; assumed as a global pointer since only the device global memory is visible; and managed on the host side. The vector and scalar L1 caches are invalidated; of volatile data before each kernel dispatch execution to allow constant; memory to change values between kernel dispatches. **Region**; The region address space uses the hardware Global Data Store (GDS). All; wavefronts executing on the same device will access the same memory for any; given region address. However, the same region address accessed by wavefronts; executing on different devices will access different memory. It is higher; performance than global memory. It is a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:24829,access,accessible,24829,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],['accessible']
Security,"erted; instrumentation points and a runtime library that can dynamically enable and; disable the instrumentation. More high level information about XRay can be found in the `XRay whitepaper`_. This document describes how to use XRay as implemented in LLVM. XRay in LLVM; ============. XRay consists of three main parts:. - Compiler-inserted instrumentation points.; - A runtime library for enabling/disabling tracing at runtime.; - A suite of tools for analysing the traces. **NOTE:** As of July 25, 2018 , XRay is only available for the following; architectures running Linux: x86_64, arm7 (no thumb), aarch64, powerpc64le,; mips, mipsel, mips64, mips64el, NetBSD: x86_64, FreeBSD: x86_64 and; OpenBSD: x86_64. The compiler-inserted instrumentation points come in the form of nop-sleds in; the final generated binary, and an ELF section named ``xray_instr_map`` which; contains entries pointing to these instrumentation points. The runtime library; relies on being able to access the entries of the ``xray_instr_map``, and; overwrite the instrumentation points at runtime. Using XRay; ==========. You can use XRay in a couple of ways:. - Instrumenting your C/C++/Objective-C/Objective-C++ application.; - Generating LLVM IR with the correct function attributes. The rest of this section covers these main ways and later on how to customize; what XRay does in an XRay-instrumented binary. Instrumenting your C/C++/Objective-C Application; ------------------------------------------------. The easiest way of getting XRay instrumentation for your application is by; enabling the ``-fxray-instrument`` flag in your clang invocation. For example:. ::. clang -fxray-instrument ... By default, functions that have at least 200 instructions (or contain a loop) will; get XRay instrumentation points. You can tweak that number through the; ``-fxray-instruction-threshold=`` flag:. ::. clang -fxray-instrument -fxray-instruction-threshold=1 ... The loop detection can be disabled with ``-fxray-ignore-loops`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:1188,access,access,1188,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['access'],['access']
Security,"erver = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); ```. Be aware, that with *lighttpd* one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: `http://lighttpd_host_name/root.app/`. Example of authorization configuration for FastCGI connection:. auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ). ## Integration with existing applications. In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a [THttpServer::Register()](https://root.cern/doc/master/classTHttpServer.html#a73658daf379e87a4832fe9dc5c1483ed) call. Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the `gSystem->ProcessEvents()` call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session. If an application runs in compiled code and does not contain `gSystem->ProcessEvents()` calls, two method are available. ### Asynchronous timer. The first method is to configure an asynchronous timer for the server, like for example:. ```cpp; serv->SetTimer(100, kFALSE);; ```. Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of **`TH1::Fill()`** calls and an histogram object may be incomplete. Therefore such method is not recommended. ### Regular calls of THttpServer::ProcessR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:13076,access,access,13076,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['access']
Security,"erwise we would need to check for `libpng` and `libbzip2` on the system; and adjust `FREETYPE_LIBRARIES` to include `-lpng` and `-lbzip2`.; The current solution goes for the minimal configuration. The original request for; this update was posted [here](https://sft.its.cern.ch/jira/browse/ROOT-7631). ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### THttpServer. Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of; objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class. When command is registered with THttpServer::RegisterCommand() method,; one could configure additional arguments which should be submitted when; command is executed with cmd.json requests. Introduce restriction rules for objects access with THttpServer::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; ne",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:19338,access,accessible,19338,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['access'],['accessible']
Security,"es and strip executables and libraries (Darwin Only)"" OFF). option(LLVM_EXPERIMENTAL_DEBUGINFO_ITERATORS; ""Add extra Booleans to ilist_iterators to communicate facts for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_SPLIT_DWARF; ""Use -gsplit-dwarf when compiling llvm and --gdb-index when linking."" OFF). # Define an option controlling whether we should build for 32-bit on 64-bit; # platforms, where supported.; if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES ""AIX"")); # TODO: support other platforms and toolchains.; option(LLVM_BUILD_32_BITS ""Build 32 bits executables and libraries."" OFF); endif(). # Define the default arguments to use with 'lit', and an option for the user to; # override.; set(LIT_ARGS_DEFAULT ""-sv""); if ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:28307,sanitiz,sanitizer,28307,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,1,['sanitiz'],['sanitizer']
Security,"es for standard button; functions. Let's remember a few standard names and definitions of well; known buttons:. ***`OK`*** - any changed information in a window is accepted and the; window is closed;. ***`Cancel`*** - closes window without implementing submitted changes;. ***`Reset `***- resets defaults and cancels any changed information that; has not be submitted;. ***`Apply`*** - any changed information is accepted and again displayed; in the window that remains open;. ***`Close`*** - closes the window;. ***`Help`*** - opens online Help. Below are examples of text buttons. Note the two placement methods. The; first example should be used when there are one to three command; buttons; the second one when there are more than three buttons. ![](pictures/0200020E.jpg). Picture buttons are usually rectangular in shape with an icon or; graphics label. These buttons may appear alone or placed in a group at; the window's top or side. They are most frequently used to quickly; access commands, many of which are normally accessed through the tool; bar. For example, the picture buttons below can be used to provide; different styles of a histogram drawing. ![](pictures/0200020F.jpg). Here is the example how to create the first button:. ``` {.cpp}; TGPictureButton *fPicture = new TGPictureButton(parent,; gClient->GetPicture(""h1_s.xpm""), 11);; ```. The picture of file h1\_s.xpm is used in the button. All `.xpm` files; are located in the directory `$ROOTSYS/icons`. You can assign a command; directly as a parameter of the picture button constructor. The picture; of **`TGPictureButton`** can be changed by:. ``` {.cpp}; fPicture->SetPicture(""h2_s.xpm"");; ```. The advantage of command buttons is that they are always visible,; providing a reminder of their existence. They can be inscribed with a; meaningful description of what they do by; `TGToolTip(""Some describing text"").` Their activation is much easier and; faster than using a two-step menu bar/pull-down sequence. The only; disadv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:57673,access,access,57673,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,2,['access'],"['access', 'accessed']"
Security,"es passed from the; user/programmer. OpenMP pragmas are an example of the latter. If any such metadata is dropped from the program, the code's semantics; must not change. Metadata on Loops; =================. Attributes can be attached to loops as described in :ref:`llvm.loop`.; Attributes can describe properties of the loop, disable transformations,; force specific transformations and set transformation options. Because metadata nodes are immutable (with the exception of; ``MDNode::replaceOperandWith`` which is dangerous to use on uniqued; metadata), in order to add or remove a loop attributes, a new ``MDNode``; must be created and assigned as the new ``llvm.loop`` metadata. Any; connection between the old ``MDNode`` and the loop is lost. The; ``llvm.loop`` node is also used as LoopID (``Loop::getLoopID()``), i.e.; the loop effectively gets a new identifier. For instance,; ``llvm.mem.parallel_loop_access`` references the LoopID. Therefore, if; the parallel access property is to be preserved after adding/removing; loop attributes, any ``llvm.mem.parallel_loop_access`` reference must be; updated to the new LoopID. Transformation Metadata Structure; =================================. Some attributes describe code transformations (unrolling, vectorizing,; loop distribution, etc.). They can either be a hint to the optimizer; that a transformation might be beneficial, instruction to use a specific; option, , or convey a specific request from the user (such as; ``#pragma clang loop`` or ``#pragma omp simd``). If a transformation is forced but cannot be carried-out for any reason,; an optimization-missed warning must be emitted. Semantic information; such as a transformation being safe (e.g.; ``llvm.mem.parallel_loop_access``) can be unused by the optimizer; without generating a warning. Unless explicitly disabled, any optimization pass may heuristically; determine whether a transformation is beneficial and apply it. If; metadata for another transformation was specified, ap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst:1930,access,access,1930,interpreter/llvm-project/llvm/docs/TransformMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TransformMetadata.rst,1,['access'],['access']
Security,"es that a ""detector"" method to be; implemented and latter should answer the question ""whether functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:5642,access,access,5642,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,2,"['access', 'hash']","['access', 'hash-table']"
Security,"es that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer passed; to our functions does not fit those, something is definitely wrong. - ``""allocation type mismatch""``: when the optional deallocation type mismat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:15159,checksum,checksum,15159,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['checksum'],['checksum']
Security,"es to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:14792,secur,security-sensitive,14792,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security-sensitive']
Security,"es to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done in the deallocation path,; and several options exist to tune this behavior. Usage; =====. Platform; --------; If using Fuchsia or an Android version greater than 11, your memory allocations; are already service by Scudo (note that Android Svelte configurations still use; jemalloc). Library; -------; The allocator static library can be built from the LLVM tree thanks to the; ``scudo_standalone`` CMake rule. The associated tests can be exercised thanks to; the ``check-scudo_standalone`` CMake rule. Linking the static library to your project can require the use of the; ``whole-archive`` linker flag (or equivalent), depending on your linker.; Additional flags might also be necessary. Your linked binary should now make use of the Scudo allocation and deallocation; functions. You may also build Scudo like this:. .. code:: console. cd $LLVM/compiler-rt/l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:5422,access,accesses,5422,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['access'],['accesses']
Security,"es. 487; NAD; Operator overloading in constant expressions; Yes. 488; CD1; Local types, overload resolution, and template argument deduction; Yes (C++11 onwards). 489; NAD; Must member function templates be instantiated during overload resolution?; N/A. 490; CD2; Name lookup in friend declarations; Clang 2.8. 491; CD1; Initializers for empty-class aggregrate members; Duplicate of 413. 492; CD1; typeid constness inconsistent with example; Unknown. 493; CD2; Type deduction from a bool context; Duplicate of 976. 494; CD1; Problems with the resolution of issue 45; Duplicate of 372. 495; CD2; Overload resolution with template and non-template conversion functions; Clang 3.5. 496; CD3; Is a volatile-qualified type really a POD?; Superseded by 2094. 497; CD1; Missing required initialization in example; Superseded by 253. 498; open; Storage class specifiers in definitions of class members; Not resolved. 499; CD2; Throwing an array of unknown size; Yes. 500; CD1; Access in base-specifiers of friend and nested classes; Duplicate of 372. 501; NAD; Visibility of friend declarations within the befriending class; Yes. 502; C++11; Dependency of nested enumerations and enumerators; Yes. 503; open; Cv-qualified function types in template argument deduction; Not resolved. 504; NAD; Should use of a variable in its own initializer require a diagnostic?; Unknown. 505; CD1; Conditionally-supported behavior for unknown character escapes; Yes. 506; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis; Yes. 507; dup; Ambiguity assigning class object to built-in type; Duplicate of 260. 508; C++11; Non-constructed value-initialized objects; N/A. 509; CD1; Dead code in the specification of default initialization; N/A. 510; CD1; Default initialization of POD classes?; N/A. 511; open; POD-structs with template assignment operators; Not resolved. 512; NAD; Union members with user-declared non-default constructors; Yes. 513; CD1; Non-class “most-derived” objects; N/A. 514; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:34162,Access,Access,34162,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"es. The import() method now supports a new argument RenameAllVariablesExcept(const char* suffix, const char keepList) which; will rename all variables of the imported function by extended them with a supplied suffix,; except for a given list of variables, which are not renamed.; A new utility function importFromFile() has been added, which is similar to import, except that it take a string; specifier for the object to be imported rather than a reference. The string is expected to be of the form ; fileName:workspaceName:objectName and simplifies import of objects from other workspaces on file. The importFromFile; accepts all arguments accepted by the standard import() method.; Generic objects (inheriting from TObject) can now also be stored in the workspace under an alias name, rather; under their own name, which simplifies management of objects of types like TMatrixD that do not have a settable name. ws.import(matrix,""cov_matrix"") ;. New accessors have been added that return a RooArgSet of all elements of the workspace of a given type, e.g.; allVars(), allPdfs(). The Print() method now accepts option ""t"", which prints the contents tree-style instead of a flat list of components,; as illustrated below. *** Print() ***. p.d.f.s; -------; RooProdPdf::bkg[ ptBkgPdf * mllBkgPdf * effBkgPdf|pt ] = 0.267845; RooEfficiency::effBkgPdf[ cat=cut effFunc=effBkg ] = 0.76916; RooEfficiency::effSigPdf[ cat=cut effFunc=effSig ] = 0.899817; RooAddPdf::genmodel[ Nsig * sig + Nbkg * bkg ] = 0.502276; RooPolynomial::mllBkgPdf[ x=mll coefList=(mbkg_slope) ] = 0.775; RooGaussian::mllSigPdf[ x=mll mean=msig_mean sigma=msig_sigma ] = 1; RooExponential::ptBkgPdf[ x=pt c=pbkg_slope ] = 0.449329; RooExponential::ptSigPdf[ x=pt c=psig_slope ] = 0.818731; RooProdPdf::sig[ ptSigPdf * mllSigPdf * effSigPdf|pt ] = 0.736708. functions; --------; RooFormulaVar::effBkg[ actualVars=(pt,ab,mb,sb) formula=""0.5*@1*(1+TMath::Erf((@0-@2)/@3))"" ] = 0.76916; RooFormulaVar::effSig[ actualVars=(pt,as,ms,ss) for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:2843,access,accessors,2843,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['access'],['accessors']
Security,"es. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is allocated in host memory accessed as; MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also; causes it to be treated as non-volatile and so is not invalidated by; ``*_vol``.; * On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent); and so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX6-GFX9 are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table`. .. table:: AMDHSA Memory Model Code Sequences GFX6-GFX9; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table. =========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:210639,access,accessed,210639,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"es; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21776,secur,security,21776,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['secur'],['security']
Security,"es``"" (all functions +; globals), the ""``.apple_types``"" (names of all types that are defined), and; the ""``.apple_namespaces``"" (all namespaces), we currently set the ``Atom``; array to be:. .. code-block:: c. HeaderData.atom_count = 1;; HeaderData.atoms[0].type = eAtomTypeDIEOffset;; HeaderData.atoms[0].form = DW_FORM_data4;. This defines the contents to be the DIE offset (eAtomTypeDIEOffset) that is; encoded as a 32 bit value (DW_FORM_data4). This allows a single name to have; multiple matching DIEs in a single file, which could come up with an inlined; function for instance. Future tables could include more information about the; DIE such as flags indicating if the DIE is a function, method, block,; or inlined. The KeyType for the DWARF table is a 32 bit string table offset into the; "".debug_str"" table. The "".debug_str"" is the string table for the DWARF which; may already contain copies of all of the strings. This helps make sure, with; help from the compiler, that we reuse the strings between all of the DWARF; sections and keeps the hash table size down. Another benefit to having the; compiler generate all strings as DW_FORM_strp in the debug info, is that; DWARF parsing can be made much faster. After a lookup is made, we get an offset into the hash data. The hash data; needs to be able to deal with 32 bit hash collisions, so the chunk of data; at the offset in the hash data consists of a triple:. .. code-block:: c. uint32_t str_offset; uint32_t hash_data_count; HashData[hash_data_count]. If ""str_offset"" is zero, then the bucket contents are done. 99.9% of the; hash data chunks contain a single item (no 32 bit hash collision):. .. code-block:: none. .------------.; | 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] => ""main""); | 0x00000004 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x........ | uint32_t HashData[2] DIE offset; | 0x........ | uint32_t HashData[3] DIE offset; | 0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:75295,hash,hash,75295,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"escriptors can have an optional third argument, but that must be the; constant integer zero. Struct type descriptors are represented as ``MDNode`` s with an odd number; of operands greater than 1. The first operand is an ``MDString`` denoting; the name of the struct type. Like in scalar type descriptors the actual; value of this name operand is irrelevant to LLVM. After the name operand,; the struct type descriptors have a sequence of alternating ``MDNode`` and; ``ConstantInt`` operands. With N starting from 1, the 2N - 1 th operand,; an ``MDNode``, denotes a contained field, and the 2N th operand, a; ``ConstantInt``, is the offset of the said contained field. The offsets; must be in non-decreasing order. Access tags are represented as ``MDNode`` s with either 3 or 4 operands.; The first operand is an ``MDNode`` pointing to the node representing the; base type. The second operand is an ``MDNode`` pointing to the node; representing the access type. The third operand is a ``ConstantInt`` that; states the offset of the access. If a fourth field is present, it must be; a ``ConstantInt`` valued at 0 or 1. If it is 1 then the access tag states; that the location being accessed is ""constant"" (meaning; ``pointsToConstantMemory`` should return true; see `other useful; AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_). The TBAA root of; the access type and the base type of an access tag must be the same, and; that is the TBAA root of the access tag. '``tbaa.struct``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The :ref:`llvm.memcpy <int_memcpy>` is often used to implement; aggregate assignment operations in C and similar languages, however it; is defined to copy a contiguous region of memory, which is more than; strictly necessary for aggregate types which contain holes due to; padding. Also, it doesn't contain any TBAA information about the fields; of the aggregate. ``!tbaa.struct`` metadata can describe which memory subregions in a; memcpy are padding and what the TBAA tags",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:279147,access,access,279147,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"esence of `atomic` accesses; that enforce an order, thus not ""unordered"" and ""monotonic"", `volatile` accesses,; as well as `convergent` function calls. Note that `convergent` operations can involve communication that is; considered to be not through memory and does not necessarily imply an; ordering between threads for the purposes of the memory model. Therefore,; an operation can be both `convergent` and `nosync`. If a `nosync` function does ever synchronize with another thread,; the behavior is undefined.; ``nounwind``; This function attribute indicates that the function never raises an; exception. If the function does raise an exception, its runtime; behavior is undefined. However, functions marked nounwind may still; trap or generate asynchronous exceptions. Exception handling schemes; that are recognized by LLVM to handle asynchronous exceptions, such; as SEH, will still provide their implementation defined semantics.; ``nosanitize_bounds``; This attribute indicates that bounds checking sanitizer instrumentation; is disabled for this function.; ``nosanitize_coverage``; This attribute indicates that SanitizerCoverage instrumentation is disabled; for this function.; ``null_pointer_is_valid``; If ``null_pointer_is_valid`` is set, then the ``null`` address; in address-space 0 is considered to be a valid address for memory loads and; stores. Any analysis or optimization should not treat dereferencing a; pointer to ``null`` as undefined behavior in this function.; Note: Comparing address of a global variable to ``null`` may still; evaluate to false because of a limitation in querying this attribute inside; constant expressions.; ``optdebug``; This attribute suggests that optimization passes and code generator passes; should make choices that try to preserve debug info without significantly; degrading runtime performance.; This attribute is incompatible with the ``minsize``, ``optsize``, and; ``optnone`` attributes.; ``optforfuzzing``; This attribute indicates that th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:94683,sanitiz,sanitizer,94683,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['sanitiz'],['sanitizer']
Security,"esolution; Not resolved. 2736; open; Standard layout class with empty base class also in first member; Not resolved. 2737; open; Temporary lifetime extension for reference init-captures; Not resolved. 2738; review; ""denotes a destructor"" is missing specification; Not resolved. 2739; open; Nested requirement not a constant expression; Not resolved. 2740; open; Too many objects have constexpr-unknown type; Not resolved. 2741; open; Implicit conversion sequence from empty list to array of unknown bound; Not resolved. 2742; open; Guaranteed copy elision for brace-initialization from prvalue; Not resolved. 2743; open; Copying non-trivial objects nested within a union; Not resolved. 2744; open; Multiple objects of the same type at the same address; Not resolved. 2745; open; Dependent odr-use in generic lambdas; Not resolved. 2746; open; Checking of default template arguments; Not resolved. 2747; DR; Cannot depend on an already-deleted splice; Unknown. 2748; tentatively ready; Accessing static data members via null pointer; Unknown. 2749; DR; Treatment of ""pointer to void"" for relational comparisons; Unknown. 2750; DRWP; construct_at without constructor call; Unknown. 2751; NAD; Order of destruction for parameters for operator functions; Unknown. 2752; open; Excess-precision floating-point literals; Not resolved. 2753; DR; Storage reuse for string literal objects and backing arrays; Unknown. 2754; DR; Using *this in explicit object member functions that are coroutines; Unknown. 2755; DR; Incorrect wording applied by P2738R1; Unknown. 2756; review; Completion of initialization by delegating constructor; Not resolved. 2757; review; Deleting or deallocating storage of an object during its construction; Not resolved. 2758; DR; What is ""access and ambiguity control""?; Unknown. 2759; DR; [[no_unique_address] and common initial sequence; Unknown. 2760; DR; Defaulted constructor that is an immediate function; Unknown. 2761; DR; Implicitly invoking the deleted destructor of an anon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:190150,Access,Accessing,190150,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Accessing']
Security,esolved. 1702; drafting; Rephrasing the definition of “anonymous union”; Not resolved. 1703; NAD; Language linkage of names of functions with internal linkage; Unknown. 1704; CD5; Type checking in explicit instantiation of variable templates; Unknown. 1705; CD4; Unclear specification of “more specialized”; Unknown. 1706; drafting; alignas pack expansion syntax; Not resolved. 1707; C++14; template in elaborated-type-specifier without nested-name-specifier; Unknown. 1708; CD4; overly-strict requirements for names with C language linkage; Unknown. 1709; drafting; Stringizing raw string literals containing newline; Not resolved. 1710; C++17; Missing template keyword in class-or-decltype; No. 1711; CD6; Missing specification of variable template partial specializations; Unknown. 1712; CD4; constexpr variable template declarations; Unknown. 1713; dup; Linkage of variable template specializations; Unknown. 1714; NAD; odr-use of this from a local class; Unknown. 1715; CD4; Access and inherited constructor templates; Clang 3.9. 1716; C++14; When are default arguments evaluated?; Unknown. 1717; C++14; Missing specification of type of binary literal; Unknown. 1718; drafting; Macro invocation spanning end-of-file; Not resolved. 1719; CD4; Layout compatibility and cv-qualification revisited; Unknown. 1720; NAD; Macro invocation in #include directive; Unknown. 1721; drafting; Diagnosing ODR violations for static data members; Not resolved. 1722; CD4; Should lambda to function pointer conversion function be noexcept?; Clang 9. 1723; drafting; Multicharacter user-defined character literals; Not resolved. 1724; CD6; Unclear rules for deduction failure; Unknown. 1725; NAD; Trailing return type with nested function declarator; Unknown. 1726; CD6; Declarator operators and conversion function; Unknown. 1727; NAD; Type of a specialization of a variable template; Unknown. 1728; CD5; Type of an explicit instantiation of a variable template; Unknown. 1729; CD6; Matching declarations and def,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:116131,Access,Access,116131,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"ess below, the LLVM Security Group decides on embargo date for public disclosure for each Security issue. An embargo may be lifted before the agreed-upon date if all vendors planning to ship a fix have already done so, and if the reporter does not object. Collaboration; -------------. Members of the LLVM Security Group are expected to:. * Promptly share any LLVM vulnerabilities they become aware of.; * Volunteer to drive issues forward.; * Help evaluate the severity of incoming issues.; * Help write and review patches to address security issues.; * Participate in the member nomination and removal processes. Discussion Medium; =================. *FUTURE*: this section needs more work! Where discussions occur is influenced by other factors that are still open in this document. We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-syn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:10933,secur,security,10933,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"ess`` are all (potential) clobbers of said; ``MemoryAccess``, and the value produced by a ``MemoryAccess`` can act as a clobber; for other ``MemoryAccess``\ es. If a ``MemoryAccess`` is a *clobber* of another, it means that these two; ``MemoryAccess``\ es may access the same memory. For example, ``x = MemoryDef(y)``; means that ``x`` potentially modifies memory that ``y`` modifies/constrains; (or has modified / constrained).; In the same manner, ``a = MemoryPhi({BB1,b},{BB2,c})`` means that; anyone that uses ``a`` is accessing memory potentially modified / constrained; by either ``b`` or ``c`` (or both). And finally, ``MemoryUse(x)`` means; that this use accesses memory that ``x`` has modified / constrained; (as an example, think that if ``x = MemoryDef(...)``; and ``MemoryUse(x)`` are in the same loop, the use can't; be hoisted outside alone). Another useful way of looking at it is in terms of memory versions.; In that view, operands of a given ``MemoryAccess`` are the version; of the entire memory before the operation, and if the access produces; a value (i.e. ``MemoryDef/MemoryPhi``),; the value is the new version of the memory after the operation. .. code-block:: llvm. define void @foo() {; entry:; %p1 = alloca i8; %p2 = alloca i8; %p3 = alloca i8; ; 1 = MemoryDef(liveOnEntry); store i8 0, ptr %p3; br label %while.cond. while.cond:; ; 6 = MemoryPhi({entry,1},{if.end,4}); br i1 undef, label %if.then, label %if.else. if.then:; ; 2 = MemoryDef(6); store i8 0, ptr %p1; br label %if.end. if.else:; ; 3 = MemoryDef(6); store i8 1, ptr %p2; br label %if.end. if.end:; ; 5 = MemoryPhi({if.then,2},{if.else,3}); ; MemoryUse(5); %1 = load i8, ptr %p1; ; 4 = MemoryDef(5); store i8 2, ptr %p2; ; MemoryUse(1); %2 = load i8, ptr %p3; br label %while.cond; }. The ``MemorySSA`` IR is shown in comments that precede the instructions they map; to (if such an instruction exists). For example, ``1 = MemoryDef(liveOnEntry)``; is a ``MemoryAccess`` (specifically, a ``MemoryDef``), and it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:5483,access,access,5483,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security,"essing C source code. The main; interface to this library for outside clients is the large ``Preprocessor``; class. It contains the various pieces of state that are required to coherently; read tokens out of a translation unit. The core interface to the ``Preprocessor`` object (once it is set up) is the; ``Preprocessor::Lex`` method, which returns the next :ref:`Token <Token>` from; the preprocessor stream. There are two types of token providers that the; preprocessor is capable of reading from: a buffer lexer (provided by the; :ref:`Lexer <Lexer>` class) and a buffered token stream (provided by the; :ref:`TokenLexer <TokenLexer>` class). .. _Token:. The Token class; ---------------. The ``Token`` class is used to represent a single lexed token. Tokens are; intended to be used by the lexer/preprocess and parser libraries, but are not; intended to live beyond them (for example, they should not live in the ASTs). Tokens most often live on the stack (or some other location that is efficient; to access) as the parser is running, but occasionally do get buffered up. For; example, macro definitions are stored as a series of tokens, and the C++; front-end periodically needs to buffer tokens up for tentative parsing and; various pieces of look-ahead. As such, the size of a ``Token`` matters. On a; 32-bit system, ``sizeof(Token)`` is currently 16 bytes. Tokens occur in two forms: :ref:`annotation tokens <AnnotationToken>` and; normal tokens. Normal tokens are those returned by the lexer, annotation; tokens represent semantic information and are produced by the parser, replacing; normal tokens in the token stream. Normal tokens contain the following; information:. * **A SourceLocation** --- This indicates the location of the start of the; token. * **A length** --- This stores the length of the token as stored in the; ``SourceBuffer``. For tokens that include them, this length includes; trigraphs and escaped newlines which are ignored by later phases of the; compiler. By pointi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:44923,access,access,44923,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['access'],['access']
Security,"essing modes which, in its fully general form, looks; like `(%base,%index,scale)offset`. Here `%base` and `%index` are 64-bit; registers that can potentially be any value, and may be attacker controlled,; and `scale` and `offset` are fixed immediate values. `scale` must be `1`, `2`,; `4`, or `8`, and `offset` can be any 32-bit sign extended value. The exact; computation performed to find the address is then: `%base + (scale * %index) +; offset` under 64-bit 2's complement modular arithmetic. One issue with this approach is that, after hardening, the `%base + (scale *; %index)` subexpression will compute a value near zero (`-1 + (scale * -1)`) and; then a large, positive `offset` will index into memory within the first two; gigabytes of address space. While these offsets are not attacker controlled,; the attacker could chose to attack a load which happens to have the desired; offset and then successfully read memory in that region. This significantly; raises the burden on the attacker and limits the scope of attack but does not; eliminate it. To fully close the attack we must work with the operating system; to preclude mapping memory in the low two gigabytes of address space. ###### 64-bit load checking instructions. We can use the following instruction sequences to check loads. We set up `%r8`; in these examples to hold the special value of `-1` which will be `cmov`ed over; `%rax` in misspeculated paths. Single register addressing mode:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; orq %rax, %rsi # Mask the pointer if misspeculating.; movl (%rsi), %edi; ```. Two register addressing mode:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; orq %rax, %rsi # Mask the pointer if misspeculating.; orq %rax, %rcx # Mask the index if misspeculating.; movl (%rsi,%rcx), %edi; ```. This will result in a negative address near zero or in `offset` wrapping the; address space back to a small positive ad",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:28931,attack,attacker,28931,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,2,['attack'],"['attack', 'attacker']"
Security,"est, draw } from './jsrootsys/modules/core.mjs';; let res = await httpRequest(""your_server/multi.json?number=3"", ""multi"",; ""Files/job1.root/hpx/root.json\nFiles/job1.root/hpxpy/root.json\nFiles/job1.root/hprof/root.json\n"");; for (let n = 0; n < res.length; ++n) {; console.log('Requested element of type', res[n]._typename);; // draw('drawid', res[n], 'hist');; }; ```. Here argument ""multi"" identifies, that server response should be parsed with `parseMulti()` function, which correctly interprets JSON code, produced by `multi.json` request. When sending such request to the server, one should provide list of objects names and not forget ""?number=N"" parameter in the request URL string. ## Using unix sockets. Starting from ROOT version 6.28, one can start server with unix socket. Just do:. Just call:; ```cpp; [root] new THttpServer(""socket:/tmp/root.socket""); ```; Name of socket should be unique and not match any existing files. Most easy way to access `THttpServer` running via unix socket is to configure ssh tunnel:; ```; [shell] ssh -L 7654:/tmp/root.socket localhost; ```. Once such tunnel is configured one can open following URL in web browser:; ```; [shell] xdg-open http://localhost:7654; ```. ## Websockets supports. Websockets support available starting from ROOT v6.12.; Minimal example provided in [$ROOTSYS/tutorials/http/ws.C](https://root.cern/doc/master/ws_8C.html) macro. To work with websockets, subclass of [THttpWSHandler](https://root.cern/doc/master/classTHttpWSHandler.html) should be created and registered to THttpServer:. ```cpp; #include ""THttpWSHandler.h"". class TUserHandler : public THttpWSHandler {; public:; TUserHandler(const char *name, const char *title) : THttpWSHandler(name, title) {}. // provide custom HTML page when open correspondent address; TString GetDefaultPageContent() override { return ""file:ws.htm""; }. Bool_t ProcessWS(THttpCallArg *arg) override;; };; ```. Central method is `TUserHandler::ProcessWS(THttpCallArg *arg)`, where four kinds o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:24544,access,access,24544,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['access']
Security,"est.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, %bb.2`. - MIR code contains a whole IR module. This is necessary because there are; no equivalents in MIR for global variables, references to external functions,; function attributes, metadata, debug info. Instead some MIR data references; the IR constructs. You can often remove t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3352,expose,exposesReturnsTwice,3352,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['expose'],['exposesReturnsTwice']
Security,"esults; computed along the way as part of each access queried. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, const MemoryLocation &Loc);``; returns the access clobbering memory location ``Loc``, starting at ``MA``.; Because this API does not request the clobbering access of a specific memory; access, there are no results that can be cached. Locating clobbers yourself; ^^^^^^^^^^^^^^^^^^^^^^^^^^. If you choose to make your own walker, you can find the clobber for a; ``MemoryAccess`` by walking every ``MemoryDef`` that dominates said; ``MemoryAccess``. The structure of ``MemoryDef``\ s makes this relatively simple;; they ultimately form a linked list of every clobber that dominates the; ``MemoryAccess`` that you're trying to optimize. In other words, the; ``definingAccess`` of a ``MemoryDef`` is always the nearest dominating; ``MemoryDef`` or ``MemoryPhi`` of said ``MemoryDef``. Use and Def optimization; ------------------------. ``MemoryUse``\ s keep a single operand, which is their defining or optimized; access.; Traditionally ``MemorySSA`` optimized ``MemoryUse``\ s at build-time, up to a; given threshold.; Specifically, the operand of every ``MemoryUse`` was optimized to point to the; actual clobber of said ``MemoryUse``. This can be seen in the above example; the; second ``MemoryUse`` in ``if.end`` has an operand of ``1``, which is a; ``MemoryDef`` from the entry block. This is done to make walking,; value numbering, etc, faster and easier.; As of `this revision <https://reviews.llvm.org/D121381>`_, the default was; changed to not optimize uses at build time, in order to provide the option to; reduce compile-time if the walking is not necessary in a pass. Most users call; the new API ``ensureOptimizedUses()`` to keep the previous behavior and do a; one-time optimization of ``MemoryUse``\ s, if this was not done before.; New pass users are recommended to call ``ensureOptimizedUses()``. Initially it was not possible to optimize ``MemoryDef``\ s in t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:11082,access,access,11082,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security,"et 0x000034f0 and start looking to see if our 32 bit hash matches. To; do so, we need to read the next pointer, then read the hash, compare it, and; skip to the next bucket. Each time we are skipping many bytes in memory and; touching new pages just to do the compare on the full 32 bit hash. All of; these accesses then tell us that we didn't have a match. Name Hash Tables; """""""""""""""""""""""""""""""". To solve the issues mentioned above we have structured the hash tables a bit; differently: a header, buckets, an array of all unique 32 bit hash values,; followed by an array of hash value data offsets, one for each hash value, then; the data for all hash values:. .. code-block:: none. .-------------.; | HEADER |; |-------------|; | BUCKETS |; |-------------|; | HASHES |; |-------------|; | OFFSETS |; |-------------|; | DATA |; `-------------'. The ``BUCKETS`` in the name tables are an index into the ``HASHES`` array. By; making all of the full 32 bit hash values contiguous in memory, we allow; ourselves to efficiently check for a match while touching as little memory as; possible. Most often checking the 32 bit hash values is as far as the lookup; goes. If it does match, it usually is a match with no collisions. So for a; table with ""``n_buckets``"" buckets, and ""``n_hashes``"" unique 32 bit hash; values, we can clarify the contents of the ``BUCKETS``, ``HASHES`` and; ``OFFSETS`` as:. .. code-block:: none. .-------------------------.; | HEADER.magic | uint32_t; | HEADER.version | uint16_t; | HEADER.hash_function | uint16_t; | HEADER.bucket_count | uint32_t; | HEADER.hashes_count | uint32_t; | HEADER.header_data_len | uint32_t; | HEADER_DATA | HeaderData; |-------------------------|; | BUCKETS | uint32_t[n_buckets] // 32 bit hash indexes; |-------------------------|; | HASHES | uint32_t[n_hashes] // 32 bit hash values; |-------------------------|; | OFFSETS | uint32_t[n_hashes] // 32 bit offsets to hash value data; |-------------------------|; | ALL HASH DATA |; `-------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:63375,hash,hash,63375,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"et into .debug_str (terminate data for hash); `------------'. So we still have all of the same data, we just organize it more efficiently for; debugger lookup. If we repeat the same ""``printf``"" lookup from above, we; would hash ""``printf``"" and find it matches ``BUCKETS[3]`` by taking the 32 bit; hash value and modulo it by ``n_buckets``. ``BUCKETS[3]`` contains ""6"" which; is the index into the ``HASHES`` table. We would then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:67957,hash,hash,67957,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"et it up for you. The Virtual Analysis Facility client; ------------------------------------. The Virtual Analysis Facility client takes care of setting the; environment for the end user required by your software's experiment. The; environment will both be set on the client and on each PROOF node. Technically it is a Bash shell script which provides shortcuts for PROOF; on Demand commands and ensures local and remote environment consistency:; by executing it you enter a new clean environment where all your; software dependencies have already been set up. Local and remote environment configuration is split into a series of; files, which give the possibility to:. - have a system-wide, sysadmin-provided experiment configuration. - execute user actions either *before* or *after* the execution of the; system-wide script (for instance, choosing the preferred version of; the experiment's software). - transfer a custom user **payload** on each PROOF worker (for instance,; user's client-generated Grid credentials to make PROOF workers; capable of accessing a remote authenticated storage). Configuration files are searched for in two different locations:. - a system-wide directory: `<client_install_dir>/etc`. - user's home directory: `~/.vaf`. > A system-wide configuration file always has precedence over user's; > configuration. It is thus possible for the sysadmin to enforce a; > policy where some scripts cannot ever be overridden. Thanks to this separation, users can maintain an uncluttered directory; with very simple configuration files that contain only what really needs; or is allowed to be customized: for instance, user might specify a single line; containing the needed ROOT version, while all the technicalities to set; up the environment are taken care of inside system-installed scripts,; leaving the user's configuration directory clean and uncluttered. ### Local environment configuration. All the local environment files are loaded at the time of the; client's startup f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:1676,access,accessing,1676,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,2,"['access', 'authenticat']","['accessing', 'authenticated']"
Security,"etadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimiza",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311885,access,access,311885,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"etadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312246,access,accessing,312246,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessing']
Security,"etails).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) then all of the destination arguments (specified by indexes in `DstArgs`) also become tainted. Under the `Sinks` key, the user can specify a list of operations where the checker should emit a bug report if tainted data reaches it (see :ref:`clangsa-taint-sink-details` for details). .. _clangsa-taint-filter-details:. Filter syntax and semantics; ###########################. An entry under `Filters` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function during symbolic execution the checker will sanitize taint from the memory region referred to by the given arguments or return a sanitized value.; - `Args` is a list of numbers in the range of ``[-1..int_max]``.; It indicates the indexes of arguments in the function call.; The number ``-1`` signifies the return value; other numbers identify call arguments.; The values of these arguments are considered clean after the function call. The following keys are optional:; - `Scope` is a string that specifies the prefix of the function's name in its fully qualified name. This option restricts the set of matching function calls. It can encode not only namespaces but struct/class names as well to match member functions. .. _clangsa-taint-propagation-details:. Propagation syntax and semantics; ################################. An entry under `Propagation` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function du",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:5619,sanitiz,sanitize,5619,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,2,['sanitiz'],"['sanitize', 'sanitized']"
Security,eter pack end?; Not resolved. 2106; CD4; Unclear restrictions on use of function-type template arguments; Unknown. 2107; CD4; Lifetime of temporaries for default arguments in array copying; Unknown. 2108; drafting; Conversions to non-class prvalues in reference initialization; Not resolved. 2109; CD4; Value dependence underspecified; Unknown. 2110; drafting; Overload resolution for base class conversion and reference/non-reference; Not resolved. 2111; NAD; Array temporaries in reference binding; Unknown. 2112; CD5; new auto{x}; Unknown. 2113; CD4; Incompete specification of types for declarators; Unknown. 2114; CD3; Missing description of incompatibility from aggregate NSDMIs; Unknown. 2115; drafting; Order of implicit destruction vs release of automatic storage; Not resolved. 2116; C++17; Direct or copy initialization for omitted aggregate initializers; Unknown. 2117; drafting; Explicit specializations and constexpr function templates; Not resolved. 2118; open; Stateful metaprogramming via friend injection; Not resolved. 2119; NAD; Disambiguation of multi-level covariant return type; Unknown. 2120; CD4; Array as first non-static data member in standard-layout class; Clang 7. 2121; CD6; More flexible lambda syntax; Unknown. 2122; CD4; Glvalues of void type; Unknown. 2123; open; Omitted constant initialization of local static variables; Not resolved. 2124; CD4; Signature of constructor template; Unknown. 2125; NAD; Copy elision and comma operator; Unknown. 2126; C++20; Lifetime-extended temporaries in constant expressions; Clang 12. 2127; drafting; Partial specialization and nullptr; Not resolved. 2128; drafting; Imprecise rule for reference member initializer; Not resolved. 2129; CD4; Non-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:144268,inject,injection,144268,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injection']
Security,"ethod 2. Another method allows to create the evolution of a given radioactive; material/mixture at a given moment in time:. ~~~{.cpp}; TGeoMaterial::DecayMaterial(Double_t time, Double_t precision=0.001); ~~~. The method will create the mixture that result from the decay of a; initial material/mixture at time, while all resulting elements having a; fractional weight less than precision are excluded. A demo macro for radioactive material features is; `$ROOTSYS/tutorials/geom/RadioNuclides.C` It demonstrates also the decay; of a mixture made of radionuclides. \image html geometry004.png width=600px. \anchor GM00c; ### Tracking Media. The class TGeoMedium describes tracking media properties. This has; a pointer to a material and the additional data members representing the; properties related to tracking. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; ~~~. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ~~~{.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ~~~. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). \anchor GM00d; ### User Interface for Handling Materials and Media. The TGeoManager class contains the API for accessing and handling; defined materials:. ~~~{.cpp}; TGeoManager::GetMaterial(name);; ~~~. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md:10438,access,accessing,10438,geom/geom/doc/materials.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/materials.md,1,['access'],['accessing']
Security,"etrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoManager->GetListOfNavigators();; ```. Upon closing the geometry a default navigator is provided as first one; in this list, but one may add its own via:. ``` {.cpp}; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; ```. A navigator holds several variables describing the current navigation; state: current point position, current direction distance to next; boundary, isotropic safety, pointer to current and next nods as well as; several tracking flags related to volume boundary conditions or other; properties required for track propagation in geometry. Each geometry; query affects these variables, so the only way in testing several; navigation alternatives and remember",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:102681,access,accessible,102681,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessible']
Security,"ets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:21891,hash,hash,21891,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['hash'],['hash']
Security,"etup in this folder, and can be found in `<builddir>/lib/`.; Loading it with `LD_PRELOAD` will bring ROOT's default sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1674,sanitiz,sanitizer,1674,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['sanitiz'],['sanitizer']
Security,"eturn;; case ';': // ignore top-level semicolons.; getNextToken();; break;; case tok_def:; HandleDefinition();; break;; case tok_extern:; HandleExtern();; break;; default:; HandleTopLevelExpression();; break;; }; }; }. The most interesting part of this is that we ignore top-level; semicolons. Why is this, you ask? The basic reason is that if you type; ""4 + 5"" at the command line, the parser doesn't know whether that is the; end of what you will type or not. For example, on the next line you; could type ""def foo..."" in which case 4+5 is the end of a top-level; expression. Alternatively you could type ""\* 6"", which would continue; the expression. Having top-level semicolons allows you to type ""4+5;"",; and the parser will know you are done. Conclusions; ===========. With just under 400 lines of commented code (240 lines of non-comment,; non-blank code), we fully defined our minimal language, including a; lexer, parser, and AST builder. With this done, the executable will; validate Kaleidoscope code and tell us if it is grammatically invalid.; For example, here is a sample interaction:. .. code-block:: bash. $ ./a.out; ready> def foo(x y) x+foo(y, 4.0);; Parsed a function definition.; ready> def foo(x y) x+y y;; Parsed a function definition.; Parsed a top-level expr; ready> def foo(x y) x+y );; Parsed a function definition.; Error: unknown token when expecting an expression; ready> extern sin(a);; ready> Parsed an extern; ready> ^D; $. There is a lot of room for extension here. You can define new AST nodes,; extend the language in many ways, etc. In the `next; installment <LangImpl03.html>`_, we will describe how to generate LLVM; Intermediate Representation (IR) from the AST. Full Code Listing; =================. Here is the complete code listing for our running example. .. code-block:: bash. # Compile; clang++ -g -O3 toy.cpp; # Run; ./a.out. Here is the code:. .. literalinclude:: ../../../examples/Kaleidoscope/Chapter2/toy.cpp; :language: c++. `Next: Implementing Code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst:24507,validat,validate,24507,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl02.rst,1,['validat'],['validate']
Security,"euid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22357,secur,security,22357,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['secur'],['security']
Security,"evelopers even use ``__underscored`` names; in headers to avoid collisions with ""normal"" names that (by; convention) shouldn't even be macros. These conventions are a; barrier to entry for developers coming from non-C languages, are; boilerplate for more experienced developers, and make our headers; far uglier than they should be. * **Tool confusion**: In a C-based language, it is hard to build tools; that work well with software libraries, because the boundaries of; the libraries are not clear. Which headers belong to a particular; library, and in what order should those headers be included to; guarantee that they compile correctly? Are the headers C, C++,; Objective-C++, or one of the variants of these languages? What; declarations in those headers are actually meant to be part of the; API, and what declarations are present only because they had to be; written as part of the header file?. Semantic import; ---------------; Modules improve access to the API of software libraries by replacing the textual preprocessor inclusion model with a more robust, more efficient semantic model. From the user's perspective, the code looks only slightly different, because one uses an ``import`` declaration rather than a ``#include`` preprocessor directive:. .. code-block:: c. import std.io; // pseudo-code; see below for syntax discussion. However, this module import behaves quite differently from the corresponding ``#include <stdio.h>``: when the compiler sees the module import above, it loads a binary representation of the ``std.io`` module and makes its API available to the application directly. Preprocessor definitions that precede the import declaration have no impact on the API provided by ``std.io``, because the module itself was compiled as a separate, standalone module. Additionally, any linker flags required to use the ``std.io`` module will automatically be provided when the module is imported [#]_; This semantic import model addresses many of the problems of the preproce",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:3885,access,access,3885,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['access'],['access']
Security,"event error dterr and all its parameters, convoluted with a triple; gaussian resolution model and multiplied with a Gaussian p.d.f. in the; energy substituted mass. (In plain RooFit this would have required at; least 23 lines of code). A series of three new tutorial macros has been added to illustrate the; various features of the object factory. rf511_wsfactory_basic.C - Basic factory concepts; rf512_wsfactory_oper.C - Using operator p.d.f.s in the factory; rf513_wsfactory_tools.C - Advanced example using interfaced high level tools. A formal transaction model is used to commit composite objects into; the workspace. If an error is detected in the expression, no objects; will be committed to the workspace, thus leaving no 'partial builds'. Compact demo of several new major features. The macro below demonstrates in a couple of lines a number of major new features in RooFit 3.00: Use of. workspace factory to quickly create and store (compiled) models; workspace CINT interface to easily access contents in a typesafe way; new adaptive ND numeric integration technique to normalize arbitrary p.d.f. in fast; and reliable way; new adaptive TFoam sampling technique to efficiently generate toy MC data from strongly; peaked datasets; parallel processing in likelihood construction and use of profile likelihood operator; to represent profile likelihoods as regular RooFit functions. void demo(); {; // Construct compiled 2-D model that requires numeric integration for normalization; RooWorkspace w(""w"",1) ;; w.factory(""CEXPR::model('1/((x-a)*(x-a)+0.001)+1/((y-b)*(y-b)+0.001)',x[-1,1],y[-1,1],a[-5,5],b[-5,5])"") ;. // Generate data from model (using TFoam adaptive sampling algorithm); RooDataSet* d = w::model.generate(RooArgSet(w::x,w::y),1000) ;; w::model.fitTo(*d) ;. // Make 2D plot on (x,y); TH2* hh = w::model.createHistogram(""x,y"",40,40) ;; hh->SetLineColor(kBlue) ;. // Make Projection on x (integrate over y); RooPlot* framex = w::x.frame(Title(""Data and p.d.f. projected on X"")) ;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:22031,access,access,22031,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['access'],['access']
Security,"ever a lookup within that JITDylib fails; to find one or more symbols. The definition generator is given a chance to; produce a definition of the missing symbol(s) before the lookup proceeds. ORC provides the ``DynamicLibrarySearchGenerator`` utility for reflecting symbols; from the process (or a specific dynamic library) for you. For example, to reflect; the whole interface of a runtime library:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; auto &JD = ES.createJITDylib(""main"");. if (auto DLSGOrErr =; DynamicLibrarySearchGenerator::Load(""/path/to/lib""; DL.getGlobalPrefix())); JD.addGenerator(std::move(*DLSGOrErr);; else; return DLSGOrErr.takeError();. // IR added to JD can now link against all symbols exported by the library; // at '/path/to/lib'.; CompileLayer.add(JD, loadModule(...));. The ``DynamicLibrarySearchGenerator`` utility can also be constructed with a; filter function to restrict the set of symbols that may be reflected. For; example, to expose an allowed set of symbols from the main process:. .. code-block:: c++. const DataLayout &DL = getDataLayout();; MangleAndInterner Mangle(ES, DL);. auto &JD = ES.createJITDylib(""main"");. DenseSet<SymbolStringPtr> AllowList({; Mangle(""puts""),; Mangle(""gets""); });. // Use GetForCurrentProcess with a predicate function that checks the; // allowed list.; JD.addGenerator(cantFail(DynamicLibrarySearchGenerator::GetForCurrentProcess(; DL.getGlobalPrefix(),; [&](const SymbolStringPtr &S) { return AllowList.count(S); })));. // IR added to JD can now link against any symbols exported by the process; // and contained in the list.; CompileLayer.add(JD, loadModule(...));. References to process or library symbols could also be hardcoded into your IR; or object files using the symbols' raw addresses, however symbolic resolution; using the JIT symbol tables should be preferred: it keeps the IR and objects; readable and reusable in subsequent JIT sessions. Hardcoded addresses are; difficult to read, and usually onl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:33728,expose,expose,33728,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['expose'],['expose']
Security,"exact number and a value of 0 represents no stall). If you'd like to add a CustomBehaviour class for a target that doesn't; already have one, refer to an existing implementation to see how to set it; up. The classes are implemented within the target specific backend (for; example `/llvm/lib/Target/AMDGPU/MCA/`) so that they can access backend symbols. Instrument Manager; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; On certain architectures, scheduling information for certain instructions; do not contain all of the information required to identify the most precise; schedule class. For example, data that can have an impact on scheduling can; be stored in CSR registers. One example of this is on RISCV, where values in registers such as `vtype`; and `vl` change the scheduling behaviour of vector instructions. Since MCA; does not keep track of the values in registers, instrument comments can; be used to specify these values. InstrumentManager's main function is `getSchedClassID()` which has access; to the MCInst and all of the instruments that are active for that MCInst.; This function can use the instruments to override the schedule class of; the MCInst. On RISCV, instrument comments containing LMUL information are used; by `getSchedClassID()` to map a vector instruction and the active; LMUL to the scheduling class of the pseudo-instruction that describes; that base instruction and the active LMUL. Custom Views; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; :program:`llvm-mca` comes with several Views such as the Timeline View and; Summary View. These Views are generic and can work with most (if not all); targets. If you wish to add a new View to :program:`llvm-mca` and it does not; require any backend functionality that is not already exposed through MC layer; classes (MCSubtargetInfo, MCInstrInfo, etc.), please add it to the; `/tools/llvm-mca/View/` directory. However, if your new View is target specific; AND requires unexposed backend symbols or functionality, you can define it in; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst:46288,access,access,46288,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-mca.rst,1,['access'],['access']
Security,"exception reporting detailing; * Mapped C++ exception cleanup bug fix; * STL vector constructor passes the CPython sequence construction; * STL vector slicing passes the CPython sequence slicing tests; * Extended documentation. 2019-12-23: 1.6.0; -----------------. * Classes derived from ``std::exception`` can be used as Python exceptions; * Template handling detailing (for Eigen); * Support keyword arguments; * Added add_library_path at module level; * Extended documentation; * Fix regression bugs: #176, #179, #180, #182. 2019-11-07: 1.5.7; -----------------. * Allow implicit converions for move arguments; * Choose vector over initializer_list if part of the template argument list. 2019-11-03: 1.5.6; -----------------. * Added public C++ API for some CPyCppyy core functions (CPython only); * Support for char16_t/char16_t* and char32_t/char32_t*; * Respect ``std::hash`` in ``__hash__``; * Fix iteration over vector of shared_ptr; * Length checking on global variables of type 'signed char[N]'; * Properly support overloaded templated with non-templated ``__setitem__``; * Support for array of const char* as C-strings; * Enable type resolution of clang's builtin ``__type_pack_element``; * Fix for inner class type naming when it directly declares a variable. 2019-10-16: 1.5.5; -----------------. * Added signal -> exception support in cppyy.ll; * Support for lazily combining overloads of operator*/+-; * No longer call trivial destructors; * Support for free function unary operators; * Refactored and optimized operator==/!= usage; * Refactored converters/executors for lower memory usage; * Bug fixes in rootcling and _cppyy_generator.py. 2019-09-25: 1.5.4; -----------------. * operator+/* now respect C++-side associativity; * Fix potential crash if modules are reloaded; * Fix some portability issues on Mac/Windows of cppyy-cling. 2019-09-15: 1.5.3; -----------------. * Performance improvements; * Support for anonymous/unnamed/nested unions; * Extended documentation. 2019-09-0",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst:15702,hash,hash,15702,bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/changelog.rst,1,['hash'],['hash']
Security,"executable. .. option:: @<FILE>. Read command-line options from response file `<FILE>`. ELF SPECIFIC OPTIONS; --------------------. The following options are implemented only for the ELF file format. .. option:: --arch-specific, -A. Display architecture-specific information, e.g. the ARM attributes section on ARM. .. option:: --bb-addr-map. Display the contents of the basic block address map section(s), which contain the; address of each function, along with the relative offset of each basic block. .. option:: --demangle, -C. Display demangled symbol names in the output. .. option:: --dependent-libraries. Display the dependent libraries section. .. option:: --dyn-relocations. Display the dynamic relocation entries. .. option:: --dyn-symbols, --dyn-syms, --dt. Display the dynamic symbol table. .. option:: --dynamic-table, --dynamic, -d. Display the dynamic table. .. option:: --cg-profile. Display the callgraph profile section. .. option:: --histogram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output (the default) is an expanded and; structured format. ``GNU`` output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --section-groups, -g. Display section groups. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dynamic symbols. .. option:: --memtag. Display information about memory tagging present in the binary. This includes; various dynamic entries, decoded global descriptor sections, and decoded; Android-specific ELF notes. .. option:: --notes, -n. Display all notes. .. option:: -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst:5335,hash,hash,5335,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,1,['hash'],['hash']
Security,"explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63797,access,access,63797,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['access'],['access']
Security,"explicitly visible in the IR. Doing so requires that we:. #. create a new SSA value for each potentially relocated pointer, and; ensure that no uses of the original (non relocated) value is; reachable after the safepoint,; #. specify the relocation in a way which is opaque to the compiler to; ensure that the optimizer can not introduce new uses of an; unrelocated value after a statepoint. This prevents the optimizer; from performing unsound optimizations.; #. recording a mapping of live pointers (and the allocation they're; associated with) for each statepoint. At the most abstract level, inserting a safepoint can be thought of as; replacing a call instruction with a call to a multiple return value; function which both calls the original target of the call, returns; its result, and returns updated values for any live pointers to; garbage collected objects. Note that the task of identifying all live pointers to garbage; collected values, transforming the IR to expose a pointer giving the; base object for every such live pointer, and inserting all the; intrinsics correctly is explicitly out of scope for this document.; The recommended approach is to use the :ref:`utility passes; <statepoint-utilities>` described below. This abstract function call is concretely represented by a sequence of; intrinsic calls known collectively as a ""statepoint relocation sequence"". Let's consider a simple call in LLVM IR:. .. code-block:: llvm. define i8 addrspace(1)* @test1(i8 addrspace(1)* %obj); gc ""statepoint-example"" {; call void ()* @foo(); ret i8 addrspace(1)* %obj; }. Depending on our language we may need to allow a safepoint during the execution; of ``foo``. If so, we need to let the collector update local values in the; current frame. If we don't, we'll be accessing a potential invalid reference; once we eventually return from the call. In this example, we need to relocate the SSA value ``%obj``. Since we can't; actually change the value in the SSA value ``%obj``, we need to int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:7557,expose,expose,7557,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['expose'],['expose']
Security,"expressions and dependent; types (from step #2) and instantiate those templates with various types,; some of which type-check and some that don't, and test the error messages; in each case. #. There are some ""extras"" that make other features work better. It's worth; handling these extras to give your expression complete integration into; Clang:. * Add code completion support for your expression in; ``SemaCodeComplete.cpp``.; * If your expression has types in it, or has any ""interesting"" features; other than subexpressions, extend libclang's ``CursorVisitor`` to provide; proper visitation for your expression, enabling various IDE features such; as syntax highlighting, cross-referencing, and so on. The; ``c-index-test`` helper program can be used to test these features. Testing; -------; All functional changes to Clang should come with test coverage demonstrating; the change in behavior. .. _verifying-diagnostics:. Verifying Diagnostics; ^^^^^^^^^^^^^^^^^^^^^; Clang ``-cc1`` supports the ``-verify`` command line option as a way to; validate diagnostic behavior. This option will use special comments within the; test file to verify that expected diagnostics appear in the correct source; locations. If all of the expected diagnostics match the actual output of Clang,; then the invocation will return normally. If there are discrepancies between; the expected and actual output, Clang will emit detailed information about; which expected diagnostics were not seen or which unexpected diagnostics were; seen, etc. A complete example is:. .. code-block: c++. // RUN: %clang_cc1 -verify %s; int A = B; // expected-error {{use of undeclared identifier 'B'}}. If the test is run and the expected error is emitted on the expected line, the; diagnostic verifier will pass. However, if the expected error does not appear; or appears in a different location than expected, or if additional diagnostics; appear, the diagnostic verifier will fail and emit information as to why. The ``-verify`` com",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:154646,validat,validate,154646,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['validat'],['validate']
Security,"ey/TDirectory objects and null; value for TUUID objects inside TFile. As drawback, TRef objects stored in such; file cannot be read correctly.; * Significantly improved the scaling of hadd tear-down/cleanup-phase in the presence; of large number histograms and in the presence of large number of directories.; * TMemFile: Apply customization of minimal block size also to the first block.; * Add renaming rule for instances of the math classes from `genvector` and `smatrix` to; instance for one floating point type (`float`, `double`, `Double32_t`, `Float16_t`) to; instances for any other floating point type.; * Corrected the application of `I/O customization rules` when the target classes contained; typedefs (in particular `Double32_t`); * Prevent splitting of objects when a `Streamer Function` was explicitly attached to their; `TClass`.; * In hadd fix verbose level arg parsing; * Allow user to change the type of the content of a TClonesArray.; * Avoid deleted memory access in `MakeProject` and in handling of; `I/O customization rules`. ## TTree Libraries. * Prevent a situation in `TTreeFormula` when stale cached information was re-used.; * Prevent a noticeable memory leak when reading uncompressed TTree. ## Histogram Libraries. * Allow reading v5 TF1 that were stored memberwise in a TClonesArray. ## Math Libraries. ## RooFit Libraries. ## 2D Graphics Libraries. * Provide support of NDC coordinates for TArrow.; * Fix interactive movement of TLine/TArrow objects when NDC coordinates are used; * Provide TGraph::MovePoints() method; * New options `RX`and `RY` for TMultiGraph in order to draw reverse axis along X and Y.; * Combined with the option ""Z"" the option ""CJUST"" allows to draw the color palette; with axis labels justified on the color boundaries (implemented by Otto Schaile).; * The `TCanvas` Event Status Bar now displays the date and time when the mouse cursor; is moved over a time axis (implemented by Otto Schaile).; * Negative values were not painted with option """,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:4674,access,access,4674,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['access'],['access']
Security,"e}"" >> ""${_to_native}""; ); install(FILES ""${CMAKE_BINARY_DIR}/include/ROOT.modulemap"" DESTINATION ${CMAKE_INSTALL_INCLUDEDIR} COMPONENT headers). add_dependencies(move_headers copymodulemap). # Take all the modulemap contents we collected from the packages and append them to our modulemap.; # We have to delay this because the ROOT_CXXMODULES_EXTRA_MODULEMAP_CONTENT is filled in the; # add_subdirectory calls above.; get_property(__modulemap_extra_content GLOBAL PROPERTY ROOT_CXXMODULES_EXTRA_MODULEMAP_CONTENT); string(REPLACE "";"" """" __modulemap_extra_content ""${__modulemap_extra_content}""); # Write module.modulemap.extra to a temporary file first, to not touch module.modulemap.extra; # if it's unchanged.; file(WRITE ""${CMAKE_BINARY_DIR}/include/module.modulemap.extra.tmp"" ""${__modulemap_extra_content}""); configure_file(""${CMAKE_BINARY_DIR}/include/module.modulemap.extra.tmp""; ""${CMAKE_BINARY_DIR}/include/module.modulemap.extra""; COPYONLY). # From now on we handled all exposed module and want to make all new modulemaps private to ROOT.; set(ROOT_CXXMODULES_WRITE_TO_CURRENT_DIR ON). set (CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS}""). string(REGEX REPLACE ""[ ]-"" "";-"" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); if(MSVC); string(REPLACE ""-Zc:__cplusplus"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); string(REPLACE ""-nologo"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); string(REPLACE ""-EHsc-"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); string(REPLACE ""-GR"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); string(REPLACE ""-MDd"" """" CMAKE_CXX_FLAGS_SEPARATE ""${CMAKE_CXX_FLAGS_SEPARATE}""); endif(). if(runtime_cxxmodules); # Dummy target that does nothing, we don't need a PCH for modules.; # Onepcm target has all dependencies needed for allDict.cxx.pch, which allow; # to test hsimple.C after all C++ modules are updated.; add_custom_target(onepcm); foreach(target_dependency ${ROOT_LIBRARY_TARGETS}); add_dependen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt:18591,expose,exposed,18591,CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/CMakeLists.txt,1,['expose'],['exposed']
Security,"f Clang for Windows; that has libFuzzer from; `LLVM Snapshot Builds <https://llvm.org/builds/>`_. Using libFuzzer on Windows without ASAN is unsupported. Building fuzzers with the; ``/MD`` (dynamic runtime library) compile option is unsupported. Support for these; may be added in the future. Linking fuzzers with the ``/INCREMENTAL`` link option; (or the ``/DEBUG`` option which implies it) is also unsupported. Send any questions or comments to the mailing list: libfuzzer(#)googlegroups.com. Q. When libFuzzer is not a good solution for a problem?; ---------------------------------------------------------. * If the test inputs are validated by the target library and the validator; asserts/crashes on invalid inputs, in-process fuzzing is not applicable.; * Bugs in the target library may accumulate without being detected. E.g. a memory; corruption that goes undetected at first and then leads to a crash while; testing another input. This is why it is highly recommended to run this; in-process fuzzer with all sanitizers to detect most bugs on the spot.; * It is harder to protect the in-process fuzzer from excessive memory; consumption and infinite loops in the target library (still possible).; * The target library should not have significant global state that is not; reset between the runs.; * Many interesting target libraries are not designed in a way that supports; the in-process fuzzer interface (e.g. require a file path instead of a; byte array).; * If a single test run takes a considerable fraction of a second (or; more) the speed benefit from the in-process fuzzer is negligible.; * If the target library runs persistent threads (that outlive; execution of one test) the fuzzing results will be unreliable. Q. So, what exactly this Fuzzer is good for?; --------------------------------------------. This Fuzzer might be a good choice for testing libraries that have relatively; small inputs, each input takes < 10ms to run, and the library code is not expected; to crash on in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:29778,sanitiz,sanitizers,29778,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['sanitiz'],['sanitizers']
Security,"f RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65311,access,access,65311,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['access'],['access']
Security,"f a class. It is the opposite of a constructor that creates the; object of a class when it is called. The compiler will provide a; destructor that does nothing if none is provided. We will add one to; our Quad class so that we can see when it is called. The class names; the destructor but with a prefix \~ which is the C++ one's complement; i.e. bit wise complement, and hence has destruction overtones! We; declare it in the .h file and define it in the `.cxx` file. It does; not do much except print out that it has been called (still a useful; debug technique despite today's powerful debuggers!). Now run root, load the Quad class and create a heap object:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad *my_objptr = new Quad(1.,2.,-3.);; ```. To delete the object:. ``` {.cpp}; root[] delete my_objptr;; root[] my_objptr = 0;; ```. You should see the print out from its destructor. Setting the pointer; to zero afterwards is not strictly necessary (and Cling does it; automatically), but the object is no more accessible, and any attempt; to use the pointer again will, as has already been stated, cause; grief. So much for heap objects, but how are stack objects deleted? In; C++, a stack object is deleted as soon as control leaves the innermost; compound statement that encloses it. Therefore, it is singularly; futile to do something like:. ``` {.cpp}; root[] { Quad my_object(1.,2.,-3.); }; ```. Cling does not follow this rule; if you type in the above line, you; will not see the destructor message. As explained in the Script; lesson, you can load in compound statements, which would be a bit; pointless if everything disappeared as soon as it was loaded! Instead,; to reset the stack you have to type:. ``` {.cpp}; root[] gROOT->Reset();; ```. This sends the Reset message via the global pointer to the ROOT; object, which, amongst its many roles, acts as a resource manager.; Start ROOT again and type in the following:. ``` {.cpp}; root[] .L Quad.cxx; root[] Quad my_object(1.,2.,-3.);",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:13283,access,accessible,13283,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['access'],['accessible']
Security,"f a kernel dispatch uses scratch, then the hardware allocates memory from a; pool of backing memory allocated by the runtime for each wavefront. The lanes; of the wavefront access this using dword (4 byte) interleaving. The mapping; used from private address to backing memory address is:. ``wavefront-scratch-base +; ((private-address / 4) * wavefront-size * 4) +; (wavefront-lane-id * 4) + (private-address % 4)``. If each lane of a wavefront accesses the same private address, the; interleaving results in adjacent dwords being accessed and hence requires; fewer cache lines to be fetched. There are different ways that the wavefront scratch base address is; determined by a wavefront (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). Scratch memory can be accessed in an interleaved manner using buffer; instructions with the scratch buffer descriptor and per wavefront scratch; offset, by the scratch instructions, or by flat instructions. Multi-dword; access is not supported except by flat and scratch instructions in; GFX9-GFX11. Code that manipulates the stack values in other lanes of a wavefront,; such as by ``addrspacecast``-ing stack pointers to generic ones and taking offsets; that reach other lanes or by explicitly constructing the scratch buffer descriptor,; triggers undefined behavior when it modifies the scratch values of other lanes.; The compiler may assume that such modifications do not occur.; When using code object V5 ``LIBOMPTARGET_STACK_SIZE`` may be used to provide the; private segment size in bytes, for cases where a dynamic stack is used. **Constant 32-bit**; *TODO*. **Buffer Fat Pointer**; The buffer fat pointer is an experimental address space that is currently; unsupported in the backend. It exposes a non-integral pointer that is in; the future intended to support the modelling of 128-bit buffer descriptors; plus a 32-bit offset into the buffer (in total encapsulating a 160-bit; *pointer*), allowing normal LLVM load/store/atomic operations to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:27856,access,access,27856,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"f bytes of type record data following the; header. - **HashStreamIndex** - The index of a stream which contains a list of hashes; for every type record. This value may be -1, indicating that hash; information is not present. In practice a valid stream index is always; observed, so any producer implementation should be prepared to emit this; stream to ensure compatibility with tools which may expect it to be present. - **HashAuxStreamIndex** - Presumably the index of a stream which contains a; separate hash table, although this has not been observed in practice and it's; unclear what it might be used for. - **HashKeySize** - The size of a hash value (usually 4 bytes). - **NumHashBuckets** - The number of buckets used to generate the hash values; in the aforementioned hash streams. - **HashValueBufferOffset / HashValueBufferLength** - The offset and size within; the TPI Hash Stream of the list of hash values. It should be assumed that; there are either 0 hash values, or a number equal to the number of type; records in the TPI stream (``TypeIndexEnd - TypeEndBegin``). Thus, if; ``HashBufferLength`` is not equal to ``(TypeIndexEnd - TypeEndBegin) *; HashKeySize`` we can consider the PDB malformed. - **IndexOffsetBufferOffset / IndexOffsetBufferLength** - The offset and size; within the TPI Hash Stream of the Type Index Offsets Buffer. This is a list; of pairs of uint32_t's where the first value is a :ref:`Type Index; <type_indices>` and the second value is the offset in the type record data of; the type with this index. This can be used to do a binary search followed by; a linear search to get O(log n) lookup by type index. - **HashAdjBufferOffset / HashAdjBufferLength** - The offset and size within; the TPI hash stream of a serialized hash table whose keys are the hash values; in the hash value buffer and whose values are type indices. This appears to; be useful in incremental linking scenarios, so that if a type is modified an; entry can be created mapping the old hash",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst:9961,hash,hash,9961,interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,1,['hash'],['hash']
Security,"f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introduced the ``-maix-small-local-exec-tls`` option to produce a faster; access sequence for local-exec TLS variables where the offset from the TLS; base is encoded as an immediate operand.; This access sequence is not used for TLS variables larger than 32KB, and is; currently only supported on 64-bit mode.; - Inline assembler supports VSR register in pure digits.; - Enabled ThinLTO support. Requires AIX 7.2 TL5 SP7 or newer, or AIX 7.3 TL2; or newer. Similar to the LTO support on AIX, ThinLTO is implemented with; the libLTO.so plugin. SystemZ Support; ^^^^^^^^^^^^^^^; - Properly support 16 byte atomic int/fp types and ops. Atomic __int128 (and; long double) variables are now aligned to 16 bytes by default (like gcc 14). WebAssembly Support; ^^^^^^^^^^^^^^^^^^^. AVR Support; ^^^^^^^^^^^. DWARF Support in Clang; ----------------------. Floating Point Support in Clang; -------------------------------; - Add ``__builtin_elementwise_log`` builtin for floating point types only.; - Add ``__builtin_elementwise_log10`` builtin for floating point types only.; - Add ``__builtin_elementwise_log2`` builtin for floating point types only.; - Add ``__builtin_elementwise_exp`` builtin for floating point types only.; - Add ``__builtin_elementwise",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:65434,access,access,65434,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['access'],['access']
Security,f non-type typename-specifier; Unknown. 1975; CD4; Permissible declarations for exception-specifications; Unknown. 1976; NAD; Ambiguity of namespace-aliases; Unknown. 1977; drafting; Contradictory results of failed destructor lookup; Not resolved. 1978; CD4; Redundant description of explicit constructor use; Unknown. 1979; drafting; Alias template specialization in template member definition; Not resolved. 1980; drafting; Equivalent but not functionally-equivalent redeclarations; Not resolved. 1981; CD4; Implicit contextual conversions and explicit; Unknown. 1982; NAD; Deduction extending parameter pack; Unknown. 1983; CD5; Inappropriate use of virt-specifier; Unknown. 1984; NAD; Lossless narrowing conversions; Unknown. 1985; NAD; Unknown bound array member with brace-or-equal-initializer; Unknown. 1986; drafting; odr-use and delayed initialization; Not resolved. 1987; NAD; constexpr static data members across translation units; Unknown. 1988; CD4; Ambiguity between dependent and non-dependent bases in implicit member access; Unknown. 1989; drafting; Insufficient restrictions on parameters of postfix operators; Not resolved. 1990; CD4; Ambiguity due to optional decl-specifier-seq; Unknown. 1991; CD4; Inheriting constructors vs default arguments; Clang 3.9. 1992; CD4; new (std::nothrow) int[N] can throw; Unknown. 1993; drafting; Use of template<> defining member of explicit specialization; Not resolved. 1994; dup; Confusing wording regarding multiple template<> prefixes; Duplicate of 529. 1995; CD4; exception-specifications and non-type template parameters; Unknown. 1996; drafting; Reference list-initialization ignores conversion functions; Not resolved. 1997; drafting; Placement new and previous initialization; Not resolved. 1998; NAD; Additional sources of xvalue expressions; Unknown. 1999; CD4; Representation of source characters as universal-character-names; Unknown. 2000; CD4; header-name outside #include directive; Unknown. 2001; CD4; non-directive is underspeci,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:135104,access,access,135104,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"f prebuilt ; mkdir prebuilt; clang -cc1 -emit-module -o prebuilt/A.pcm -fmodules module.modulemap -fmodule-name=A; clang -cc1 -emit-module -o prebuilt/B.pcm -fmodules module.modulemap -fmodule-name=B -fmodule-file=A=prebuilt/A.pcm; clang -cc1 -emit-obj use.c -fmodules -fmodule-map-file=module.modulemap -fmodule-file=A=prebuilt/A.pcm -fmodule-file=B=prebuilt/B.pcm. Instead of of specifying the mappings manually, it can be convenient to use the ``-fprebuilt-module-path`` option. Let's also use ``-fimplicit-module-maps`` instead of manually pointing to our module map. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-module -o prebuilt/A.pcm -fmodules module.modulemap -fmodule-name=A; clang -cc1 -emit-module -o prebuilt/B.pcm -fmodules module.modulemap -fmodule-name=B -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt. A trick to prebuild all modules required for our source file in one command is to generate implicit modules while using the ``-fdisable-module-hash`` option. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf pre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:20709,hash,hash,20709,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['hash'],['hash']
Security,"f the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like in; ""total-ordering"", we will track every number and flag, but instead of; comparison, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are two main important fields in the class:. ``FnTree`` – the set of all unique functions. It keeps items that couldn't be; merged with each other. It is defined as:. ``std::set<FunctionNode> FnTree;``. Here ``FunctionNode`` is a wrapper for ``llvm::Function`` class, with; implemented “<” operator among the functions set (below we explain how it works; exactly; this is a key point in fast functions comparison). ``Deferred`` – merging process can affect bodies of functions that are in; ``FnTree`` already. Obviously, such functions should be rechecked again. In this; case, we remove them from ``FnTree``, and mark them to be rescanned, namely; put them into ``Deferred`` list. runOnModule; """"""""""""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:7437,hash,hash,7437,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['hash'],['hash']
Security,"f the base expression is more; complex, then the cost can rise quickly. I've seen loops where the end; expression was actually something like: ""``SomeMap[X]->end()``"" and map lookups; really aren't cheap. By writing it in the second form consistently, you; eliminate the issue entirely and don't even have to think about it. The second (even bigger) issue is that writing the loop in the first form hints; to the reader that the loop is mutating the container (a fact that a comment; would handily confirm!). If you write the loop in the second form, it is; immediately obvious without even looking at the body of the loop that the; container isn't being modified, which makes it easier to read the code and; understand what it does. While the second form of the loop is a few extra keystrokes, we do strongly; prefer it. ``#include <iostream>`` is Forbidden; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The use of ``#include <iostream>`` in library files is hereby **forbidden**,; because many common implementations transparently inject a `static constructor`_; into every translation unit that includes it. Note that using the other stream headers (``<sstream>`` for example) is not; problematic in this regard --- just ``<iostream>``. However, ``raw_ostream``; provides various APIs that are better performing for almost every use than; ``std::ostream`` style APIs. .. note::. New code should always use `raw_ostream`_ for writing, or the; ``llvm::MemoryBuffer`` API for reading files. .. _raw_ostream:. Use ``raw_ostream``; ^^^^^^^^^^^^^^^^^^^. LLVM includes a lightweight, simple, and efficient stream implementation in; ``llvm/Support/raw_ostream.h``, which provides all of the common features of; ``std::ostream``. All new code should use ``raw_ostream`` instead of; ``ostream``. Unlike ``std::ostream``, ``raw_ostream`` is not a template and can be forward; declared as ``class raw_ostream``. Public headers should generally not include; the ``raw_ostream`` header, but use forward declarations an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst:55163,inject,inject,55163,interpreter/llvm-project/llvm/docs/CodingStandards.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodingStandards.rst,1,['inject'],['inject']
Security,"f type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is; ``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as; described in the TBAA metadata. ``ImmediateParent(BaseTy, Offset)`` is; undefined if ``Offset`` is non-zero. * If ``BaseTy`` is a struct type then ``ImmediateParent(BaseTy, Offset)``; is ``(NewTy, NewOffset)`` where ``NewTy`` is the type contained in; ``BaseTy`` at offset ``Offset`` and ``NewOffset`` is ``Offset`` adjusted; to be relative within that inner type. A memory access with an access tag ``(BaseTy1, AccessTy1, Offset1)``; aliases a memory access with an access tag ``(BaseTy2, AccessTy2,; Offset2)`` if either ``(BaseTy1, Offset1)`` is reachable from ``(Base2,; Offset2)`` via the ``Parent`` relation or vice versa. As a concrete example, the type descriptor graph for the following program. .. code-block:: c. struct Inner {; int i; // offset 0; float f; // offset 4; };. struct Outer {; float f; // offset 0; double d; // offset 4; struct Inner inner_a; // offset 12; };. void f(struct Outer* outer, struct Inner* inner, float* f, int* i, char* c) {; outer->f = 0; // tag0: (OuterStructTy, FloatScalarTy, 0); outer->inner_a.i = 0; // tag1: (OuterStructTy, IntScalarTy, 12); outer->inner_a.f = 0.0; // tag2: (OuterStructTy, FloatScalarTy, 16); *f = 0.0; // tag3: (FloatScalarTy, FloatScalarTy, 0); }. is (note that in C and C++, ``char`` can be used to access any arbitrary; type):. .. code-block:: text. Root = ""TBAA Root""; CharScalarTy = (""char"", Root, 0); FloatScalarTy = (""float"", CharScalarTy, 0); DoubleScalarTy = (""double"", CharScalarTy, 0); IntScalarTy = (""int"", CharScalarT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:276010,access,access,276010,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,4,['access'],['access']
Security,"f((@0-@2)/@3))"" ] = 0.76916; RooFormulaVar::effSig[ actualVars=(pt,as,ms,ss) formula=""0.5*@1*(1+TMath::Erf((@0-@2)/@3))"" ] = 0.899817. *** Print(""t"") ***. p.d.f.s; -------; RooAddPdf::genmodel[ Nsig * sig + Nbkg * bkg ] = 0.502276; RooProdPdf::sig[ ptSigPdf * mllSigPdf * effSigPdf|pt ] = 0.736708; RooExponential::ptSigPdf[ x=pt c=psig_slope ] = 0.818731; RooGaussian::mllSigPdf[ x=mll mean=msig_mean sigma=msig_sigma ] = 1; RooEfficiency::effSigPdf[ cat=cut effFunc=effSig ] = 0.899817; RooFormulaVar::effSig[ actualVars=(pt,as,ms,ss) formula=""0.5*@1*(1+TMath::Erf((@0-@2)/@3))"" ] = 0.899817; RooProdPdf::bkg[ ptBkgPdf * mllBkgPdf * effBkgPdf|pt ] = 0.267845; RooExponential::ptBkgPdf[ x=pt c=pbkg_slope ] = 0.449329; RooPolynomial::mllBkgPdf[ x=mll coefList=(mbkg_slope) ] = 0.775; RooEfficiency::effBkgPdf[ cat=cut effFunc=effBkg ] = 0.76916; RooFormulaVar::effBkg[ actualVars=(pt,ab,mb,sb) formula=""0.5*@1*(1+TMath::Erf((@0-@2)/@3))"" ] = 0.76916. The workspace factory can now access all objects in the generic object store of the workspace, e.g. TMatrixDSym* cov ; RooWorkspace w(""w"") ;; w.import(*cov,""cov"") ;; w.factory(""MultiVarGaussian::mvg({x[-10,10],y[-10,10]},{3,5},cov)"") ;. The workspace factory now correctly identifies and matches typedef-ed names in factory constructor; specifications.; All objects created by the factory and inserted by the workspace get a string attribute ""factory_tag"",; that contains the reduced factory string that was used to create that object, e.g. RooWorkspace w(""w"") ;; w.factory(""Gaussian::g(x[-10,10],m[0],s[3])"") ;; cout << w.pdf(""g"")->getStringAttribute(""factory_tag"") << endl ;; RooGaussian::g(x,m,s). Previously all factory orders that would create objects with names of objects that already existed always; resulted in an error. Now, this will only happen if the factory tag of the existing object is different; from the tag of the existing object. w.factory(""Gaussian::g(x[-10,10],m[0],s[3])"") ;; w.factory(""Chebychev::g(x[-10,10],{0,1,2})"") ; //",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html:4794,access,access,4794,roofit/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v526/index.html,2,['access'],['access']
Security,"f.Define(""mycol"", ""return run_my_fun();"")` needs to be at least declarable; to the interpreter also locally so that the column can be properly tracked. ## Histogram Libraries. ### Upgrade TUnfold to version 17.9. The [TUnfold package](https://www.desy.de/~sschmitt/tunfold.html) inside ROOT is upgraded from version 17.6 to version 17.9. ## Math Libraries. ### Usage of `std::span<const double>` in Minuit 2 interfaces. To avoid forcing the user to do manual memory allocations via `std::vector`, the interfaces of Minuit 2 function adapter classes like `ROOT::Minuit2::FCNBase` or `ROOT::Minuit2::FCNGradientBase` were changed to accept `std::span<const double>` arguments instead of `std::vector<double> const&`.; This should have minimal impact on users, since one should usual use Minuit 2 via the `ROOT::Math::Minimizer` interface, which is unchanged. ## RooFit Libraries. ### Miscellaneous. * Setting `useHashMapForFind(true)` is not supported for RooArgLists anymore, since hash-assisted finding by name hash can be ambiguous: a RooArgList is allowed to have different elements with the same name. If you want to do fast lookups by name, convert your RooArgList to a RooArgSet. * The function `RooFit::bindFunction()` now supports arbitrary many input variables when binding a Python function. * The `ExportOnly()` attribute of the `RooStats::HistFactory::Measurement` object is now switched on by default, and the associated getter and setter functions are deprecated. They will be removed in ROOT 6.36. If you want to fit the model as well instead of just exporting it to a RooWorkspace, please do so with your own code as demonstrated in the `hf001` tutorial. ### Deprecations. * The `RooStats::MarkovChain::GetAsDataSet` and `RooStats::MarkovChain::GetAsDataHist` functions are deprecated and will be removed in ROOT 6.36. The same functionality can be implemented by calling `RooAbsData::reduce` on the Markov Chain's `RooDataSet*` (obtained using `MarkovChain::GetAsConstDataSet`) and th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md:4822,hash,hash-assisted,4822,README/ReleaseNotes/v634/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v634/index.md,2,['hash'],"['hash', 'hash-assisted']"
Security,f1444741 \; --hash=sha256:184c5108a2aca3c5b3d3bf9395d50893a7ab82a38004c8f61c258d4428e80206 \; --hash=sha256:18aeb1bf9a78867dc38b259769503436b7c72f7a1f1f4c93ff9a17de54319b27 \; --hash=sha256:1d4c7e777c441b20e32f52bd377e0c409713e8bb1386e1099c2415f26e479595 \; --hash=sha256:1e2722cc9fbb45d9b87631ac70924c11d3a401b2d7f410cc0e3bbf249f2dca62 \; --hash=sha256:1fe35611261b29bd1de0070f0b2f47cb6ff71fa6595c077e42bd0c419fa27b98 \; --hash=sha256:28c119d996beec18c05208a8bd78cbe4007878c6dd15091efb73a30e90539696 \; --hash=sha256:326c013efe8048858a6d312ddd31d56e468118ad4cdeda36c719bf5bb6192290 \; --hash=sha256:40df9b996c2b73138957fe23a16a4f0ba614f4c0efce1e9406a184b6d07fa3a9 \; --hash=sha256:42f8152b8dbc4fe7d96729ec2b99c7097d656dc1213a3229ca5383f973a5ed6d \; --hash=sha256:49a183be227561de579b4a36efbb21b3eab9651dd81b1858589f796549873dd6 \; --hash=sha256:4fb147e7a67ef577a588a0e2c17b6db51dda102c71de36f8549b6816a96e1867 \; --hash=sha256:50550eb667afee136e9a77d6dc71ae76a44df8b3e51e41b77f6de2932bfe0f47 \; --hash=sha256:510c9deebc5c0225e8c96813043e62b680ba2f9c50a08d3724c7f28a747d1486 \; --hash=sha256:5773183b6446b2c99bb77e77595dd486303b4faab2b086e7b17bc6bef28865f6 \; --hash=sha256:596106435fa6ad000c2991a98fa58eeb8656ef2325d7e158344fb33864ed87e3 \; --hash=sha256:6965a7bc3cf88e5a1c3bd2e0b5c22f8d677dc88a455344035f03399034eb3007 \; --hash=sha256:69b023b2b4daa7548bcfbd4aa3da05b3a74b772db9e23b982788168117739938 \; --hash=sha256:6c22bec3fbe2524cde73d7ada88f6566758a8f7227bfbf93a408a9d86bcc12a0 \; --hash=sha256:704219a11b772aea0d8ecd7058d0082713c3562b4e271b849ad7dc4a5c90c13c \; --hash=sha256:7e07cbde391ba96ab58e532ff4803f79c4129397514e1413a7dc761ccd755735 \; --hash=sha256:81e0b275a9ecc9c0c0c07b4b90ba548307583c125f54d5b6946cfee6360c733d \; --hash=sha256:855fb52b0dc35af121542a76b9a84f8d1cd886ea97c84703eaa6d88e37a2ad28 \; --hash=sha256:8d4e9c88387b0f5c7d5f281e55304de64cf7f9c0021a3525bd3b1c542da3b0e4 \; --hash=sha256:9046c58c4395dff28dd494285c82ba00b546adfc7ef001486fbf0324bc174fba \; --hash=sha256:9eb6caa,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:17407,hash,hash,17407,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,f2131a77 \; --hash=sha256:6897af51655e3691ff853668779c7bad41579facacf5fd7253b0133308cf000d \; --hash=sha256:68d1f8a9e9e37c1223b656399be5d6b448dea850bed7d0f87a8311f1ff3dabb0 \; --hash=sha256:6ac7ffc7ad6d040517be39eb591cac5ff87416c2537df6ba3cba3bae290c0fed \; --hash=sha256:6b3251890fff30ee142c44144871185dbe13b11bab478a88887a639655be1068 \; --hash=sha256:6c4caeef8fa63d06bd437cd4bdcf3ffefe6738fb1b25951440d80dc7df8c03ac \; --hash=sha256:6ef1d82a3af9d3eecdba2321dc1b3c238245d890843e040e41e470ffa64c3e25 \; --hash=sha256:753f10e867343b4511128c6ed8c82f7bec3bd026875576dfd88483c5c73b2fd8 \; --hash=sha256:7cd13a2e3ddeed6913a65e66e94b51d80a041145a026c27e6bb76c31a853c6ab \; --hash=sha256:7ed9e526742851e8d5cc9e6cf41427dfc6068d4f5a3bb03659444b4cabf6bc26 \; --hash=sha256:7f04c839ed0b6b98b1a7501a002144b76c18fb1c1850c8b98d458ac269e26ed2 \; --hash=sha256:802fe99cca7457642125a8a88a084cef28ff0cf9407060f7b93dca5aa25480db \; --hash=sha256:80402cd6ee291dcb72644d6eac93785fe2c8b9cb30893c1af5b8fdd753b9d40f \; --hash=sha256:8465322196c8b4d7ab6d1e049e4c5cb460d0394da4a27d23cc242fbf0034b6b5 \; --hash=sha256:86216b5cee4b06df986d214f664305142d9c76df9b6512be2738aa72a2048f99 \; --hash=sha256:87d1351268731db79e0f8e745d92493ee2841c974128ef629dc518b937d9194c \; --hash=sha256:8bdb58ff7ba23002a4c5808d608e4e6c687175724f54a5dade5fa8c67b604e4d \; --hash=sha256:8c622a5fe39a48f78944a87d4fb8a53ee07344641b0562c540d840748571b811 \; --hash=sha256:8d756e44e94489e49571086ef83b2bb8ce311e730092d2c34ca8f7d925cb20aa \; --hash=sha256:8f4a014bc36d3c57402e2977dada34f9c12300af536839dc38c0beab8878f38a \; --hash=sha256:9063e24fdb1e498ab71cb7419e24622516c4a04476b17a2dab57e8baa30d6e03 \; --hash=sha256:90d558489962fd4918143277a773316e56c72da56ec7aa3dc3dbbe20fdfed15b \; --hash=sha256:923c0c831b7cfcb071580d3f46c4baf50f174be571576556269530f4bbd79d04 \; --hash=sha256:95f2a5796329323b8f0512e09dbb7a1860c46a39da62ecb2324f116fa8fdc85c \; --hash=sha256:96b02a3dc4381e5494fad39be677abcb5e6634bf7b4fa83a6dd3112607547001 \; --hash=sha256:9f96df6,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:4536,hash,hash,4536,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,f28865f6 \; --hash=sha256:596106435fa6ad000c2991a98fa58eeb8656ef2325d7e158344fb33864ed87e3 \; --hash=sha256:6965a7bc3cf88e5a1c3bd2e0b5c22f8d677dc88a455344035f03399034eb3007 \; --hash=sha256:69b023b2b4daa7548bcfbd4aa3da05b3a74b772db9e23b982788168117739938 \; --hash=sha256:6c22bec3fbe2524cde73d7ada88f6566758a8f7227bfbf93a408a9d86bcc12a0 \; --hash=sha256:704219a11b772aea0d8ecd7058d0082713c3562b4e271b849ad7dc4a5c90c13c \; --hash=sha256:7e07cbde391ba96ab58e532ff4803f79c4129397514e1413a7dc761ccd755735 \; --hash=sha256:81e0b275a9ecc9c0c0c07b4b90ba548307583c125f54d5b6946cfee6360c733d \; --hash=sha256:855fb52b0dc35af121542a76b9a84f8d1cd886ea97c84703eaa6d88e37a2ad28 \; --hash=sha256:8d4e9c88387b0f5c7d5f281e55304de64cf7f9c0021a3525bd3b1c542da3b0e4 \; --hash=sha256:9046c58c4395dff28dd494285c82ba00b546adfc7ef001486fbf0324bc174fba \; --hash=sha256:9eb6caa9a297fc2c2fb8862bc5370d0303ddba53ba97e71f08023b6cd73d16a8 \; --hash=sha256:a0cd17c15d3bb3fa06978b4e8958dcdc6e0174ccea823003a106c7d4d7899ac5 \; --hash=sha256:afd7e57eddb1a54f0f1a974bc4391af8bcce0b444685d936840f125cf046d5bd \; --hash=sha256:b1275ad35a5d18c62a7220633c913e1b42d44b46ee12554e5fd39c70a243d6a3 \; --hash=sha256:b786eecbdf8499b9ca1d697215862083bd6d2a99965554781d0d8d1ad31e13a0 \; --hash=sha256:ba336e390cd8e4d1739f42dfe9bb83a3cc2e80f567d8805e11b46f4a943f5515 \; --hash=sha256:baa90d3f661d43131ca170712d903e6295d1f7a0f595074f151c0aed377c9b9c \; --hash=sha256:bc1bf2925a1ecd43da378f4db9e4f799775d6367bdb94671027b73b393a7c42c \; --hash=sha256:bd4af7373a854424dabd882decdc5579653d7868b8fb26dc7d0e99f823aa5924 \; --hash=sha256:bf07ee2fef7014951eeb99f56f39c9bb4af143d8aa3c21b1677805985307da34 \; --hash=sha256:bfdf460b1736c775f2ba9f6a92bca30bc2095067b8a9d77876d1fad6cc3b4a43 \; --hash=sha256:c8098ddcc2a85b61647b2590f825f3db38891662cfc2fc776415143f599bb859 \; --hash=sha256:d2b04aac4d386b172d5b9692e2d2da8de7bfb6c387fa4f801fbf6fb2e6ba4673 \; --hash=sha256:d483d2cdf104e7c9fa60c544d92981f12ad66a457afae824d146093b8c294c54 \; --hash=sha256:d858aa5,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:18555,hash,hash,18555,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,f303377a \; --hash=sha256:3d47fa203a7bd9c5b6cee4736ee84ca03b8ef23193c0d1ca99b5089f72645c73 \; --hash=sha256:3e4d1f6587322d2788836a99c69062fbb091331ec940e02d12d179c1d53e25fc \; --hash=sha256:42cb296636fcc8b0644486d15c12376cb9fa75443e00fb25de0b8602e64c1714 \; --hash=sha256:45485e01ff4d3630ec0d9617310448a8702f70e9c01906b0d0118bdf9d124cf2 \; --hash=sha256:4a78b2b446bd7c934f5dcedc588903fb2f5eec172f3d29e52a9096a43722adfc \; --hash=sha256:4ab2fe47fae9e0f9dee8c04187ce5d09f48eabe611be8259444906793ab7cbce \; --hash=sha256:4d0d1650369165a14e14e1e47b372cfcb31d6ab44e6e33cb2d4e57265290044d \; --hash=sha256:549a3a73da901d5bc3ce8d24e0600d1fa85524c10287f6004fbab87672bf3e1e \; --hash=sha256:55086ee1064215781fff39a1af09518bc9255b50d6333f2e4c74ca09fac6a8f6 \; --hash=sha256:572c3763a264ba47b3cf708a44ce965d98555f618ca42c926a9c1616d8f34269 \; --hash=sha256:573f6eac48f4769d667c4442081b1794f52919e7edada77495aaed9236d13a96 \; --hash=sha256:5b4c145409bef602a690e7cfad0a15a55c13320ff7a3ad7ca59c13bb8ba4d45d \; --hash=sha256:6463effa3186ea09411d50efc7d85360b38d5f09b870c48e4600f63af490e56a \; --hash=sha256:65f6f63034100ead094b8744b3b97965785388f308a64cf8d7c34f2f2e5be0c4 \; --hash=sha256:663946639d296df6a2bb2aa51b60a2454ca1cb29835324c640dafb5ff2131a77 \; --hash=sha256:6897af51655e3691ff853668779c7bad41579facacf5fd7253b0133308cf000d \; --hash=sha256:68d1f8a9e9e37c1223b656399be5d6b448dea850bed7d0f87a8311f1ff3dabb0 \; --hash=sha256:6ac7ffc7ad6d040517be39eb591cac5ff87416c2537df6ba3cba3bae290c0fed \; --hash=sha256:6b3251890fff30ee142c44144871185dbe13b11bab478a88887a639655be1068 \; --hash=sha256:6c4caeef8fa63d06bd437cd4bdcf3ffefe6738fb1b25951440d80dc7df8c03ac \; --hash=sha256:6ef1d82a3af9d3eecdba2321dc1b3c238245d890843e040e41e470ffa64c3e25 \; --hash=sha256:753f10e867343b4511128c6ed8c82f7bec3bd026875576dfd88483c5c73b2fd8 \; --hash=sha256:7cd13a2e3ddeed6913a65e66e94b51d80a041145a026c27e6bb76c31a853c6ab \; --hash=sha256:7ed9e526742851e8d5cc9e6cf41427dfc6068d4f5a3bb03659444b4cabf6bc26 \; --hash=sha256:7f04c83,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:3306,hash,hash,3306,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,f37a02ea \; --hash=sha256:8023faf4e01efadfa183e863fefde0046de576c6f14659e8782065bcece22198 \; --hash=sha256:8758846a7e80910096950b67071243da3e5a20ed2546e6392603c096778d48e0 \; --hash=sha256:8afafd99945ead6e075b973fefa56379c5b5c53fd8937dad92c662da5d8fd5ee \; --hash=sha256:8c41976a29d078bb235fea9b2ecd3da465df42a562910f9022f1a03107bd02be \; --hash=sha256:8e254ae696c88d98da6555f5ace2279cf7cd5b3f52be2b5cf97feafe883b58d2 \; --hash=sha256:8f9293864fe09b8149f0cc42ce56e3f0e54de883a9de90cd427f191c346eb2e1 \; --hash=sha256:9402b03f1a1b4dc4c19845e5c749e3ab82d5078d16a2a4c2cd2df62d57bb0707 \; --hash=sha256:962f82a3086483f5e5f64dbad880d31038b698494799b097bc59c2edf392fce6 \; --hash=sha256:9aad3c1755095ce347e26488214ef77e0485a3c34a50c5a5e2471dff60b9dd9c \; --hash=sha256:9dcdfd0eaf283af041973bff14a2e143b8bd64e069f4c383416ecd79a81aab58 \; --hash=sha256:aa57bd9cf8ae831a362185ee444e15a93ecb2e344c8e52e4d721ea3ab6ef1823 \; --hash=sha256:aa7bd130efab1c280bed0f45501b7c8795f9fdbeb02e965371bbef3523627779 \; --hash=sha256:ab4a0df41e7c16a1392727727e7998a467472d0ad65f3ad5e6e765015df08636 \; --hash=sha256:ad9e82fb8f09ade1c3e1b996a6337afac2b8b9e365f926f5a61aacc71adc5b3c \; --hash=sha256:af598ed32d6ae86f1b747b82783958b1a4ab8f617b06fe68795c7f026abbdcad \; --hash=sha256:b076b6226fb84157e3f7c971a47ff3a679d837cf338547532ab866c57930dbee \; --hash=sha256:b7ff0f54cb4ff66dd38bebd335a38e2c22c41a8ee45aa608efc890ac3e3931bc \; --hash=sha256:bfce63a9e7834b12b87c64d6b155fdd9b3b96191b6bd334bf37db7ff1fe457f2 \; --hash=sha256:c011a4149cfbcf9f03994ec2edffcb8b1dc2d2aede7ca243746df97a5d41ce48 \; --hash=sha256:c9c804664ebe8f83a211cace637506669e7890fec1b4195b505c214e50dd4eb7 \; --hash=sha256:ca379055a47383d02a5400cb0d110cef0a776fc644cda797db0c5696cfd7e18e \; --hash=sha256:cb0932dc158471523c9637e807d9bfb93e06a95cbf010f1a38b98623b929ef2b \; --hash=sha256:cd0f502fe016460680cd20aaa5a76d241d6f35a1c3350c474bac1273803893fa \; --hash=sha256:ceb01949af7121f9fc39f7d27f91be8546f3fb112c608bc4029aef0bab86a2a5 \; --hash=sha256:d080e0a,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:13406,hash,hash,13406,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,f392fce6 \; --hash=sha256:9aad3c1755095ce347e26488214ef77e0485a3c34a50c5a5e2471dff60b9dd9c \; --hash=sha256:9dcdfd0eaf283af041973bff14a2e143b8bd64e069f4c383416ecd79a81aab58 \; --hash=sha256:aa57bd9cf8ae831a362185ee444e15a93ecb2e344c8e52e4d721ea3ab6ef1823 \; --hash=sha256:aa7bd130efab1c280bed0f45501b7c8795f9fdbeb02e965371bbef3523627779 \; --hash=sha256:ab4a0df41e7c16a1392727727e7998a467472d0ad65f3ad5e6e765015df08636 \; --hash=sha256:ad9e82fb8f09ade1c3e1b996a6337afac2b8b9e365f926f5a61aacc71adc5b3c \; --hash=sha256:af598ed32d6ae86f1b747b82783958b1a4ab8f617b06fe68795c7f026abbdcad \; --hash=sha256:b076b6226fb84157e3f7c971a47ff3a679d837cf338547532ab866c57930dbee \; --hash=sha256:b7ff0f54cb4ff66dd38bebd335a38e2c22c41a8ee45aa608efc890ac3e3931bc \; --hash=sha256:bfce63a9e7834b12b87c64d6b155fdd9b3b96191b6bd334bf37db7ff1fe457f2 \; --hash=sha256:c011a4149cfbcf9f03994ec2edffcb8b1dc2d2aede7ca243746df97a5d41ce48 \; --hash=sha256:c9c804664ebe8f83a211cace637506669e7890fec1b4195b505c214e50dd4eb7 \; --hash=sha256:ca379055a47383d02a5400cb0d110cef0a776fc644cda797db0c5696cfd7e18e \; --hash=sha256:cb0932dc158471523c9637e807d9bfb93e06a95cbf010f1a38b98623b929ef2b \; --hash=sha256:cd0f502fe016460680cd20aaa5a76d241d6f35a1c3350c474bac1273803893fa \; --hash=sha256:ceb01949af7121f9fc39f7d27f91be8546f3fb112c608bc4029aef0bab86a2a5 \; --hash=sha256:d080e0a5eb2529460b30190fcfcc4199bd7f827663f858a226a81bc27beaa97e \; --hash=sha256:dd15ff04ffd7e05ffcb7fe79f1b98041b8ea30ae9234aed2a9168b5797c3effb \; --hash=sha256:df0be2b576a7abbf737b1575f048c23fb1d769f267ec4358296f31c2479db8f9 \; --hash=sha256:e09031c87a1e51556fdcb46e5bd4f59dfb743061cf93c4d6831bf894f125eb57 \; --hash=sha256:e4dd52d80b8c83fdce44e12478ad2e85c64ea965e75d66dbeafb0a3e77308fcc \; --hash=sha256:f698de3fd0c4e6972b92290a45bd9b1536bffe8c6759c62471efaa8acb4c37bc \; --hash=sha256:fec21693218efe39aa7f8599346e90c705afa52c5b31ae019b2e57e8f6542bb2 \; --hash=sha256:ffcc3f7c66b5f5b7931a5aa68fc9cecc51e685ef90282f4a82f0f5e9b704ad11; # via jinja2; mdit-py-p,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:14062,hash,hash,14062,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,f46041c3 \; --hash=sha256:525808b8019e36eb524b8c68acdd63a37e75714eac50e988180b169d64480a00 \; --hash=sha256:56d9f2ecac662ca1611d183feb03a3fa4406469dafe241673d521dd5ae92a155 \; --hash=sha256:5bbe06f8eeafd38e5d0a4894ffec89378b6c6a625ff57e3028921f8ff59318ac \; --hash=sha256:65c1a9bcdadc6c28eecee2c119465aebff8f7a584dd719facdd9e825ec61ab52 \; --hash=sha256:68e78619a61ecf91e76aa3e6e8e33fc4894a2bebe93410754bd28fce0a8a4f9f \; --hash=sha256:69c0f17e9f5a7afdf2cc9fb2d1ce6aabdb3bafb7f38017c0b77862bcec2bbad8 \; --hash=sha256:6b2b56950d93e41f33b4223ead100ea0fe11f8e6ee5f641eb753ce4b77a7042b \; --hash=sha256:715d3562f79d540f251b99ebd6d8baa547118974341db04f5ad06d5ea3eb8007 \; --hash=sha256:787003c0ddb00500e49a10f2844fac87aa6ce977b90b0feaaf9de23c22508b24 \; --hash=sha256:7ef3cb2ebbf91e330e3bb937efada0edd9003683db6b57bb108c4001f37a02ea \; --hash=sha256:8023faf4e01efadfa183e863fefde0046de576c6f14659e8782065bcece22198 \; --hash=sha256:8758846a7e80910096950b67071243da3e5a20ed2546e6392603c096778d48e0 \; --hash=sha256:8afafd99945ead6e075b973fefa56379c5b5c53fd8937dad92c662da5d8fd5ee \; --hash=sha256:8c41976a29d078bb235fea9b2ecd3da465df42a562910f9022f1a03107bd02be \; --hash=sha256:8e254ae696c88d98da6555f5ace2279cf7cd5b3f52be2b5cf97feafe883b58d2 \; --hash=sha256:8f9293864fe09b8149f0cc42ce56e3f0e54de883a9de90cd427f191c346eb2e1 \; --hash=sha256:9402b03f1a1b4dc4c19845e5c749e3ab82d5078d16a2a4c2cd2df62d57bb0707 \; --hash=sha256:962f82a3086483f5e5f64dbad880d31038b698494799b097bc59c2edf392fce6 \; --hash=sha256:9aad3c1755095ce347e26488214ef77e0485a3c34a50c5a5e2471dff60b9dd9c \; --hash=sha256:9dcdfd0eaf283af041973bff14a2e143b8bd64e069f4c383416ecd79a81aab58 \; --hash=sha256:aa57bd9cf8ae831a362185ee444e15a93ecb2e344c8e52e4d721ea3ab6ef1823 \; --hash=sha256:aa7bd130efab1c280bed0f45501b7c8795f9fdbeb02e965371bbef3523627779 \; --hash=sha256:ab4a0df41e7c16a1392727727e7998a467472d0ad65f3ad5e6e765015df08636 \; --hash=sha256:ad9e82fb8f09ade1c3e1b996a6337afac2b8b9e365f926f5a61aacc71adc5b3c \; --hash=sha256:af598ed,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:12586,hash,hash,12586,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,f490e56a \; --hash=sha256:65f6f63034100ead094b8744b3b97965785388f308a64cf8d7c34f2f2e5be0c4 \; --hash=sha256:663946639d296df6a2bb2aa51b60a2454ca1cb29835324c640dafb5ff2131a77 \; --hash=sha256:6897af51655e3691ff853668779c7bad41579facacf5fd7253b0133308cf000d \; --hash=sha256:68d1f8a9e9e37c1223b656399be5d6b448dea850bed7d0f87a8311f1ff3dabb0 \; --hash=sha256:6ac7ffc7ad6d040517be39eb591cac5ff87416c2537df6ba3cba3bae290c0fed \; --hash=sha256:6b3251890fff30ee142c44144871185dbe13b11bab478a88887a639655be1068 \; --hash=sha256:6c4caeef8fa63d06bd437cd4bdcf3ffefe6738fb1b25951440d80dc7df8c03ac \; --hash=sha256:6ef1d82a3af9d3eecdba2321dc1b3c238245d890843e040e41e470ffa64c3e25 \; --hash=sha256:753f10e867343b4511128c6ed8c82f7bec3bd026875576dfd88483c5c73b2fd8 \; --hash=sha256:7cd13a2e3ddeed6913a65e66e94b51d80a041145a026c27e6bb76c31a853c6ab \; --hash=sha256:7ed9e526742851e8d5cc9e6cf41427dfc6068d4f5a3bb03659444b4cabf6bc26 \; --hash=sha256:7f04c839ed0b6b98b1a7501a002144b76c18fb1c1850c8b98d458ac269e26ed2 \; --hash=sha256:802fe99cca7457642125a8a88a084cef28ff0cf9407060f7b93dca5aa25480db \; --hash=sha256:80402cd6ee291dcb72644d6eac93785fe2c8b9cb30893c1af5b8fdd753b9d40f \; --hash=sha256:8465322196c8b4d7ab6d1e049e4c5cb460d0394da4a27d23cc242fbf0034b6b5 \; --hash=sha256:86216b5cee4b06df986d214f664305142d9c76df9b6512be2738aa72a2048f99 \; --hash=sha256:87d1351268731db79e0f8e745d92493ee2841c974128ef629dc518b937d9194c \; --hash=sha256:8bdb58ff7ba23002a4c5808d608e4e6c687175724f54a5dade5fa8c67b604e4d \; --hash=sha256:8c622a5fe39a48f78944a87d4fb8a53ee07344641b0562c540d840748571b811 \; --hash=sha256:8d756e44e94489e49571086ef83b2bb8ce311e730092d2c34ca8f7d925cb20aa \; --hash=sha256:8f4a014bc36d3c57402e2977dada34f9c12300af536839dc38c0beab8878f38a \; --hash=sha256:9063e24fdb1e498ab71cb7419e24622516c4a04476b17a2dab57e8baa30d6e03 \; --hash=sha256:90d558489962fd4918143277a773316e56c72da56ec7aa3dc3dbbe20fdfed15b \; --hash=sha256:923c0c831b7cfcb071580d3f46c4baf50f174be571576556269530f4bbd79d04 \; --hash=sha256:95f2a57,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:4372,hash,hash,4372,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,f59318ac \; --hash=sha256:65c1a9bcdadc6c28eecee2c119465aebff8f7a584dd719facdd9e825ec61ab52 \; --hash=sha256:68e78619a61ecf91e76aa3e6e8e33fc4894a2bebe93410754bd28fce0a8a4f9f \; --hash=sha256:69c0f17e9f5a7afdf2cc9fb2d1ce6aabdb3bafb7f38017c0b77862bcec2bbad8 \; --hash=sha256:6b2b56950d93e41f33b4223ead100ea0fe11f8e6ee5f641eb753ce4b77a7042b \; --hash=sha256:715d3562f79d540f251b99ebd6d8baa547118974341db04f5ad06d5ea3eb8007 \; --hash=sha256:787003c0ddb00500e49a10f2844fac87aa6ce977b90b0feaaf9de23c22508b24 \; --hash=sha256:7ef3cb2ebbf91e330e3bb937efada0edd9003683db6b57bb108c4001f37a02ea \; --hash=sha256:8023faf4e01efadfa183e863fefde0046de576c6f14659e8782065bcece22198 \; --hash=sha256:8758846a7e80910096950b67071243da3e5a20ed2546e6392603c096778d48e0 \; --hash=sha256:8afafd99945ead6e075b973fefa56379c5b5c53fd8937dad92c662da5d8fd5ee \; --hash=sha256:8c41976a29d078bb235fea9b2ecd3da465df42a562910f9022f1a03107bd02be \; --hash=sha256:8e254ae696c88d98da6555f5ace2279cf7cd5b3f52be2b5cf97feafe883b58d2 \; --hash=sha256:8f9293864fe09b8149f0cc42ce56e3f0e54de883a9de90cd427f191c346eb2e1 \; --hash=sha256:9402b03f1a1b4dc4c19845e5c749e3ab82d5078d16a2a4c2cd2df62d57bb0707 \; --hash=sha256:962f82a3086483f5e5f64dbad880d31038b698494799b097bc59c2edf392fce6 \; --hash=sha256:9aad3c1755095ce347e26488214ef77e0485a3c34a50c5a5e2471dff60b9dd9c \; --hash=sha256:9dcdfd0eaf283af041973bff14a2e143b8bd64e069f4c383416ecd79a81aab58 \; --hash=sha256:aa57bd9cf8ae831a362185ee444e15a93ecb2e344c8e52e4d721ea3ab6ef1823 \; --hash=sha256:aa7bd130efab1c280bed0f45501b7c8795f9fdbeb02e965371bbef3523627779 \; --hash=sha256:ab4a0df41e7c16a1392727727e7998a467472d0ad65f3ad5e6e765015df08636 \; --hash=sha256:ad9e82fb8f09ade1c3e1b996a6337afac2b8b9e365f926f5a61aacc71adc5b3c \; --hash=sha256:af598ed32d6ae86f1b747b82783958b1a4ab8f617b06fe68795c7f026abbdcad \; --hash=sha256:b076b6226fb84157e3f7c971a47ff3a679d837cf338547532ab866c57930dbee \; --hash=sha256:b7ff0f54cb4ff66dd38bebd335a38e2c22c41a8ee45aa608efc890ac3e3931bc \; --hash=sha256:bfce63a,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:12832,hash,hash,12832,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,"f7893912e06 in main umr2.cc:4. By default, MemorySanitizer collects both allocation points and all; intermediate stores the uninitialized value went through. Origin; tracking has proved to be very useful for debugging MemorySanitizer; reports. It slows down program execution by a factor of 1.5x-2x on top; of the usual MemorySanitizer slowdown and increases memory overhead. Clang option ``-fsanitize-memory-track-origins=1`` enables a slightly; faster mode when MemorySanitizer collects only allocation points but; not intermediate stores. Use-after-destruction detection; ===============================. MemorySanitizer includes use-after-destruction detection. After invocation of; the destructor, the object will be considered no longer readable, and using; underlying memory will lead to error reports in runtime. Refer to the standard; for `lifetime <https://eel.is/c++draft/basic.life#1>`_ definition. This feature can be disabled with either:. #. Pass addition Clang option ``-fno-sanitize-memory-use-after-dtor`` during; compilation.; #. Set environment variable `MSAN_OPTIONS=poison_in_dtor=0` before running; the program. Handling external code; ======================. MemorySanitizer requires that all program code is instrumented. This; also includes any libraries that the program depends on, even libc.; Failing to achieve this may result in false reports.; For the same reason you may need to replace all inline assembly code that writes to memory; with a pure C/C++ code. Full MemorySanitizer instrumentation is very difficult to achieve. To; make it easier, MemorySanitizer runtime library includes 70+; interceptors for the most common libc functions. They make it possible; to run MemorySanitizer-instrumented programs linked with; uninstrumented libc. For example, the authors were able to bootstrap; MemorySanitizer-instrumented Clang compiler by linking it with; self-built instrumented libc++ (as a replacement for libstdc++). Supported Platforms; ===================. Memo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst:5809,sanitiz,sanitize-memory-use-after-dtor,5809,interpreter/llvm-project/clang/docs/MemorySanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MemorySanitizer.rst,1,['sanitiz'],['sanitize-memory-use-after-dtor']
Security,f91174d4 \; --hash=sha256:f27273b60488abe721a075bcca6d7f3964f9f6f067c8c4c605743023d7d3944f \; --hash=sha256:f30c3cb33b24454a82faecaf01b19c18562b1e89558fb6c56de4d9118a032fd5 \; --hash=sha256:fb69256e180cb6c8a894fee62b3afebae785babc1ee98b81cdf68bbca1987f33 \; --hash=sha256:fd1abc0d89e30cc4e02e4064dc67fcc51bd941eb395c502aac3ec19fab46b519 \; --hash=sha256:ff8fa367d09b717b2a17a052544193ad76cd49979c805768879cb63d9ca50561; # via requests; commonmark==0.9.1 \; --hash=sha256:452f9dc859be7f06631ddcb328b6919c67984aca654e5fefb3914d54691aed60 \; --hash=sha256:da2f38c92590f83de410ba1a3cbceafbc74fee9def35f9251ba9a971d6d66fd9; # via recommonmark; docutils==0.20.1 \; --hash=sha256:96f387a2c5562db4476f09f13bbab2192e764cac08ebbf3a34a95d9b1e4a59d6 \; --hash=sha256:f08a4e276c3a1583a86dce3e34aba3fe04d02bba2dd51ed16106244e8a923e3b; # via; # -r requirements.txt; # myst-parser; # recommonmark; # sphinx; furo==2023.8.19 \; --hash=sha256:12f99f87a1873b6746228cfde18f77244e6c1ffb85d7fed95e638aae70d80590 \; --hash=sha256:e671ee638ab3f1b472f4033b0167f502ab407830e0db0f843b1c1028119c9cd1; # via -r requirements.txt; idna==3.6 \; --hash=sha256:9ecdbbd083b06798ae1e86adcbfe8ab1479cf864e4ee30fe4e46a003d12491ca \; --hash=sha256:c05567e9c24a6b9faaa835c4821bad0590fbb9d5779e7caa6e1cc4978e7eb24f; # via requests; imagesize==1.4.1 \; --hash=sha256:0d8d18d08f840c19d0ee7ca1fd82490fdc3729b7ac93f49870406ddde8ef8d8b \; --hash=sha256:69150444affb9cb0d5cc5a92b3676f0b2fb7cd9ae39e947a5e11a36b4497cd4a; # via sphinx; jinja2==3.1.2 \; --hash=sha256:31351a702a408a9e7595a8fc6150fc3f43bb6bf7e319770cbc0db9df9437e852 \; --hash=sha256:6088930bfe239f0e6710546ab9c19c9ef35e29792895fed6e6e31a023a182a61; # via; # myst-parser; # sphinx; markdown==3.5.1 \; --hash=sha256:5874b47d4ee3f0b14d764324d2c94c03ea66bee56f2d929da9f2508d65e722dc \; --hash=sha256:b65d7beb248dc22f2e8a31fb706d93798093c308dc1aba295aedeb9d41a813bd; # via sphinx-markdown-tables; markdown-it-py==3.0.0 \; --hash=sha256:355216845c60bd96232cd8d8c40e8f9765cc86f46880e43a8fd2,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:8879,hash,hash,8879,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,2,['hash'],['hash']
Security,"f; row_mask:0b1010; row_mask:x|y. .. _amdgpu_synid_bank_mask:. bank_mask; ~~~~~~~~~. Controls which banks are enabled for data sharing. By default, all banks are enabled. Note: the lanes of a wavefront are organized in four *rows* and four *banks*.; (There are only two rows in *wave32* mode.). ================== ====================================================================; Syntax Description; ================== ====================================================================; bank_mask:{0..15} Specifies a *bank mask* as a positive; :ref:`integer number <amdgpu_synid_integer_number>`; or an :ref:`absolute expression<amdgpu_synid_absolute_expression>`. Each of the 4 bits in the mask controls one bank; (0 - disabled, 1 - enabled).; ================== ====================================================================. Examples:. .. parsed-literal::. bank_mask:0x3; bank_mask:0b0011; bank_mask:x&y. .. _amdgpu_synid_bound_ctrl:. bound_ctrl; ~~~~~~~~~~. Controls data sharing when accessing an invalid lane. By default, data sharing with; invalid lanes is disabled. ======================================== ================================================; Syntax Description; ======================================== ================================================; bound_ctrl:1 Enables data sharing with invalid lanes. Accessing data from an invalid lane will; return zero. bound_ctrl:0 (GFX11+) Disables data sharing with invalid lanes.; ======================================== ================================================. .. WARNING:: For historical reasons, *bound_ctrl:0* has the same meaning as *bound_ctrl:1* for older architectures. .. _amdgpu_synid_fi16:. fi; ~~. Controls interaction with *inactive* lanes for *dpp16* instructions. The default value is zero. Note: *inactive* lanes are those whose :ref:`exec<amdgpu_synid_exec>` mask bit is zero. ======================================== ==================================================; Syntax Description; ==",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst:45815,access,accessing,45815,interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUModifierSyntax.rst,1,['access'],['accessing']
Security,"f; their pointers point to the same address. This might be too strict for; some classes where equality is already achieved if some or all of the; data members are equal. By overriding the following **`TObject`** member; functions, you can change the behavior of objects in collections:. - `IsEqual()`is used by the `FindObject() `collection method. By; default, `IsEqual()` compares the two object pointers. - `Compare()`returns -1, 0 or 1 depending if the object is smaller,; equal or larger than the other object. By default, a **`TObject`**; has not a valid `Compare()` method. - `IsSortable() `returns true if the class is sort able (i.e. if it; has a valid `Compare(`) method). By default, a **`TObject`** is not; sort able. - `Hash() `returns a hash value. It needs to be implemented if an; object has to be stored in a collection using a hashing technique,; like **`THashTable`**, **`THashList`** and **`TMap`**. By default,; `Hash(`) returns the address of the object. It is essential to; choose a good hash function. The example below shows how to use and override these member functions. ``` {.cpp}; class TObjNum : public TObject {; private:; Int_t num; // TObjNum is a simple container for an integer.; public:; TObjNum(Int_t i = 0) : num(i) { }; ~TObjNum() { }; void SetNum(Int_t i) { num = i; }; Int_t GetNum() const { return num; }; void Print(Option_t *) const; { printf(""num = %dn"", num); }; Bool_t IsEqual(TObject *obj) const; { return num == ((TObjNum*)obj)->num; }; Bool_t IsSortable() const { return kTRUE; }; Int_t Compare(const TObject *obj) const; { if (num < ((TObjNum*)obj)->num) return -1;; else if (num > ((TObjNum*)obj)->num) return 1;; else return 0; }; ULong_t Hash() const { return num; }; };; ```. ## The TIter Generic Iterator. As stated above, the **`TIterator`** class is abstract; it is not; possible to create **`TIterator`** objects. However, it should be; possible to write generic code to process all members of a collection so; there is a need for a generic i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:9597,hash,hash,9597,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['hash'],['hash']
Security,fac6a8f6 \; --hash=sha256:572c3763a264ba47b3cf708a44ce965d98555f618ca42c926a9c1616d8f34269 \; --hash=sha256:573f6eac48f4769d667c4442081b1794f52919e7edada77495aaed9236d13a96 \; --hash=sha256:5b4c145409bef602a690e7cfad0a15a55c13320ff7a3ad7ca59c13bb8ba4d45d \; --hash=sha256:6463effa3186ea09411d50efc7d85360b38d5f09b870c48e4600f63af490e56a \; --hash=sha256:65f6f63034100ead094b8744b3b97965785388f308a64cf8d7c34f2f2e5be0c4 \; --hash=sha256:663946639d296df6a2bb2aa51b60a2454ca1cb29835324c640dafb5ff2131a77 \; --hash=sha256:6897af51655e3691ff853668779c7bad41579facacf5fd7253b0133308cf000d \; --hash=sha256:68d1f8a9e9e37c1223b656399be5d6b448dea850bed7d0f87a8311f1ff3dabb0 \; --hash=sha256:6ac7ffc7ad6d040517be39eb591cac5ff87416c2537df6ba3cba3bae290c0fed \; --hash=sha256:6b3251890fff30ee142c44144871185dbe13b11bab478a88887a639655be1068 \; --hash=sha256:6c4caeef8fa63d06bd437cd4bdcf3ffefe6738fb1b25951440d80dc7df8c03ac \; --hash=sha256:6ef1d82a3af9d3eecdba2321dc1b3c238245d890843e040e41e470ffa64c3e25 \; --hash=sha256:753f10e867343b4511128c6ed8c82f7bec3bd026875576dfd88483c5c73b2fd8 \; --hash=sha256:7cd13a2e3ddeed6913a65e66e94b51d80a041145a026c27e6bb76c31a853c6ab \; --hash=sha256:7ed9e526742851e8d5cc9e6cf41427dfc6068d4f5a3bb03659444b4cabf6bc26 \; --hash=sha256:7f04c839ed0b6b98b1a7501a002144b76c18fb1c1850c8b98d458ac269e26ed2 \; --hash=sha256:802fe99cca7457642125a8a88a084cef28ff0cf9407060f7b93dca5aa25480db \; --hash=sha256:80402cd6ee291dcb72644d6eac93785fe2c8b9cb30893c1af5b8fdd753b9d40f \; --hash=sha256:8465322196c8b4d7ab6d1e049e4c5cb460d0394da4a27d23cc242fbf0034b6b5 \; --hash=sha256:86216b5cee4b06df986d214f664305142d9c76df9b6512be2738aa72a2048f99 \; --hash=sha256:87d1351268731db79e0f8e745d92493ee2841c974128ef629dc518b937d9194c \; --hash=sha256:8bdb58ff7ba23002a4c5808d608e4e6c687175724f54a5dade5fa8c67b604e4d \; --hash=sha256:8c622a5fe39a48f78944a87d4fb8a53ee07344641b0562c540d840748571b811 \; --hash=sha256:8d756e44e94489e49571086ef83b2bb8ce311e730092d2c34ca8f7d925cb20aa \; --hash=sha256:8f4a014,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:4044,hash,hash,4044,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,"factory functions `MakeCsvDataFrame`, `MakeArrowDataFrame`, `MakeNTupleDataFrame` and `MakeSqliteDataFrame` that were deprecated in v6.28 have been removed. Use `FromCSV`, `FromArrow`, `FromRNTuple` or `FromSqlite` instead.; - The TStorage reallocation routine without a size (`TStorage::ReAlloc(void *ovp, size_t size`) and heap related routines (`TStorage::AddToHeap`, `TStorage::IsOnHeap`, `TStorage::GetHeapBegin`, `TStorage::GetHeapEnd`) that were deprecated in v6.02/00 have been removed.; - The deprecated `Format(const char* option, int sigDigits)` option for `RooAbsPdf::paramOn()` was removed. Please use the `Format(const char* option, ...)` overload that takes command arguments.; - The deprecated `RooAbsPdf::paramOn()` overload that directly takes a formatting string was removed. Please take the overload that uses command arguments.; - The `RooCatType` class was deprecated in ROOT 6.22 and its original `RooCatType.h` header is now removed. If you still need access to this class, please include `RooFitLegacy/RooCatTypeLegacy.h`.; - The `RooAbsString` that was only an alias for `RooStringVar` got removed.; - The `RooDataWeightedAverage` is now deprecated and will be removed in 6.32. It was only supposed to be an implementation detail of RooFits plotting that is now not necessary anymore.; - The `RooSpan` class was removed and its place in the implementation details of RooFit is now taken by `std::span`.; - The `RooAbsArg::isCloneOf()` and `RooAbsArg::getCloningAncestors()` member functions were removed because they didn't work (always returned `false` and an empty list respectively); - `ROOT::Math::KelvinFunctions` had an incompatible license and needed to be removed without deprecation.; - The use of `ROOT_GIT_BRANCH` and `ROOT_GIT_COMMIT` have been deprecated in favor of parsing `etc/gitinfo.txt`. This later file is now generated as part of the build of ROOT; `RGitCommit.h` (defining `ROOT_GIT_BRANCH` and `ROOT_GIT_COMMIT`) is not updated anymore. This simplifies",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:3402,access,access,3402,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['access'],['access']
Security,fdfed15b \; --hash=sha256:923c0c831b7cfcb071580d3f46c4baf50f174be571576556269530f4bbd79d04 \; --hash=sha256:95f2a5796329323b8f0512e09dbb7a1860c46a39da62ecb2324f116fa8fdc85c \; --hash=sha256:96b02a3dc4381e5494fad39be677abcb5e6634bf7b4fa83a6dd3112607547001 \; --hash=sha256:9f96df6923e21816da7e0ad3fd47dd8f94b2a5ce594e00677c0013018b813458 \; --hash=sha256:a10af20b82360ab00827f916a6058451b723b4e65030c5a18577c8b2de5b3389 \; --hash=sha256:a50aebfa173e157099939b17f18600f72f84eed3049e743b68ad15bd69b6bf99 \; --hash=sha256:a981a536974bbc7a512cf44ed14938cf01030a99e9b3a06dd59578882f06f985 \; --hash=sha256:a9a8e9031d613fd2009c182b69c7b2c1ef8239a0efb1df3f7c8da66d5dd3d537 \; --hash=sha256:ae5f4161f18c61806f411a13b0310bea87f987c7d2ecdbdaad0e94eb2e404238 \; --hash=sha256:aed38f6e4fb3f5d6bf81bfa990a07806be9d83cf7bacef998ab1a9bd660a581f \; --hash=sha256:b01b88d45a6fcb69667cd6d2f7a9aeb4bf53760d7fc536bf679ec94fe9f3ff3d \; --hash=sha256:b261ccdec7821281dade748d088bb6e9b69e6d15b30652b74cbbac25e280b796 \; --hash=sha256:b2b0a0c0517616b6869869f8c581d4eb2dd83a4d79e0ebcb7d373ef9956aeb0a \; --hash=sha256:b4a23f61ce87adf89be746c8a8974fe1c823c891d8f86eb218bb957c924bb143 \; --hash=sha256:bd8f7df7d12c2db9fab40bdd87a7c09b1530128315d047a086fa3ae3435cb3a8 \; --hash=sha256:beb58fe5cdb101e3a055192ac291b7a21e3b7ef4f67fa1d74e331a7f2124341c \; --hash=sha256:c002b4ffc0be611f0d9da932eb0f704fe2602a9a949d1f738e4c34c75b0863d5 \; --hash=sha256:c083af607d2515612056a31f0a8d9e0fcb5876b7bfc0abad3ecd275bc4ebc2d5 \; --hash=sha256:c180f51afb394e165eafe4ac2936a14bee3eb10debc9d9e4db8958fe36afe711 \; --hash=sha256:c235ebd9baae02f1b77bcea61bce332cb4331dc3617d254df3323aa01ab47bd4 \; --hash=sha256:cd70574b12bb8a4d2aaa0094515df2463cb429d8536cfb6c7ce983246983e5a6 \; --hash=sha256:d0eccceffcb53201b5bfebb52600a5fb483a20b61da9dbc885f8b103cbe7598c \; --hash=sha256:d965bba47ddeec8cd560687584e88cf699fd28f192ceb452d1d7ee807c5597b7 \; --hash=sha256:db364eca23f876da6f9e16c9da0df51aa4f104a972735574842618b8c6d999d4 \; --hash=sha256:ddbb255,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:6258,hash,hash,6258,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,"ferent work-groups; as they may be executing on different WGPs.; * The scalar memory operations access a scalar L0 cache shared by all wavefronts; on a WGP. The scalar and vector L0 caches are not coherent. However, scalar; operations are used in a restricted way so do not impact the memory model. See; :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory L0 caches use an L1 cache shared by all WGPs on; the same SA. Therefore, no special action is required for coherence between; the wavefronts of a single work-group. However, a ``buffer_gl1_inv`` is; required for coherence between wavefronts executing in different work-groups; as they may be executing on different SAs that access different L1s.; * The L1 caches have independent quadrants to service disjoint ranges of virtual; addresses.; * Each L0 cache has a separate request queue per L1 quadrant. Therefore, the; vector and scalar memory operations performed by different wavefronts, whether; executing in the same or different work-groups (which may be executing on; different CUs accessing different L0s), can be reordered relative to each; other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is required to ensure; synchronization between vector memory operations of different wavefronts. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L1 caches use an L2 cache shared by all SAs on the same agent.; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each L1 quadrant of a single SA accesses a different L2 channel. Each L1; quadrant has a separate request queue per L2 channel. Therefore, the vector; and scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different SAs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0) &",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:338318,access,accessing,338318,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessing']
Security,"fety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20216,access,access,20216,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['access'],['access']
Security,ff3dabb0 \; --hash=sha256:6ac7ffc7ad6d040517be39eb591cac5ff87416c2537df6ba3cba3bae290c0fed \; --hash=sha256:6b3251890fff30ee142c44144871185dbe13b11bab478a88887a639655be1068 \; --hash=sha256:6c4caeef8fa63d06bd437cd4bdcf3ffefe6738fb1b25951440d80dc7df8c03ac \; --hash=sha256:6ef1d82a3af9d3eecdba2321dc1b3c238245d890843e040e41e470ffa64c3e25 \; --hash=sha256:753f10e867343b4511128c6ed8c82f7bec3bd026875576dfd88483c5c73b2fd8 \; --hash=sha256:7cd13a2e3ddeed6913a65e66e94b51d80a041145a026c27e6bb76c31a853c6ab \; --hash=sha256:7ed9e526742851e8d5cc9e6cf41427dfc6068d4f5a3bb03659444b4cabf6bc26 \; --hash=sha256:7f04c839ed0b6b98b1a7501a002144b76c18fb1c1850c8b98d458ac269e26ed2 \; --hash=sha256:802fe99cca7457642125a8a88a084cef28ff0cf9407060f7b93dca5aa25480db \; --hash=sha256:80402cd6ee291dcb72644d6eac93785fe2c8b9cb30893c1af5b8fdd753b9d40f \; --hash=sha256:8465322196c8b4d7ab6d1e049e4c5cb460d0394da4a27d23cc242fbf0034b6b5 \; --hash=sha256:86216b5cee4b06df986d214f664305142d9c76df9b6512be2738aa72a2048f99 \; --hash=sha256:87d1351268731db79e0f8e745d92493ee2841c974128ef629dc518b937d9194c \; --hash=sha256:8bdb58ff7ba23002a4c5808d608e4e6c687175724f54a5dade5fa8c67b604e4d \; --hash=sha256:8c622a5fe39a48f78944a87d4fb8a53ee07344641b0562c540d840748571b811 \; --hash=sha256:8d756e44e94489e49571086ef83b2bb8ce311e730092d2c34ca8f7d925cb20aa \; --hash=sha256:8f4a014bc36d3c57402e2977dada34f9c12300af536839dc38c0beab8878f38a \; --hash=sha256:9063e24fdb1e498ab71cb7419e24622516c4a04476b17a2dab57e8baa30d6e03 \; --hash=sha256:90d558489962fd4918143277a773316e56c72da56ec7aa3dc3dbbe20fdfed15b \; --hash=sha256:923c0c831b7cfcb071580d3f46c4baf50f174be571576556269530f4bbd79d04 \; --hash=sha256:95f2a5796329323b8f0512e09dbb7a1860c46a39da62ecb2324f116fa8fdc85c \; --hash=sha256:96b02a3dc4381e5494fad39be677abcb5e6634bf7b4fa83a6dd3112607547001 \; --hash=sha256:9f96df6923e21816da7e0ad3fd47dd8f94b2a5ce594e00677c0013018b813458 \; --hash=sha256:a10af20b82360ab00827f916a6058451b723b4e65030c5a18577c8b2de5b3389 \; --hash=sha256:a50aebf,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:4700,hash,hash,4700,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,1,['hash'],['hash']
Security,"ffer | use basic `TRootSniffer` without support of hist, gpad, graph, tree classes |. Example:. ```cpp; new THttpServer(""http:8080;ro;noglobal""); ```. ## Registering objects. At any time, one could register other objects with the command:. ```cpp; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; ```. One should specify sub-folder name, where objects will be registered.; If sub-folder name does not starts with slash `/`, than top-name folder `/Objects/` will be prepended.; At any time one could unregister objects:. ```cpp; serv->Unregister(gr);; ```. THttpServer does not take ownership over registered objects - they should be deleted by user. If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated. ## Accessing file system. THttpServer provides partial access to the files from file system.; First of all, JSROOT scripts and files can be accessed via ""jsrootsys/"" path like ""http://localhost:8080/jsrootsys/modules/core.mjs"".; Files from ROOT install directory can be get via ""rootsys/"" path like ""http://localhost:8080/rootsys/icons/about.xpm"".; Also files from current directory where ROOT is running can be accessed via ""currentdir/"" path like ""http://localhost:8080/currentdir/file.txt"". If necessary, one can add custom path as well, using [THttpServer::AddLocation](https://root.cern/doc/master/classTHttpServer.html#a5322c3bbfddb8eb6849297d83ccaf87f) method:. ```cpp; serv->AddLocation(""mydir/"", ""/home/user/specials"");; ```. Then files from that directory could be addressed via URL like ""http://localhost:8080/mydir/myfile.root"". ## Command interface. THttpServer class provide simple interface to invoke command from web browser.; One just register command like:. ```cpp; serv->RegisterCommand(""/DoSomething"", ""SomeFunction()"");; ```. Element with name `DoSomething` will appear in the web browser and can be clicked.; It will result in `gROOT->",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:4185,access,accessed,4185,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['accessed']
Security,"fferent objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3758,access,access,3758,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['access'],['access']
Security,"ffset`` based on the address of the ``Target``. * ``Target``, accessible via ``getTarget``, is a pointer to a ``Symbol``,; representing whose address is relevant to the fixup calculation specified by; the edge's ``Kind``. * ``Addend``, accessible via ``getAddend``, is a constant whose interpretation; is determined by the edge's ``Kind``. * ``Section`` -- A set of ``Symbol`` instances, plus a set of ``Block``; instances, with a ``Name``, a set of ``ProtectionFlags``, and an ``Ordinal``. Sections make it easy to iterate over the symbols or blocks associated with; a particular section in the source object file. * ``blocks()`` returns an iterator over the set of blocks defined in the; section (as ``Block*`` pointers). * ``symbols()`` returns an iterator over the set of symbols defined in the; section (as ``Symbol*`` pointers). * ``Name`` is represented as an ``llvm::StringRef``, and is accessible via the; ``getName`` method. * ``ProtectionFlags`` are represented as a sys::Memory::ProtectionFlags enum,; and accessible via the ``getProtectionFlags`` method. These flags describe; whether the section is readable, writable, executable, or some combination; of these. The most common combinations are ``RW-`` for writable data,; ``R--`` for constant data, and ``R-X`` for code. * ``SectionOrdinal``, accessible via ``getOrdinal``, is a number used to order; the section relative to others. It is usually used to preserve section; order within a segment (a set of sections with the same memory protections); when laying out memory. For the graph-theorists: The ``LinkGraph`` is bipartite, with one set of; ``Symbol`` nodes and one set of ``Addressable`` nodes. Each ``Symbol`` node has; one (implicit) edge to its target ``Addressable``. Each ``Block`` has a set of; edges (possibly empty, represented as ``Edge`` instances) back to elements of; the ``Symbol`` set. For convenience and performance of common algorithms,; symbols and blocks are further grouped into ``Sections``. The ``LinkGraph",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:13035,access,accessible,13035,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security,fiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61932,access,access,61932,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"fined in a different TU due to the possibility of incorrect resource usage calculations, leading to undefined behavior. On the other hand, the ``-fgpu-rdc`` mode allows the definition and use of function pointers across different TUs, as resource usage calculations can accommodate functions from disparate TUs. Virtual Function Support; ========================. In Clang with HIP, support for calling virtual functions of an object in device or host code is contingent on where the object is constructed. - **Constructed in Device Code**: Virtual functions of an object can be called in device code on a specific offloading device if the object is constructed in device code on an offloading device with the same architecture.; - **Constructed in Host Code**: Virtual functions of an object can be called in host code if the object is constructed in host code. In other scenarios, calling virtual functions is not allowed. Explanation; -----------. An object constructed on the device side contains a pointer to the virtual function table on the device side, which is not accessible in host code, and vice versa. Thus, trying to invoke virtual functions from a context different from where the object was constructed will be disallowed because the appropriate virtual table cannot be accessed. The virtual function tables for offloading devices with different architecures are different, therefore trying to invoke virtual functions from an offloading device with a different architecture than where the object is constructed is also disallowed. Example Usage; -------------. .. code-block:: c++. class Base {; public:; __device__ virtual void virtualFunction() {; // Base virtual function implementation; }; };. class Derived : public Base {; public:; __device__ void virtualFunction() override {; // Derived virtual function implementation; }; };. __global__ void kernel() {; Derived obj;; Base* basePtr = &obj;; basePtr->virtualFunction(); // Allowed since obj is constructed in device code; }; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst:9951,access,accessible,9951,interpreter/llvm-project/clang/docs/HIPSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HIPSupport.rst,2,['access'],"['accessed', 'accessible']"
Security,"fined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76609,sanitiz,sanitize-recover,76609,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize-recover']
Security,finitions in templates; Unknown. 2175; CD4; Ambiguity with attribute in conversion operator declaration; Unknown. 2176; CD4; Destroying the returned object when a destructor throws; Unknown. 2177; CD5; Placement operator delete and parameter copies; Unknown. 2178; NAD; Substitution of dependent template arguments in default template arguments; Unknown. 2179; drafting; Required diagnostic for partial specialization after first use; Not resolved. 2180; CD4; Virtual bases in destructors and defaulted assignment operators; Yes. 2181; drafting; Normative requirements in an informative Annex; Not resolved. 2182; drafting; Pointer arithmetic in array-like containers; Not resolved. 2183; NAD; Problems in description of potential exceptions; Unknown. 2184; CD4; Missing C compatibility entry for decrement of bool; Unknown. 2185; CD6; Cv-qualified numeric types; Unknown. 2186; drafting; Unclear point that “preceding initialization” must precede; Not resolved. 2187; drafting; Protected members and access via qualified-id; Not resolved. 2188; open; empty-declaration grammar ambiguity; Not resolved. 2189; open; Surrogate call template; Not resolved. 2190; open; Insufficient specification of __has_include; Not resolved. 2191; C++17; Incorrect result for noexcept(typeid(v)); Unknown. 2192; open; Constant expressions and order-of-eval undefined behavior; Not resolved. 2193; NAD; numeric_limits<int>::radix and digits; Unknown. 2194; drafting; Impossible case in list initialization; Not resolved. 2195; open; Unsolicited reading of trailing volatile members; Not resolved. 2196; C++17; Zero-initialization with virtual base classes; Unknown. 2197; C++17; Overload resolution and deleted special member functions; Unknown. 2198; C++17; Linkage of enumerators; Unknown. 2199; CD6; Typedefs and tags; Clang 3.8. 2200; NAD; Conversions in template argument deduction; Unknown. 2201; C++17; Cv-qualification of array types; Unknown. 2202; drafting; When does default argument instantiation occur?; No,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:149133,access,access,149133,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"flags);; }; };. Tags; ----. The YAML syntax supports tags as a way to specify the type of a node before; it is parsed. This allows dynamic types of nodes. But the YAML I/O model uses; static typing, so there are limits to how you can use tags with the YAML I/O; model. Recently, we added support to YAML I/O for checking/setting the optional; tag on a map. Using this functionality it is even possible to support different; mappings, as long as they are convertible. To check a tag, inside your mapping() method you can use io.mapTag() to specify; what the tag should be. This will also add that tag when writing yaml. Validation; ----------. Sometimes in a YAML map, each key/value pair is valid, but the combination is; not. This is similar to something having no syntax errors, but still having; semantic errors. To support semantic level checking, YAML I/O allows; an optional ``validate()`` method in a MappingTraits template specialization. When parsing YAML, the ``validate()`` method is call *after* all key/values in; the map have been processed. Any error message returned by the ``validate()``; method during input will be printed just a like a syntax error would be printed.; When writing YAML, the ``validate()`` method is called *before* the YAML; key/values are written. Any error during output will trigger an ``assert()``; because it is a programming error to have invalid struct values. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mapping"" is a mapping that uses the inline notation; (e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:23369,validat,validate,23369,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['validat'],['validate']
Security,"following interfaces are not yet available:. - DeleteVariable. They might be re-implemented in a later version. ### rootcling, rootcint and genreflex. rootcling is the successor to rootcint and it preserves its old commandline; arguments and provides more (see help). The executable rootcint still exists; but it is just a redirection to rootcling.; The following *backward incompatibilities* are present between rootcint in; version 5 and rootcling in version 6:. - rootcling does not support multiline \#pragma without a line; continuation as rootcint did (rootcint support \#pragma link with a; line continutation only in ROOT v5.34/02 and above).; - rootcling no longer re-\#defines the private and protected keywords; to public. In particular this means that code compiled as part of; the dictionary no longer has access to protected and private members; of a class (except where allowed by the C++ standard).; In particular, this means that the code used for read rules (\#pragma read); can no longer access private member unless they have been mentioned as a; target of the rule.; - rootcling no longer considers a friend declaration to be a; declaration for the friended function. In particular this means that; rootcling may now issue:. ``` {.cpp}; Error: in this version of ROOT, the option '!' used in a linkdef file; implies the actual existence of customized operators.; The following declaration is now required:; TBuffer &operator<<(TBuffer &,const THit *);; ```. if the operator `<<` declaration is missing. To steer the parsing done during the execution of rootcling, a new; macro: *\_\_ROOTCLING\_\_* is now defined during the parsing. The macros; *\_\_CINT\_\_* and *\_\_MAKECINT\_\_* are defined only when looking for; `#pragma` statement. The genreflex executable is still available, it preserves the same command; line options as in version 5 and provides new ones. Old selection XML files; are transparently usable by the new implementation. On the other hand some; of the new ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:6602,access,access,6602,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['access'],['access']
Security,"foo"" = 0x1234. One use case for; absolute symbols is allowing resolution of process symbols. E.g. .. code-block:: c++. JD.define(absoluteSymbols(SymbolMap({; { Mangle(""printf""),; { ExecutorAddr::fromPtr(&printf),; JITSymbolFlags::Callable } }; });. With this mapping established code added to the JIT can refer to printf; symbolically rather than requiring the address of printf to be ""baked in"".; This in turn allows cached versions of the JIT'd code (e.g. compiled objects); to be re-used across JIT sessions as the JIT'd code no longer changes, only the; absolute symbol definition does. For process and library symbols the DynamicLibrarySearchGenerator utility (See; :ref:`How to Add Process and Library Symbols to JITDylibs; <ProcessAndLibrarySymbols>`) can be used to automatically build absolute; symbol mappings for you. However the absoluteSymbols function is still useful; for making non-global objects in your JIT visible to JIT'd code. For example,; imagine that your JIT standard library needs access to your JIT object to make; some calls. We could bake the address of your object into the library, but then; it would need to be recompiled for each session:. .. code-block:: c++. // From standard library for JIT'd code:. class MyJIT {; public:; void log(const char *Msg);; };. void log(const char *Msg) { ((MyJIT*)0x1234)->log(Msg); }. We can turn this into a symbolic reference in the JIT standard library:. .. code-block:: c++. extern MyJIT *__MyJITInstance;. void log(const char *Msg) { __MyJITInstance->log(Msg); }. And then make our JIT object visible to the JIT standard library with an; absolute symbol definition when the JIT is started:. .. code-block:: c++. MyJIT J = ...;. auto &JITStdLibJD = ... ;. JITStdLibJD.define(absoluteSymbols(SymbolMap({; { Mangle(""__MyJITInstance""),; { ExecutorAddr::fromPtr(&J), JITSymbolFlags() } }; });. Aliases and Reexports; ---------------------. Aliases and reexports allow you to define new symbols that map to existing; symbols. This can ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:14249,access,access,14249,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['access'],['access']
Security,"for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts auth); : Number of pool accounts to create. Proxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same cluster should have the same value of this; field. It is used to mutually authenticate VMs and it is used like a; password. Context password; : Current profile will be saved on the [CernVM Online; repository](http://cernvm-online.cern.ch/). If you don't want the; information there to be publicly available to other users, type in; a value for protecting the context with an encryption password. You will have to create a profile for the **master** and the **slave**. Since; most of the configuration variables are the same (like the *HTCondor; shared secret*) you can create one, clone it and change only what's; needed to change. Deploy it on the cloud; ----------------------. Provided you have access to a certain cloud API, you'll need to; instantiate a certain number of CernVM batch images with proper; contextualization: one for the master, as many as you want as slaves. CernVM supports contextualization through the ""user data"" field; supported by all cloud infrastructures. Each cloud infrastructure has a different method of setting the ""user; data"". The following description will focus on:. - [OpenNebula](http://opennebula.org/). - OpenStack (such as the [CERN Agile; infrastructure](https://openstack.cern.ch/)). - [Amazon EC2](http://aws.amazon.com/ec2/)-compatible interfaces via; the open [Eucalyptu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:3275,encrypt,encryption,3275,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,2,"['encrypt', 'password']","['encryption', 'password']"
Security,"for June 27, 2011. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Dario Berzano, INFN and University of Torino, ALICE, Proof,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Wim Lavrijsen, LBNL, PyRoot,; Sergei Linev, GSI,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Eddy Offermann, Renaissance, ; Bartolomeu Rabacal, CERN/ADL, Math, ; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg Stelzer, DESY/Atlas, TMVA, ; Alja Tadel, UCSD/CMS, Eve, ; Matevz Tadel, UCSD/CMS, Eve, ; Eckhard von Toerne, University Bonn, ATLAS, TMVA, ; Wouter Verkerke, NIKHEF/Atlas,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html:1309,authenticat,authentication,1309,doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v530/index.html,2,['authenticat'],['authentication']
Security,"for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unknown. 2628; DR; Implicit deduction guides should propagate constraints; No. 2629; C++23; Variables of floating-point type as switch conditions; Unknown. 2630; C++23; Syntactic specification of class completeness; Unknown. 2631; C++23; Immediate function evaluations in default arguments; Clang 16. 2632; review; 'user-declared' is not defined; Not resolved. 2633; open; typeid of constexpr-unknown dynamic type; Not resolved. 2634; tentatively ready; Avoid circularity in specification of scope for friend class declarations; Unknown. 2635; C++23; Constrained structured bindings; Clang 16. 2636; C++23; Update Annex E based on Unicode 15.0 UAX #31; N/A. 2637; tentatively ready; Injected-class-name as a simple-template-id; Unknown. 2638; tentatively ready; Improve the example for initializing by initializer list; Unknown. 2639; C++23; new-lines after phase 1; Unknown. 2640; C++23; Allow more characters in an n-char sequence; Clang 16. 2641; C++23; Redundant specification of value category of literals; Unknown. 2642; C++23; Inconsistent use of T and C; N/A. 2643; C++23; Completing a pointer to array of unknown bound; Unknown. 2644; C++23; Incorrect comment in example; Clang 8. 2645; C++23; Unused term ""default argument promotions""; Unknown. 2646; C++23; Defaulted special member functions; Unknown. 2647; C++23; Fix for ""needed for constant evaluation""; Unknown. 2648; C++23; Correspondence of surrogate call function and conversion function; Unknown. 2649; C++23; Incorrect note about implicit conversion sequence; Unknown. 2650; C++23; Incorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:181772,Inject,Injected-class-name,181772,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Inject'],['Injected-class-name']
Security,"for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; metadata for the outer loop; !3 = distinct !{} ; access group for instructions in the inner loop (which are implicitly contained in outer loop as well); !4 = distinct !{} ; access group for instructions in the outer, but not the inner loop. .. _langref_llvm_loop_mustprogress:. '``llvm.loop.mustprogress``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.mustprogress`` metadata indicates that this loop is required to; terminate, unwind, or interact with the environment in an observable way e.g.; via a volatile memory access, I/O, or other synchronization. If such a loop is; not found to interact with the environment in an observable way, the loop may; be removed. This corresponds to the ``mustprogress`` function attribute. '``irr_loop``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^. ``irr_loop`` metadata may be attached to the terminator instruction of a basic; block that's an irreducible loop header (note that an irreducible loop has more; than once header basic blocks.) If ``irr_loop`` metadata is attached to the; terminator instruction of a basic block that is not really an irreduc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:314277,access,access,314277,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['access']
Security,"formation about the; DIE such as flags indicating if the DIE is a function, method, block,; or inlined. The KeyType for the DWARF table is a 32 bit string table offset into the; "".debug_str"" table. The "".debug_str"" is the string table for the DWARF which; may already contain copies of all of the strings. This helps make sure, with; help from the compiler, that we reuse the strings between all of the DWARF; sections and keeps the hash table size down. Another benefit to having the; compiler generate all strings as DW_FORM_strp in the debug info, is that; DWARF parsing can be made much faster. After a lookup is made, we get an offset into the hash data. The hash data; needs to be able to deal with 32 bit hash collisions, so the chunk of data; at the offset in the hash data consists of a triple:. .. code-block:: c. uint32_t str_offset; uint32_t hash_data_count; HashData[hash_data_count]. If ""str_offset"" is zero, then the bucket contents are done. 99.9% of the; hash data chunks contain a single item (no 32 bit hash collision):. .. code-block:: none. .------------.; | 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] => ""main""); | 0x00000004 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x........ | uint32_t HashData[2] DIE offset; | 0x........ | uint32_t HashData[3] DIE offset; | 0x00000000 | uint32_t KeyType (end of hash chain); `------------'. If there are collisions, you will have multiple valid string offsets:. .. code-block:: none. .------------.; | 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] => ""main""); | 0x00000004 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x........ | uint32_t HashData[2] DIE offset; | 0x........ | uint32_t HashData[3] DIE offset; | 0x00002023 | uint32_t KeyType (.debug_str[0x0002023] => ""print""); | 0x00000002 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:75834,hash,hash,75834,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['hash'],['hash']
Security,"fsyntax-only t.c; t.c:5:11: error: invalid type argument of unary '*' (have 'int'); return *SomeA.X;; ^; $ clang -fsyntax-only t.c; t.c:5:11: error: indirection requires pointer operand ('int' invalid); int y = *SomeA.X;; ^~~~~~~~. Typedef Preservation and Selective Unwrapping; Many programmers use high-level user defined types, typedefs, and other; syntactic sugar to refer to types in their program. This is useful because they; can abbreviate otherwise very long types and it is useful to preserve the; typename in diagnostics. However, sometimes very simple typedefs can wrap; trivial types and it is important to strip off the typedef to understand what; is going on. Clang aims to handle both cases well.; The following example shows where it is important to preserve; a typedef in C. $ clang -fsyntax-only t.c; t.c:15:11: error: can't convert between vector values of different size ('__m128' and 'int const *'); myvec[1]/P;; ~~~~~~~~^~. The following example shows where it is useful for the compiler to expose; underlying details of a typedef. If the user was somehow confused about how the; system ""pid_t"" typedef is defined, Clang helpfully displays it with ""aka"". $ clang -fsyntax-only t.c; t.c:13:9: error: member reference base type 'pid_t' (aka 'int') is not a structure or union; myvar = myvar.x;; ~~~~~ ^. In C++, type preservation includes retaining any qualification written into type names. For example, if we take a small snippet of code such as:. namespace services {; struct WebService { };; }; namespace myapp {; namespace servers {; struct Server { };; }; }. using namespace myapp;; void addHTTPService(servers::Server const &server, ::services::WebService const *http) {; server += http;; }. and then compile it, we see that Clang is both providing accurate information and is retaining the types as written by the user (e.g., ""servers::Server"", ""::services::WebService""):. $ clang -fsyntax-only t.cpp; t.cpp:9:10: error: invalid operands to binary expression ('servers::S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html:4677,expose,expose,4677,interpreter/llvm-project/clang/www/diagnostics.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/diagnostics.html,2,['expose'],['expose']
Security,"function in unnamed namespace; Unknown. 2231; NAD; Class member access to static data member template; Unknown. 2232; open; thread_local anonymous unions; Not resolved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, and TUs; Not resolved. 2251; C++17; Unreachable enumeration list-initialization; Unknown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:152922,access,access,152922,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"function prologue to; redirect control away from the function in a thread safe; manner. It guarantees that the first instruction of the; function will be large enough to accommodate a short jump; instruction, and will be sufficiently aligned to allow being; fully changed via an atomic compare-and-swap instruction.; While the first requirement can be satisfied by inserting large; enough NOP, LLVM can and will try to re-purpose an existing; instruction (i.e. one that would have to be emitted anyway) as; the patchable instruction larger than a short jump. ``""prologue-short-redirect""`` is currently only supported on; x86-64. This attribute by itself does not imply restrictions on; inter-procedural optimizations. All of the semantic effects the; patching may have to be separately conveyed via the linkage type.; ``""probe-stack""``; This attribute indicates that the function will trigger a guard region; in the end of the stack. It ensures that accesses to the stack must be; no further apart than the size of the guard region to a previous; access of the stack. It takes one required string value, the name of; the stack probing function that will be called. If a function that has a ``""probe-stack""`` attribute is inlined into; a function with another ``""probe-stack""`` attribute, the resulting; function has the ``""probe-stack""`` attribute of the caller. If a; function that has a ``""probe-stack""`` attribute is inlined into a; function that has no ``""probe-stack""`` attribute at all, the resulting; function has the ``""probe-stack""`` attribute of the callee.; ``""stack-probe-size""``; This attribute controls the behavior of stack probes: either; the ``""probe-stack""`` attribute, or ABI-required stack probes, if any.; It defines the size of the guard region. It ensures that if the function; may use more stack space than the size of the guard region, stack probing; sequence will be emitted. It takes one required integer value, which; is 4096 by default. If a function that has a ``""stack-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:98153,access,accesses,98153,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],"['access', 'accesses']"
Security,"function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1950,access,accessed,1950,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['accessed']
Security,"fy that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the same name. The third argument is the value of the expression being profiled. The profiled; expression's value should be representable as an unsigned 64-bit value. The; fourth argument represents the kind of value profiling that is being done. The; supported value profiling kinds are enumerated through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:531136,hash,hash,531136,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security,"g %i is \""%s\""\n"", i, argv[i]);; }. % cat print-args-main.c; void print_args(int argc, char *argv[]);. int main(int argc, char *argv[]) {; print_args(argc, argv);; return 0;; }. % clang -c -o print-args.o print-args.c; % clang -c -o print-args-main.o print-args-main.c; % llvm-jitlink print-args.o print-args-main.o -args a b c; arg 0 is ""a""; arg 1 is ""b""; arg 2 is ""c"". Alternative entry points may be specified using the ``-entry <entry point; name>`` option. Other options can be found by calling ``llvm-jitlink -help``. llvm-jitlink as a regression testing utility; --------------------------------------------. One of the primary aims of ``llvm-jitlink`` was to enable readable regression; tests for JITLink. To do this it supports two options:. The ``-noexec`` option tells llvm-jitlink to stop after looking up the entry; point, and before attempting to execute it. Since the linked code is not; executed, this can be used to link for other targets even if you do not have; access to the target being linked (the ``-define-abs`` or ``-phony-externals``; options can be used to supply any missing definitions in this case). The ``-check <check-file>`` option can be used to run a set of ``jitlink-check``; expressions against working memory. It is typically used in conjunction with; ``-noexec``, since the aim is to validate JIT'd memory rather than to run the; code and ``-noexec`` allows us to link for any supported target architecture; from the current process. In ``-check`` mode, ``llvm-jitlink`` will scan the; given check-file for lines of the form ``# jitlink-check: <expr>``. See; examples of this usage in ``llvm/test/ExecutionEngine/JITLink``. Remote execution via llvm-jitlink-executor; ------------------------------------------. By default ``llvm-jitlink`` will link the given objects into its own process,; but this can be overridden by two options:. The ``-oop-executor[=/path/to/executor]`` option tells ``llvm-jitlink`` to; execute the given executor (which defaults to ``llv",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:38991,access,access,38991,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['access']
Security,"g 2 is ""c"". Alternative entry points may be specified using the ``-entry <entry point; name>`` option. Other options can be found by calling ``llvm-jitlink -help``. llvm-jitlink as a regression testing utility; --------------------------------------------. One of the primary aims of ``llvm-jitlink`` was to enable readable regression; tests for JITLink. To do this it supports two options:. The ``-noexec`` option tells llvm-jitlink to stop after looking up the entry; point, and before attempting to execute it. Since the linked code is not; executed, this can be used to link for other targets even if you do not have; access to the target being linked (the ``-define-abs`` or ``-phony-externals``; options can be used to supply any missing definitions in this case). The ``-check <check-file>`` option can be used to run a set of ``jitlink-check``; expressions against working memory. It is typically used in conjunction with; ``-noexec``, since the aim is to validate JIT'd memory rather than to run the; code and ``-noexec`` allows us to link for any supported target architecture; from the current process. In ``-check`` mode, ``llvm-jitlink`` will scan the; given check-file for lines of the form ``# jitlink-check: <expr>``. See; examples of this usage in ``llvm/test/ExecutionEngine/JITLink``. Remote execution via llvm-jitlink-executor; ------------------------------------------. By default ``llvm-jitlink`` will link the given objects into its own process,; but this can be overridden by two options:. The ``-oop-executor[=/path/to/executor]`` option tells ``llvm-jitlink`` to; execute the given executor (which defaults to ``llvm-jitlink-executor``) and; communicate with it via file descriptors which it passes to the executor; as the first argument with the format ``filedescs=<in-fd>,<out-fd>``. The ``-oop-executor-connect=<host>:<port>`` option tells ``llvm-jitlink`` to; connect to an already running executor via TCP on the given host and port. To; use this option you will need t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:39333,validat,validate,39333,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['validat'],['validate']
Security,"g `repr()` on a `cppyy.gbl.std.string` object now comes with a ""b"" prefix, i.e. a bytes object is returned instead of a Python string.; This is an intentional change for better unicode support. See: https://github.com/root-project/root/issues/15153#issuecomment-2040504962. ### No more implicit conversion of static size `char` buffer to Python strings. A static size character buffer of type `char[n]` is not converted to a Python string anymore.; The reason for this: since it was previously assumed the string was; null-terminated, there was no way to get the bytes after a `null`, even if you; wanted to. ```python; import ROOT. ROOT.gInterpreter.Declare(""""""; struct Struct { char char_buffer[5] {}; }; // struct with char[n]; void fill_char_buffer(Struct & st) {; std::string foo{""foo""};; std::memcpy(st.char_buffer, foo.data(), foo.size());; }; """"""). struct = ROOT.Struct(); ROOT.fill_char_buffer(struct); char_buffer = struct.char_buffer. # With thew new cppyy, you get access to the lower level buffer instead of a; # Python string:; print(""struct.char_buffer : "", char_buffer). # However, you can turn the buffer into a string very easily with as_string():; print(""struct.char_buffer.as_string(): "", char_buffer.as_string()); ```; The output of this script with ROOT 6.32:; ```; struct.char_buffer : <cppyy.LowLevelView object at 0x74c7a2682fb0>; struct.char_buffer.as_string(): foo; ```. ### Deprecate the attribute pythonization of `TDirectory` in favor of item-getting syntax. The new recommended way to get objects from a `TFile` or any `TDirectory` in general is now via `__getitem__`:. ```python; tree = my_file[""my_tree""] # instead of my_file.my_tree; ```. This is more consistent with other Python collections (like dictionaries), makes sure that member functions can't be confused with branch names, and easily allows you to use string variables as keys. With the new dictionary-like syntax, you can also get objects with names that don't qualify as a Python variable. Here is a shor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md:20695,access,access,20695,README/ReleaseNotes/v632/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v632/index.md,1,['access'],['access']
Security,"g a combined index; for a distributed ThinLTO backend via clang's ""``-fthinlto-index=<>``"" flag; (this part is not yet implemented, use llvm-as to create a bitcode object; before feeding into thin link tools for now). There are currently 3 types of summary entries in the LLVM assembly:; :ref:`module paths<module_path_summary>`,; :ref:`global values<gv_summary>`, and; :ref:`type identifiers<typeid_summary>`. .. _module_path_summary:. Module Path Summary Entry; -------------------------. Each module path summary entry lists a module containing global values included; in the summary. For a single IR module there will be one such entry, but; in a combined summary index produced during the thin link, there will be; one module path entry per linked module with summary. Example:. .. code-block:: text. ^0 = module: (path: ""/path/to/file.o"", hash: (2468601609, 1329373163, 1565878005, 638838075, 3148790418)). The ``path`` field is a string path to the bitcode file, and the ``hash``; field is the 160-bit SHA-1 hash of the IR bitcode contents, used for; incremental builds and caching. .. _gv_summary:. Global Value Summary Entry; --------------------------. Each global value summary entry corresponds to a global value defined or; referenced by a summarized module. Example:. .. code-block:: text. ^4 = gv: (name: ""f""[, summaries: (Summary)[, (Summary)]*]?) ; guid = 14740650423002898831. For declarations, there will not be a summary list. For definitions, a; global value will contain a list of summaries, one per module containing; a definition. There can be multiple entries in a combined summary index; for symbols with weak linkage. Each ``Summary`` format will depend on whether the global value is a; :ref:`function<function_summary>`, :ref:`variable<variable_summary>`, or; :ref:`alias<alias_summary>`. .. _function_summary:. Function Summary; ^^^^^^^^^^^^^^^^. If the global value is a function, the ``Summary`` entry will look like:. .. code-block:: text. function: (module: ^0, flags",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:340478,hash,hash,340478,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['hash'],['hash']
Security,"g alternatives.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-core-stdvariant-c>`__.; (`#66481 <https://github.com/llvm/llvm-project/pull/66481>`_). - Added a new experimental checker ``alpha.cplusplus.ArrayDelete`` to detect; destructions of arrays of polymorphic objects that are destructed as their; base class (`CERT EXP51-CPP <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_).; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#alpha-cplusplus-arraydelete-c>`__.; (`0e246bb67573 <https://github.com/llvm/llvm-project/commit/0e246bb67573799409d0085b89902a330998ddcc>`_). - Added a new checker configuration option ``InvalidatingGetEnv=[true,false]`` to; ``security.cert.env.InvalidPtr``. It's not set by default.; If set, ``getenv`` calls won't invalidate previously returned pointers.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__.; (`#67663 <https://github.com/llvm/llvm-project/pull/67663>`_). Crash and bug fixes; ^^^^^^^^^^^^^^^^^^^. - Fixed a crash caused by ``builtin_bit_cast``.; (`#69922 <https://github.com/llvm/llvm-project/issues/69922>`_). - Fixed a ``core.StackAddressEscape`` crash on temporary object fields.; (`#66221 <https://github.com/llvm/llvm-project/issues/66221>`_). - A few crashes have been found and fixed using randomized testing related; to the use of ``_BitInt()`` in tidy checks and in clang analysis.; (`#67212 <https://github.com/llvm/llvm-project/pull/67212>`_,; `#66782 <https://github.com/llvm/llvm-project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-project/pull/65888>`_,; `#65887 <https://github.com/llvm/llvm-project/pull/65887>`_). - Fixed note links of the HTML output.; (`#64054 <https://github.com/llvm/llvm-project/issues/64054>`_). - Allow widening rage-based for loops.; (`#70190 <https://githu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:70710,secur,security-cert-env-invalidptr,70710,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['secur'],['security-cert-env-invalidptr']
Security,"g scheme and lifetime; management for LLVMContexts. The ThreadSafeContext may be locked to prevent; accidental concurrent access by two Modules that use the same LLVMContext.; The underlying LLVMContext is freed once all ThreadSafeContext values pointing; to it are destroyed, allowing the context memory to be reclaimed as soon as; the Modules referring to it are destroyed. ThreadSafeContexts can be explicitly constructed from a; std::unique_ptr<LLVMContext>:. .. code-block:: c++. ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());. ThreadSafeModules can be constructed from a pair of a std::unique_ptr<Module>; and a ThreadSafeContext value. ThreadSafeContext values may be shared between; multiple ThreadSafeModules:. .. code-block:: c++. ThreadSafeModule TSM1(; std::make_unique<Module>(""M1"", *TSCtx.getContext()), TSCtx);. ThreadSafeModule TSM2(; std::make_unique<Module>(""M2"", *TSCtx.getContext()), TSCtx);. Before using a ThreadSafeContext, clients should ensure that either the context; is only accessible on the current thread, or that the context is locked. In the; example above (where the context is never locked) we rely on the fact that both; ``TSM1`` and ``TSM2``, and TSCtx are all created on one thread. If a context is; going to be shared between threads then it must be locked before any accessing; or creating any Modules attached to it. E.g. .. code-block:: c++. ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());. ThreadPool TP(NumThreads);; JITStack J;. for (auto &ModulePath : ModulePaths) {; TP.async(; [&]() {; auto Lock = TSCtx.getLock();; auto M = loadModuleOnContext(ModulePath, TSCtx.getContext());; J.addModule(ThreadSafeModule(std::move(M), TSCtx));; });; }. TP.wait();. To make exclusive access to Modules easier to manage the ThreadSafeModule class; provides a convenience function, ``withModuleDo``, that implicitly (1) locks the; associated context, (2) runs a given function object, (3) unlocks the context,; and (3) returns the result generated ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:29195,access,accessible,29195,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['access'],['accessible']
Security,"g to a node with no entries. The existence of; ``!noundef`` metadata on the instruction tells the optimizer that the value; loaded is known to be :ref:`well defined <welldefinedvalues>`.; If the value isn't well defined, the behavior is undefined. If the ``!noundef``; metadata is combined with poison-generating metadata like ``!nonnull``,; violation of that metadata constraint will also result in undefined behavior. Semantics:; """""""""""""""""""". The location of memory pointed to is loaded. If the value being loaded; is of scalar type then the number of bytes read does not exceed the; minimum number of bytes needed to hold all bits of the type. For; example, loading an ``i24`` reads at most three bytes. When loading a; value of a type like ``i20`` with a size that is not an integral number; of bytes, the result is undefined if the value was not originally; written using a store of the same type.; If the value being loaded is of aggregate type, the bytes that correspond to; padding may be accessed but are ignored, because it is impossible to observe; padding from the loaded aggregate value.; If ``<pointer>`` is not a well-defined value, the behavior is undefined. Examples:; """""""""""""""""". .. code-block:: llvm. %ptr = alloca i32 ; yields ptr; store i32 3, ptr %ptr ; yields void; %val = load i32, ptr %ptr ; yields i32:val = i32 3. .. _i_store:. '``store``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. store [volatile] <ty> <value>, ptr <pointer>[, align <alignment>][, !nontemporal !<nontemp_node>][, !invariant.group !<empty_node>] ; yields void; store atomic [volatile] <ty> <value>, ptr <pointer> [syncscope(""<target-scope>"")] <ordering>, align <alignment> [, !invariant.group !<empty_node>] ; yields void; !<nontemp_node> = !{ i32 1 }; !<empty_node> = !{}. Overview:; """""""""""""""""". The '``store``' instruction is used to write to memory. Arguments:; """""""""""""""""""". There are two arguments to the ``store`` instruction: a value to store and an; address at which to store it. The ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:418667,access,accessed,418667,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"g user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68530,secur,security,68530,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"g will perform; a lookup into the identifier table. If an identifier is found, its contents; (macro definitions, flags, top-level declarations, etc.) will be deserialized,; at which point the corresponding ``IdentifierInfo`` structure will have the; same contents it would have after parsing the headers in the AST file. Within the AST file, the identifiers used to name declarations are represented; with an integral value. A separate table provides a mapping from this integral; value (the identifier ID) to the location within the on-disk hash table where; that identifier is stored. This mapping is used when deserializing the name of; a declaration, the identifier of a token, or any other construct in the AST; file that refers to a name. .. _pchinternals-method-pool:. Method Pool Block; ^^^^^^^^^^^^^^^^^. The method pool block is represented as an on-disk hash table that serves two; purposes: it provides a mapping from the names of Objective-C selectors to the; set of Objective-C instance and class methods that have that particular; selector (which is required for semantic analysis in Objective-C) and also; stores all of the selectors used by entities within the AST file. The design; of the method pool is similar to that of the :ref:`identifier table; <pchinternals-ident-table>`: the first time a particular selector is formed; during the compilation of the program, Clang will search in the on-disk hash; table of selectors; if found, Clang will read the Objective-C methods; associated with that selector into the appropriate front-end data structure; (``Sema::InstanceMethodPool`` and ``Sema::FactoryMethodPool`` for instance and; class methods, respectively). As with identifiers, selectors are represented by numeric values within the AST; file. A separate index maps these numeric selector values to the offset of the; selector within the on-disk hash table, and will be used when de-serializing an; Objective-C method declaration (or other Objective-C construct) that refers ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:20287,hash,hash,20287,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['hash'],['hash']
Security,"g. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_inv sc0`` is required which will invalidate; the L1 cache. * A ``buffer_inv sc0`` is required to invalidate the L1 cache for coherence; between wavefronts executing in different work-groups as they may be; executing on different CUs. * Atomic read-modify-write instructions implicitly bypass the L1 cache.; Therefore, they do not use the sc0 bit for coherence and instead use it to; indicate if the instruction returns the original value being updated. They; do use sc1 to indicate system or agent scope coherence. * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:286026,access,access,286026,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"g. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that ``flat_load/store/atomic`` instructions can report out of vector memory; order if they access LDS memory, and out of LDS operation order if they access; global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore:. * No special action is required for coherence between the lanes of a single; wavefront. * No special action is required for coherence between wavefronts in the same; work-group since they execute on the same CU. The exception is when in; tgsplit execution mode as wavefronts of the same work-group can be in; different CUs and so a ``buffer_wbinvl1_vol`` is required as described in; the following item. * A ``buffer_wbinvl1_vol`` is required for coherence between wavefronts; executing in different work-groups as they may be executing on different; CUs. * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a group of CUs. The scalar and vector L1 caches are not coherent. However,; scalar operations are used in a restricted way so do not impact the memory; model. See :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory operations use an L2 cache shared by all CUs on; the same agent. * The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:235878,access,access,235878,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"g/doxygen/Value_8h_source.html>`_. doxygen info: `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_. The ``Value`` class is the most important class in the LLVM Source base. It; represents a typed value that may be used (among other things) as an operand to; an instruction. There are many different types of ``Value``\ s, such as; Constant_\ s, Argument_\ s. Even Instruction_\ s and :ref:`Function; <c_Function>`\ s are ``Value``\ s. A particular ``Value`` may be used many times in the LLVM representation for a; program. For example, an incoming argument to a function (represented with an; instance of the Argument_ class) is ""used"" by every instruction in the function; that references the argument. To keep track of this relationship, the ``Value``; class keeps a list of all of the ``User``\ s that is using it (the User_ class; is a base class for all nodes in the LLVM graph that can refer to ``Value``\ s).; This use list is how LLVM represents def-use information in the program, and is; accessible through the ``use_*`` methods, shown below. Because LLVM is a typed representation, every LLVM ``Value`` is typed, and this; Type_ is available through the ``getType()`` method. In addition, all LLVM; values can be named. The ""name"" of the ``Value`` is a symbolic string printed; in the LLVM code:. .. code-block:: llvm. %foo = add i32 1, 2. .. _nameWarning:. The name of this instruction is ""foo"". **NOTE** that the name of any value may; be missing (an empty string), so names should **ONLY** be used for debugging; (making the source code easier to read, debugging printouts), they should not be; used to keep track of values or map between them. For this purpose, use a; ``std::map`` of pointers to the ``Value`` itself instead. One important aspect of LLVM is that there is no distinction between an SSA; variable and the operation that produces it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:141921,access,accessible,141921,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessible']
Security,"garithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like in; ""total-ordering"", we will track every number and flag, but instead of; comparison, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are two main important fields in the class:. ``FnTree`` – the set of all unique functions. It keeps items that couldn't be; merged with each other. It is defined as:. ``std::set<FunctionNode> FnTree;``. Here ``FunctionNode`` is a wrapper for ``llvm::Function`` class, with; implemented “<” operator among the functions set (below we explain how it works; exactly; this is a key point in fast functions comparison). ``Deferred`` – ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:7076,access,access,7076,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['access'],['access']
Security,"ge about whether the pointer points to; globally-constant memory (for which it returns ``NoModRef``) or; locally-invariant memory (for which it returns ``Ref``). Globally-constant; memory includes functions, constant global variables, and the null pointer.; Locally-invariant memory is memory that we know is invariant for the lifetime; of its SSA value, but not necessarily for the life of the program: for example,; the memory pointed to by ``readonly`` ``noalias`` parameters is known-invariant; for the duration of the corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8161,access,access,8161,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['access'],['access']
Security,"ge; is printed. Properly handle the case of class which version is zero and to properly initialization array of objects (streamerElement type kStreamLoop). Fix support for call to MakeProject like:. gFile->MakeProject(""./classCode/"",""*"",""RECREATE++""). Better error handling if the source file failed to be created; or if the project directory can not be created. TParallelMergingFile. Introduce the class TParallelMergingFile part of the net package. This class connect ot a parallel merge server; and upload its content every time Write is called on the file object. After the upload the object of classes; with a ResetAfterMerge function are reset. A TParallelMergingFile is created whether a ?pmerge option is passed to TFile::Open as part of the file name.; For example:. TFile::Open(""mergedClient.root?pmerge"",""RECREATE""); // For now contact localhost:1095; TFile::Open(""mergedClient.root?pmerge=localhost:1095"",""RECREATE"");; TFile::Open(""rootd://root.cern/files/output.root?pmerger=pcanal:password@locahost:1095"",""NEW""). tutorials/net/treeClient.C and fastMergeServer.C: update to follow the change in interfaces; Introduce the tutorials parallelMergerClient.C and the temporary tutorials parallelMergerServer.C; to demonstrate the parallel merging (with parallelMergerServer.C being the prototype of the upcoming; parallel merger server executable). Other. Introduce the new function TFileMerger::PartialMerge(Int_t) which; will Merge the list of file _with_ the content of the output; file (if any). This allows make several successive Merge; into the same TFile object.; Yhe argument defines the type of merge as define by the bit values in EPartialMergeType:; ; kRegular : normal merge, overwritting the output file.; kIncremental : merge the input file with the content of the output file (if already exising) (default).; kAll : merge all type of objects (default).; kResetable : merge only the objects with a MergeAfterReset member function. ; kNonResetable : merge only the objects withou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:6431,password,password,6431,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,2,['password'],['password']
Security,"general should not be used unless there; is no other option. 2. The dictionaries. The most convenient place to specify the conversion rules is a dictionary. One can; do that either in CINT's LinkDef file or in the selection xml file being fed to genreflex.; The syntax of the rules is the following:. * For CINT dictionaries:. #pragma read \; sourceClass=""ClassA"" \; source=""double m_a; double m_b; double m_c"" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }"". * For REFLEX dictionaries:. <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>. The variables in the rules have the following meaning:. * sourceClass - The field defines the on-disk class that is the input for the rule.; * source - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version - A list of versions of the source class that can be an inpu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt:2400,checksum,checksum,2400,io/doc/DataModelEvolution.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/DataModelEvolution.txt,2,['checksum'],['checksum']
Security,"generated with elements |; | | | uniformly distributed |; | | | between $\alpha$ and $\beta$ |; +--------------------------+------------+---------------------------------------------+. Output **`TMatrixX`** indicates that the returned matrix is of the same; type as `A`, being **`TMatrixD`**, **`TMatrixDSym`** or; **`TMatrixDSparse`**. Next table shows miscellaneous operations for; **`TMatrixD`**. +--------------------------------+------------+---------------------------------+; | Format | Output | Description |; +--------------------------------+------------+---------------------------------+; | `A.Rank1Update(v1,v2,alpha)` | `TMatrixD` | Perform with vector `v1` and |; | | | `v2`, a rank 1 operation on the |; | | | matrix: |; | | | $A = A + \alpha.\nu.\nu2^T$ |; +--------------------------------+------------+---------------------------------+. ## Matrix Views. Another way to access matrix elements is through the matrix-view; classes, **`TMatrixDRow`**, **`TMatrixDColumn`**, **`TMatrixDDiag`** and; **`TMatrixDSub`** (each has also a const version which is obtained by; simply appending const to the class name). These classes create a; reference to the underlying matrix, so no memory management is involved.; The next table shows how the classes access different parts of the; matrix:. +--------------------------------+-----------------------------------------+; | class | view |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDRow const(X,i)` | x_{i0} & ... & x_{ij} & ... & x_{in} \\ |; | `TMatrixDRow(X,i)` | & & & & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & x_{0j} & & x_{0n} \\ |; | | & & ... & & \\ |; | `TMatrixDColumn const(X,j)` | & & x_{ij} & & \\ |; | `TMatrixDColumn(X,j)` | & & ... & & \\ ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:24856,access,access,24856,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['access'],['access']
Security,"ger to only return an analysis if it's; already cached. The analysis manager only provides analysis results for the same IR type as; what the pass runs on. For example, a function pass receives an analysis; manager that only provides function-level analyses. This works for many; passes which work on a fixed scope. However, some passes want to peek up or; down the IR hierarchy. For example, an SCC pass may want to look at function; analyses for the functions inside the SCC. Or it may want to look at some; immutable global analysis. In these cases, the analysis manager can provide a; proxy to an outer or inner level analysis manager. For example, to get a; ``FunctionAnalysisManager`` from a ``CGSCCAnalysisManager``, you can call. .. code-block:: c++. FunctionAnalysisManager &FAM =; AM.getResult<FunctionAnalysisManagerCGSCCProxy>(InitialC, CG); .getManager();. and use ``FAM`` as a typical ``FunctionAnalysisManager`` that a function pass; would have access to. To get access to an outer level IR analysis, you can; call. .. code-block:: c++. const auto &MAMProxy =; AM.getResult<ModuleAnalysisManagerCGSCCProxy>(InitialC, CG);; FooAnalysisResult *AR = MAMProxy.getCachedResult<FooAnalysis>(M);. Asking for a cached and immutable outer level IR analysis works via; ``getCachedResult()``, but getting direct access to an outer level IR analysis; manager to compute an outer level IR analysis is not allowed. This is for a; couple reasons. The first reason is that running analyses across outer level IR in inner level; IR passes can result in quadratic compile time behavior. For example, a module; analysis often scans every function and allowing function passes to run a module; analysis may cause us to scan functions a quadratic number of times. If passes; could keep outer level analyses up to date rather than computing them on demand; this wouldn't be an issue, but that would be a lot of work to ensure every pass; updates all outer level analyses, and so far this hasn't been necessa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:8416,access,access,8416,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['access'],['access']
Security,"get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be loaded at startup. However, when calling into ROOT; functions from python, that won't happen, since python is not sanitised. Therefore, the address sanitizer runtime has to be preloaded with; `LD_PRELOAD=<pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1885,sanitiz,sanitizers,1885,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['sanitiz'],['sanitizers']
Security,"gh the vtable.; This is not the same as the linkage of the vtable, because call sites could be; using a pointer of a more widely-visible base class. For example, consider this; code:. .. code-block:: c++. __attribute__((visibility(""default""))); struct A {; virtual void f();; };. __attribute__((visibility(""hidden""))); struct B : A {; virtual void f();; };. With LTO, we know that all code which can see the declaration of ``B`` is; visible to us. However, a pointer to a ``B`` could be cast to ``A*`` and passed; to another linkage unit, which could then call ``f`` on it. This call would; load from the vtable for ``B`` (using the object pointer), and then call; ``B::f``. This means we can't remove the function pointer from ``B``'s vtable,; or the implementation of ``B::f``. However, if we can see all code which knows; about any dynamic base class (which would be the case if ``B`` only inherited; from classes with hidden visibility), then this optimisation would be valid. This concept is represented in IR by the ``!vcall_visibility`` metadata; attached to vtable objects, with the following values:. .. list-table::; :header-rows: 1; :widths: 10 90. * - Value; - Behavior. * - 0 (or omitted); - **Public**; Virtual function calls using this vtable could be made from external; code. * - 1; - **Linkage Unit**; All virtual function calls which might use this vtable are in the; current LTO unit, meaning they will be in the current module once; LTO linking has been performed. * - 2; - **Translation Unit**; All virtual function calls which might use this vtable are in the; current module. In addition, all function pointer loads from a vtable marked with the; ``!vcall_visibility`` metadata (with a non-zero value) must be done using the; :ref:`llvm.type.checked.load <type.checked.load>` intrinsic, so that virtual; calls sites can be correlated with the vtables which they might load from.; Other parts of the vtable (RTTI, offset-to-top, ...) can still be accessed with; normal loads.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst:10671,access,accessed,10671,interpreter/llvm-project/llvm/docs/TypeMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst,1,['access'],['accessed']
Security,"gin a ""scope"". For these records, all following records; up until the next ``S_END`` record are ""children"" of this symbol record. For example,; given a symbol record which describes a certain function, all local variables of this; function would appear following the function up until the corresponding ``S_END`` record. Finally, there are three general categories of symbol record, grouped by where they are legal; to appear in a PDB file. Public Symbols (which appear only in the; :doc:`publics stream <PublicStream>`), Global Symbols (which appear only in the; :doc:`globals stream <GlobalStream>`) and module symbols (which appear in the; :doc:`module info stream <ModiStream>`). .. _public_symbols:. Public Symbols; --------------. Public symbols are the CodeView equivalent of DWARF ``.debug_pubnames``. There; is one public symbol record for every function or variable in the program that; has a mangled name. The :doc:`Publics Stream <PublicStream>`, which contains these; records, additionally contains a hash table that allows one to quickly locate a; record by mangled name. S_PUB32 (0x110e); ^^^^^^^^^^^^^^^^. There is only type of public symbol, an ``S_PUB32`` which describes a mangled; name, a flag indicating what kind of symbol it is (e.g. function, variable), and; the symbol's address. The :ref:`dbi_section_map_substream` of the; :doc:`DBI Stream <DbiStream>` can be consulted to determine what module this address; corresponds to, and from there that module's :doc:`module debug stream <ModiStream>`; can be consulted to locate full information for the symbol with the given address. .. _global_symbols:. Global Symbols; --------------. While there is one :ref:`public symbol <public_symbols>` for every symbol in the; program with `external` linkage, there is one global symbol for every symbol in the; program with linkage (including internal linkage). As a result, global symbols do; not describe a mangled name *or* an address, since symbols with internal linkage; need not ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst:2692,hash,hash,2692,interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,1,['hash'],['hash']
Security,"ging implementation against; a string Mode identifier. The implementation is an instance of; ``XRayLogImpl`` defined in ``xray/xray_log_interface.h``.; - ``__xray_log_select_mode(...)``: Select the mode to install, associated with; a string Mode identifier. Only implementations registered with; ``__xray_log_register_mode(...)`` can be chosen with this function.; - ``__xray_log_init_mode(...)``: This function allows for initializing and; re-initializing an installed logging implementation. See; ``xray/xray_log_interface.h`` for details, part of the XRay compiler-rt; installation. Once a logging implementation has been initialized, it can be ""stopped"" by; finalizing the implementation through the ``__xray_log_finalize()`` function.; The finalization routine is the opposite of the initialization. When finalized,; an implementation's data can be cleared out through the; ``__xray_log_flushLog()`` function. For implementations that support in-memory; processing, these should register an iterator function to provide access to the; data via the ``__xray_log_set_buffer_iterator(...)`` which allows code calling; the ``__xray_log_process_buffers(...)`` function to deal with the data in; memory. All of this is better explained in the ``xray/xray_log_interface.h`` header. Basic Mode; ----------. XRay supports a basic logging mode which will trace the application's; execution, and periodically append to a single log. This mode can be; installed/enabled by setting ``xray_mode=xray-basic`` in the ``XRAY_OPTIONS``; environment variable. Combined with ``patch_premain=true`` this can allow for; tracing applications from start to end. Like all the other modes installed through ``__xray_log_select_mode(...)``, the; implementation can be configured through the ``__xray_log_init_mode(...)``; function, providing the mode string and the flag options. Basic-mode specific; defaults can be provided in the ``XRAY_BASIC_OPTIONS`` environment variable. Flight Data Recorder Mode; ------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst:7828,access,access,7828,interpreter/llvm-project/llvm/docs/XRay.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/XRay.rst,1,['access'],['access']
Security,"gn;; assign -> print;. subgraph SynthesizeExpression {; synth [label="" SynthesizeExpr() "", shape=""note"", fontcolor=white, fillcolor=""#3333ff"", style=filled];; mem [label="" New Memory \n Allocation? "", shape=""diamond""];; withaloc [label="" SetValueWithAlloc() "", shape=""box""];; noaloc [label="" SetValueNoAlloc() "", shape=""box""];; right [label="" 1. RValue Structure \n (a temporary value)"", shape=""box""];; left2 [label="" 2. LValue Structure \n (a variable with \n an address)"", shape=""box""];; left3 [label="" 3. Built-In Type \n (int, float, etc.)"", shape=""box""];; output [label="" move to 'Assign' step "", shape=""box""];. synth -> mem;; mem -> withaloc [label=""Yes""];; mem -> noaloc [label=""No""];; withaloc -> right;; noaloc -> left2;; noaloc -> left3;; right -> output;; left2 -> output;; left3 -> output;; }; output -> assign; }. Where is the captured result stored?; ------------------------------------. ``LastValue`` holds the last result of the value printing. It is a class member; because it can be accessed even after subsequent inputs. **Note:** If no value printing happens, then it is in an invalid state. Improving Efficiency and User Experience; ----------------------------------------. The Value object is essentially used to create a mapping between an expression; 'type' and the allocated 'memory'. Built-in types (bool, char, int,; float, double, etc.) are copyable. Their memory allocation size is known; and the Value object can introduce a small-buffer optimization.; In case of objects, the ``Value`` class provides reference-counted memory; management. The implementation maps the type as written and the Clang Type to be able to use; the preprocessor to synthesize the relevant cast operations. For example,; ``X(char, Char_S)``, where ``char`` is the type from the language's type system; and ``Char_S`` is the Clang builtin type which represents it. This mapping helps; to import execution results from the interpreter in a compiled program and vice; versa. The ``Value.h`` heade",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst:8583,access,accessed,8583,interpreter/llvm-project/clang/docs/ClangRepl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangRepl.rst,1,['access'],['accessed']
Security,"gned-integer-truncation``,; ``implicit-signed-integer-truncation``, and; ``implicit-integer-sign-change``.; - ``-fsanitize=integer``: Checks for undefined or suspicious integer; behavior (e.g. unsigned integer overflow).; Enables ``signed-integer-overflow``, ``unsigned-integer-overflow``,; ``shift``, ``integer-divide-by-zero``,; ``implicit-unsigned-integer-truncation``,; ``implicit-signed-integer-truncation``, and; ``implicit-integer-sign-change``.; - ``-fsanitize=nullability``: Enables ``nullability-arg``,; ``nullability-assign``, and ``nullability-return``. While violating; nullability does not have undefined behavior, it is often unintentional,; so UBSan offers to catch it. Volatile; --------. The ``null``, ``alignment``, ``object-size``, ``local-bounds``, and ``vptr`` checks do not apply; to pointers to types with the ``volatile`` qualifier. Minimal Runtime; ===============. There is a minimal UBSan runtime available suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Ove",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:11918,attack,attack,11918,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['attack'],['attack']
Security,"go expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as updat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:14405,secur,security,14405,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,2,['secur'],"['securely', 'security']"
Security,"group local shared; ``DW_MSPACE_LLVM_private`` thread private; ``DW_MSPACE_LLVM_lo_user``; ``DW_MSPACE_LLVM_hi_user``; =========================== ============ ============== ============== ==============. .. note::. The approach presented in; :ref:`amdgpu-dwarf-source-language-memory-spaces-table` is to define the; default ``DW_MSPACE_LLVM_none`` to be the generic address class and not the; global address class. This matches how CLANG and LLVM have added support for; CUDA-like languages on top of existing C++ language support. This allows all; addresses to be generic by default which matches CUDA-like languages. An alternative approach is to define ``DW_MSPACE_LLVM_none`` as being the; global memory space and then change ``DW_MSPACE_LLVM_global`` to; ``DW_MSPACE_LLVM_generic``. This would match the reality that languages that; do not support multiple memory spaces only have one default global memory; space. Generally, in these languages if they expose that the target; architecture supports multiple memory spaces, the default one is still the; global memory space. Then a language that does support multiple memory spaces; has to explicitly indicate which pointers have the added ability to reference; more than the global memory space. However, compilers generating DWARF for; CUDA-like languages would then have to define every CUDA-like language pointer; type or reference type with a ``DW_AT_LLVM_memory_space`` attribute of; ``DW_MSPACE_LLVM_generic`` to match the language semantics. A.3 Program Scope Entries; -------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 3 sections. A.3.1 Unit Entries; ~~~~~~~~~~~~~~~~~~. .. _amdgpu-dwarf-full-and-partial-compilation-unit-entries:. A.3.1.1 Full and Partial Compilation Unit Entries; +++++++++++++++++++++++++++++++++++++++++++++++++. .. note::. This augments DWARF Version 5 section 3.1.1 an",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:152955,expose,expose,152955,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['expose'],['expose']
Security,"gs: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69307,access,access,69307,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['access'],['access']
Security,"gs`` displays the DAG before Legalization. * ``-view-dag-combine2-dags`` displays the DAG before the second optimization; pass. * ``-view-isel-dags`` displays the DAG before the Select phase. * ``-view-sched-dags`` displays the DAG before Scheduling. The ``-view-sunit-dags`` displays the Scheduler's dependency graph. This graph; is based on the final SelectionDAG, with nodes that must be scheduled together; bundled into a single scheduling-unit node, and with immediate operands and; other nodes that aren't relevant for scheduling omitted. The option ``-filter-view-dags`` allows to select the name of the basic block; that you are interested to visualize and filters all the previous; ``view-*-dags`` options. .. _Build initial DAG:. Initial SelectionDAG Construction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The initial SelectionDAG is na\ :raw-html:`&iuml;`\ vely peephole expanded from; the LLVM input by the ``SelectionDAGBuilder`` class. The intent of this pass; is to expose as much low-level, target-specific details to the SelectionDAG as; possible. This pass is mostly hard-coded (e.g. an LLVM ``add`` turns into an; ``SDNode add`` while a ``getelementptr`` is expanded into the obvious; arithmetic). This pass requires target-specific hooks to lower calls, returns,; varargs, etc. For these features, the :raw-html:`<tt>` `TargetLowering`_; :raw-html:`</tt>` interface is used. .. _legalize types:; .. _Legalize SelectionDAG Types:; .. _Legalize SelectionDAG Ops:. SelectionDAG LegalizeTypes Phase; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The Legalize phase is in charge of converting a DAG to only use the types that; are natively supported by the target. There are two main ways of converting values of unsupported scalar types to; values of supported types: converting small types to larger types (""promoting""),; and breaking up large integer types into smaller ones (""expanding""). For; example, a target might require that all f32 values are promoted to f64 and that; all i1/i8/i16 values are",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:40378,expose,expose,40378,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['expose'],['expose']
Security,"gument expression ``F`` undergoes element-wise; conversion from a float vector to an integer vector to create a temporary; ``int3``. On expiration the temporary undergoes elementwise conversion back to; the floating point vector type ``float3``. This results in an implicit; element-wise conversion of the vector even if the value is unused in the; function (effectively truncating the floating point values). .. code-block:: c++. void UB(out int X) {}. void main() {; int X = 7;; UB(X); // X is undefined!; }. In this example an initialized value is passed to an ``out`` parameter.; Parameters marked ``out`` are not initialized by the argument expression or; implicitly by the function. They must be explicitly initialized. In this case; the argument is not initialized in the function so the temporary is still; uninitialized when it is copied back to the argument expression. This is; undefined behavior in HLSL, and any use of the argument after the call is a use; of an undefined value which may be illegal in the target (DXIL programs with; used or potentially used ``undef`` or ``poison`` values fail validation). Clang Implementation; ====================. .. note::. The implementation described here is a proposal. It has not yet been fully; implemented, so the current state of Clang's sources may not reflect this; design. A prototype implementation was built on DXC which is Clang-3.7 based.; The prototype can be found; `here <https://github.com/microsoft/DirectXShaderCompiler/pull/5249>`_. A lot; of the changes in the prototype implementation are restoring Clang-3.7 code; that was previously modified to its original state. The implementation in clang depends on two new AST nodes and minor extensions to; Clang's existing support for Objective-C write-back arguments. The goal of this; design is to capture the semantic details of HLSL function calls in the AST, and; minimize the amount of magic that needs to occur during IR generation. The two new AST nodes are ``HLSLArrayTemp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:5235,validat,validation,5235,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,1,['validat'],['validation']
Security,"gument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key = ...;; oldObject = dictionary[key];; dictionary[key] = newObject; // replace oldObject with newObject. The next section explains how subscripting expressions map to accessor; methods. Subscripting Methods; --------------------. Objective-C supports two kinds of subscript expressions: *array-style*; subscript expressions use integer typed subscripts; *dictionary-style*; subscript expressions use Objective-C object pointer typed subscripts.; Each type of subscript expression is mapped to a message send using a; predefined selector. The advantage of this design is flexibility: class; designers are free to introduce subscripting by declaring methods or by; adopting protocols. Moreover, because the method names are selected by; the type of the subscript, an object can be subscripted using both array; and dictionary styles. Array-Style Subscripting; ^^^^^^^^^^^^^^^^^^^^^^^^. When the subscript operand has an integral type, the expression is; rewritten to use one of two different selectors, depending on whether; the element is being read or written. When an expression reads an; element using an integral index, as in the following ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:11553,access,accessor,11553,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['access'],['accessor']
Security,"guousStorage(Vec); // Works.; }. // DISCOURAGED: Clients cannot pass e.g. SmallVector<Foo, 8>.; hardcodedSmallSize(SmallVector<Foo, 2> &Out);; // ENCOURAGED: Clients can pass any SmallVector<Foo, N>.; allowsAnySmallSize(SmallVectorImpl<Foo> &Out);. void someFunc2() {; SmallVector<Foo, 8> Vec;; hardcodedSmallSize(Vec); // Error.; allowsAnySmallSize(Vec); // Works.; }. Even though it has ""``Impl``"" in the name, SmallVectorImpl is widely used; and is no longer ""private to the implementation"". A name like; ``SmallVectorHeader`` might be more appropriate. .. _dss_pagedvector:. llvm/ADT/PagedVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``PagedVector<Type, PageSize>`` is a random access container that allocates; ``PageSize`` elements of type ``Type`` when the first element of a page is; accessed via the ``operator[]``. This is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``ma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:63449,access,accessed,63449,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security,"h 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key = ...;; oldObject = dictionary[key];; dictionary[key] = newObject; // replace oldObject with newObject. The next section explains how subscripting expressions map to accessor; methods. Subscripting Methods; --------------------. Objective-C supports two kinds of subscript expressions: *array-style*; subscript expressions use integer typed subsc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:10710,validat,validates,10710,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['validat'],['validates']
Security,"h `WebKit's style guide; <https://www.webkit.org/coding/coding-style.html>`_; * ``Microsoft``; A style complying with `Microsoft's style guide; <https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference>`_; * ``GNU``; A style complying with the `GNU coding standards; <https://www.gnu.org/prep/standards/standards.html>`_; * ``InheritParentConfig``; Not a real style, but allows to use the ``.clang-format`` file from the; parent directory (or its parent if there is none). If there is no parent; file found it falls back to the ``fallback`` style, and applies the changes; to that. With this option you can overwrite some parts of your main style for your; subdirectories. This is also possible through the command line, e.g.:; ``--style={BasedOnStyle: InheritParentConfig, ColumnLimit: 20}``. .. START_FORMAT_STYLE_OPTIONS. .. _AccessModifierOffset:. **AccessModifierOffset** (``Integer``) :versionbadge:`clang-format 3.3` :ref:`¶ <AccessModifierOffset>`; The extra indent or outdent of access modifiers, e.g. ``public:``. .. _AlignAfterOpenBracket:. **AlignAfterOpenBracket** (``BracketAlignmentStyle``) :versionbadge:`clang-format 3.8` :ref:`¶ <AlignAfterOpenBracket>`; If ``true``, horizontally aligns arguments after an open bracket. This applies to round brackets (parentheses), angle brackets and square; brackets. Possible values:. * ``BAS_Align`` (in configuration: ``Align``); Align parameters on the open bracket, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_DontAlign`` (in configuration: ``DontAlign``); Don't align, instead use ``ContinuationIndentWidth``, e.g.:. .. code-block:: c++. someLongFunction(argument1,; argument2);. * ``BAS_AlwaysBreak`` (in configuration: ``AlwaysBreak``); Always break after an open bracket, if the parameters don't fit; on a single line, e.g.:. .. code-block:: c++. someLongFunction(; argument1, argument2);. * ``BAS_BlockIndent`` (in configuration: ``BlockIndent``); Always break after ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:6956,access,access,6956,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"h are the same virtual address space used by the CPU. However, some; virtual addresses may only be accessible to the CPU, some only accessible; by the GPU, and some by both. Using the constant address space indicates that the data will not change; during the execution of the kernel. This allows scalar read instructions to; be used. As the constant address space could only be modified on the host; side, a generic pointer loaded from the constant address space is safe to be; assumed as a global pointer since only the device global memory is visible; and managed on the host side. The vector and scalar L1 caches are invalidated; of volatile data before each kernel dispatch execution to allow constant; memory to change values between kernel dispatches. **Region**; The region address space uses the hardware Global Data Store (GDS). All; wavefronts executing on the same device will access the same memory for any; given region address. However, the same region address accessed by wavefronts; executing on different devices will access different memory. It is higher; performance than global memory. It is allocated by the runtime. The data; store (DS) instructions can be used to access it. **Local**; The local address space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates the wavefronts of a; work-group, and freed when all the wavefronts of a work-group have; terminated. All wavefronts belonging to the same work-group will access the; same memory for any given local address. However, the same local address; accessed by wavefronts belonging to different work-groups will access; different memory. It is higher performance than global memory. The data store; (DS) instructions can be used to access it. **Private**; The private address space uses the hardware scratch memory support which; automatically allocates memory when it creates a wavefront and frees it when; a wavefronts terminates. The memory accessed by a lane of a wavefro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:25705,access,accessed,25705,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],"['access', 'accessed']"
Security,"h this nonsense for my; front-end? Wouldn't it be better if I just did SSA construction; directly, avoiding use of the mem2reg optimization pass? In short, we; strongly recommend that you use this technique for building SSA form,; unless there is an extremely good reason not to. Using this technique; is:. - Proven and well tested: clang uses this technique; for local mutable variables. As such, the most common clients of LLVM; are using this to handle a bulk of their variables. You can be sure; that bugs are found fast and fixed early.; - Extremely Fast: mem2reg has a number of special cases that make it; fast in common cases as well as fully general. For example, it has; fast-paths for variables that are only used in a single block,; variables that only have one assignment point, good heuristics to; avoid insertion of unneeded phi nodes, etc.; - Needed for debug info generation: `Debug information in; LLVM <../../SourceLevelDebugging.html>`_ relies on having the address of; the variable exposed so that debug info can be attached to it. This; technique dovetails very naturally with this style of debug info. If nothing else, this makes it much easier to get your front-end up and; running, and is very simple to implement. Let's extend Kaleidoscope with; mutable variables now!. Mutable Variables in Kaleidoscope; =================================. Now that we know the sort of problem we want to tackle, let's see what; this looks like in the context of our little Kaleidoscope language.; We're going to add two features:. #. The ability to mutate variables with the '=' operator.; #. The ability to define new variables. While the first item is really what this is about, we only have; variables for incoming arguments as well as for induction variables, and; redefining those only goes so far :). Also, the ability to define new; variables is a useful thing regardless of whether you will be mutating; them. Here's a motivating example that shows how we could use these:. ::. # Def",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:9904,expose,exposed,9904,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['expose'],['exposed']
Security,"h, and participates in modification; and seq_cst total orderings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system`` or ``agent`` and executed by a thread; on the same agent.; - ``workgroup`` and executed by a thread in the; same work-group.; - ``wavefront`` and executed by a thread in the; same wavefront. ``workgroup`` Synchronizes with, and participates in modification; and seq_cst total orderings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent`` or ``workgroup`` and; executed by a thread in the same work-group.; - ``wavefront`` and executed by a thread in the; same wavefront. ``wavefront`` Synchronizes with, and participates in modification; and seq_cst total orderings with, other operations; (except image operations) for all address spaces; (except private, or generic that accesses private); provided the other operation's sync scope is:. - ``system``, ``agent``, ``workgroup`` or; ``wavefront`` and executed by a thread in the; same wavefront. ``singlethread`` Only synchronizes with and participates in; modification and seq_cst total orderings with,; other operations (except image operations) running; in the same thread for all address spaces (for; example, in signal handlers). ``one-as`` Same as ``system`` but only synchronizes with other; operations within the same address space. ``agent-one-as`` Same as ``agent`` but only synchronizes with other; operations within the same address space. ``workgroup-one-as`` Same as ``workgroup`` but only synchronizes with; other operations within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:34287,access,accesses,34287,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"hains/lib64 -L$HOME/toolchains/lib64"". If you fail to set rpath, most LLVM binaries will fail on startup with a message; from the loader similar to ``libstdc++.so.6: version `GLIBCXX_3.4.20' not; found``. This means you need to tweak the -rpath linker flag. This method will add an absolute path to the rpath of all executables. That's; fine for local development. If you want to distribute the binaries you build; so that they can run on older systems, copy ``libstdc++.so.6`` into the; ``lib/`` directory. All of LLVM's shipping binaries have an rpath pointing at; ``$ORIGIN/../lib``, so they will find ``libstdc++.so.6`` there. Non-distributed; binaries don't have an rpath set and won't find ``libstdc++.so.6``. Pass; ``-DLLVM_LOCAL_RPATH=""$HOME/toolchains/lib64""`` to cmake to add an absolute; path to ``libstdc++.so.6`` as above. Since these binaries are not distributed,; having an absolute local path is fine for them. When you build Clang, you will need to give *it* access to modern C++; standard library in order to use it as your new host in part of a bootstrap.; There are two easy ways to do this, either build (and install) libc++ along; with Clang and then use it with the ``-stdlib=libc++`` compile and link flag,; or install Clang into the same prefix (``$HOME/toolchains`` above) as GCC.; Clang will look within its own prefix for libstdc++ and use it if found. You; can also add an explicit prefix for Clang to look in for a GCC toolchain with; the ``--gcc-toolchain=/opt/my/gcc/prefix`` flag, passing it to both compile and; link commands when using your just-built-Clang to bootstrap. .. _Getting Started with LLVM:. Getting Started with LLVM; =========================. The remainder of this guide is meant to get you up and running with LLVM and to; give you some basic information about the LLVM environment. The later sections of this guide describe the `general layout`_ of the LLVM; source tree, a `simple example`_ using the LLVM tool chain, and `links`_ to find; more in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst:19479,access,access,19479,interpreter/llvm-project/llvm/docs/GettingStarted.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GettingStarted.rst,1,['access'],['access']
Security,"hange should be kept as small as possible. This simplifies your work; (into a logical progression), simplifies code review and reduces the chance; that you will get negative feedback on the change. Small increments also; facilitate the maintenance of a high quality code base. * Often, an independent precursor to a big change is to add a new API and slowly; migrate clients to use the new API. Each change to use the new API is often; ""obvious"" and can be committed without review. Once the new API is in place; and used, it is much easier to replace the underlying implementation of the; API. This implementation change is logically separate from the API; change. If you are interested in making a large change, and this scares you, please make; sure to first `discuss the change/gather consensus`_ then ask about the best way; to go about making the change. Attribution of Changes; ----------------------. When contributors submit a patch to an LLVM project, other developers with; commit access may commit it for the author once appropriate (based on the; progression of code review, etc.). When doing so, it is important to retain; correct attribution of contributions to their contributors. However, we do not; want the source code to be littered with random attributions ""this code written; by J. Random Hacker"" (this is noisy and distracting). In practice, the revision; control system keeps a perfect history of who changed what, and the CREDITS.txt; file describes higher-level contributions. If you commit a patch for someone; else, please follow the attribution of changes in the simple manner as outlined; by the `commit messages`_ section. Overall, please do not add contributor names; to the source code. Also, don't commit patches authored by others unless they have submitted the; patch to the project or you have been authorized to submit them on their behalf; (you work together and your company authorized you to contribute the patches,; etc.). The author should first submit them",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:29723,access,access,29723,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['access'],['access']
Security,"hasAnyBase`` not binding nodes in its submatcher.; (`#65421 <https://github.com/llvm/llvm-project/issues/65421>`_); - Fixed a bug where RecursiveASTVisitor fails to visit the; initializer of a bitfield.; `Issue 64916 <https://github.com/llvm/llvm-project/issues/64916>`_; - Fixed a bug where range-loop-analysis checks for trivial copyability,; rather than trivial copy-constructibility; `Issue 47355 <https://github.com/llvm/llvm-project/issues/47355>`_; - Fixed a bug where Template Instantiation failed to handle Lambda Expressions; with certain types of Attributes.; (`#76521 <https://github.com/llvm/llvm-project/issues/76521>`_). Miscellaneous Bug Fixes; ^^^^^^^^^^^^^^^^^^^^^^^. Miscellaneous Clang Crashes Fixed; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; - Fixed a crash when parsing top-level ObjC blocks that aren't properly; terminated. Clang should now also recover better when an @end is missing; between blocks.; `Issue 64065 <https://github.com/llvm/llvm-project/issues/64065>`_; - Fixed a crash when check array access on zero-length element.; `Issue 64564 <https://github.com/llvm/llvm-project/issues/64564>`_; - Fixed a crash when an ObjC ivar has an invalid type. See; (`#68001 <https://github.com/llvm/llvm-project/pull/68001>`_); - Fixed a crash in C when redefined struct is another nested redefinition.; `Issue 41302 <https://github.com/llvm/llvm-project/issues/41302>`_; - Fixed a crash when ``-ast-dump=json`` was used for code using class; template deduction guides.; - Fixed a crash when a lambda marked as ``static`` referenced a captured; variable in an expression.; `Issue 74608 <https://github.com/llvm/llvm-project/issues/74608>`_; - Fixed a crash with modules and a ``constexpr`` destructor.; `Issue 68702 <https://github.com/llvm/llvm-project/issues/68702>`_. OpenACC Specific Changes; ------------------------; - OpenACC Implementation effort is beginning with semantic analysis and parsing; of OpenACC pragmas. The ``-fopenacc`` flag was added to enable these new,; albei",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:57707,access,access,57707,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['access'],['access']
Security,"hat does static storage duration do when zero for the type is not all zero bits?; Unknown. 17; C89; 39 unrelated questions about C89; Unknown. 18; NAD; How does fscanf behave in the presence of multibyte characters?; N/A. 19; NAD; Definition of the term ""printing character"" and isgraph(); N/A. 20; NAD; Is a compiler which allows the Relaxed Ref/Def linkage model to be considered a conforming compiler?; Yes. 21; C89; What is the result of: printf(""%#.4o"", 345);?; N/A. 22; C89; What is the result of: strtod(""100ergs"", &ptr);?; N/A. 23; NAD; what is the result of strtod(""0.0e99999"", &ptr);?; N/A. 24; NAD; In subclause 7.10.1.4 The strtod function: What does '""C"" locale' mean?; N/A. 25; NAD; What is meant by 'representable floating-point value?'; Yes. 26; NAD; Can a strictly conforming program contain a string literal with '$' or '@'?; Yes. 27; C89; Can there be characters in the character set that are not in the required source character set?; Yes. 28; NAD; Do object access rules apply to dynamically allocated objects?; Unknown. 29; NAD; Do two types have to have the same tag to be compatible?; No. 30; NAD; Can 'sin(DBL_MAX)' result in 'errno' being set to 'EDOM'?; N/A. 31; NAD; Can constant expressions overflow?; Yes. 32; NAD; Must implementations diagnose extensions to the constant evaluation rules?; No. 33; NAD; Conformance questions around 'shall' violations outside of constraints sections; Yes. 34; C89; External declarations in different scopes; Yes. 35; NAD; Questions about definition of functions without a prototype. Partial; Tags declared directly within an identifier list are incorrectly scoped; to the prototype rather than to the function body.; . 36; NAD; May floating-point constants be represented with more precision than implied by its type?; Yes. 37; NAD; Questions about multibyte characters and Unicode; Yes. 38; NAD; Questions about argument substitution during macro expansion; Yes. 39; NAD; Questions about the ""C"" locale; Yes. 40; NAD; 9 unrelated quest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:2700,access,access,2700,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,2,['access'],['access']
Security,"hat have made existing approaches to safer C dialects difficult to; adopt, offering these properties that make it widely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds checking. Consider the; example below where the ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds anno",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:2985,access,access,2985,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['access']
Security,"hat match the; provided matcher. Example matches X, Y; (matcher = cxxRecordDecl(has(cxxRecordDecl(hasName(""X""))); class X {}; // Matches X, because X::X is a class of name X inside X.; class Y { class X {}; };; class Z { class Y { class X {}; }; }; // Does not match Z. ChildT must be an AST base type. Usable as: Any Matcher; Note that has is direct matcher, so it also matches things like implicit; casts and paren casts. If you are matching with expr then you should; probably consider using ignoringParenImpCasts like:; has(ignoringParenImpCasts(expr())). Matcher<*>hasParentMatcher<*>; Matches AST nodes that have a parent that matches the provided; matcher. Given; void f() { for (;;) { int x = 42; if (true) { int x = 43; } } }; compoundStmt(hasParent(ifStmt())) matches ""{ int x = 43; }"". Usable as: Any Matcher. Matcher<*>invocationMatcher<*>...Matcher<*>; Matches function calls and constructor calls. Because CallExpr and CXXConstructExpr do not share a common; base class with API accessing arguments etc, AST Matchers for code; which should match both are typically duplicated. This matcher; removes the need for duplication. Given code; struct ConstructorTakesInt; {; ConstructorTakesInt(int i) {}; };. void callTakesInt(int i); {; }. void doCall(); {; callTakesInt(42);; }. void doConstruct(); {; ConstructorTakesInt cti(42);; }. The matcher; invocation(hasArgument(0, integerLiteral(equals(42)))); matches the expression in both doCall and doConstruct. Matcher<*>optionallyMatcher<*>; Matches any node regardless of the submatcher. However, optionally will retain any bindings generated by the submatcher.; Useful when additional information which may or may not present about a main; matching node is desired. For example, in:; class Foo {; int bar;; }; The matcher:; cxxRecordDecl(; optionally(has(; fieldDecl(hasName(""bar"")).bind(""var""); ))).bind(""record""); will produce a result binding for both ""record"" and ""var"".; The matcher will produce a ""record"" binding for even if there is",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:135264,access,accessing,135264,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['access'],['accessing']
Security,"hat; `can be ignored <CodeGenerator.html#tail-call-optimization>`_. The; ``musttail`` marker means that the call must be tail call optimized in order; for the program to be correct. This is true even in the presence of; attributes like ""disable-tail-calls"". The ``musttail`` marker provides these; guarantees:. #. The call will not cause unbounded stack growth if it is part of a; recursive cycle in the call graph.; #. Arguments with the :ref:`inalloca <attr_inalloca>` or; :ref:`preallocated <attr_preallocated>` attribute are forwarded in place.; #. If the musttail call appears in a function with the ``""thunk""`` attribute; and the caller and callee both have varargs, then any unprototyped; arguments in register or memory are forwarded to the callee. Similarly,; the return value of the callee is returned to the caller's caller, even; if a void return type is in use. Both markers imply that the callee does not access allocas from the caller.; The ``tail`` marker additionally implies that the callee does not access; varargs from the caller. Calls marked ``musttail`` must obey the following; additional rules:. - The call must immediately precede a :ref:`ret <i_ret>` instruction,; or a pointer bitcast followed by a ret instruction.; - The ret instruction must return the (possibly bitcasted) value; produced by the call, undef, or void.; - The calling conventions of the caller and callee must match.; - The callee must be varargs iff the caller is varargs. Bitcasting a; non-varargs function to the appropriate varargs type is legal so; long as the non-varargs prefixes obey the other rules.; - The return type must not undergo automatic conversion to an `sret` pointer. In addition, if the calling convention is not `swifttailcc` or `tailcc`:. - All ABI-impacting function attributes, such as sret, byval, inreg,; returned, and inalloca, must match.; - The caller and callee prototypes must match. Pointer types of parameters; or return types may differ in pointee type, but not in addr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:473718,access,access,473718,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"have access to, sharp regression in; compile time of internal workload, etc.), the reverter is expected to be; proactive about working with the patch author to debug and test candidate; patches.; * Reverts should be reasonably timely. A change submitted two hours ago; can be reverted without prior discussion. A change submitted two years ago; should not be. Where exactly the transition point is is hard to say, but; it's probably in the handful of days in tree territory. If you are unsure,; we encourage you to reply to the commit thread, give the author a bit to; respond, and then proceed with the revert if the author doesn't seem to be; actively responding.; * When re-applying a reverted patch, the commit message should be updated to; indicate the problem that was addressed and how it was addressed. Obtaining Commit Access; -----------------------. We grant commit access to contributors with a track record of submitting high; quality patches. If you would like commit access, please send an email to; `Chris <mailto:clattner@llvm.org>`_ with your GitHub username. This is true; for former contributors with SVN access as well as new contributors. If; approved, a GitHub invitation will be sent to your GitHub account. In case you; don't get notification from GitHub, go to; `Invitation Link <https://github.com/orgs/llvm/invitation>`_ directly. Once; accept the invitation, you'll get commit access. Prior to obtaining commit access, it is common practice to request that; someone with commit access commits on your behalf. When doing so, please; provide the name and email address you would like to use in the Author; property of the commit. For external tracking purposes, committed changes are automatically reflected; on a commits mailing list soon after the commit lands (e.g. llvm-commits_).; Note that these mailing lists are moderated, and it is not unusual for a large; commit to require a moderator to approve the email, so do not be concerned if a; commit does not immediatel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:23106,access,access,23106,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['access'],['access']
Security,"he ""Bazaar style"", a term from; the book ""The Cathedral and the Bazaar"" by Eric S. Raymond. It means a; liberal, informal development style that heavily relies on the diverse; and deep talent of the user community. The result is that physicists; developed ROOT for themselves; this made it specific, appropriate,; useful, and over time refined and very powerful. The development of; ROOT is a continuous conversation between users and developers with; the line between the two blurring at times and the users becoming; co-developers. When it comes to storing and mining large amount of data, physics; plows the way with its Terabytes, but other fields and industry follow; close behind as they acquiring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and contribute possible fixes. More users find more bugs,; because they stress the program in different ways. By now, after ten; years, the age of ROOT is quite mature. Most likely, you will find the; features you are looking for, and if you have found a hole, you are; encouraged to participate in the dialog and post your suggestion or; even implementation on the ROOT forum. ## The ROOT forum. If you have a question, it is likely that it has been asked, answered,; and stored in the ROOT Forum. Please use; the search engine to see if your question has already been answered; before posting a topic in the; Forum. You can access the ROOT forum at: <https://root-forum.cern.ch>. ## Contact Information. Several authors wrote this book and you may see a ""change of voice""; from one chapter to the next. We felt we could accept this in order to; have the expert explain what they know best. If you would like to; contribute a chapter or add to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:1925,expose,expose,1925,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['expose'],['expose']
Security,"he Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:68825,hash,hash,68825,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,5,['hash'],['hash']
Security,"he RooFit collection constructors. #### Allow for use of Python collections instead of C++ STL containers. Some RooFit functions take STL map-like types such as `std::map` as parameters, for example the [RooCategory constructor](https://root.cern/doc/v626/classRooCategory.html#ae63ae78231765d184b7a839c74746a49). In the past, you had to create the correct C++ class in Python, but now you can usually pass a Python dictionary instead. For example, a RooCategory can be created like this:; ```Python; sample = ROOT.RooCategory(""sample"", ""sample"", {""Sample1"": 1, ""Sample2"": 2, ""Sample3"": 3}); ```. #### RooWorkspace accessors. In Python, you can now get objects stored in a [RooWorkspace](https://root.cern/doc/v626/classRooWorkspace.html) with the item retrieval operator, and the return value is also always downcasted to the correct type. That means in Python you don't have to use [RooWorkspace::var()](https://root.cern/doc/v626/classRooWorkspace.html#acf5f9126ee264c234721a4ed1f9bf837) to access variables or [RooWorkspace::pdf()](https://root.cern/doc/v626/classRooWorkspace.html#afa7384cece424a1a94a644bb05549eee) to access pdfs, but you can always get any object using square brackets. For example:; ```Python; # w is a RooWorkspace instance that contains the variables `x`, `y`, and `z` for which we want to generate toy data:; model.generate({w[""x""], w[""y""], w[""z""]}, 1000); ```. ### New PyROOT functions for interoperability with NumPy and Pandas. New member functions of RooFit classes were introduced exclusively to PyROOT for better interoperability between RooFit and Numpy and Pandas:. - `RooDataSet.from_numpy`: Import a RooDataSet from a dictionary of numpy arrays (static method); - `RooDataSet.to_numpy`: Export a RooDataSet to a dictionary of numpy arrays; - `RooDataSet.from_pandas`: Import a RooDataSet from a Pandas dataframe (static method); - `RooDataSet.to_pandas`: Export a RooDataSet to a Pandas dataframe; - `RooDataHist.from_numpy`: Import a RooDataHist from numpy arra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:22212,access,access,22212,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['access'],['access']
Security,"he ``TargetFrameLowering`` class; ---------------------------------. The ``TargetFrameLowering`` class is used to provide information about the stack; frame layout of the target. It holds the direction of stack growth, the known; stack alignment on entry to each function, and the offset to the local area.; The offset to the local area is the offset from the stack pointer on function; entry to the first location where function data (local variables, spill; locations) can be stored. The ``TargetSubtarget`` class; -----------------------------. The ``TargetSubtarget`` class is used to provide information about the specific; chip set being targeted. A sub-target informs code generation of which; instructions are supported, instruction latencies and instruction execution; itinerary; i.e., which processing units are used, in what order, and for how; long. The ``TargetJITInfo`` class; ---------------------------. The ``TargetJITInfo`` class exposes an abstract interface used by the; Just-In-Time code generator to perform target-specific activities, such as; emitting stubs. If a ``TargetMachine`` supports JIT code generation, it should; provide one of these objects through the ``getJITInfo`` method. .. _code being generated:; .. _machine code representation:. Machine code description classes; ================================. At the high-level, LLVM code is translated to a machine specific representation; formed out of :raw-html:`<tt>` `MachineFunction`_ :raw-html:`</tt>`,; :raw-html:`<tt>` `MachineBasicBlock`_ :raw-html:`</tt>`, and :raw-html:`<tt>`; `MachineInstr`_ :raw-html:`</tt>` instances (defined in; ``include/llvm/CodeGen``). This representation is completely target agnostic,; representing instructions in their most abstract form: an opcode and a series of; operands. This representation is designed to support both an SSA representation; for machine code, as well as a register allocated, non-SSA form. .. _MachineInstr:. The ``MachineInstr`` class; --------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:14872,expose,exposes,14872,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['expose'],['exposes']
Security,"he ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void setName(const std::string &Name)``. This family of methods is used to access and assign a name to a ``Value``, be; aware of the :ref:`precaution above <nameWarning>`. * ``void replaceAllUsesWith(Value *V)``. This method traverses the use list of a ``Value`` changing all User_\ s of the; current value to refer to ""``V``"" instead. For example, if you detect that an; instruction always produces a constant value (for example through constant; folding), you can replace all uses of the instruction with the constant like; this:. .. code-block:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/doxygen/User_8h_source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:144142,access,access,144142,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"he base pointer and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.load``' intrinsic is designed for conditional reading of selected vector elements in a single IR operation. It is useful for targets that support vector masked loads and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar load operations.; The result of this operation is equivalent to a regular vector load instruction followed by a 'select' between the loaded and the passthru values, predicated on the same mask. However, using this intrinsic prevents exceptions on memory access to masked-off lanes. ::. %res = call <16 x float> @llvm.masked.load.v16f32.p0(ptr %ptr, i32 4, <16 x i1>%mask, <16 x float> %passthru). ;; The result of the two following instructions is identical aside from potential memory access exception; %loadlal = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %loadlal, <16 x float> %passthru. .. _int_mstore:. '``llvm.masked.store.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating-point or pointer data type. ::. declare void @llvm.masked.store.v8i32.p0 (<8 x i32> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>); declare void @llvm.masked.store.v16f32.p0(<16 x float> <value>, ptr <ptr>, i32 <alignment>, <16 x i1> <mask>); ;; The data is a vector of pointers; declare void @llvm.masked.store.v8p0.p0 (<8 x ptr> <value>, ptr <ptr>, i32 <alignment>, <8 x i1> <mask>). Overview:; """""""""""""""""". Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. Arguments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The seco",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:845425,access,access,845425,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"he binary ids of the instrumented binaries to associate binaries with; profiles for source code coverage. See `binary id`_ RFC for the design. .. _`profile metadata`:. Profile Metadata; ^^^^^^^^^^^^^^^^^^. This section stores the metadata to map counters and value profiles back to; instrumented code regions (e.g., LLVM IR for IRPGO). The in-memory representation of the metadata is `__llvm_profile_data`_.; Some fields are used to reference data from other sections in the profile.; The fields are documented as follows:. .. _`__llvm_profile_data`: https://github.com/llvm/llvm-project/blob/7c3b67d2038cfb48a80299089f6a1308eee1df7f/compiler-rt/include/profile/InstrProfData.inc#L65-L95. ``NameRef``; The MD5 of the function's PGO name. PGO name has the format; ``[<filepath><delimiter>]<mangled-name>`` where ``<filepath>`` and; ``<delimiter>`` are provided for local-linkage functions to tell possibly; identical functions. .. _FuncHash:. ``FuncHash``; A checksum of the function's IR, taking control flow graph and instrumented; value sites into accounts. See `computeCFGHash`_ for details. .. _`computeCFGHash`: https://github.com/llvm/llvm-project/blob/7c3b67d2038cfb48a80299089f6a1308eee1df7f/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp#L616-L685. .. _`CounterPtr`:. ``CounterPtr``; The in-memory address difference between profile data and the start of corresponding; counters. Counter position is stored this way (as a link-time constant) to reduce; instrumented binary size compared with snapshotting the address of symbols directly.; See `commit a1532ed`_ for further information. .. _`commit a1532ed`: https://github.com/llvm/llvm-project/commit/a1532ed27582038e2d9588108ba0fe8237f01844. .. note::; ``CounterPtr`` might represent a different value for non-IRPGO use case. For; example, for `binary profile correlation`_, it represents the absolute address of counter.; When in doubt, check source code. .. _`BitmapPtr`:. ``BitmapPtr``; The in-memory address difference betw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst:6924,checksum,checksum,6924,interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,1,['checksum'],['checksum']
Security,"he build process needs them.; You may also need to install ``wheel`` first if you have an older version of; ``pip`` and/or do not use virtualenv (which installs wheel by default).; Example::. $ python -m pip install wheel --user; $ PATH=$HOME/.local/bin:$PATH python -m pip install cppyy --user. Wheels on PyPI; --------------. Wheels for the backend (``cppyy-cling``) are available on PyPI for GNU/Linux,; MacOS-X, and MS Windows (both 32b and 64b).; The Linux wheels are built for manylinux2014, but with the dual ABI enabled.; The wheels for MS Windows were build with MSVC Community Edition 2017. There are no wheels for the ``CPyCppyy`` and ``cppyy`` packages, to allow; the C++ standard chosen to match the local compiler. pip with conda; --------------. Although installing ``cppyy`` through `conda-forge`_ is recommended, it is; possible to build/install with ``pip`` under Anaconda/miniconda. Typical Python extensions only expose a C interface for use through the; Python C-API, requiring only calling conventions (and the Python C-API; version, of course) to match to be binary compatible.; Here, cppyy differs because it exposes C++ APIs: it thus requires a C++; run-time that is ABI compatible with the C++ compiler that was used during; build-time. A set of modern compilers is available through conda-forge, but are only; intended for use with ``conda-build``.; In particular, the corresponding run-time is installed (for use through rpath; when building), but not set up.; That is, the conda compilers are added to ``PATH`` but not their libraries; to ``LD_LIBRARY_PATH`` (Mac, Linux; ``PATH`` for both on MS Windows).; Thus, you get the conda compilers and your system libraries mixed in the same; build environment, unless you set ``LD_LIBRARY_PATH`` (``PATH`` on Windows); explicitly, e.g. by adding ``$CONDA_PREFIX/lib``.; Note that the conda documentation recommends against this.; Furthermore, the compilers from conda-forge are not vanilla distributions:; header files have been",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst:3284,expose,expose,3284,bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/installation.rst,1,['expose'],['expose']
Security,"he dtor for the contained object; 3. The contained object itself. Note that it is necessary to maintain #1 & #2 in the exception object itself; because objects without virtual function tables may be thrown (as in this ; example). Assuming this, TryHandler would look something like this:. TryHandler: ; Exception *E = getThreadLocalException();; switch (E->RTTIType) {; case IntRTTIInfo:; ...int Stuff... // The action to perform from the catch block; break;; case DoubleRTTIInfo:; ...double Stuff... // The action to perform from the catch block; goto TryCleanup // This catch block rethrows the exception; break; // Redundant, eliminated by the optimizer; default:; goto TryCleanup // Exception not caught, rethrow; }. // Exception was consumed; if (E->dtor); E->dtor(E->object) // Invoke the dtor on the object if it exists; goto EndTry // Continue mainline code... And that is all there is to it. The throw(E) function would then be implemented like this (which may be ; inlined into the caller through standard optimization):. function throw(Exception *E) {; // Get the start of the stack trace...; %frame %f = call getStackCurrentFrame(). // Get the label information that corresponds to it; label * %L = call getFrameLabel(%f); while (%L == 0 && !isFirstFrame(%f)) {; // Loop until a cleanup handler is found; %f = call getNextFrame(%f); %L = call getFrameLabel(%f); }. if (%L != 0) {; call setThreadLocalException(E) // Allow handlers access to this...; call doNonLocalBranch(%L); }; // No handler found!; call BlowUp() // Ends up calling the terminate() method in use; }. That's a brief rundown of how C++ exception handling could be implemented in; llvm. Java would be very similar, except it only uses destructors to unlock; synchronized blocks, not to destroy data. Also, it uses two stack walks: a; nondestructive walk that builds a stack trace, then a destructive walk that; unwinds the stack as shown here. . It would be trivial to get exception interoperability between C++ and Java. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt:6934,access,access,6934,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-05-18-ExceptionHandling.txt,1,['access'],['access']
Security,"he file `rootlogon.C` coming; with this tutorial. Another relevant file is `rootlogoff.C` that it; called when the session is finished. ### ROOT command history ###. Every command typed at the ROOT prompt is stored in a file `.root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please mo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20356,access,access,20356,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['access'],['access']
Security,"he range from 1 to 12 or equal to 16. Examples:. .. parsed-literal::. ttmp0; ttmp[0]; ttmp[0:1]; ttmp[1:1]; ttmp[0:3]; ttmp[2*2]; ttmp[1-1:2-1]; [ttmp4]; [ttmp4,ttmp5,ttmp6,ttmp7]. Examples of *ttmp* registers with an invalid alignment:. .. parsed-literal::. ttmp[1:2]; ttmp[2:5]. .. _amdgpu_synid_tba:. tba; ---. Trap base address, 64-bits wide. Holds the pointer to the current; trap handler program. ================== ======================================================================= =============; Syntax Description Availability; ================== ======================================================================= =============; tba 64-bit *trap base address* register. GFX7, GFX8; [tba] 64-bit *trap base address* register (an SP3 syntax). GFX7, GFX8; [tba_lo,tba_hi] 64-bit *trap base address* register (an SP3 syntax). GFX7, GFX8; ================== ======================================================================= =============. High and low 32 bits of *trap base address* may be accessed as separate registers:. ================== ======================================================================= =============; Syntax Description Availability; ================== ======================================================================= =============; tba_lo Low 32 bits of *trap base address* register. GFX7, GFX8; tba_hi High 32 bits of *trap base address* register. GFX7, GFX8; [tba_lo] Low 32 bits of *trap base address* register (an SP3 syntax). GFX7, GFX8; [tba_hi] High 32 bits of *trap base address* register (an SP3 syntax). GFX7, GFX8; ================== ======================================================================= =============. .. _amdgpu_synid_tma:. tma; ---. Trap memory address, 64-bits wide. ================= ======================================================================= ==================; Syntax Description Availability; ================= ======================================================================= ===========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:12575,access,accessed,12575,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['access'],['accessed']
Security,"he same material. ### Radionuclides. A new class **`TGeoElementRN`** was introduced in this version to; provide support for radioactive nuclides and their decays. A database of; 3162 radionuclides can be loaded on demand via the table of elements; (**`TGeoElementTable`** class). One can make then materials/mixtures; based on these radionuclides and use them in a geometry. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""geom"",""radionuclides"");; root[] TGeoElementTable *table = geom->GetElementTable();; root[] TGeoElementRN *c14 = table->GetElementRN(14,6); // A,Z; root[] c14->Print();; 6-C-014 ENDF=60140; A=14; Z=6; Iso=0; Level=0[MeV]; Dmass=3.0199[MeV];; Hlife=1.81e+11[s] J/P=0+; Abund=0; Htox=5.8e-10; Itox=5.8e-10; Stat=0; Decay modes:; BetaMinus Diso: 0 BR: 100.000% Qval: 0.1565; ```. One can make materials or mixtures from radionuclides:. ``` {.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""C14"", c14, 2.0);; ```. The following properties of radionuclides can be currently accessed via; getters in the **`TGeoElementRN`** class:. Atomic number and charge (from the base class **`TGeoElement`**). - Isomeric number (`ISO`); - ENDF code - following the convention: `ENDF=10000*Z+100*A+ISO`; - Isomeric energy level [`MeV`]; - Mass excess [`MeV`]; - Half life [`s`]; - Spin/Parity - can be retrieved with: `TGeoElementRN::GetTitle()`; - Hynalation and ingestion toxicities; - List of decays - `TGeoElementRN::GetDecays()`. The radioactive decays of a radionuclide are represented by the class; **`TGeoDecayChannel`** and they are stored in a **`TObjArray`**. Decay; provides:. - Decay mode; - Variation of isomeric number; - `Q` value for the decay [`GeV`]; - Parent element; - Daughter element. Radionuclides are linked one to each other via their decays, until the; last element in the decay chain which must be stable. One can iterate; decay chains using the iterator **`TGeoElemIter`**:. ``` {.cpp}; root[] TGeoElemIter next(c14);; root[] TGeoElementRN *elem;; root[] wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:18461,access,accessed,18461,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessed']
Security,"he second argument. It is undefined behavior to call; this function with a ``list`` that has not been initialized by either; ``__builtin_va_start`` or ``__builtin_va_copy``. * ``void __builtin_va_copy(__builtin_va_list dest, __builtin_va_list src)``. A builtin function for the target-specific ``va_copy`` function-like macro.; This function initializes ``dest`` as a copy of ``src``. It is undefined; behavior to call this function with an already initialized ``dest`` argument. Memory builtins; ---------------. Clang provides constant expression evaluation support for builtin forms of the; following functions from the C standard library headers; ``<string.h>`` and ``<wchar.h>``:. * ``memcpy``; * ``memmove``; * ``wmemcpy``; * ``wmemmove``. In each case, the builtin form has the name of the C library function prefixed; by ``__builtin_``. Constant evaluation support is only provided when the source and destination; are pointers to arrays with the same trivially copyable element type, and the; given size is an exact multiple of the element size that is no greater than; the number of elements accessible through the source and destination operands. Guaranteed inlined copy; ^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c. void __builtin_memcpy_inline(void *dst, const void *src, size_t size);. ``__builtin_memcpy_inline`` has been designed as a building block for efficient; ``memcpy`` implementations. It is identical to ``__builtin_memcpy`` but also; guarantees not to call any external functions. See LLVM IR `llvm.memcpy.inline; <https://llvm.org/docs/LangRef.html#llvm-memcpy-inline-intrinsic>`_ intrinsic; for more information. This is useful to implement a custom version of ``memcpy``, implement a; ``libc`` memcpy or work around the absence of a ``libc``. Note that the `size` argument must be a compile time constant. Note that this intrinsic cannot yet be called in a ``constexpr`` context. Guaranteed inlined memset; ^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c. void __builtin_memset",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:137915,access,accessible,137915,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['accessible']
Security,"he second; operand specifies, which tests to perform :ref:`llvm.is.fpclass <llvm.is.fpclass>`.; The third operand is the vector mask and has the same number of elements as the; result vector type. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.is.fpclass``' intrinsic performs llvm.is.fpclass (:ref:`llvm.is.fpclass <llvm.is.fpclass>`). Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <2 x i1> @llvm.vp.is.fpclass.v2f16(<2 x half> %x, i32 3, <2 x i1> %m, i32 %evl); %t = call <vscale x 2 x i1> @llvm.vp.is.fpclass.nxv2f16(<vscale x 2 x half> %x, i32 3, <vscale x 2 x i1> %m, i32 %evl). .. _int_mload_mstore:. Masked Vector Load and Store Intrinsics; ---------------------------------------. LLVM provides intrinsics for predicated vector load and store operations. The predicate is specified by a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits of the mask are on, the intrinsic is identical to a regular vector load or store. When all bits are off, no memory is accessed. .. _int_mload:. '``llvm.masked.load.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data is a vector of any integer, floating-point or pointer data type. ::. declare <16 x float> @llvm.masked.load.v16f32.p0(ptr <ptr>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.load.v2f64.p0(ptr <ptr>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); ;; The data is a vector of pointers; declare <8 x ptr> @llvm.masked.load.v8p0.p0(ptr <ptr>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads a vector from memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:842962,access,accessed,842962,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"he standard GNU / GCC atomic builtins but taking an extra; memory scope argument. These are designed to be a generic alternative to the; ``__opencl_atomic_*`` builtin functions for targets that support atomic memory; scopes. Atomic memory scopes are designed to assist optimizations for systems with; several levels of memory hierarchy like GPUs. The following memory scopes are; currently supported:. * ``__MEMORY_SCOPE_SYSTEM``; * ``__MEMORY_SCOPE_DEVICE``; * ``__MEMORY_SCOPE_WRKGRP``; * ``__MEMORY_SCOPE_WVFRNT``; * ``__MEMORY_SCOPE_SINGLE``. This controls whether or not the atomic operation is ordered with respect to the; whole system, the current device, an OpenCL workgroup, wavefront, or just a; single thread. If these are used on a target that does not support atomic; scopes, then they will behave exactly as the standard GNU atomic builtins. Low-level ARM exclusive memory builtins; ---------------------------------------. Clang provides overloaded builtins giving direct access to the three key ARM; instructions for implementing atomic operations. .. code-block:: c. T __builtin_arm_ldrex(const volatile T *addr);; T __builtin_arm_ldaex(const volatile T *addr);; int __builtin_arm_strex(T val, volatile T *addr);; int __builtin_arm_stlex(T val, volatile T *addr);; void __builtin_arm_clrex(void);. The types ``T`` currently supported are:. * Integer types with width at most 64 bits (or 128 bits on AArch64).; * Floating-point types; * Pointer types. Note that the compiler does not guarantee it will not insert stores which clear; the exclusive monitor in between an ``ldrex`` type operation and its paired; ``strex``. In practice this is only usually a risk when the extra store is on; the same cache line as the variable being modified and Clang will only insert; stack stores on its own, so it is best not to use these operations on variables; with automatic storage duration. Also, loads and stores may be implicit in code written between the ``ldrex`` and; ``strex``. Clang will",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:143542,access,access,143542,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access']
Security,"he; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline constant; registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``. In 64 bit; address mode the aperture sizes are 2^32 bytes and the base is aligned to 2^32; which makes it easier to convert from flat to segment or segment to flat. Image and Samplers; ~~~~~~~~~~~~~~~~~~. Image and sample handles created by an HSA compatible runtime (see; :ref:`amdgpu-os`) are 64-bit addresses of a hardware 32-byte V# and 48 byte S#; object respectively. In order to support the HSA ``query_sampler`` operations; two extra dwords are used to store the HSA BRIG enumeration values for the; queries that are not trivially deducible from the S# representation. HSA Signals; ~~~~~~~~~~~. HSA signal handles created by an HSA compatible runtime (see :ref:`amdgpu-os`); are 64-bit addresses of a structure allocated in memory accessible from both the; CPU and GPU. The structure is defined by the runtime and subject to change; between releases. For example, see [AMD-ROCm-github]_. .. _amdgpu-amdhsa-hsa-aql-queue:. HSA AQL Queue; ~~~~~~~~~~~~~. The HSA AQL queue structure is defined by an HSA compatible runtime (see; :ref:`amdgpu-os`) and subject to change between releases. For example, see; [AMD-ROCm-github]_. For some processors it contains fields needed to implement; certain language features such as the flat address aperture bases. It also; contains fields used by CP such as managing the allocation of scratch memory. .. _amdgpu-amdhsa-kernel-descriptor:. Kernel Descriptor; ~~~~~~~~~~~~~~~~~. A kernel descriptor consists of the information needed by CP to initiate the; execution of a kernel, including the entry point address of the machine code; that implements the kernel. Code Object V3 Kernel Descriptor; ++++++++++++++++++++++++++++++++. CP microcode requi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:157295,access,accessible,157295,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessible']
Security,"he; Geometry""). If tracking is performed using **`TGeo`**, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained by `TOP` (if the same is positioned 4 times we will; get 4 identical items). This rule will apply to any clicked volume in; the hierarchy. Note that right clicking a volume item activates the; volume context menu containing several specific methods. We will call; the volume hierarchy developed in this way as the; `logical geometry graph`. The volume objects are nodes inside this graph; and the same volume can be accessed starting from different branches. On the other hand, the real geometrical objects that are seen when; visualizing or tracking the geometry are depicted in the `TOP_1` branch.; These are the nodes of the `physical` `tree` of positioned volumes; represented by **`TGeoNode`** objects. This hierarchy is a tree since a; node can have only one parent and several daughters. For a better; understanding of the hierarchy, have a look at; <https://root.cern.ch/doc/master/classTGeoManager.html>. Just close now the `X3D` window and focus at the wire frame picture; drawn in a pad. Activate Options/Event Status. Moving the mouse in the; pad, you will notice that objects are sometimes changing color to red.; Volumes are highlighted in this way whenever the mouse pointer is close; enough to one of its vertices. When this happens, the corresponding; volume is selected and you will see in the bottom right size of the ROOT; canvas its name, shape type and corresponding path in th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:10343,access,accessed,10343,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessed']
Security,"hecker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data as buffer size; }. Unix Alpha Checkers. Name, DescriptionExample. alpha.unix.BlockInCrit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:11389,secur,security,11389,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['secur'],['security']
Security,"hen creating server, one could specify:. root [0] serv = new THttpServer(""fastcgi:9000"");. This opens port 9000, which should be specified in web server configuration.; For instance, lighttpd.conf file could contain path like this:. fastcgi.server = (; ""/remote_scripts/"" =>; (( ""host"" => ""192.168.1.10"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ). In this case one should be able to access root application via address. http://your_lighttpd_host/remote_scripts/root.cgi/. AUTHOR:. Sergey Linev, S.Linev@gsi.de. CHANGES:. January 2015; - Provide exe.json request to execute arbitrary object method and return; result in JSON format. Server should run in non-readonly mode. Fall 2014; - Implement gzip for result of any submitted requests, automatically done ; when .gz extension is provided; - Provide access to arbitrary data member of objects, registered to the server; - Prevent data caching in the browser by setting no-cache header. April 2014; - In TCivetweb class support digest authentication method. User; can specify auth_file and auth_domain parameters to protect; access to the server; - Fix error in FastCgi, now correctly works with Apache; - Avoid direct usage of TASImage. March 2014; - Replace mongoose by civetweb due to more liberal MIT license.; Works out of the box while civetweb version fully corresponds to; previously used version of mongoose.; - Introduce TBufferJSON class to store arbitrary ROOT object; into JSON format. It is not one-to-one storage (like XML), but; rather JS-like structures. For instance, all TCollections converted; into JavaScript Array. Produced JS object is similar to JSRootIO.; - Process get.json request, which returns object in JSON form.; It can be used directly is script without special I/O of Bertrand.; - Use get.json on browser side to simplify logic. No need for extra; requests for streamer infos.; - Process get.xml request, provide full object streaming via TBufferXML.; It is complete object data, but with",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:1757,authenticat,authentication,1757,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,2,['authenticat'],['authentication']
Security,"hen it contains information from; multiple vendors. Augmentation strings occur in the ``DW_AT_LLVM_augmentation``; attribute, in the lookup by name table, and in the CFI Common Information Entry; (CIE). See :ref:`amdgpu-dwarf-full-and-partial-compilation-unit-entries`,; :ref:`amdgpu-dwarf-name-index-section-header`, and; :ref:`amdgpu-dwarf-structure_of-call-frame-information`. 2.16 Support Embedding Source Text for Online Compilation; ---------------------------------------------------------. AMDGPU supports programming languages that include online compilation where the; source text may be created at runtime. For example, the OpenCL and HIP language; runtimes support online compilation. To support is, a way to embed the source; text in the debug information is provided. See :ref:`amdgpu-dwarf-line-number-information`. 2.17 Allow MD5 Checksums to be Optionally Present; -------------------------------------------------. In DWARF Version 5 the file timestamp and file size can be optional, but if the; MD5 checksum is present it must be valid for all files. This is a problem if; using link time optimization to combine compilation units where some have MD5; checksums and some do not. Therefore, sSupport to allow MD5 checksums to be; optionally present in the line table is added. See :ref:`amdgpu-dwarf-line-number-information`. 2.18 Add the HIP Programing Language; ------------------------------------. The HIP programming language [:ref:`HIP <amdgpu-dwarf-HIP>`], which is supported; by the AMDGPU, is added. See :ref:`amdgpu-dwarf-language-names-table`. 2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution; --------------------------------------------------------------------------------------------. A compiler can perform loop optimizations that result in the generated code; executing multiple iterations concurrently. For example, software pipelining; schedules multiple iterations in an interleaved fashion to allow the; instructions of",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:32099,checksum,checksum,32099,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['checksum'],['checksum']
Security,"hen the state information is a map from a key to a value. The methods; available for state types declared with this macro are add,; set, get, remove, and contains. All of these macros take as parameters the name to be used for the custom; category of state information and the data type(s) to be used for storage. The; data type(s) specified will become the parameter type and/or return type of the; methods that manipulate the new category of state information. Each of these; methods are templated with the name of the custom data type. For example, a common case is the need to track data associated with a; symbolic expression; a map type is the most logical way to implement this. The; key for this map will be a pointer to a symbolic expression; (SymbolRef). If the data type to be associated with the symbolic; expression is an integer, then the custom category of state information would be; declared as. REGISTER_MAP_WITH_PROGRAMSTATE(ExampleDataType, SymbolRef, int). The data would be accessed with the function. ProgramStateRef state;; SymbolRef Sym;; ...; int currentlValue = state->get<ExampleDataType>(Sym);. and set with the function. ProgramStateRef state;; SymbolRef Sym;; int newValue;; ...; ProgramStateRef newState = state->set<ExampleDataType>(Sym, newValue);. In addition, the macros define a data type used for storing the data of the; new data category; the name of this type is the name of the data category with; ""Ty"" appended. For REGISTER_TRAIT_WITH_PROGRAMSTATE, this will simply; be passed data type; for the other three macros, this will be a specialized; version of the llvm::ImmutableList,; llvm::ImmutableSet,; or llvm::ImmutableMap; templated class. For the ExampleDataType example above, the type; created would be equivalent to writing the declaration:. using ExampleDataTypeTy = llvm::ImmutableMap<SymbolRef, int>;. These macros will cover a majority of use cases; however, they still have a; few limitations. They cannot be used inside namespaces (since they e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html:14153,access,accessed,14153,interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/checker_dev_manual.html,2,['access'],['accessed']
Security,"her;; };; ```; ```c; typedef struct {; // private fields; } llvm_blake3_hasher;; ```. An incremental BLAKE3 hashing state, which can accept any number of; updates. This implementation doesn't allocate any heap memory, but; `sizeof(llvm_blake3_hasher)` itself is relatively large, currently 1912 bytes; on x86-64. This size can be reduced by restricting the maximum input; length, as described in Section 5.4 of [the BLAKE3; spec](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf),; but this implementation doesn't currently support that strategy. ## Common API Functions. ```c++; BLAKE3::BLAKE3();. void BLAKE3::init();; ```; ```c; void llvm_blake3_hasher_init(; llvm_blake3_hasher *self);; ```. Initialize a `llvm_blake3_hasher` in the default hashing mode. ---. ```c++; void BLAKE3::update(ArrayRef<uint8_t> Data);. void BLAKE3::update(StringRef Str);; ```; ```c; void llvm_blake3_hasher_update(; llvm_blake3_hasher *self,; const void *input,; size_t input_len);; ```. Add input to the hasher. This can be called any number of times. ---. ```c++; template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; using BLAKE3Result = std::array<uint8_t, NumBytes>;. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; void BLAKE3::final(BLAKE3Result<NumBytes> &Result);. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; BLAKE3Result<NumBytes> BLAKE3::final();; ```; ```c; void llvm_blake3_hasher_finalize(; const llvm_blake3_hasher *self,; uint8_t *out,; size_t out_len);; ```. Finalize the hasher and return an output of any length, given in bytes.; This doesn't modify the hasher itself, and it's possible to finalize; again after adding more input. The constant `LLVM_BLAKE3_OUT_LEN` provides; the default output length, 32 bytes, which is recommended for most; callers. Outputs shorter than the default length of 32 bytes (256 bits) provide; less security. An N-bit BLAKE3 output is intended to provide N bits of; first and second preimage resistance and N/2 bits of collision; resistance, for ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:2936,hash,hasher,2936,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['hash'],['hasher']
Security,"here are different ways that the wavefront scratch base address is determined; by a wavefront (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). This; memory can be accessed in an interleaved manner using buffer instruction with; the scratch buffer descriptor and per wavefront scratch offset, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS requires; hardware aperture setup and M0 (GFX7-GFX8) register setup (see; :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a segment address and a flat address the base address of the; apertures address can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline constant; registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``. In 64 bit; address mode the aperture sizes are 2^32 bytes and the base is aligned to 2^32; which makes it easier to convert from flat to segment or segment to flat. Image and",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:155692,access,access,155692,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"hes of the 2 hottest target functions' names (this is the same hash used; to represent function names in the profile database), and the 5th and 7th; operands give the execution count that each of the respective prior target; functions was called. .. _md_annotation:. '``annotation``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``annotation`` metadata can be used to attach a tuple of annotation strings; or a tuple of a tuple of annotation strings to any instruction. This metadata does; not impact the semantics of the program and may only be used to provide additional; insight about the program and transformations to users. Example:. .. code-block:: text. %a.addr = alloca ptr, align 8, !annotation !0; !0 = !{!""auto-init""}. Embedding tuple of strings example:. .. code-block:: text. %a.ptr = getelementptr ptr, ptr %base, i64 0. !annotation !0; !0 = !{!1}; !1 = !{!""gep offset"", !""0""}. '``func_sanitize``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``func_sanitize`` metadata is used to attach two values for the function; sanitizer instrumentation. The first value is the ubsan function signature.; The second value is the address of the proxy variable which stores the address; of the RTTI descriptor. If :ref:`prologue <prologuedata>` and '``func_sanitize``'; are used at the same time, :ref:`prologue <prologuedata>` is emitted before; '``func_sanitize``' in the output. Example:. .. code-block:: text. @__llvm_rtti_proxy = private unnamed_addr constant ptr @_ZTIFvvE; define void @_Z3funv() !func_sanitize !0 {; return void; }; !0 = !{i32 846595819, ptr @__llvm_rtti_proxy}. .. _md_kcfi_type:. '``kcfi_type``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``kcfi_type`` metadata can be used to attach a type identifier to; functions that can be called indirectly. The type data is emitted before the; function entry in the assembly. Indirect calls with the :ref:`kcfi operand; bundle<ob_kcfi>` will emit a check that compares the type identifier to the; metadata. Example:. .. code-block:: text. de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:322817,sanitiz,sanitizer,322817,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['sanitiz'],['sanitizer']
Security,"hey are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking up a value (even when hash collisions happen),; hash table growth does not recompute the hash values for strings already in the; table, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:89404,hash,hash,89404,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,4,['hash'],['hash']
Security,"hey could be invalidated by changes to; inner level IR. Outer analyses unused by inner passes can and often will be; invalidated by changes to inner level IR. These invalidations happen after the; inner pass manager finishes, so accessing mutable analyses would give invalid; results. The exception to not being able to access outer level analyses is accessing; function analyses in loop passes. Loop passes often use function analyses such; as the dominator tree. Loop passes inherently require modifying the function the; loop is in, and that includes some function analyses the loop analyses depend; on. This discounts future concurrency over separate loops in a function, but; that's a tradeoff due to how tightly a loop and its function are coupled. To; make sure the function analyses that loop passes use are valid, they are; manually updated in the loop passes to ensure that invalidation is not; necessary. There is a set of common function analyses that loop passes and; analyses have access to which is passed into loop passes as a; ``LoopStandardAnalysisResults`` parameter. Other mutable function analyses are; not accessible from loop passes. As with any caching mechanism, we need some way to tell analysis managers; when results are no longer valid. Much of the analysis manager complexity; comes from trying to invalidate as few analysis results as possible to keep; compile times as low as possible. There are two ways to deal with potentially invalid analysis results. One is; to simply force clear the results. This should generally only be used when; the IR that the result is keyed on becomes invalid. For example, a function; is deleted, or a CGSCC has become invalid due to call graph changes. The typical way to invalidate analysis results is for a pass to declare what; types of analyses it preserves and what types it does not. When transforming; IR, a pass either has the option to update analyses alongside the IR; transformation, or tell the analysis manager that analyse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:11241,access,access,11241,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['access'],['access']
Security,"hich deserves a bit of explanation: if a; register class constraint allocates a register which is too small for the value; type operand provided as input, the input value will be split into multiple; registers, and all of them passed to the inline asm. However, this feature is often not as useful as you might think. Firstly, the registers are *not* guaranteed to be consecutive. So, on those; architectures that have instructions which operate on multiple consecutive; instructions, this is not an appropriate way to support them. (e.g. the 32-bit; SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The; hardware then loads into both the named register, and the next register. This; feature of inline asm would not be useful to support that.). A few of the targets provide a template string modifier allowing explicit access; to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and; ``D``). On such an architecture, you can actually access the second allocated; register (yet, still, not any subsequent ones). But, in that case, you're still; probably better off simply splitting the value into two separate operands, for; clarity. (e.g. see the description of the ``A`` constraint on X86, which,; despite existing only for use with this feature, is not really a good idea to; use). Indirect inputs and outputs; """""""""""""""""""""""""""""""""""""""""""""""""""""". Indirect output or input constraints can be specified by the ""``*``"" modifier; (which goes after the ""``=``"" in case of an output). This indicates that the asm; will write to or read from the contents of an *address* provided as an input; argument. (Note that in this way, indirect outputs act more like an *input* than; an output: just like an input, they consume an argument of the call expression,; rather than producing a return value. An indirect output constraint is an; ""output"" only in that the asm is expected to write to the contents of the input; memory location, instead of just read from it). Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:215187,access,access,215187,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"hip rules just to; declare a property when the default is so reasonable. Changing the rule away; from non-ARC practice was acceptable because we had conservatively banned the; synthesis in order to give ourselves exactly this leeway. Applying ``__attribute__((NSObject))`` to a property not of retainable object; pointer type has the same behavior it does outside of ARC: it requires the; property type to be some sort of pointer and permits the use of modifiers other; than ``assign``. These modifiers only affect the synthesized getter and; setter; direct accesses to the ivar (even if synthesized) still have primitive; semantics, and the value in the ivar will not be automatically released during; deallocation. .. _arc.ownership.semantics:. Semantics; ---------. There are five :arc-term:`managed operations` which may be performed on an; object of retainable object pointer type. Each qualifier specifies different; semantics for each of these operations. It is still undefined behavior to; access an object outside of its lifetime. A load or store with ""primitive semantics"" has the same semantics as the; respective operation would have on an ``void*`` lvalue with the same alignment; and non-ownership qualification. :arc-term:`Reading` occurs when performing a lvalue-to-rvalue conversion on an; object lvalue. * For ``__weak`` objects, the current pointee is retained and then released at; the end of the current full-expression. In particular, messaging a ``__weak``; object keeps the object retained until the end of the full expression. .. code-block:: objc. __weak MyObject *weakObj;. void foo() {; // weakObj is retained before the message send and released at the end of; // the full expression.; [weakObj m];; }. This must execute atomically with respect to assignments and to the final; release of the pointee.; * For all other objects, the lvalue is loaded with primitive semantics. :arc-term:`Assignment` occurs when evaluating an assignment operator. The; semantics vary based o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:37626,access,access,37626,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['access']
Security,"his allows dynamic types of nodes. But the YAML I/O model uses; static typing, so there are limits to how you can use tags with the YAML I/O; model. Recently, we added support to YAML I/O for checking/setting the optional; tag on a map. Using this functionality it is even possible to support different; mappings, as long as they are convertible. To check a tag, inside your mapping() method you can use io.mapTag() to specify; what the tag should be. This will also add that tag when writing yaml. Validation; ----------. Sometimes in a YAML map, each key/value pair is valid, but the combination is; not. This is similar to something having no syntax errors, but still having; semantic errors. To support semantic level checking, YAML I/O allows; an optional ``validate()`` method in a MappingTraits template specialization. When parsing YAML, the ``validate()`` method is call *after* all key/values in; the map have been processed. Any error message returned by the ``validate()``; method during input will be printed just a like a syntax error would be printed.; When writing YAML, the ``validate()`` method is called *before* the YAML; key/values are written. Any error during output will trigger an ``assert()``; because it is a programming error to have invalid struct values. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mapping"" is a mapping that uses the inline notation; (e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should be; written in YAML using flow mapping, your MappingTraits specialization should; add ""static const bool flow = true;"".",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:23489,validat,validate,23489,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['validat'],['validate']
Security,"histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output is an expanded and structured format.; ``GNU`` (the default) output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --extra-sym-info. Display extra information (section name) when showing symbols. .. option:: --section-groups, -g. Display section groups. .. option:: --expand-relocs. When used with :option:`--relocations`, display each relocation in an expanded; multi-line format. .. option:: --file-header, -h. Display file headers. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dynamic symbols. .. option:: --headers, -e. Equivalent to setting: :option:`--file-header`, :option:`--program-headers`,; and :option:`--sections`. .. option:: --help. Display a summary of command line options. .. option:: --hex-dump=<section[,section,...]>, -x. Display the specified section(s) as hexadecimal bytes. ``section`` may be a; section index or section name. .. option:: --memtag. Display information about memory tagging present in the binary. This includes; various memtag-specific dynamic entries, decoded global descriptor sections,; and decoded Android-specific ELF notes. .. option:: --needed-libs. Display the needed libraries. .. option:: --no-demangle. Do not display demangled symbol names in the output. On by default. .. option:: --notes, -n. Display all notes. .. option:: --pretty-print. When used with :option:`--elf-output-style`, JSON output will be formatted in; a more readable format. .. option:: --program-headers, --segments, -l. Display the program headers. .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst:2587,hash,hash,2587,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,1,['hash'],['hash']
Security,"hnically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical examp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65484,secur,security-taint-TaintPropagation,65484,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security-taint-TaintPropagation']
Security,"hough it has some holes (it allows ""``123KKK``"" for example),; it is good enough for this example. Note that we use the option itself to print; out the error message (the ``error`` method always returns true) in order to get; a nice error message (shown below). Now that we have our parser class, we can; use it like this:. .. code-block:: c++. static cl::opt<unsigned, false, FileSizeParser>; MFS(""max-file-size"", cl::desc(""Maximum file size to accept""),; cl::value_desc(""size""));. Which adds this to the output of our program:. ::. OPTIONS:; -help - display available options (-help-hidden for more); ...; -max-file-size=<size> - Maximum file size to accept. And we can test that our parse works correctly now (the test program just prints; out the max-file-size argument value):. ::. $ ./test; MFS: 0; $ ./test -max-file-size=123MB; MFS: 128974848; $ ./test -max-file-size=3G; MFS: 3221225472; $ ./test -max-file-size=dog; -max-file-size option: 'dog' value invalid for file size argument!. It looks like it works. The error message that we get is nice and helpful, and; we seem to accept reasonable file sizes. This wraps up the ""custom parser""; tutorial. Exploiting external storage; ---------------------------. Several of the LLVM libraries define static ``cl::opt`` instances that will; automatically be included in any program that links with that library. This is; a feature. However, sometimes it is necessary to know the value of the command; line option outside of the library. In these cases the library does or should; provide an external storage location that is accessible to users of the; library. Examples of this include the ``llvm::DebugFlag`` exported by the; ``lib/Support/Debug.cpp`` file and the ``llvm::TimePassesIsEnabled`` flag; exported by the ``lib/IR/PassManager.cpp`` file. .. todo::. TODO: complete this section. .. _dynamically loaded options:. Dynamically adding command line options; ---------------------------------------. .. todo::. TODO: fill in this section; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:66853,access,accessible,66853,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['access'],['accessible']
Security,"ht corner; of the box, and show it again by clicking on the ""+"". List of Data and Function Members; The central part of a class are its members. Some are available to you; some; are hidden from you, because they are only meant to be used internally.; As an example, a class might allow you to set, access, and print its values, or store; them into a file.; Because methods should have reasonable names, often the method name itself is already; a hint on what it does.; If you want to get a TNamed's; name, you will immediately see TNamed::GetName() in its list of functions.; A click on this name will send you to the documentation for the method.; If you enabled the display of inherited members you will see; some members with a class name prefix. It tells you where this method has been defined.; Display Options; The info box contains options that influence how; the list of members is displayed: you can e.g. show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are marked with a red bar. Of course you won't see any protected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:5612,access,access,5612,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,2,['access'],['access']
Security,"https://clang.llvm.org/docs/AutomaticReferenceCounting.html#void-objc-storestrong-id-object-id-value>`_. '``llvm.objc.storeWeak``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.storeWeak(ptr, ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_storeWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-storeweak>`_. Preserving Debug Information Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These intrinsics are used to carry certain debuginfo together with; IR-level operations. For example, it may be desirable to; know the structure/union name and the original user-level field; indices. Such information got lost in IR GetElementPtr instruction; since the IR types are different from debugInfo types and unions; are converted to structs in IR. '``llvm.preserve.array.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.array.access.index.p0s_union.anons.p0a10s_union.anons(<type> base,; i32 dim,; i32 index). Overview:; """""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic returns the getelementptr address; based on array base ``base``, array dimension ``dim`` and the last access index ``index``; into the array. The return type ``ret_type`` is a pointer type to the array element.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:972634,access,access,972634,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"hus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66127,sanitiz,sanitizing,66127,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['sanitiz'],['sanitizing']
Security,"i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. LLVM libunwind processes this unwind info correctly,; however. This means that if exceptions are used together with ShadowCallStack,; the program must use a compatible unwinder. Security; ========. ShadowCallStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5222,attack,attackers,5222,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,2,"['attack', 'expose']","['attackers', 'exposed']"
Security,"i8*`` style typed pointers. In opaque pointer mode, all typed pointers used in IR, bitcode, or created; using ``PointerType::get()`` and similar APIs are automatically converted into; opaque pointers. This simplifies migration and allows testing existing IR with; opaque pointers. .. code-block:: llvm. define i8* @test(i8* %p) {; %p2 = getelementptr i8, i8* %p, i64 1; ret i8* %p2; }. ; Is automatically converted into the following if -opaque-pointers; ; is enabled:. define ptr @test(ptr %p) {; %p2 = getelementptr i8, ptr %p, i64 1; ret ptr %p2; }. Migration Instructions; ======================. In order to support opaque pointers, two types of changes tend to be necessary.; The first is the removal of all calls to ``PointerType::getElementType()`` and; ``Type::getPointerElementType()``. In the LLVM middle-end and backend, this is usually accomplished by inspecting; the type of relevant operations instead. For example, memory access related; analyses and optimizations should use the types encoded in the load and store; instructions instead of querying the pointer type. Here are some common ways to avoid pointer element type accesses:. * For loads, use ``getType()``.; * For stores, use ``getValueOperand()->getType()``.; * Use ``getLoadStoreType()`` to handle both of the above in one call.; * For getelementptr instructions, use ``getSourceElementType()``.; * For calls, use ``getFunctionType()``.; * For allocas, use ``getAllocatedType()``.; * For globals, use ``getValueType()``.; * For consistency assertions, use; ``PointerType::isOpaqueOrPointeeTypeEquals()``.; * To create a pointer type in a different address space, use; ``PointerType::getWithSamePointeeType()``.; * To check that two pointers have the same element type, use; ``PointerType::hasSameElementTypeAs()``.; * While it is preferred to write code in a way that accepts both typed and; opaque pointers, ``Type::isOpaquePointerTy()`` and; ``PointerType::isOpaque()`` can be used to handle opaque pointers specially.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:6607,access,access,6607,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['access'],['access']
Security,"i?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; public mutator methods, instead, simply call ``setName`` on a value, which will; autoinsert it into the appropriate symbol table. .. _UserLayout:. The ``User`` and owned ``Use`` classes' memory layout; -----------------------------------------------------. The ``User`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1User.html>`__); class provides a basis for expressing the ownership of ``User`` towards other; `Value instance <https://llvm.org/doxygen/classllvm_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:125928,access,accessed,125928,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security,"i_val:. * The **cl::multi_val** attribute specifies that this option takes has multiple; values (example: ``-sectalign segname sectname sectvalue``). This attribute; takes one unsigned argument - the number of values for the option. This; attribute is valid only on ``cl::list`` options (and will fail with compile; error if you try to use it with other option types). It is allowed to use all; of the usual modifiers on multi-valued options (besides; ``cl::ValueDisallowed``, obviously). .. _cl::cat:. * The **cl::cat** attribute specifies the option category that the option; belongs to. The category should be a `cl::OptionCategory`_ object. .. _cl::callback:. * The **cl::callback** attribute specifies a callback function that is; called when an option is seen, and can be used to set other options,; as in option B implies option A. If the option is a `cl::list`_,; and `cl::CommaSeparated`_ is also specified, the callback will fire; once for each value. This could be used to validate combinations or; selectively set other options. .. code-block:: c++. cl::opt<bool> OptA(""a"", cl::desc(""option a""));; cl::opt<bool> OptB(; ""b"", cl::desc(""option b -- This option turns on option a""),; cl::callback([&](const bool &) { OptA = true; }));; cl::list<std::string, cl::list<std::string>> List(; ""list"",; cl::desc(""option list -- This option turns on options a when ""; ""'foo' is included in list""),; cl::CommaSeparated,; cl::callback([&](const std::string &Str) {; if (Str == ""foo""); OptA = true;; }));. Option Modifiers; ----------------. Option modifiers are the flags and expressions that you pass into the; constructors for `cl::opt`_ and `cl::list`_. These modifiers give you the; ability to tweak how options are parsed and how ``-help`` output is generated to; fit your application well. These options fall into five main categories:. #. Hiding an option from ``-help`` output. #. Controlling the number of occurrences required and allowed. #. Controlling whether or not a value must be specifi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:39085,validat,validate,39085,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['validat'],['validate']
Security,"iasAnalysis.html>`_ analysis group.; Every implementation of an analysis group should join using this macro. .. code-block:: c++. namespace {; // Declare that we implement the AliasAnalysis interface; INITIALIZE_AG_PASS(BasicAA, AliasAnalysis, ""basic-aa"",; ""Basic Alias Analysis (default AA impl)"",; false, // Is CFG Only?; true, // Is Analysis?; true); // Is default Analysis Group implementation?; }. Here we show how the default implementation is specified (using the final; argument to the ``INITIALIZE_AG_PASS`` template). There must be exactly one; default implementation available at all times for an Analysis Group to be used.; Only default implementation can derive from ``ImmutablePass``. Here we declare; that the `BasicAliasAnalysis; <https://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass is the default; implementation for the interface. Pass Statistics; ===============. The `Statistic <https://llvm.org/doxygen/Statistic_8h_source.html>`_ class is; designed to be an easy way to expose various success metrics from passes.; These statistics are printed at the end of a run, when the :option:`-stats`; command line option is enabled on the command line. See the :ref:`Statistics; section <Statistic>` in the Programmer's Manual for details. .. _writing-an-llvm-pass-passmanager:. What PassManager does; ---------------------. The `PassManager <https://llvm.org/doxygen/PassManager_8h_source.html>`_ `class; <https://llvm.org/doxygen/classllvm_1_1PassManager.html>`_ takes a list of; passes, ensures their :ref:`prerequisites <writing-an-llvm-pass-interaction>`; are set up correctly, and then schedules passes to run efficiently. All of the; LLVM tools that run passes use the PassManager for execution of these passes. The PassManager does two main things to try to reduce the execution time of a; series of passes:. #. **Share analysis results.** The ``PassManager`` attempts to avoid; recomputing analysis results as much as possible. This means keeping track; of which analy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:40357,expose,expose,40357,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['expose'],['expose']
Security,"iasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11784,inject,injection,11784,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injection']
Security,"iated; jump table entry, which must be emitted even in the common case where the; function is never address-taken anywhere in the program, and must be used; even for direct calls between DSOs, in addition to the PLT overhead. - There is no good way to take a CFI-valid address of a function written in; assembly or a language not supported by Clang. The reason is that the code; generator would need to insert a jump table in order to form a CFI-valid; address for assembly functions, but there is no way in general for the; code generator to determine the language of the function. This may be; possible with LTO in the intra-DSO case, but in the cross-DSO case the only; information available is the function declaration. One possible solution; is to add a C wrapper for each assembly function, but these wrappers can; present a significant maintenance burden for heavy users of assembly in; addition to adding runtime overhead. For these reasons, we provide the option of making the jump table non-canonical; with the flag ``-fno-sanitize-cfi-canonical-jump-tables``. When the jump; table is made non-canonical, symbol table entries point directly to the; function body. Any instances of a function's address being taken in C will; be replaced with a jump table address. This scheme does have its own caveats, however. It does end up breaking; function address equality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table))`` attribute may be used to make; the jump table entry of a specific function canonical so that the external; code will end up taking an address for the function that will ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:13358,sanitiz,sanitize-cfi-canonical-jump-tables,13358,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['sanitiz'],['sanitize-cfi-canonical-jump-tables']
Security,"ibility to change; only the generating function, passed as TMacro. Add also check on the; free space on the device and skip file generation if less than 10% or; less than 1 GB.; Record in TStatus also the max memory usage on the master and printed; via TStatus::Print; this allow a quick visualisation of the overall; memory usage at the end of the query.; Import version 0.9.6 of afdsmgrd; Make sure that the name(s) of the processed dataset(s) are registered; in the TFileInfo objects being processed, so that it can be used for; monitoring.; In XrdProofd, add possibility to skip the checks for the data; directories during session startup, as they may significantly slowdown; the startup process is the medium is busy. In such a case, admins; are responsible to create the directories in advance; the session; releated part fo the path is created by the session once up.; In XrdProofd, move the check for the username after authentication.; This is because authentication may run some credentials-to-user mapping; which can modify the requested username. This way we really check the; final username and not the one requested by the client, which may even; not exist on the machines. Side modification: when the mapping function; returns more usernames, the username specified by the client is used to; help choosing the effective username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambigui",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:2301,authenticat,authentication,2301,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,2,['authenticat'],['authentication']
Security,"ibrary DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD; Argument dependent lookup and points of instantiation; N/A. 35; TC1; Definition of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete type to same type; Yes. 51; TC1; Overloading and user-defined conversions; Clang 2.8. 52; TC1; Non-static members, member selection and access checking; Clang 2.8. 53; TC1; Lvalue-to-rvalue conversion before certain static_casts; Yes. 54; CD1; Static_cast from private base to derived class; Clang 2.8. 55; NAD; Adding/subtracting pointer and enumeration value; Yes. 56; TC1; Redeclaring typedefs within classes; Yes. 57; open; Empty unions; Not resolved. 58; CD1; Signedness of bit fields of enum type; Clang 3.1. 59; TC1; Clarification of overloading and UDC to reference type; Yes. 60; CD1; Reference binding and valid conversion sequences; Yes. 61; NAD; Address of static member function ""&p->f"";",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:3722,Access,Access,3722,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"ibute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310241,access,access,310241,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ic information in the IR. Why do struct member indices always use ``i32``?; ------------------------------------------------. The specific type i32 is probably just a historical artifact, however it's wide; enough for all practical purposes, so there's been no need to change it. It; doesn't necessarily imply i32 address arithmetic; it's just an identifier which; identifies a field in a struct. Requiring that all struct indices be the same; reduces the range of possibilities for cases where two GEPs are effectively the; same but have distinct operand types. What's an uglygep?; ------------------. Some LLVM optimizers operate on GEPs by internally lowering them into more; primitive integer expressions, which allows them to be combined with other; integer expressions and/or split into multiple separate integer expressions. If; they've made non-trivial changes, translating back into LLVM IR can involve; reverse-engineering the structure of the addressing in order to fit it into the; static type of the original first operand. It isn't always possibly to fully; reconstruct this structure; sometimes the underlying addressing doesn't; correspond with the static type at all. In such cases the optimizer instead will; emit a GEP with the base pointer casted to a simple address-unit pointer, using; the name ""uglygep"". This isn't pretty, but it's just as valid, and it's; sufficient to preserve the pointer aliasing guarantees that GEP provides. Summary; =======. In summary, here's some things to always remember about the GetElementPtr; instruction:. #. The GEP instruction never accesses memory, it only provides pointer; computations. #. The second operand to the GEP instruction is always a pointer and it must be; indexed. #. There are no superfluous indices for the GEP instruction. #. Trailing zero indices are superfluous for pointer aliasing, but not for the; types of the pointers. #. Leading zero indices are not superfluous for pointer aliasing nor the types; of the pointers.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:21455,access,accesses,21455,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['accesses']
Security,"ic on arbitrary pointers and this has been; a source of many bounds safety issues. In practice, many pointers are merely; pointing to a single object and incrementing or decrementing such a pointer; immediately makes the pointer go out-of-bounds. To prevent this unsafety,; ``-fbounds-safety`` provides the annotation ``__single`` that causes pointer; arithmetic on annotated pointers to be a compile time error. * ``__single`` : indicates that the pointer is either pointing to a single; object or null. Hence, pointers with ``__single`` do not permit pointer; arithmetic nor being subscripted with a non-zero index. Dereferencing a; ``__single`` pointer is allowed but it requires a null check. Upper and lower; bounds checks are not required because the ``__single`` pointer should point; to a valid object unless it's null. ``__single`` is the default annotation for ABI-visible pointers. This; gives strong security guarantees in that these pointers cannot be incremented or; decremented unless they have an explicit, overriding bounds annotation that can; be used to verify the safety of the operation. The compiler issues an error when; a ``__single`` pointer is utilized for pointer arithmetic or array access, as; these operations would immediately cause the pointer to exceed its bounds.; Consequently, this prompts programmers to provide sufficient bounds information; to pointers. In the following example, the pointer on parameter p is; single-by-default, and is employed for array access. As a result, the compiler; generates an error suggesting to add ``__counted_by`` to the pointer. .. code-block:: c. void fill_array_with_indices(int *p, unsigned count) {; for (unsigned i = 0; i < count; ++i) {; p[i] = i; // error; }; }. External bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. ""External"" bounds annotations provide a way to express a relationship between a; pointer variable and another variable (or expression) containing the bounds; information of the pointer. In the followin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:8101,secur,security,8101,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['secur'],['security']
Security,"ic` (`TMatrixDSym`) or `sparse` (`TMatrixDSparse`). - `size`<br>; Number of rows and columns. - `index`<br>; Range start of row and column index. By default these start at 0. - `sparse map`<br>; Only relevant for a sparse matrix. It indicates where elements are unequal 0. #### Accessing matrix properties. Use one of the following methods to access the information about the relevant matrix property:. - `Int_t GetRowLwb()`: Row lower-bound index. - `Int_t GetRowUpb()`: Row upper-bound index. - `Int_t GetNrows()`: Number of rows. - `Int_t GetColLwb()`: Column lower-bound index. - `Int_t GetColUpb()`: Column upper-bound index. - `Int_t GetNcols()`: Number of columns. - `Int_t GetNoElements()`: Number of elements, for a dense matrix this equals: `fNrows x fNcols`. - `Double_t GetTol()`: Tolerance number that is used in decomposition operations. - `Int_t *GetRowIndexArray()`: For sparse matrices, access to the row index of `fNrows+1` entries. - `Int_t *GetColIndexArray()`: For sparse matrices, access to the column index of `fNelems` entries. #### Setting matrix properties. Use one of the following methods to set a matrix property:. - `SetTol (Double_t tol)`<br>; Sets the tolerance number. - `ResizeTo (Int_t nrows,Int_t ncols, Int_t nr_nonzeros=-1)`<br>; Changes the matrix shape to `nrows x ncols`. Index will start at 0. - `ResizeTo(Int_t row_lwb,Int_t row_upb, Int_t col_lwb,Int_t col_upb, Int_t nr_nonzeros=-1)`<br>; Changes the matrix shape to `row_lwb:row_upb x col_lwb:col_upb`. - `SetRowIndexArray (Int_t *data)`<br>; For sparse matrices, it sets the row index. The array data should contain at least `fNrows+1` entries column lower-bound index. - `SetColIndexArray (Int_t *data)`<br>; For sparse matrices, it sets the column index. The array data should contain at least `fNelems` entries. - `SetSparseIndex (Int_t nelems new)`<br>; Allocates memory for a sparse map of `nelems_new` elements and copies (if exists) at most `nelems_new` matrix elements over to the new structure. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:3192,access,access,3192,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['access'],['access']
Security,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180419,sanitiz,sanitize-coverage,180419,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,7,['sanitiz'],"['sanitize-coverage', 'sanitize-memory-track-origins', 'sanitize-memory-use-after-dtor', 'sanitize-recover', 'sanitize-stats', 'sanitizer', 'sanitizers']"
Security,"icate of 353. 266; NAD; No grammar sentence symbol; N/A. 267; open; Alignment requirement for new-expressions; Not resolved. 268; open; Macro name suppression in rescanned replacement text; Not resolved. 269; NAD; Order of initialization of multiply-defined static data members; of class templates; N/A. 270; CD1; Order of initialization of static data members of class templates; N/A. 271; CD6; Explicit instantiation and template argument deduction; Unknown. 272; CD1; Explicit destructor invocation and qualified-ids; Yes. 273; CD1; POD classes and operator&(); Yes. 274; CD1; Cv-qualification and char-alias access to out-of-lifetime objects; N/A. 275; CD1; Explicit instantiation/specialization and using-directives; No. 276; CD1; Order of destruction of parameters and temporaries; N/A. 277; CD1; Zero-initialization of pointers; Clang 3.1. 278; NAD; External linkage and nameless entities; Unknown. 279; CD6; Correspondence of ""names for linkage purposes""; Unknown. 280; CD1; Access and surrogate call functions; Clang 2.9. 281; CD1; inline specifier in friend declarations; No. 282; open; Namespace for extended_type_info; Not resolved. 283; CD1; Template type-parameters are not syntactically type-names; Yes. 284; CD1; qualified-ids in class declarations; No. 285; NAD; Identifying a function template being specialized; Yes. 286; CD1; Incorrect example in partial specialization; Clang 2.8. 287; drafting; Order dependencies in template instantiation; Not resolved. 288; CD1; Misuse of ""static type"" in describing pointers; N/A. 289; CD1; Incomplete list of contexts requiring a complete type; Yes. 290; NAD; Should memcpy be allowed into a POD with a const member?; N/A. 291; CD1; Overload resolution needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specificatio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:18452,Access,Access,18452,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"icate state.; orq %rax, %rcx # Mask the pointer if misspeculating.; movq (%rcx), %rdi # Hardened load.; movl (%rdi), %edx # Unhardened load due to dependent addr.; ```. This doesn't check the load through `%rdi` as that pointer is dependent on a; checked load already. ###### Protect large, load-heavy blocks with a single lfence. It may be worth using a single `lfence` instruction at the start of a block; which begins with a (very) large number of loads that require independent; protection *and* which require hardening the address of the load. However, this; is unlikely to be profitable in practice. The latency hit of the hardening; would need to exceed that of an `lfence` when *correctly* speculatively; executed. But in that case, the `lfence` cost is a complete loss of speculative; execution (at a minimum). So far, the evidence we have of the performance cost; of using `lfence` indicates few if any hot code patterns where this trade off; would make sense. ###### Tempting optimizations that break the security model. Several optimizations were considered which didn't pan out due to failure to; uphold the security model. One in particular is worth discussing as many others; will reduce to it. We wondered whether only the *first* load in a basic block could be checked. If; the check works as intended, it forms an invalid pointer that doesn't even; virtual-address translate in the hardware. It should fault very early on in its; processing. Maybe that would stop things in time for the misspeculated path to; fail to leak any secrets. This doesn't end up working because the processor is; fundamentally out-of-order, even in its speculative domain. As a consequence,; the attacker could cause the initial address computation itself to stall and; allow an arbitrary number of unrelated loads (including attacked loads of; secret data) to pass through. #### Interprocedural Checking. Modern x86 processors may speculate into called functions and out of functions; to their return addr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:36918,secur,security,36918,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['secur'],['security']
Security,"icense (see LICENSE.TXT in; the topmost) directory, it has no external dependencies, and it works on; all platforms that I tested:; - Linux; - Windows (probably >= 2000); - MacOS; - Solaris; Adding other platforms is trivial. = Internal Design. TextInput.h contains the main interface. The reading can be extended by; adding classes that derive from Reader; the displaying can be extended; by deriving from Display. There can be multiple readers and multiple displays. All displays are; equal, all readers are equal. All displays show the input of all; readers. The terminal / console implementations for readers and; displays are provided. Both readers and displays only attach while; textinput is acively reading input. As soon as the input is done (enter; was pressed), they detach from the terminal, allowing the application; to take control of the terminal, and even to crash without leaving the; terminal in a non-default state. The editor provides basic emacs-like keybinding, as known from e.g.; bash. It supports ^O, ^R (for now without regex), and most word-centric; editing commands. See KeyBinding for details. KeyBinding maps the InputData read from the Reader to Editor::Commands.; The Editor performs the requested editing actions, and the Displays; are informed about the changes. TextInput gives access to the read; state (""are we done?"") and the input. = Why no [N]Curses?. Because of platform independence (well, one could still have a; TerminalDisplayCurses) and because nowadays this is actually rarely; needed. Sure, it's the ""right"" way of interfacing terminals. But the; number of terminal types in the wild has siginifantly decreased, so; just hard-coding escape sequences became a viable alternative. = References. These pages helped when writing libtextinput:; http://tldp.org/LDP/lpg/node129.html; http://rtfm.etla.org/xterm/ctlseq.html; http://frexx.de/xterm-256-notes; Thanks a lot to the authors for creating these useful pages!. Axel Naumann <axel@cern.ch>, May 2011; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt:1514,access,access,1514,core/textinput/src/textinput/doc/textinput.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/doc/textinput.txt,1,['access'],['access']
Security,"ich are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing the execution of a script. - Adding a new primitive or modifying some primitives for example the; name and title of an object. - You can also set the ""bit-modified"" explicitly with the `Modified`; method:. ``` {.cpp}; // the pad has changed; root[] pad1->Modified(); // recursively update all modified pads:; root[] c1->Update(); ```. A subsequent call to `TCanvas::Update()` scans the list of sub-pads; and repaints the pads declared modified. In compiled code or in a long macro, you may want to access an object; created during the paint process. To do so, you can force the painting; with a `TCanvas::Update()`. For example, a **`TGraph`** creates a; histogram (**`TH1`**) to paint itself. In this case the internal; histogram obtained with `TGraph::GetHistogram()` is created only after; the pad is painted. The pad is painted automatically after the script is; finished executing or if you force the painting with `TPad::Modified()`; followed by a `TCanvas::Update()`. Note that it is not necessary to call; `TPad::Modified()` after a call to `Draw()`. The ""bit-modified"" is set; automatically by `Draw()`. A note about the ""bit-modified"" in sub pads:; when you want to update a sub pad in your canvas, you need to call; `pad->Modified()` rather than `canvas->Modified()`, and follow it with a; `canvas->Update()`. If you use `canvas->Modified()`, followed by a call; to `canvas->Update()`, the sub pad has not been declared modified and it; will not be updated. Also note that a call to `pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:27019,access,access,27019,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['access'],['access']
Security,"icipated in writing or reviewing a transparency report in the last year.; - When employed by a company or other entity, the parent entity has no more than three members already in the LLVM Security Group.; - When nominated as a vendor contact, their position with that vendor remains the same as when originally nominated.; - Nominees are trusted by existing Security Group members to keep communications embargoed while still active. Nomination process; ------------------. Anyone who feels they meet these criteria can nominate themselves, or may be nominated by a third party such as an existing LLVM Security Group member. The nomination should state whether the nominee is nominated as an individual, researcher, or as a vendor contact. It should clearly describe the grounds for nomination. For the moment, nominations are generally proposed, discussed, and voted on using Phabricator. An `example nomination is available here`_. The use of Phabricator helps keep membership discussions open, transparent, and easily accessible to LLVM developers in many ways. If, for any reason, a fully-world-readable nomination seems inappropriate, you may `open a new issue`_, and a discussion can be had about the best way to approach nomination, given the constraints that individuals are under. Our recommended method of nomination may change as our `Discussion Medium`_ story evolves over time. Choosing new members; --------------------. If a nomination for LLVM Security Group membership is supported by a majority of existing LLVM Security Group members, then it carries within five business days unless an existing member of the Security Group objects. If an objection is raised, the LLVM Security Group members should discuss the matter and try to come to consensus; failing this, the nomination will succeed only by a two-thirds supermajority vote of the LLVM Security Group. Accepting membership; --------------------. Before new LLVM Security Group membership is finalized, the successful nomine",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:5645,access,accessible,5645,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['access'],['accessible']
Security,"id in the Y; dimension (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). Used by CP to set up; ``COMPUTE_PGM_RSRC2.TGID_Y_EN``.; 9 1 bit ENABLE_SGPR_WORKGROUP_ID_Z Enable the setup of the; system SGPR register for; the work-group id in the Z; dimension (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). Used by CP to set up; ``COMPUTE_PGM_RSRC2.TGID_Z_EN``.; 10 1 bit ENABLE_SGPR_WORKGROUP_INFO Enable the setup of the; system SGPR register for; work-group information (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). Used by CP to set up; ``COMPUTE_PGM_RSRC2.TGID_SIZE_EN``.; 12:11 2 bits ENABLE_VGPR_WORKITEM_ID Enable the setup of the; VGPR system registers used; for the work-item ID.; :ref:`amdgpu-amdhsa-system-vgpr-work-item-id-enumeration-values-table`; defines the values. Used by CP to set up; ``COMPUTE_PGM_RSRC2.TIDIG_CMP_CNT``.; 13 1 bit ENABLE_EXCEPTION_ADDRESS_WATCH Must be 0. Wavefront starts execution; with address watch; exceptions enabled which; are generated when L1 has; witnessed a thread access; an *address of; interest*. CP is responsible for; filling in the address; watch bit in; ``COMPUTE_PGM_RSRC2.EXCP_EN_MSB``; according to what the; runtime requests.; 14 1 bit ENABLE_EXCEPTION_MEMORY Must be 0. Wavefront starts execution; with memory violation; exceptions exceptions; enabled which are generated; when a memory violation has; occurred for this wavefront from; L1 or LDS; (write-to-read-only-memory,; mis-aligned atomic, LDS; address out of range,; illegal address, etc.). CP sets the memory; violation bit in; ``COMPUTE_PGM_RSRC2.EXCP_EN_MSB``; according to what the; runtime requests.; 23:15 9 bits GRANULATED_LDS_SIZE Must be 0. CP uses the rounded value; from the dispatch packet,; not this value, as the; dispatch may contain; dynamically allocated group; segment memory. CP writes; directly to; ``COMPUTE_PGM_RSRC2.LDS_SIZE``. Amount of group segment; (LDS) to allocate for each; work-group. Granularity is; device specific:. GFX",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:173252,access,access,173252,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"idely adoptable in practice:. * It is designed to preserve the Application Binary Interface (ABI).; * It interoperates well with plain C code.; * It can be adopted partially and incrementally while still providing safety; benefits.; * It is a conforming extension to C.; * Consequently, source code that adopts the extension can continue to be; compiled by toolchains that do not support the extension (CAVEAT: this still; requires inclusion of a header file macro-defining bounds annotations to; empty).; * It has a relatively low adoption cost. This document discusses the key designs of ``-fbounds-safety``. The document is; subject to be actively updated with a more detailed specification. The; implementation plan can be found in :doc:`BoundsSafetyImplPlans`. Programming Model; =================. Overview; --------. ``-fbounds-safety`` ensures that pointers are not used to access memory beyond; their bounds by performing bounds checking. If a bounds check fails, the program; will deterministically trap before out-of-bounds memory is accessed. In our model, every pointer has an explicit or implicit bounds attribute that; determines its bounds and ensures guaranteed bounds checking. Consider the; example below where the ``__counted_by(count)`` annotation indicates that; parameter ``p`` points to a buffer of integers containing ``count`` elements. An; off-by-one error is present in the loop condition, leading to ``p[i]`` being; out-of-bounds access during the loop's final iteration. The compiler inserts a; bounds check before ``p`` is dereferenced to ensure that the access remains; within the specified bounds. .. code-block:: c. void fill_array_with_indices(int *__counted_by(count) p, unsigned count) {; // off-by-one error (i < count); for (unsigned i = 0; i <= count; ++i) {; // bounds check inserted:; // if (i >= count) trap();; p[i] = i;; }; }. A bounds annotation defines an invariant for the pointer type, and the model; ensures that this invariant remains true. In the ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:3148,access,accessed,3148,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['accessed']
Security,"ied in the folder hierarchy by an ""UNIX-like""; naming convention. The base of all folders is `//root`. It is visible at; the top of the left panel in the browser. The browser shows several; folders under `//root`. New folders can be added and removed to/from a folder. ## Why Use Folders?. One reason to use folders is to reduce class dependencies and improve; modularity. Each set of data has a producer class and one or many; consumer classes. When using folders, the producer class places a; pointer to the data into a folder, and the consumer class retrieves a; reference to the folder. The consumer can access the objects in a folder by specifying the path; name of the folder. Here is an example of a folder's path name:. `//root/Event/Hits/TCP`. One does not have to specify the full path name. If the partial path; name is unique, it will find it; otherwise it will return the first; occurrence of the path. The first diagram shows a system without folders. The objects have; pointers to each other to access each other's data. Pointers are an; efficient way to share data between classes. However, a direct pointer; creates a direct coupling between classes. This design can become a very; tangled web of dependencies in a system with a large number of classes. ![](pictures/020000E2.jpg). In the second diagram, a reference to the data is in the folder and the; consumers refer to the folder rather than each other to access the data.; The naming and search service provided by the ROOT folders hierarchy; provides an alternative. It loosely couples the classes and greatly; enhances I/O operations. In this way, folders separate the data from the; algorithms and greatly improve the modularity of an application by; minimizing the class dependencies. ![](pictures/020000E3.jpg). In addition, the folder hierarchy creates a picture of the data; organization. This is useful when discussing data design issues or when; learning the data organization. The example below illustrates this; poin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md:1214,access,access,1214,documentation/users-guide/FoldersTasks.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FoldersTasks.md,1,['access'],['access']
Security,"ield ID +; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Structural Role | Flags |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. The field version and type version are used for schema evolution. The structural role of the field can have one of the following values:. | Value | Structural role |; |----------|--------------------------------------------------------------------------|; | 0x00 | Leaf field in the schema tree |; | 0x01 | The field is the parent of a collection (e.g., a vector) |; | 0x02 | The field is the parent of a record (e.g., a struct) |; | 0x03 | The field is the parent of a variant |; | 0x04 | The field stores objects serialized with the ROOT streamer |. The ""flags"" field can have any of the following bits set:. | Bit | Meaning |; |----------|----------------------------------------------------------------------------|; | 0x01 | Repetitive field, i.e. for every entry $n$ copies of the field are stored |; | 0x02 | Projected field |; | 0x04 | Has ROOT type checksum as reported by TClass |. If `flag==0x01` (_repetitive field_) is set, the field represents a fixed-size array.; For fixed-size arrays, another (sub) field with `Parent Field ID` equal to the ID of this field; is expected to be found, representing the array content.; The field backing `std::bitmap<N>` is a single repetitive field.; (See Section ""Mapping of C++ Types to Fields and Columns""). If `flag==0x02` (_projected field_) is set,; the field has been created as a virtual field from another, non-projected source field.; If a projected field has attached columns,; these columns are alias columns to physical columns attached to the source field.; The following restrictions apply on field projections:; - The source field and the target field must have the same structural role,; except for an `RNTupleCardinality` field, which must have a collection field as a source.; - For streamer fields and leaf fields, the type name of the source field and ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:15904,checksum,checksum,15904,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['checksum'],['checksum']
Security,"iendDecl(hasType(""X"")); and public virtual X (matcher = cxxBaseSpecifier(hasType(; asString(""class X""))); class X {};; void y(X &x) { x; X z; }; typedef int U;; class Y { friend class X; };; class Z : public virtual X {};. Matcher<CXXConstructExpr>forEachArgumentWithParamMatcher<Expr> ArgMatcher, Matcher<ParmVarDecl> ParamMatcher; Matches all arguments and their respective ParmVarDecl. Given; void f(int i);; int y;; f(y);; callExpr(; forEachArgumentWithParam(; declRefExpr(to(varDecl(hasName(""y"")))),; parmVarDecl(hasType(isInteger())); )); matches f(y);; with declRefExpr(...); matching int y; and parmVarDecl(...); matching int i. Matcher<CXXConstructExpr>forEachArgumentWithParamTypeMatcher<Expr> ArgMatcher, Matcher<QualType> ParamMatcher; Matches all arguments and their respective types for a CallExpr or; CXXConstructExpr. It is very similar to forEachArgumentWithParam but; it works on calls through function pointers as well. The difference is, that function pointers do not provide access to a; ParmVarDecl, but only the QualType for each argument. Given; void f(int i);; int y;; f(y);; void (*f_ptr)(int) = f;; f_ptr(y);; callExpr(; forEachArgumentWithParamType(; declRefExpr(to(varDecl(hasName(""y"")))),; qualType(isInteger()).bind(""type); )); matches f(y) and f_ptr(y); with declRefExpr(...); matching int y; and qualType(...); matching int. Matcher<CXXConstructExpr>hasAnyArgumentMatcher<Expr> InnerMatcher; Matches any argument of a call expression or a constructor call; expression, or an ObjC-message-send expression. Given; void x(int, int, int) { int y; x(1, y, 42); }; callExpr(hasAnyArgument(declRefExpr())); matches x(1, y, 42); with hasAnyArgument(...); matching y. For ObjectiveC, given; @interface I - (void) f:(int) y; @end; void foo(I *i) { [i f:12]; }; objcMessageExpr(hasAnyArgument(integerLiteral(equals(12)))); matches [i f:12]. Matcher<CXXConstructExpr>hasArgumentunsigned N, Matcher<Expr> InnerMatcher; Matches the n'th argument of a call expression or a construct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:147903,access,access,147903,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['access'],['access']
Security,"iers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or more member fields or functions. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */; public:; foo() {}. private:; protected:; };. * ``ELBAMS_Always`` (in configuration: ``Always``); Always add empty line before access modifiers unless access modifier; is at the start of struct or class definition. .. code-block:: c++. struct foo {; private:; int i;. protected:; int j;; /* comment */. public:; foo() {}. private:. protected:; };. .. _ExperimentalAutoDetectBinPacking:. **ExperimentalAutoDetectBinPacking** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <ExperimentalAutoDetectBinPacking>`; If ``true``, clang-format detects whether function calls and; definitions are formatted with one parameter per line. Each call can be bin-packed, one-per-line or inconclusive. If it is; inconclusive, e.g. completely on one line, but a decision needs to be; made",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:62273,access,access,62273,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83933,access,access,83933,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['access'],['access']
Security,"if(NOT asan OR MSVC); return(); endif(). # Make a shared library that holds the ROOT default config for address sanitizer.; # This is can be used with LD_PRELOAD; add_library(ROOTSanitizerConfig SHARED SanitizerSetup.cxx). # Make a static library that holds the ROOT default config for address sanitizer.; # We link this into all executables in ROOT, so they automatically start up with good defaults.; set(library ROOTStaticSanitizerConfig); add_library(${library} STATIC SanitizerSetup.cxx); set_property(TARGET ${library} PROPERTY POSITION_INDEPENDENT_CODE ON). # This pulls in the sanitizer link flags when linking against the config library; target_link_libraries(${library} INTERFACE ${ASAN_EXTRA_EXE_LINKER_FLAGS}). # Make it visible to the outside to sanitize e.g. roottest executables; set_property(GLOBAL APPEND PROPERTY ROOT_EXPORTED_TARGETS ${library}); add_library(ROOT::${library} ALIAS ${library}). # Now sanitize executables that are not created with ROOT_EXECUTABLE():; foreach(target llvm-min-tblgen llvm-tblgen clang-tblgen); target_link_libraries(${target} PRIVATE ${library}); endforeach(); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/CMakeLists.txt:112,sanitiz,sanitizer,112,core/sanitizer/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/CMakeLists.txt,5,['sanitiz'],"['sanitize', 'sanitizer']"
Security,"ifferent consequences; depending on whether; you try to build a binary, or you just try to access a class that is; defined in a library. #### Linktime Library Dependencies. When building your own executable you will have to link against the; libraries that contain the classes you use. The ROOT reference guide; states the library a class is reference guide defined in. Almost all; relevant classes can be found in libraries returned by; `root-config -glibs`; the graphics libraries are retuned by; `root-config --libs`. These commands are commonly used in `Makefiles`.; Using `root-config` instead of enumerating the libraries by hand; allows you to link them in a platform independent way. Also, if ROOT; library names change you will not need to change your Makefile. A batch program that does not have a graphic display, which creates,; fills, and saves histograms and trees, only needs to link the core; libraries (`libCore`, `libRIO`), `libHist` and `libTree`.; If ROOT needs access to other libraries, it loads them dynamically.; For example, if the **`TreeViewer`** is used, `libTreePlayer` and all; libraries `libTreePlayer` depends on are loaded also. The dependent; libraries are shown in the ROOT reference guide's library dependency; graph. The difference between reference guide `libHist` and; `libHistPainter` is that the former needs to be explicitly linked and; the latter will be loaded automatically at runtime when ROOT needs it,; by means of the Plugin Manager. plugin manager. In the Figure 1-2, the libraries represented by green boxes outside of; the core are loaded via the plugin manager plugin manager or; equivalent techniques, while the white ones are not. Of course, if one; wants to access a plugin library directly, it has to be explicitly; linked. An example of a plugin library is `libMinuit`. To create and; fill histograms you need to link `libHist.so`. If the code has a call; to fit the histogram, the ""fitter"" will dynamically load libMinuit if; it is not yet lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:17893,access,access,17893,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['access'],['access']
Security,"ig. Display the address-significance table. .. option:: --arch-specific, -A. Display architecture-specific information, e.g. the ARM attributes section on ARM. .. option:: --bb-addr-map. Display the contents of the basic block address map section(s), which contain the; address of each function, along with the relative offset of each basic block. .. option:: --decompress, -z. Dump decompressed section content when used with ``-x`` or ``-p``.; If the section(s) are not compressed, they are displayed as is. .. option:: --demangle, -C. Display demangled symbol names in the output. .. option:: --dependent-libraries. Display the dependent libraries section. .. option:: --dyn-relocations. Display the dynamic relocation entries. .. option:: --dyn-symbols, --dyn-syms. Display the dynamic symbol table. .. option:: --dynamic-table, --dynamic, -d. Display the dynamic table. .. option:: --cg-profile. Display the callgraph profile section. .. option:: --histogram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output is an expanded and structured format.; ``GNU`` (the default) output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --extra-sym-info. Display extra information (section name) when showing symbols. .. option:: --section-groups, -g. Display section groups. .. option:: --expand-relocs. When used with :option:`--relocations`, display each relocation in an expanded; multi-line format. .. option:: --file-header, -h. Display file headers. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dyn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst:1625,hash,hash,1625,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,1,['hash'],['hash']
Security,"ight License. Overview; --------. CivetWeb keeps the balance between functionality and; simplicity by a carefully selected list of features:. - Liberal, commercial-friendly, permissive,; [MIT license](http://en.wikipedia.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md).; - Works on Windows, Mac, Linux, UNIX, iPhone, Android, Buildroot, and many; other platforms.; - Scripting and database support (CGI, SQLite database, Lua Server Pages,; Server side Lua scripts, Server side JavaScript).; This provides a ready to go, powerful web development platform in a one; single-click executable with **no dependencies**.0; - Support for CGI, SSI, HTTP digest (MD5) authorization, WebSocket,; WebDAV.; - HTTPS (SSL/TLS) support using [OpenSSL](https://www.openssl.org/).; - Optional support for authentication using client side X.509 certificates.; - Resumed download, URL rewrite, file blacklist, IP-based ACL.; - May run as Windows service.; - Download speed limit based on client subnet or URI pattern.; - Simple and clean embedding API.; - The source is in single file to make things easy.; - Embedding examples included.; - HTTP client capable of sending arbitrary HTTP/HTTPS requests.; - Websocket client functionality available (WS/WSS). ### Optionally included software. [![Lua](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/lua-logo.jpg ""Lua Logo"")](http://lua.org). [![Sqlite3](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/sqlite3-logo.jpg ""Sqlite3 Logo"")](http://sqlite.org). [![LuaFileSystem](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/luafilesystem-logo.jpg ""LuaFileSystem Lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:6140,authoriz,authorization,6140,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['authoriz'],['authorization']
Security,"ignature should include name; Yes. 358; NAD; Namespaces and extern ""C""; Yes. 359; NAD; Type definition in anonymous union; Yes. 360; CD6; Using-declaration that reduces access; Yes. 361; open; Forward reference to default argument; Not resolved. 362; CD1; Order of initialization in instantiation units; N/A. 363; NAD; Initialization of class from self; N/A. 364; CD1; Calling overloaded function with static in set, with no object; Yes. 365; open; Storage duration and temporaries; Not resolved. 366; CD1; String literal allowed in integral constant expression?; Yes. 367; CD1; throw operator allowed in constant expression?; Yes. 368; CD1; Uses of non-type parameters that should cause deduction to fail; Clang 3.6. 369; drafting; Are new/delete identifiers or preprocessing-op-or-punc?; Not resolved. 370; CD1; Can #include <...> form be used other than for standard C++ headers?; N/A. 371; open; Interleaving of constructor calls; Not resolved. 372; CD1; Is access granted by base class specifiers available in following base class specifiers?; No. 373; C++11; Lookup on namespace qualified name in using-directive; Clang 5. 374; CD2; Can explicit specialization outside namespace use qualified name?; Clang 7. 375; dup; Confusing example on lookup with typename; Duplicate of 345. 376; NAD; Class ""definition"" versus class ""declaration""; N/A. 377; CD1; Enum whose enumerators will not fit in any integral type; Yes. 378; CD1; Wording that says temporaries are declared; Duplicate of 276. 379; CD1; Change ""class declaration"" to ""class definition""; N/A. 380; open; Definition of ""ambiguous base class"" missing; Not resolved. 381; CD1; Incorrect example of base class member lookup; Yes. 382; CD1; Allow typename outside of templates; Yes (C++11 onwards). 383; CD1; Is a class with a declared but not defined destructor a POD?; Yes. 384; NAD; Argument-dependent lookup and operator functions; Yes. 385; CD1; How does protected member check of 11.5 interact with using-declarations?; Clang 2.8. 386",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:24836,access,access,24836,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"ike:. .. code-block:: text. callee: ^1[, hotness: None]?[, relbf: 0]?. The ``callee`` refers to the summary entry id of the callee. At most one; of ``hotness`` (which can take the values ``Unknown``, ``Cold``, ``None``,; ``Hot``, and ``Critical``), and ``relbf`` (which holds the integer; branch frequency relative to the entry frequency, scaled down by 2^8); may be specified. The defaults are ``Unknown`` and ``0``, respectively. .. _params_summary:. Params; ^^^^^^. The optional ``Params`` is used by ``StackSafety`` and looks like:. .. code-block:: text. Params: ((Param)[, (Param)]*). where each ``Param`` describes pointer parameter access inside of the; function and looks like:. .. code-block:: text. param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?. where the first ``param`` is the number of the parameter it describes,; ``offset`` is the inclusive range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. W",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:344660,access,accesses,344660,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security,"ikely that others will want to review a recently-posted patch,; especially if there might be objections, but no one else has done so yet, it is; also polite to provide a qualified approval (e.g., ""LGTM, but please wait for a; couple of days in case others wish to review""). If approval is received very; quickly, a patch author may also elect to wait before committing (and this is; certainly considered polite for non-trivial patches). Especially given the; global nature of our community, this waiting time should be at least 24 hours.; Please also be mindful of weekends and major holidays. Our goal is to ensure community consensus around design decisions and; significant implementation choices, and one responsibility of a reviewer, when; providing an overall approval for a patch, is to be reasonably sure that such; consensus exists. If you're not familiar enough with the community to know,; then you shouldn't be providing final approval to commit. A reviewer providing; final approval should have commit access to the LLVM project. Every patch should be reviewed by at least one technical expert in the areas of; the project affected by the change. Splitting Requests and Conditional Acceptance; ---------------------------------------------. Reviewers may request certain aspects of a patch to be broken out into separate; patches for independent review. Reviewers may also accept a patch; conditioned on the author providing a follow-up patch addressing some; particular issue or concern (although no committed patch should leave the; project in a broken state). Moreover, reviewers can accept a patch conditioned on; the author applying some set of minor updates prior to committing, and when; applicable, it is polite for reviewers to do so. Don't Unintentionally Block a Review; ------------------------------------. If you review a patch, but don't intend for the review process to block on your; approval, please state that explicitly. Out of courtesy, we generally wait on; committ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:8624,access,access,8624,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['access'],['access']
Security,"ilable :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:1646,sanitiz,sanitize,1646,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitize']
Security,ile.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBlock`` (in configuration: ``LogicalBlock``); Add empty line only when access modifier starts a new logical block.; Logical block is a group of one or ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61376,access,access,61376,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"ile::GetFileBytesRead() / TFile::GetFileReadCalls() during the last; unit of time; this allows to monitor the usage of the cache; this plot; is present only if some I/O is done, i.e. not for pure CPU tasks.; The number of active workers; The number of total and effecive sessions running; concurrently on the cluster (started by the same daemon); this plot is; present only is the number is at least onec different from 1. If enabled, send monitoring information from the master; at each GetNextPacket (at each call of TPerfStat::PacketEvent) to allow; extrnal real-time progress monitoring.; Save the status of a 'proofserv' session into a new file; in the 'activesessions' area. The full path of the new file is;          ; <admin_path>/.xproofd.<port>/activesessions/<user>.<group>.<pid>.status. The status indicates whether the session is idle, running or queued.; The status is updated every 'checkfq' secs (see xpd.proofservmgr;; default 30 s). The status is dumped by the reader thread of TXProofServ; and therefore its r/w access is protected. Enable the use of the tree cache also for local files,; adapting the default settings for the cache to the recent changes; In the XrdProofd plug-in. Improve synchronization between parent and child during; fork; Optimize loops over directory entries; Improve error and notification messages. Improved handling of Ctrl-C; this follows from a fix in; TMonitor and an improved handling of non-finished query state in the; workers (results are not send to master if the query was aborted) . Fixes. TFileMerger. Fix a problem preventing correct transmission of all; non-mergeable objects (fixes bug #52886); Remove the argument isdir from the function; MergeRecursive; Do not remove the first file in the list when returning; from MergeRecursive (fixes bug #54591); Fix a major leak when merging files with collections; written using kSingleKey option.  The merger was reading each; key in memory and deleted the object at the end, but the container is; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html:5966,access,access,5966,proof/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v526/index.html,2,['access'],['access']
Security,"ile=A=prebuilt/A.pcm; clang -cc1 -emit-obj use.c -fmodules -fmodule-map-file=module.modulemap -fmodule-file=A=prebuilt/A.pcm -fmodule-file=B=prebuilt/B.pcm. Instead of of specifying the mappings manually, it can be convenient to use the ``-fprebuilt-module-path`` option. Let's also use ``-fimplicit-module-maps`` instead of manually pointing to our module map. .. code-block:: sh. rm -rf prebuilt; mkdir prebuilt; clang -cc1 -emit-module -o prebuilt/A.pcm -fmodules module.modulemap -fmodule-name=A; clang -cc1 -emit-module -o prebuilt/B.pcm -fmodules module.modulemap -fmodule-name=B -fprebuilt-module-path=prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt. A trick to prebuild all modules required for our source file in one command is to generate implicit modules while using the ``-fdisable-module-hash`` option. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; ls prebuilt/*.pcm; # prebuilt/A.pcm prebuilt/B.pcm. Note that with explicit or prebuilt modules, we are responsible for, and should be particularly careful about the compatibility of our modules.; Using mismatching compilation options and modules may lead to issues. .. code-block:: sh. clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fprebuilt-module-path=prebuilt -DENABLE_A; # use.c:4:10: warning: implicit declaration of function 'a' is invalid in C99 [-Wimplicit-function-declaration]; # return a(x);; # ^; # 1 warning generated. So we need to maintain multiple versions of prebuilt modules. We can do so using a manual module mapping, or pointing to a different prebuilt module cache path. For example:. .. code-block:: sh. rm -rf prebuilt ; mkdir prebuilt ; rm -rf prebuilt_a ; mkdir prebuilt_a; clang -cc1 -emit-obj use.c -fmodules -fimplicit-module-maps -fmodules-cache-path=prebuilt -fdisable-module-hash; clang -cc1 -emit-obj use.c -fmodul",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:20885,hash,hash,20885,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['hash'],['hash']
Security,"iled.; Linkage relationships between ``JITDylibs`` determine how inter-module; references are resolved, and symbol resolvers are no longer used. See the; section `Design Overview`_ for more details. Unless multiple JITDylibs are needed to model linkage relationships, ORCv1; clients should place all code in a single JITDylib.; MCJIT clients should use LLJIT (see `LLJIT and LLLazyJIT`_), and can place; code in LLJIT's default created main JITDylib (See; ``LLJIT::getMainJITDylib()``). 2. All JIT stacks now need an ``ExecutionSession`` instance. ExecutionSession; manages the string pool, error reporting, synchronization, and symbol; lookup. 3. ORCv2 uses uniqued strings (``SymbolStringPtr`` instances) rather than; string values in order to reduce memory overhead and improve lookup; performance. See the subsection `How to manage symbol strings`_. 4. IR layers require ThreadSafeModule instances, rather than; std::unique_ptr<Module>s. ThreadSafeModule is a wrapper that ensures that; Modules that use the same LLVMContext are not accessed concurrently.; See `How to use ThreadSafeModule and ThreadSafeContext`_. 5. Symbol lookup is no longer handled by layers. Instead, there is a; ``lookup`` method on JITDylib that takes a list of JITDylibs to scan. .. code-block:: c++. ExecutionSession ES;; JITDylib &JD1 = ...;; JITDylib &JD2 = ...;. auto Sym = ES.lookup({&JD1, &JD2}, ES.intern(""_main""));. 6. The removeModule/removeObject methods are replaced by; ``ResourceTracker::remove``.; See the subsection `How to remove code`_. For code examples and suggestions of how to use the ORCv2 APIs, please see; the section `How-tos`_. How-tos; =======. How to manage symbol strings; ----------------------------. Symbol strings in ORC are uniqued to improve lookup performance, reduce memory; overhead, and allow symbol names to function as efficient keys. To get the; unique ``SymbolStringPtr`` for a string value, call the; ``ExecutionSession::intern`` method:. .. code-block:: c++. ExecutionSession ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:21360,access,accessed,21360,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['access'],['accessed']
Security,"iler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{dim's 0's, index}``. '``llvm.preserve.union.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <type>; @llvm.preserve.union.access.index.p0s_union.anons.p0s_union.anons(<type> base,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic carries the debuginfo field index; ``di_index`` and returns the ``base`` address.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide union debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``type`` is the same as the ``base`` type. Arguments:; """""""""""""""""""". The ``base`` is the union base address. The ``di_index`` is the field index in debuginfo. Semantics:; """""""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic returns the ``base`` address. '``llvm.preserve.struct.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.struct.access.index.p0i8.p0s_struct.anon.0s(<type> base,; i32 gep_index,; i32 di_index). Overview:; """""""""""""""""". The '``llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:974129,access,access,974129,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"iles, A and B. These are; equal in every way and support the same instructions for the same cost. They're; just physically stored apart and each instruction can only access registers from; A or B but never a mix of the two. If we want to perform an operation on data; that's in split between the two register files, we must first copy all the data; into a single register file. Given a processor like this, we would benefit from clustering related data; together into one register file so that we minimize the cost of copying data; back and forth to satisfy the (possibly conflicting) requirements of all the; instructions. Register Banks are a means to constrain the register allocator to; use a particular register file for a virtual register. In practice, register files A and B are rarely equal. They can typically store; the same data but there's usually some restrictions on what operations you can; do on each register file. A fairly common pattern is for one of them to be; accessible to integer operations and the other accessible to floating point; operations. To accommodate this, let's rename A and B to GPR (general purpose; registers) and FPR (floating point registers). We now have some additional constraints that limit us. An operation like G_FMUL; has to happen in FPR and G_ADD has to happen in GPR. However, even though this; prescribes a lot of the assignments we still have some freedom. A G_LOAD can; happen in both GPR and FPR, and which we want depends on who is going to consume; the loaded data. Similarly, G_FNEG can happen in both GPR and FPR. If we assign; it to FPR, then we'll use floating point negation. However, if we assign it to; GPR then we can equivalently G_XOR the sign bit with 1 to invert it. In summary, Register Banks are a means of disambiguating between seemingly; equivalent choices based on some analysis of the differences when each choice; is applied in a given context. To give some concrete examples:. AArch64. AArch64 has three main banks. GPR for",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst:4565,access,accessible,4565,interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/GMIR.rst,2,['access'],['accessible']
Security,"ility. The following; function is defined in core/zip/inc/Bits.h and it set the global; variable. R__SetZipMode(int algorithm);. If the algorithm is set to kUseGlobalSetting (0), the global variable; controls the algorithm for compression operations. This is the; default and the default value for the global variable is kZLIB. gDirectory; gDirectory is now a thread local!. The value of gDirectory and gFile are now all accessed via a static function of their respective class. The access is made transparent via a CPP macro. Note: Whenever a thread has an associated TThread object, the value of gDirectory is now thread local, i.e. all modifications direct or indirect of gDirectory will not be seen by the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support sharing TFile amongst threads (i.e. a TFile must be accessed from exactly one thread). This means that whenever a TFile's control is passed from a thread to another, the code must explicitly reset gDirectory to another value or there is a risk for this gDirectory to point to a stale pointer if the other thread deletes the TFile object. A TFile deletion will only affect the value of the local gDirectory and gFile. TMemFile; Introduce TMemFile and update TFileMerger to support incremental merges. Add new tutorials (net/treeClient.C + net/fastMergeServer.C); demonstrating how a TMemFile can be used to do parallel merge; from many clients. (TMemFile still needs to be better integrated; with TMessage and TSocket). The new TMemFile class support the TFile interface but only store; the information in memory. This version is limited to 32MB. TMessage mess;; ...; mess->ReadFastArray(scratch,length);; transient = new TMemFile(""hsimple.memroot"",scratch,length);. will copy the content of 'scratch' into the in-memory buffer; created by/for the TMemFile. TMem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:3576,access,accessed,3576,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,2,['access'],['accessed']
Security,"imator for the compressed cluster size uses the average compression factor; of the so far written clusters.; This has been choosen as a simple, yet expectedly accurate enough estimator (to be validated).; The following alternative strategies were discussed:. - The average compression factor of all so-far written pages.; Easy to implement.; It would better prevent outlier clusters from skewing the estimate of the successor clusters.; It would be slower though in adjusting to systematic changes in the data set,; e.g. ones that are caused by changing experimental conditions during data taking. - The average over a window of the last $k$ clusters, possibly with exponential smoothing.; More code compared to the average compression factor or all so-far written clusters.; It would be faster in adjusting to systematic changes in the data set,; e.g. ones that are caused by changing experimental conditions during data taking.; Could be a viable option if cluster compression ratios turn out to change significantly in a single file. - Calculate the cluster compression ratio from column-based individual estimators.; More complex to implement and to recalculate the estimator on every fill,; requires additional state for every column.; One might reduce the additional state and complexity by only applying the fine-grained estimator for collections.; Such an estimator would react better to a sudden change in the amount of data written for collections / columns; that have substentially different compression ratios. Page Checksums; --------------. By default, RNTuple appends xxhash-3 64bit checksums to every compressed page.; Typically, checksums increase the data size in the region of a per mille.; As a side effect, page checksums allow for efficient ""same page merging"":; identical pages in the same cluster will be written only once.; On typical datasets, same page merging saves a few percent.; Conversely, turning off page checksums also disables the same page merging optimization.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md:4807,checksum,checksums,4807,tree/ntuple/v7/doc/tuning.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md,4,['checksum'],['checksums']
Security,"ime consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if you can't agree, generally the best way is to do what the reviewer; asks; we optimize for readability of the code, which the reviewer is; in a better position to judge; if this feels like it's not the right; option, you can contact the cfe-dev mailing list to get more feedback; on the direction;. Commit access; =============. Once you've contributed a handful of patches to LLVM, start to think; about getting commit access yourself. It's probably a good idea if:. - you've landed 3-5 patches of larger scope than ""fix a typo"". - you'd be willing to review changes that are closely related to yours. - you'd like to keep contributing to LLVM. Getting commit access; ---------------------. LLVM uses Git for committing changes. The details are in the `developer; policy; document <https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access>`__. With great power; ----------------. Actually, this would be a great time to read the rest of the `developer; policy <https://llvm.org/docs/DeveloperPolicy.html>`__, too. At minimum,; you need to be subscribed to the relevant commits list before landing; changes (e.g. llvm-commits@lists.llvm.org), as discussion often happens; there if a new patch causes problems. Post-commit errors; ------------------. Once your change is submitted it will be picked up by automated build; bots that will build and test your patch in a variety of configurations. You can see all configurations and their current state in a waterfall; view at http://lab.llvm.org/buildbot/#/waterfall. The waterfall view is good; to get a general overview over the tested configurations and to see; which configuration have been broken for a while. The console view at http://lab.llvm.org/buildbot/#/console helps to get a; better understanding of the build results of a specific patch. If you; want to follow along",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:13191,access,access,13191,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['access'],['access']
Security,"imely notification and release to vendors who package and distribute LLVM-based toolchains and projects.; 5. Ensure timely notification to users of LLVM-based toolchains whose compiled code is security-sensitive, through the `CVE process`_.; 6. Strive to improve security over time, for example by adding additional testing, fuzzing, and hardening after fixing issues. *Note*: these goals ensure timely action, provide disclosure timing when issues are reported, and respect vendors' / packagers' / users' constraints. The LLVM Security Group is private. It is composed of trusted LLVM contributors. Its discussions remain within the Security Group (plus issue reporter and key experts) while an issue is being investigated. After an issue becomes public, the entirety of the group’s discussions pertaining to that issue also become public. .. _report-security-issue:. How to report a security issue?; ===============================. To report a security issue in the LLVM Project, please `open a new issue`_ in the LLVM project page, on the chromium issue tracker. Be sure to use the ""Security bug report"" template. We aim to acknowledge your report within two business days since you first reach out. If you do not receive any response by then, you can escalate by posting on the `Discourse forums`_ asking to get in touch with someone from the LLVM Security Group. **The escalation mailing list is public**: avoid discussing or mentioning the specific issue when posting on it. Group Composition; =================. Security Group Members; ----------------------. The members of the group represent a wide cross-section of the community, and; meet the criteria for inclusion below. The list is in the format; `* ${full_name} (${affiliation}) [${github_username}]`. If a github; username for an individual isn't available, the brackets will be empty. * Ahmed Bougacha (Apple) [@ahmedbougacha]; * Andy Kaylor (Intel) [@andykaylor]; * Artur Pilipenko (Azul Systems Inc) []; * Boovaragavan Dasarathan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:1428,secur,security,1428,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"imply click on the top name-button in object editor to; create a standalone editor for this object in a separate window. This; facilitates operation when several objects need to be modifed in; parallel.; New tutorial alice_vsd.C has been added. It shows; how to read Visualization Summary Data files (VSD).; Code for operating three view configuration (3D / RPhi / Rhoz); has been extracted from alice_esd.C tutorial; into MultiView.C tutorial. This is now also used; by alice_vsd.C and can serve as an example to those that; need to implement similar functionality. Screenshot of calorimeters.C tutorial. Note the; individual tower selection propagated accross all the views. Screenshot of alice_vsd.C tutorial also showing the; functionality of the MultiView class. New title is also; visible in the GUI editor. Minor changes. Object editors in Eve now show the title as button.; ; Left mouse opens a floating editor that can be positioned; anywhere on the screen. This allows a user to have commonly used; editors always accessible. Maximum number of floating editors is; limited to 10.; Right mouse opens context menu for the object. In TEveFrambox add support for drawing of back-polygons for 3D; frame-boxes. Those should be transparent, otherwise the things inside; are not visible.; TEveRGBAPalette - implement additional flag fFixColorRange specifying; how the palette color range gets mapped onto signal values:; true - LowLimit -> HighLimit; false - MinValue -> MaxValue.; Add signal emitting TEveRGBAPalette::MinMaxValChanged(). Ged; editor calls this after setting the min/max range. OpenGL; Major changes. Add support for stereo rendering. This requires quad buffer; support from OpenGL driver and hardware as well as shutter; glasses. See tutorial eve/geom_cms_stereo.C.; Support for rendering into frame-buffer objects (FBO).; Using FBOs, it is now possible to save bitmap image formats at; any resolution and even when the GL window is not on screen.; Add support for global scaling o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html:4304,access,accessible,4304,graf3d/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/doc/v526/index.html,2,['access'],['accessible']
Security,"in (); {; int *b = 0;; return *b;; }. We get a few type DIEs:. .. code-block:: none. 0x00000067: TAG_base_type [5]; AT_encoding( DW_ATE_signed ); AT_name( ""int"" ); AT_byte_size( 0x04 ). 0x0000006e: TAG_pointer_type [6]; AT_type( {0x00000067} ( int ) ); AT_byte_size( 0x08 ). The DW_TAG_pointer_type is not included because it does not have a ``DW_AT_name``. ""``.apple_namespaces``"" section should contain all ``DW_TAG_namespace`` DIEs.; If we run into a namespace that has no name this is an anonymous namespace, and; the name should be output as ""``(anonymous namespace)``"" (without the quotes).; Why? This matches the output of the ``abi::cxa_demangle()`` that is in the; standard C++ library that demangles mangled names. Language Extensions and File Format Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Objective-C Extensions; """""""""""""""""""""""""""""""""""""""""""". ""``.apple_objc``"" section should contain all ``DW_TAG_subprogram`` DIEs for an; Objective-C class. The name used in the hash table is the name of the; Objective-C class itself. If the Objective-C class has a category, then an; entry is made for both the class name without the category, and for the class; name with the category. So if we have a DIE at offset 0x1234 with a name of; method ""``-[NSString(my_additions) stringWithSpecialString:]``"", we would add; an entry for ""``NSString``"" that points to DIE 0x1234, and an entry for; ""``NSString(my_additions)``"" that points to 0x1234. This allows us to quickly; track down all Objective-C methods for an Objective-C class when doing; expressions. It is needed because of the dynamic nature of Objective-C where; anyone can add methods to a class. The DWARF for Objective-C methods is also; emitted differently from C++ classes where the methods are not usually; contained in the class definition, they are scattered about across one or more; compile units. Categories can also be defined in different shared libraries.; So we need to be able to quickly find all of the methods and clas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:80331,hash,hash,80331,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"in ATLAS). The following example code outlines the main; steps (you can run it on the result of the `tree1.C` macro):. ``` {.cpp}; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); ```. Access to arrays works the same way as access to single value tree; elements, where the size of the array is determined by the number of; values actually read from the file. For example:. ``` {.cpp}; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; ```. #### Writing a Tree. Writing a ROOT **`TTree`** in a Python session is a little convoluted,; if only because you will need a C++ class to make sure that data members; can be mapped, unless you are working with built-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the pointer to the address of the; object that is used for filling must be given to the **`TTree::Branch()`**; call, even though the formal argument is declared a '`void*'`. In the; case of ROOT objects, similar pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:29978,access,access,29978,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['access'],['access']
Security,"in real aspect.; - New graphics style ""BELLE2"" from Martin Ritter. ## 3D Graphics Libraries. ## Geometry Libraries. ### Geometry drawing in web browser. When ROOT compiled with -Droot7=ON flag, one can enable geometry drawing in web browser.; Just apply --web option when starting root like: `root --web tutorials/geom/rootgeom.C`; Not all features of TGeoPainter are supported - only plain drawing of selected TGeoVolume. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:7641,sanitiz,sanitizer,7641,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,2,['sanitiz'],['sanitizer']
Security,"in the `ABI list`_. If you'd like to have instrumented libc++ functions, then you need to build it; with DFSan instrumentation from source. Here is an example of how to build; libc++ and the libc++ ABI with data flow sanitizer instrumentation. .. code-block:: console. mkdir libcxx-build; cd libcxx-build. # An example using ninja; cmake -GNinja -S <monorepo-root>/runtimes \; -DCMAKE_C_COMPILER=clang \; -DCMAKE_CXX_COMPILER=clang++ \; -DLLVM_USE_SANITIZER=""DataFlow"" \; -DLLVM_ENABLE_RUNTIMES=""libcxx;libcxxabi"". ninja cxx cxxabi. Note: Ensure you are building with a sufficiently new version of Clang. Usage; =====. With no program changes, applying DataFlowSanitizer to a program; will not alter its behavior. To use DataFlowSanitizer, the program; uses API functions to apply tags to data to cause it to be tracked, and to; check the tag of a specific data item. DataFlowSanitizer manages; the propagation of tags through the program according to its data flow. The APIs are defined in the header file ``sanitizer/dfsan_interface.h``.; For further information about each function, please refer to the header; file. .. _ABI list:. ABI List; --------. DataFlowSanitizer uses a list of functions known as an ABI list to decide; whether a call to a specific function should use the operating system's native; ABI or whether it should use a variant of this ABI that also propagates labels; through function parameters and return values. The ABI list file also controls; how labels are propagated in the former case. DataFlowSanitizer comes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`Sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:1682,sanitiz,sanitizer,1682,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['sanitiz'],['sanitizer']
Security,"in the aforementioned hash streams. - **HashValueBufferOffset / HashValueBufferLength** - The offset and size within; the TPI Hash Stream of the list of hash values. It should be assumed that; there are either 0 hash values, or a number equal to the number of type; records in the TPI stream (``TypeIndexEnd - TypeEndBegin``). Thus, if; ``HashBufferLength`` is not equal to ``(TypeIndexEnd - TypeEndBegin) *; HashKeySize`` we can consider the PDB malformed. - **IndexOffsetBufferOffset / IndexOffsetBufferLength** - The offset and size; within the TPI Hash Stream of the Type Index Offsets Buffer. This is a list; of pairs of uint32_t's where the first value is a :ref:`Type Index; <type_indices>` and the second value is the offset in the type record data of; the type with this index. This can be used to do a binary search followed by; a linear search to get O(log n) lookup by type index. - **HashAdjBufferOffset / HashAdjBufferLength** - The offset and size within; the TPI hash stream of a serialized hash table whose keys are the hash values; in the hash value buffer and whose values are type indices. This appears to; be useful in incremental linking scenarios, so that if a type is modified an; entry can be created mapping the old hash value to the new type index so that; a PDB file consumer can always have the most up to date version of the type; without forcing the incremental linker to garbage collect and update; references that point to the old version to now point to the new version.; The layout of this hash table is described in :doc:`HashTable`. .. _tpi_records:. CodeView Type Record List; =========================; Following the header, there are ``TypeRecordBytes`` bytes of data that; represent a variable length array of :doc:`CodeView type records; <CodeViewTypes>`. The number of such records (e.g. the length of the array); can be determined by computing the value ``Header.TypeIndexEnd -; Header.TypeIndexBegin``. O(log(n)) access is provided by way of the Type Index",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst:10728,hash,hash,10728,interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/TpiStream.rst,4,['hash'],['hash']
Security,"in the operation name. The operation is equivalent to performing ``DW_OP_regx R``. 2. ``DW_OP_regx``. ``DW_OP_regx`` has a single unsigned LEB128 integer operand that represents; a target architecture register number R. If the current call frame is the top call frame, it pushes a location; description L that specifies one register location description SL on the; stack. SL specifies the register location storage that corresponds to R with; a bit offset of 0 for the current thread. If the current call frame is not the top call frame, call frame information; (see :ref:`amdgpu-dwarf-call-frame-information`) is used to determine the; location description that holds the register for the current call frame and; current program location of the current thread. The resulting location; description L is pushed. *Note that if call frame information is used, the resulting location; description may be register, memory, or undefined.*. *An implementation may evaluate the call frame information immediately, or; may defer evaluation until L is accessed by an operation. If evaluation is; deferred, R and the current context can be recorded in L. When accessed, the; recorded context is used to evaluate the call frame information, not the; current context of the access operation.*. *These operations obtain a register location. To fetch the contents of a; register, it is necessary to use* ``DW_OP_regval_type``\ *, use one of the*; ``DW_OP_breg*`` *register-based addressing operations, or use* ``DW_OP_deref*``; *on a register location description.*. .. _amdgpu-dwarf-implicit-location-description-operations:. A.2.5.4.4.5 Implicit Location Description Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces DWARF Version 5 section 2.6.1.1.4. Implicit location storage represents a piece or all of an object which has no; actual location in the program but whose contents are nonetheless known, either; as a constant or can be computed from other location",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:119636,access,accessed,119636,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessed']
Security,"in using more. Next lines show how to create a menu bar with; `File`**,**`Test` and `Help` menus:. ``` {.cpp}; // menu bar item layout hints; fMBItemLayout = new TGLayoutHints(kLHintsTop|kLHintsLeft,0,4,0,0);; fMBHelpLayout = new TGLayoutHints(kLHintsTop|kLHintsRight);. // menu bar; fMenuBar = new TGMenuBar(fMain,100,20,kHorizontalFrame);. // adding popup menus; fMenuBar->AddPopup(""&File"", fMenuFile, fMBItemLayout);; fMenuBar->AddPopup(""&Test"", fMenuTest, fMBItemLayout);; fMenuBar->AddPopup(""&Help"", fMenuHelp, fMBHelpLayout);; ```. Using the method `TGMenuBar::AddPopup` we add three **`TGPopupMenu`**; objects to the menu bar `fMenuBar`. The first parameter is a hot string; used by **`TGMenuTitle`** object. When you add a popup menu to the menu; bar, a **`TGMenuTitle`** object is created by the menu bar. It is the; name of the popup menu. A menu title should have a one-word name that; reflects the purpose of all items within the corresponding popup menu.; It should also have a defined character as its unique access key. The; second parameter is the popup menu we would like to add. The third one; is an object of **`TGLayoutHints`** type that defines how the menu title; will be laid out in the menu bar. In our example the *`File`* and `Test`; menus will be laid out to the left of the menu bar with 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All rela",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:72470,access,access,72470,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security,"in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77430,sanitiz,sanitizer,77430,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['sanitiz'],"['sanitize-trap', 'sanitizer']"
Security,"information:. A.6.2 Line Number Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. A.6.2.4 The Line Number Program Header; ++++++++++++++++++++++++++++++++++++++. A.6.2.4.1 Standard Content Descriptions; #######################################. .. note::. This augments DWARF Version 5 section 6.2.4.1. .. _amdgpu-dwarf-line-number-information-dw-lnct-llvm-source:. 1. ``DW_LNCT_LLVM_source``. The component is a null-terminated UTF-8 source text string with ""\ ``\n``\; "" line endings. This content code is paired with the same forms as; ``DW_LNCT_path``. It can be used for file name entries. The value is an empty null-terminated string if no source is available. If; the source is available but is an empty file then the value is a; null-terminated single ""\ ``\n``\ "". *When the source field is present, consumers can use the embedded source; instead of attempting to discover the source on disk using the file path; provided by the* ``DW_LNCT_path`` *field. When the source field is absent,; consumers can access the file to get the source text.*. *This is particularly useful for programming languages that support runtime; compilation and runtime generation of source text. In these cases, the; source text does not reside in any permanent file. For example, the OpenCL; language [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`] supports online compilation.*. 2. ``DW_LNCT_LLVM_is_MD5``. ``DW_LNCT_LLVM_is_MD5`` indicates if the ``DW_LNCT_MD5`` content kind, if; present, is valid: when 0 it is not valid and when 1 it is valid. If; ``DW_LNCT_LLVM_is_MD5`` content kind is not present, and ``DW_LNCT_MD5``; content kind is present, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM_udata`` form. *This allows a compilation unit to have a mixture of files with and without; MD5 checksums. This can happen when multiple relocatable files are linked; together.*. .. _amdgpu-dwarf-call-frame-information:. A.6.4 Call Frame Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. not",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:188995,access,access,188995,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security,"ing Apple 4.0, LLVM 3.1]`; :revision:`These exceptions have been greatly expanded; they previously applied; only to a much-reduced subset which is difficult to categorize but which; included null pointers, message sends (under the given rules), and the various; global constants.`. An unbridged conversion to a retainable object pointer type from a type other; than a retainable object pointer type is ill-formed, as discussed above, unless; the operand of the cast has a syntactic form which is known retained, known; unretained, or known retain-agnostic. An expression is :arc-term:`known retain-agnostic` if it is:. * an Objective-C string literal,; * a load from a ``const`` system global variable of :ref:`C retainable pointer; type <arc.misc.c-retainable>`, or; * a null pointer constant. An expression is :arc-term:`known unretained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a direct call to a function, and either that function has the; ``cf_returns_not_retained`` attribute or it is an :ref:`audited; <arc.misc.c-retainable.audit>` function that does not have the; ``cf_returns_retained`` attribute and does not follow the create/copy naming; convention,; * a message send, and the declared method either has the; ``cf_returns_not_retained`` attribute or it has neither the; ``cf_returns_retained`` attribute nor a :ref:`selector family; <arc.method-families>` that implies a retained result, or; * :when-revised:`[beginning LLVM 3.6]` :revision:`a load from a` ``const``; :revision:`non-system global variable.`. An expression is :arc-term:`known retained` if it is an rvalue of :ref:`C; retainable pointer type <arc.misc.c-retainable>` and it is:. * a message send, and the declared method either has the; ``cf_returns_retained`` attribute, or it does not have the; ``cf_returns_not_retained`` attribute but it does have a :ref:`selector; family <arc.method-families>` that implies a retained result. Furthermore:. * a comma expression ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:26530,audit,audited,26530,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['audit'],['audited']
Security,"ing ROOT Objects ##. ROOT offers the possibility to write instances of classes on; disk, into a *ROOT-file* (see the `TFile` class for more details).; One says that the object is made ""persistent"" by storing; it on disk. When reading the file back, the object is reconstructed; in memory. The requirement to be satisfied to perform I/O of instances; of a certain class is that the ROOT type system is aware of the layout; in memory of that class.; This topic is beyond the scope of this document: it is worth to mention; that I/O can be performed out of the box for the almost complete set; of ROOT classes. We can explore this functionality with histograms and two simple macros. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/write_to_file.C; ```. Not bad, eh ? Especially for a language that does not foresees; persistency natively like C++. The *RECREATE* option forces ROOT to; create a new file even if a file with the same name exists on disk. Now, you may use the Cling command line to access information in the file; and draw the previously written histogram:. ``` {.cpp}; > root my_rootfile.root; root [0]; Attaching file my_rootfile.root as _file0...; root [1] _file0->ls(); TFile** my_rootfile.root; TFile* my_rootfile.root; KEY: TH1F	my_histogram;1 My Title; root [2] my_histogram->Draw(); ```; \newpage; Alternatively, you can use a simple macro to carry out the job:. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/read_from_file.C; ```. ## N-tuples in ROOT ##. ### Storing simple N-tuples ###. Up to now we have seen how to manipulate input read from ASCII files.; ROOT offers the possibility to do much better than that, with its own; n-tuple classes. Among the many advantages provided by these classes one; could cite. - Optimised disk I/O. - Possibility to store many n-tuple rows. - Write the n-tuples in ROOT files. - Interactive inspection with `TBrowser`. - Store not only numbers, but also *objects* in the columns. In this section we will discuss briefly the `TNtuple` class, which is a; simpl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:1028,access,access,1028,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['access'],['access']
Security,"ing and objects drawing, one can provide number of URL parameters in address string like:. - file - name of the file, which will be automatically open with page loading; - files - array of file names for loading; - json - name of JSON file with stored ROOT object like histogram or canvas; - item - item name to be displayed; - opt - drawing option for the item; - items - array of items name to be displayed; - opts - array of drawing options for the items; - expand - item name(s) to be expanded in the hierarchy browser; - focus - item name to be focused on in the hierarchy browser; - title - set browser title; - dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; - layout - can be 'simple', 'flex', 'tabs', 'gridNxM', 'horizNMK', 'vertNMK'; - browser - layout of the browser 'fix' (default), 'float', 'no' (hidden), 'off' (fully disabled); - nobrowser - do not display file browser (same as browser=no); - float - display floating browser (same as browser=float); - status - configure status line 'no' (default), 'off' (completely disable), 'size'; - inject - name of extra JavaScript to load, see several examples in demo/ subdir; - optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; - palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); - interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; - noselect - hide file-selection part in the browser (only when file name is specified); - mathjax - use MathJax for latex output; - latex - 'off', 'symbols', 'normal', 'mathjax', 'alwaysmath' control of TLatex processor; - style - name of TStyle object to define global JSROOT style; - toolbar - show canvas tool buttons 'off', 'on' and 'popup', 'left' or 'right' for position, 'vert' for vertical; - divsize - fixed size in pixels for main div element like &dvisize=1500x800; - canvsize - default canvas size in pixels like &canvsize=1200x800; - optstat - ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:2099,inject,inject,2099,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['inject'],['inject']
Security,"ing and; end element regions for it. In my view this differs from ghost variables in that (1) this storage does; actually exist (it is just a library implementation detail where that storage; lives) and (2) it is perfectly valid for a pointer into that storage to be; returned and for another part of the program to read or write from that storage.; (Well, in this case just read since it is allowed to be read-only memory). What I'm not OK with is modeling abstract analysis state (for example, the count; of a NSMutableArray or the typestate of a file handle) as a value stored in some; ginned up region in the store. This takes an easy problem that the analyzer does; well at (modeling typestate) and turns it into a hard one that the analyzer is; bad at (reasoning about the contents of the heap). I think the key criterion here is: ""is the region accessible from outside the; library"". That is, does the library expose the region as a pointer that can be; read to or written from in the client program? If so, then it makes sense for; this to be in the store: we are modeling reachable storage as storage. But if; we're just modeling arbitrary analysis facts that need to be invalidated when a; pointer escapes then we shouldn't try to gin up storage for them just to get; invalidation for free. **Artem:**. > In this case, I would be fine with some sort of ``AbstractStorageMemoryRegion``; > that meant ""here is a memory region and somewhere reachable from here exists; > another region of type T"". Or even multiple regions with different; > identifiers. This wouldn't specify how the memory is reachable, but it would; > allow for transfer functions to get at those regions and it would allow for; > invalidation. Yeah, this is what we can easily implement now as a; symbolic-region-based-on-a-metadata-symbol (though we can make a new region; class for that if we eg. want it typed). The problem is that the relation; between such storage region and its parent object region is essentially; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:9819,expose,expose,9819,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['expose'],['expose']
Security,"ing behavior is undefined. A variable may be defined as a global ``constant``, which indicates that; the contents of the variable will **never** be modified (enabling better; optimization, allowing the global data to be placed in the read-only; section of an executable, etc). Note that variables that need runtime; initialization cannot be marked ``constant`` as there is a store to the; variable. LLVM explicitly allows *declarations* of global variables to be marked; constant, even if the final definition of the global is not. This; capability can be used to enable slightly better optimization of the; program, but requires the language definition to guarantee that; optimizations based on the 'constantness' are valid for the translation; units that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32063,access,accessed,32063,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,ing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD3; Optional compile-time evaluation of constant expressions; Unknown. 1538; CD3; C-style cast in braced-init-list assignment; Unknown. 1539; CD3; Definition of “character type”; Unknown. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage of member of unnamed namespace; Unknown. 1545; NAD; friend function templates defined in class templates; Unknown. 1546; NAD; Errors in function ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:103052,access,access,103052,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"ing different; categories of editable objects](pictures/020001EB.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EC.jpg) ![Accessing/creating different; categories of editable objects](pictures/020001ED.jpg); ![Accessing/creating different categories of editable; objects](pictures/020001EE.jpg). The second use case applies when starting to edit an existing geometry.; Supposing the geometry was loaded into memory, besides the first method; that still applies one can also edit drawn geometry objects. For this,; the menu entry View/Editor of the canvas containing for instance a drawn; volume must be activated. For starting the volume editor one can click; on a volume. The GUI of the **`TGeoManager`** class can be started by; clicking on the top-right `40x40` pixels corner of the pad with a drawn; geometry. This is the main entry point for editing the geometry or creating new; objects. Once the interface is created (using one of the methods; described above), several categories can be accessed via a shutter GUI; widget:. - *General.* This allows changing the name/title of the geometry,; setting the top volume, closing the geometry and saving the geometry; in a file. The file name is formed by `geometry_name.C` or `.root`; depending if the geometry need to be saved as a `C` macro or a; `.root` file.; - *Shapes.* The category provides buttons for creation of all; supported shapes. The new shape name is chosen by the interface, but; can be changed from the shape editor GUI. Existing shapes can be; browsed and edited from the same category.; - *Volumes.* The category allows the creation of a new volume having a; given name, shape and medium. For creating a volume assembly only; the name is relevant. Existing volumes can be browsed or edited from; this category.; - *Materials.* Allows creation of new materials/mixtures or editing; existing ones.; - *Media.* The same for creation/editing of tracking media (materials; having a set of proper",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:167806,access,accessed,167806,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessed']
Security,"ing forward along the symbolic execution path, ExprEngine consults the mode; of the receiver's MemRegion to make decisions on whether the calls should be; inlined or not, which ensures that there is at most one split per region. At a high level, ""bifurcation mode"" allows for increased semantic coverage in; cases where the parent method contains code which is only executed when the; class is subclassed. The disadvantages of this mode are a (considerable?); performance hit and the possibility of false positives on the path where the; conservative mode is used. Objective-C Message Heuristics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ExprEngine relies on a set of heuristics to partition the set of Objective-C; method calls into those that require bifurcation and those that do not. Below; are the cases when the DynamicTypeInfo of the object is considered precise; (cannot be a subclass):. - If the object was created with +alloc or +new and initialized with an -init; method. - If the calls are property accesses using dot syntax. This is based on the; assumption that children rarely override properties, or do so in an; essentially compatible way. - If the class interface is declared inside the main source file. In this case; it is unlikely that it will be subclassed. - If the method is not declared outside of main source file, either by the; receiver's class or by any superclasses. C++ Caveats; ^^^^^^^^^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified as it is; being constructed or destructed; that is, the type of the object depends on; which base constructors have been completed. This is tracked using; DynamicTypeInfo in the DynamicTypePropagation checker. There are several limitations in the current implementation:. * Temporaries are poorly modeled right now because we're not confident in the; placement of their destructors in the CFG. We currently won't inline their; constructors unless the destructor is trivial, and don't process their; destructors at a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:15208,access,accesses,15208,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,1,['access'],['accesses']
Security,"ing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; **`TGeo`** is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. ![Ray-traced view in a pad](pictures/020001E4.jpg). ``` {.cpp}; myVolume->Raytrace(); ```. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corresponding volumes is still accessible. #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. `1. TGeoShape *clip1, *clip2, ...`. One might switch between several clipping shapes. Note that these shapes; are considered defined in the current `MARS`. Composite shapes may be; used. 2`. gGeoManager->SetClippingShape(clip1);`. One can activate or deactivate clip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:144160,validat,validation,144160,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['validat'],['validation']
Security,ing literals; Unknown. 1860; C++17; What is a “direct member?”; Unknown. 1861; CD4; Values of a bit-field; Unknown. 1862; CD5; Determining “corresponding members” for friendship; Unknown. 1863; CD4; Requirements on thrown object type to support std::current_exception(); Unknown. 1864; NAD; List-initialization of array objects; Unknown. 1865; CD4; Pointer arithmetic and multi-level qualification conversions; Unknown. 1866; CD4; Initializing variant members with non-trivial destructors; Unknown. 1867; NAD; Function/expression ambiguity with qualified parameter name; Unknown. 1868; drafting; Meaning of “placeholder type”; Not resolved. 1869; NAD; thread_local vs linkage-specifications; Unknown. 1870; CD4; Contradictory wording about definitions vs explicit specialization/instantiation; Unknown. 1871; NAD; Non-identifier characters in ud-suffix; Unknown. 1872; CD4; Instantiations of constexpr templates that cannot appear in constant expressions; Clang 9. 1873; CD4; Protected member access from derived class friends; Unknown. 1874; CD4; Type vs non-type template parameters with class keyword; Unknown. 1875; CD4; Reordering declarations in class scope; Unknown. 1876; NAD; Preventing explicit specialization; Unknown. 1877; CD4; Return type deduction from return with no operand; Unknown. 1878; CD4; operator auto template; Clang 18. 1879; NAD; Inadequate definition of alignment requirement; Unknown. 1880; CD4; When are parameter objects destroyed?; Unknown. 1881; CD4; Standard-layout classes and unnamed bit-fields; Clang 7. 1882; CD4; Reserved names without library use; Unknown. 1883; drafting; Protected access to constructors in mem-initializers; Not resolved. 1884; CD6; Unclear requirements for same-named external-linkage entities; Unknown. 1885; CD4; Return value of a function is underspecified; Unknown. 1886; CD4; Language linkage for main(); Unknown. 1887; CD4; Problems with :: as nested-name-specifier; Unknown. 1888; CD4; Implicitly-declared default constructors and ex,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:127246,access,access,127246,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"ing mode),; and only evaluated at runtime (and therefore in the runtime rounding mode) if; the compile-time evaluation fails. This is in line with the C rules;; C11 F.8.5 says: *All computation for automatic initialization is done (as if); at execution time; thus, it is affected by any operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <Co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:74846,sanitiz,sanitize,74846,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize']
Security,"ing pending queries from concurrently running JITLink instances that; have reached the next step and are waiting on the address of a symbol in; this graph to proceed with their link. #. Identify external symbols and resolve their addresses asynchronously. Calls the ``JITLinkContext`` to resolve the target address of any external; symbols in the graph. #. Phase 3. #. Apply external symbol resolution results. This updates the addresses of all external symbols. At this point all; nodes in the graph have their final target addresses, however node; content still points back to the original data in the object file. #. Run pre-fixup passes. These passes are called on the graph after all nodes have been assigned; their final target addresses, but before node content is copied into; working memory and fixed up. Passes run at this stage can make late; optimizations to the graph and content based on address layout. Notable use cases: GOT and PLT relaxation, where GOT and PLT accesses are; bypassed for fixup targets that are directly accessible under the assigned; memory layout. #. Copy block content to working memory and apply fixups. Copies all block content into allocated working memory (following the; target layout) and applies fixups. Graph blocks are updated to point at; the fixed up content. #. Run post-fixup passes. These passes are called on the graph after fixups have been applied and; blocks updated to point to the fixed up content. Post-fixup passes can inspect blocks contents to see the exact bytes that; will be copied to the assigned target addresses. #. Finalize memory asynchronously. Calls the ``JITLinkMemoryManager`` to copy working memory to the executor; process and apply the requested permissions. #. Phase 3. #. Notify the context that the graph has been emitted. Calls ``JITLinkContext::notifyFinalized`` and hands off the; ``JITLinkMemoryManager::FinalizedAlloc`` object for this graph's memory; allocation. This allows the context to track/hold memory allocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:21487,access,accesses,21487,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,2,['access'],"['accesses', 'accessible']"
Security,"ing"" algorithm and bases the; determination of the best node-split during the training; on a random subset of variables only, which is; individually chosen for each split.; ; BDT: Move to TRandom2 for the ""bagging"" algorithm; and throw random weights according to Poisson; statistics. (This way the random weights are closer to a; resampling with replacement algorithm.); ; TMlpANN: Extended options to; TMultilayerPerceptron learning methods. Added example for; reader application: TMVApplication.py; . GUI:. Parallel Coordinates: New GUI button for Parallel; Coordinate plotting.; . Application:. Added Python example for reader application: TMVApplication.py; . Bug fixes:. TMlpANN: fixed crash with ROOT>=5.17 when using; large number of test events; also corrected bias in cross; validation: before the test events were used, which led to; an overestimated performance evaluation in case of a small; number of degrees of freedom; separate now training tree; in two parts for training and validation with configurable; ValidationFraction; ; Cuts: Corrected inconsistency in MethodCuts:; the signal efficiency written out into the weight file does; not correspond to the center of the bin within which the; background rejection is maximised (as before) but to the; lower left edge of it. This is because the cut optimisation; algorithm determines the best background rejection for all; signal efficiencies belonging into a bin. Since the best; background rejection is in general obtained for the lowest; possible signal efficiency, the reference signal efficiency; is the lowest value in the bin.; ; Cuts: Fixed Cuts (optimisaton) method -> event; with smallest value was not included in search for optimal; cut (thanks to Dimitris Varouchas, LAL-Orsay, for helping; us detecting the problem).; ; Genetic Algorithm: Corrected configurable random; seed in GeneticAlgorithm (thanks to David Gonzalez Maline,; CERN, for pointing this out); ; GUI: Fixes in input-variable and MVA plotting:; under/over-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html:4511,validat,validation,4511,tmva/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/doc/v520/index.html,5,"['Validat', 'validat']","['ValidationFraction', 'validation']"
Security,"ing.h>; #include <unistd.h>. int main() {; // Initialize the hasher.; llvm_blake3_hasher hasher;; llvm_blake3_hasher_init(&hasher);. // Read input bytes from stdin.; unsigned char buf[65536];; while (1) {; ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));; if (n > 0) {; llvm_blake3_hasher_update(&hasher, buf, n);; } else if (n == 0) {; break; // end of file; } else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. LLVM_BLAKE3_OUT_LEN is the default output length, 32 bytes.; uint8_t output[LLVM_BLAKE3_OUT_LEN];; llvm_blake3_hasher_finalize(&hasher, output, LLVM_BLAKE3_OUT_LEN);. // Print the hash as hexadecimal.; for (size_t i = 0; i < LLVM_BLAKE3_OUT_LEN; i++) {; printf(""%02x"", output[i]);; }; printf(""\n"");; return 0;; }; ```. # API. ## The Class/Struct. ```c++; class BLAKE3 {; // API; private:; llvm_blake3_hasher Hasher;; };; ```; ```c; typedef struct {; // private fields; } llvm_blake3_hasher;; ```. An incremental BLAKE3 hashing state, which can accept any number of; updates. This implementation doesn't allocate any heap memory, but; `sizeof(llvm_blake3_hasher)` itself is relatively large, currently 1912 bytes; on x86-64. This size can be reduced by restricting the maximum input; length, as described in Section 5.4 of [the BLAKE3; spec](https://github.com/BLAKE3-team/BLAKE3-specs/blob/master/blake3.pdf),; but this implementation doesn't currently support that strategy. ## Common API Functions. ```c++; BLAKE3::BLAKE3();. void BLAKE3::init();; ```; ```c; void llvm_blake3_hasher_init(; llvm_blake3_hasher *self);; ```. Initialize a `llvm_blake3_hasher` in the default hashing mode. ---. ```c++; void BLAKE3::update(ArrayRef<uint8_t> Data);. void BLAKE3::update(StringRef Str);; ```; ```c; void llvm_blake3_hasher_update(; llvm_blake3_hasher *self,; const void *input,; size_t input_len);; ```. Add input to the hasher. This can be called any number of times. ---. ```c++; template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; using B",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:2038,hash,hashing,2038,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['hash'],['hashing']
Security,"ing; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3577,secur,security,3577,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['secur'],['security']
Security,"ing](pictures/pad_02.png). In some cases a pad need to be painted during a macro execution. To; force the pad painting `gPad->Update()` (see next section) should be performed. The list of primitives stored in the pad is also used to pick objects; and to interact with them. ### The Global Pad: gPad. When an object is drawn, it is always in the so-called active pad. For; every day use, it is comfortable to be able to access the active pad,; whatever it is. For that purpose, there is a global pointer, called; ***`gPad`***. It is always pointing to the active pad. If you want to; change the fill color of the active pad to blue but you do not know its; name, do this. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, go to the paragraph ""Color and color; palettes"" or if you have an opened canvas, click on the `View` menu,; selecting the `Colors` item. #### Finding an Object in a Pad. Now that we have a pointer to the active pad, ***`gPad`*** and that we; know this pad contains some objects, it is sometimes interesting to; access one of those objects. The method `GetPrimitive()` of **`TPad`**,; i.e. `TPad::GetPrimitive(const char* name)` does exactly this. Since; most of the objects that a pad contains derive from **`TObject`**, they; have a name. The following statement will return a pointer to the object; `myobjectname` and put that pointer into the variable `obj`. As you can; see, the type of returned pointer is `TObject*`. ``` {.cpp}; root[] obj = gPad->GetPrimitive(""myobjectname""); (class TObject*)0x1063cba8; ```. Even if your object is something more complicated, like a histogram; **`TH1F`**, this is normal. A function cannot return more than one type.; So the one chosen was the lowest common denominator to all possible; classes, the class from which everything derives, **`TObject`**. How do; we get the right pointer then? Simply do a cast of the function output; that will transform the output (pointer) into the right type. For; example if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:15891,access,access,15891,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['access'],['access']
Security,"initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21228,secur,security,21228,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['secur'],['security']
Security,"inition of the previously destroyed; static local object.; Source: C++11 3.6.3p2. void f();. class A {; public:; ~A() {; f(); // warn; }; };. class B {};. A a;. void f() {; static B b;; }. undefbehavior.ZeroAllocDereference; (C, C++); The effect of dereferencing a pointer returned as a request for zero size is; undefined.; Note: possibly an enhancement to ; unix.Malloc.; Source: C++03 3.7.3.1p2; C++11 3.7.4.1p2. #include <stdlib.h>. void test() {; int *p = (int *)malloc(0);; *p = 1; // warn; free(p);; }. void f(int);. void test() {; int *p = new int[0];; f(*p); // warn; delete[] p;; }. D8273. undefbehavior.DeadReferenced; (C++); Undefined behavior: the following usage of the pointer to the object whose; lifetime has ended can result in undefined behavior:; The object will be or was of a class type with a non-trivial destructor and; the pointer is used as the operand of a delete-expression; The object will be or was of a non-POD class type (C++11: any class type) and; the pointer is used to access a non-static data member or call a; non-static member function of the object; the pointer is implicitly converted to a pointer to a base class; type; the pointer is used as the operand of a static_cast (except; when the conversion is to void*, or to void* and; subsequently to char*, or unsigned char*); the pointer is used as the operand of a dynamic_cast; Source: C++03 3.8p5, p7; C++11 3.8p5, p7. #include <new>. class A {; public:; ~A();; };. class B : public A {};. void test() {; A *a = new A;; new(a) B;; delete a; // warn; }. #include <new>. class A {; public:; ~A();; };. class B {};. void test() {; A *a = new A;; new(a) B;; a->~A();; }. #include <new>. class A {; public:; ~A();; };. class B : public A {};. class C {};. void f(A*);. void test() {; B *b = new B;; new(b) C;; f(b); // warn; }. #include <new>. class A {; public:; ~A();; };. class B : public A {};. class C {};. A* test() {; B *b = new B;; new(b) C;; return static_cast<A*>(b); // warn; }. #include <new>. class ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:6897,access,access,6897,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,2,['access'],['access']
Security,"inking. If it has external linkage, it is visible to external; code, and does participate in linking. In addition to linkage information,; ``GlobalValue``\ s keep track of which Module_ they are currently part of. Because ``GlobalValue``\ s are memory objects, they are always referred to by; their **address**. As such, the Type_ of a global is always a pointer to its; contents. It is important to remember this when using the ``GetElementPtrInst``; instruction because this pointer must be dereferenced first. For example, if; you have a ``GlobalVariable`` (a subclass of ``GlobalValue)`` that is an array; of 24 ints, type ``[24 x i32]``, then the ``GlobalVariable`` is a pointer to; that array. Although the address of the first element of this array and the; value of the ``GlobalVariable`` are the same, they have different types. The; ``GlobalVariable``'s type is ``[24 x i32]``. The first element's type is; ``i32.`` Because of this, accessing a global value requires you to dereference; the pointer with ``GetElementPtrInst`` first, then its elements can be accessed.; This is explained in the `LLVM Language Reference Manual; <LangRef.html#globalvars>`_. .. _m_GlobalValue:. Important Public Members of the ``GlobalValue`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``bool hasInternalLinkage() const``; | ``bool hasExternalLinkage() const``; | ``void setInternalLinkage(bool HasInternalLinkage)``. These methods manipulate the linkage characteristics of the ``GlobalValue``. * ``Module *getParent()``. This returns the Module_ that the; GlobalValue is currently embedded into. .. _c_Function:. The ``Function`` class; ----------------------. ``#include ""llvm/IR/Function.h""``. header source: `Function.h <https://llvm.org/doxygen/Function_8h_source.html>`_. doxygen info: `Function Class; <https://llvm.org/doxygen/classllvm_1_1Function.html>`_. Superclasses: GlobalValue_, Constant_, User_, Value_. The ``Function`` class represents a single procedure in LLVM. It i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:153218,access,accessing,153218,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,['access'],"['accessed', 'accessing']"
Security,"insic); - fmin: ``*ptr = minnum(*ptr, val)`` (match the `llvm.minnum.*`` intrinsic); - uinc_wrap: ``*ptr = (*ptr u>= val) ? 0 : (*ptr + 1)`` (increment value with wraparound to zero when incremented above input value); - udec_wrap: ``*ptr = ((*ptr == 0) || (*ptr u> val)) ? val : (*ptr - 1)`` (decrement with wraparound to input value when decremented below zero). Example:; """""""""""""""". .. code-block:: llvm. %old = atomicrmw add ptr %ptr, i32 1 acquire ; yields i32. .. _i_getelementptr:. '``getelementptr``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = getelementptr <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr inbounds <ty>, ptr <ptrval>{, [inrange] <ty> <idx>}*; <result> = getelementptr <ty>, <N x ptr> <ptrval>, [inrange] <vector index type> <idx>. Overview:; """""""""""""""""". The '``getelementptr``' instruction is used to get the address of a; subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs; address calculation only and does not access memory. The instruction can also; be used to calculate a vector of such addresses. Arguments:; """""""""""""""""""". The first argument is always a type used as the basis for the calculations.; The second argument is always a pointer or a vector of pointers, and is the; base address to start from. The remaining arguments are indices; that indicate which of the elements of the aggregate object are indexed.; The interpretation of each index is dependent on the type being indexed; into. The first index always indexes the pointer value given as the; second argument, the second index indexes a value of the type pointed to; (not necessarily the value directly pointed to, since the first index; can be non-zero), etc. The first type indexed into must be a pointer; value, subsequent types can be arrays, vectors, and structs. Note that; subsequent types being indexed into can never be pointers, since that; would require loading the pointer before continuing calculation. The type ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:432902,access,access,432902,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"instruction to be illegal if the; predicate is satisfied and indicates that replacing it with a libcall would; make it more legal. Support for this action differs for; each opcode. * ``customIf()``, ``customFor()``, etc. declare an instruction to be illegal if the; predicate is satisfied and indicates that the backend developer will supply; a means of making it more legal. * ``unsupportedIf()``, ``unsupportedFor()``, etc. declare an instruction to be illegal; if the predicate is satisfied and indicates that there is no way to make it; legal and the compiler should fail. * ``fallback()`` falls back on an older API and should only be used while porting; existing code from that API. Rule Predicates; """""""""""""""""""""""""""""". The rule factories also have predicates in common:. * ``legal()``, ``lower()``, etc. are always satisfied. * ``legalIf()``, ``narrowScalarIf()``, etc. are satisfied if the user-supplied; ``LegalityPredicate`` function returns true. This predicate has access to the; information in the ``LegalityQuery`` to make its decision.; User-supplied predicates can also be combined using ``all(P0, P1, ...)``. * ``legalFor()``, ``narrowScalarFor()``, etc. are satisfied if the type matches one in; a given set of types. For example ``.legalFor({s16, s32})`` declares the; instruction legal if type 0 is either s16 or s32. Additional versions for two; and three type indices are generally available. For these, all the type; indices considered together must match all the types in one of the tuples. So; ``.legalFor({{s16, s32}, {s32, s64}})`` will only accept ``{s16, s32}``, or; ``{s32, s64}`` but will not accept ``{s16, s64}``. * ``legalForTypesWithMemSize()``, ``narrowScalarForTypesWithMemSize()``, etc. are; similar to ``legalFor()``, ``narrowScalarFor()``, etc. but additionally require a; MachineMemOperand to have a given size in each tuple. * ``legalForCartesianProduct()``, ``narrowScalarForCartesianProduct()``, etc. are; satisfied if each type index matches one element in ea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst:8690,access,access,8690,interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GlobalISel/Legalizer.rst,1,['access'],['access']
Security,"int3 ; 1 byte; int3 ; 1 byte. g:; jmp .Ltmp1 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. h:; jmp .Ltmp2 ; 5 bytes; int3 ; 1 byte; int3 ; 1 byte; int3 ; 1 byte. .Ltmp0:; mov 0, %eax; ret. .Ltmp1:; mov 1, %eax; ret. .Ltmp2:; mov 2, %eax; ret. foo:; mov f, %eax; mov g, %edx; mov h, %ecx; ret. Because the addresses of ``f``, ``g``, ``h`` are evenly spaced at a power of; 2, and function types do not overlap (unlike class types with base classes),; we can normally apply the `Alignment`_ and `Eliminating Bit Vector Checks; for All-Ones Bit Vectors`_ optimizations thus simplifying the check at each; call site to a range and alignment check. Shared library support; ======================. **EXPERIMENTAL**. The basic CFI mode described above assumes that the application is a; monolithic binary; at least that all possible virtual/indirect call; targets and the entire class hierarchy are known at link time. The; cross-DSO mode, enabled with **-f[no-]sanitize-cfi-cross-dso** relaxes; this requirement by allowing virtual and indirect calls to cross the; DSO boundary. Assuming the following setup: the binary consists of several; instrumented and several uninstrumented DSOs. Some of them may be; dlopen-ed/dlclose-d periodically, even frequently. - Calls made from uninstrumented DSOs are not checked and just work.; - Calls inside any instrumented DSO are fully protected.; - Calls between different instrumented DSOs are also protected, with; a performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:18922,sanitiz,sanitize-cfi-cross-dso,18922,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['sanitiz'],['sanitize-cfi-cross-dso']
Security,"inter`** client). This; is linked with ROOT graphical libraries loaded on demand in order to; control visualization actions. ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position $\vec{r}$ and direction $\vec{n}$ with respect to the world; reference frame. The direction $\vec{n}$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of **`TGeo`** to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with ROOT. The interface methods related to tracking are incorporated into; **`TGeoManager`** class and implemented in the navigator class; **`TGeoNavigator`**. In order to be able to start tracking, one has to; define the initial state providing the starting point $\vec{r_0}$; and direction $\vec{n_0}$ .; There are several ways of doing that. ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ``` {.cpp}; TObjArray *navigators = gGeoMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:101755,access,access,101755,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['access']
Security,"intf``"" and find it matches ``BUCKETS[3]`` by taking the 32 bit; hash value and modulo it by ``n_buckets``. ``BUCKETS[3]`` contains ""6"" which; is the index into the ``HASHES`` table. We would then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:68225,hash,hash,68225,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"ion is at this point necessary:. - Lines *1-3*: A simple function to ease the make-up of lines.; Remember that the class `TF1` inherits from `TAttLine`. - Lines *5-7* : Definition of a customised function, namely a Gaussian; (the ""signal"") plus a parabolic function, the ""background"". - Lines *10-12*: Some make-up for the Canvas. In particular we want; that the parameters of the fit appear very clearly and nicely on the; plot. - Lines *20-25*: Define and initialise an instance of `TF1`. - Lines *27-31*: Define and fill a histogram. - Lines *33-38*: For convenience, the same function as for the; generation of the pseudo-data is used in the fit; hence, we need to; reset the function parameters. This part of the code is very; important for each fit procedure, as it sets the initial values of; the fit. - Line *41*: A very simple command, well known by now: fit the; function to the histogram. - Lines *42-46*: Retrieve the output from the fit. Here, we simply; print the fit result and access and print the covariance matrix of; the parameters. - Lines *54-end*: Plot the pseudo-data, the fitted function and the; signal and background components at the best-fit values. [f61]: figures/functions.png ""f61""; <a name=""f61""></a>. ![Fit of pseudo data: a signal shape over a background trend. This plot; is another example of how making a plot ""self-explanatory"" can help you; better displaying your results. \label{f61}][f61]. ## Toy Monte Carlo Experiments ##. Let us look at a simple example of a toy experiment comparing two; methods to fit a function to a histogram, the $\chi^{2}$. method and a method called ""binned log-likelihood fit"", both available in ROOT. As a very simple yet powerful quantity to check the quality of the fit; results, we construct for each pseudo-data set the so-called ""pull"", the; difference of the estimated and the true value of a parameter,; normalised to the estimated error on the parameter,; $\frac{(p_{estim} - p_{true})}{\sigma_{p}}$. If everything is OK, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md:3575,access,access,3575,documentation/primer/functions_and_parameter_estimation.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/functions_and_parameter_estimation.md,1,['access'],['access']
Security,"ion needed when binding reference to class rvalue; Duplicate of 391. 292; CD3; Deallocation on exception in new before arguments evaluated; Unknown. 293; open; Syntax of explicit instantiation/specialization too permissive; Not resolved. 294; NAD; Can static_cast drop exception specifications?; No. 295; CD1; cv-qualifiers on function types; Clang 3.7. 296; CD1; Can conversion functions be static?; Yes. 297; NAD; Which template does an explicit specialization specialize?; Unknown. 298; CD1; T::x when T is cv-qualified; Clang 3.1. 299; CD1; Conversion on array bound expression in new; Clang 2.8 (C++11 onwards). 300; CD1; References to functions in template argument deduction; Yes. 301; CD1; Syntax for template-name; Clang 3.5. 302; CD1; Value-initialization and generation of default constructor; Clang 3.0. 303; NAD; Integral promotions on bit-fields; N/A. 304; TC1; Value-initialization of a reference; Clang 2.9. 305; CD1; Name lookup in destructor call; No. 306; CD1; Ambiguity by class name injection; Duplicate of 39. 307; NAD; Initialization of a virtual base class subobject; N/A. 308; NAD; Catching exceptions with ambiguous base classes; Clang 3.7. 309; CD1; Linkage of entities whose names are not simply identifiers, in introduction; Duplicate of 485. 310; open; Can function templates differing only in parameter cv-qualifiers be overloaded?; Not resolved. 311; NAD; Using qualified name to reopen nested namespace; Clang 3.0. 312; CD3; “use” of invalid pointer value not defined; Duplicate of 616. 313; dup; Class with single conversion function to integral as array size in new; Duplicate of 299 (C++11 onwards). 314; C++17; template in base class specifier; No. 315; NAD; Is call of static member function through null pointer undefined?; N/A. 316; NAD; Injected-class-name of template used as template template parameter; Superseded by 1004. 317; CD1; Can a function be declared inline after it has been called?; Clang 3.5. 318; CD1; struct A::A should not name the construct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:20182,inject,injection,20182,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injection']
Security,"ion point is is hard to say, but; it's probably in the handful of days in tree territory. If you are unsure,; we encourage you to reply to the commit thread, give the author a bit to; respond, and then proceed with the revert if the author doesn't seem to be; actively responding.; * When re-applying a reverted patch, the commit message should be updated to; indicate the problem that was addressed and how it was addressed. Obtaining Commit Access; -----------------------. We grant commit access to contributors with a track record of submitting high; quality patches. If you would like commit access, please send an email to; `Chris <mailto:clattner@llvm.org>`_ with your GitHub username. This is true; for former contributors with SVN access as well as new contributors. If; approved, a GitHub invitation will be sent to your GitHub account. In case you; don't get notification from GitHub, go to; `Invitation Link <https://github.com/orgs/llvm/invitation>`_ directly. Once; accept the invitation, you'll get commit access. Prior to obtaining commit access, it is common practice to request that; someone with commit access commits on your behalf. When doing so, please; provide the name and email address you would like to use in the Author; property of the commit. For external tracking purposes, committed changes are automatically reflected; on a commits mailing list soon after the commit lands (e.g. llvm-commits_).; Note that these mailing lists are moderated, and it is not unusual for a large; commit to require a moderator to approve the email, so do not be concerned if a; commit does not immediately appear in the archives. If you have recently been granted commit access, these policies apply:. #. You are granted *commit-after-approval* to all parts of LLVM. For; information on how to get approval for a patch, please see :doc:`CodeReview`.; When approved, you may commit it yourself. #. You are allowed to commit patches without approval which you think are; obvious. This is clea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:23530,access,access,23530,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['access'],['access']
Security,"ion status; This page tracks which C++ defect reports are implemented within Clang. Number; Status; Issue title; Available in Clang?. 1; TC1; What if two using-declarations refer to the same function but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1051,Access,Access,1051,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"ion with a explicit cast to the wanted function.; - The system works with templates and the template can not resolve the correct type of function because it is overloaded.; - If you pass a function without the explicit cast you will get a very ugly traceback.; - A lot of common standard functions for example from math.h like sin, cos etc.. are overloaded, take care passing it. ~~~{.cxx}; #include<TRInterface.h>. Double_t myfun(Double_t x); {; return 2*cos(x);; }. Int_t myfun(Int_t x); {; return x;; }. void fun(); {; ROOT::R::TRInterface &r=ROOT::R::TRInterface::Instance();; r[""myfund""]<<(Double_t (*)(Double_t))myfun;; r[""myfuni""]<<(Int_t (*)(Int_t))myfun;. r<<""print(myfund(0.0))"";; r<<""print(myfuni(1))"";; }; ~~~. ## Wrapping a class; You can wrap a class and expose it in R environment using only a pair of macrodefinitions and the template class; `ROOT::R::class_<>`; The `ROOTR_EXPOSED_CLASS(Class)` macro allows you to expose the class as a new datatype of R, but it has to be alongside; the `ROOTR_MODULE(Module)` macro which allows you to create an internal R module and make the class wrapping; To do this you must use inside the `ROOTR_MODULE` braces the class `ROOT::R::class_<>` and specify; each constructor, attribute or method that the class to export has.; Then the macrodefinition `LOAD_ROOTR_MODULE(Module)` can load the module and the class in R's environment.; You can find a more clear instruction by looking at a example below in Functor section. ##DataFrames; DataFrame? is a very important datatype in R and in ROOTR we have a class to manipulate; dataframes called TRDataFrame, with a lot of very useful operators overloaded to work with TRDataFrame's objects; in a similar way that in the R environment but from c++ in ROOT.; Example:. Lets to create need data to play with dataframe features. ~~~{.cxx}; ////////////////////////; //creating variables//; ////////////////////////; TVectorD v1(3);; std::vector<Double_t> v2(3);; std::array<Int_t,3> v3{ {1,2,3} };; std",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md:6768,expose,expose,6768,bindings/r/doc/users-guide/ROOTR_Users_Guide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/r/doc/users-guide/ROOTR_Users_Guide.md,2,['expose'],['expose']
Security,"ion-map-table. =============== ============== ====================================================================; String Key Value Type Description; =============== ============== ====================================================================; *symbol name* map *symbol name* is the ELF symbol name of the shader function code; entry address. The value is the function's metadata. See; :ref:`amdgpu-amdpal-code-object-shader-function-metadata-map-table`.; =============== ============== ====================================================================. .. .. table:: AMDPAL Code Object Shader Function Metadata Map; :name: amdgpu-amdpal-code-object-shader-function-metadata-map-table. ============================= ============== =================================================================; String Key Value Type Description; ============================= ============== =================================================================; "".api_shader_hash"" sequence of Input shader hash, typically passed in from the client. The value; 2 integers is implementation defined, and can not be relied on between; different builds of the compiler.; "".scratch_memory_size"" integer Size in bytes of scratch memory used by the shader.; "".lds_size"" integer Size in bytes of LDS memory.; "".vgpr_count"" integer Number of VGPRs used by the shader.; "".sgpr_count"" integer Number of SGPRs used by the shader.; "".stack_frame_size_in_bytes"" integer Amount of stack size used by the shader.; "".shader_subtype"" string Shader subtype/kind. Values include:. - ""Unknown"". ============================= ============== =================================================================. .. .. table:: AMDPAL Code Object Register Map; :name: amdgpu-amdpal-code-object-register-map-table. ========================== ============== ====================================================================; 32-bit Integer Key Value Type Description; ========================== ============== =======================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:411445,hash,hash,411445,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['hash'],['hash']
Security,"ion; to X.1.0git (where ``X`` is the major version of the branch.). #. All tags and branches need to be created in both the llvm/llvm-project and; llvm/llvm-test-suite repos. Update LLVM Version; ^^^^^^^^^^^^^^^^^^^. After creating the LLVM release branch, update the release branches'; version with the script in ``llvm/utils/release/bump-version.py``. Tagging the LLVM Release Candidates; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Tag release candidates:. ::. $ git tag -sa llvmorg-X.Y.Z-rcN. The Release Manager must supply pre-packaged source tarballs for users. This can; be done with the export.sh script in utils/release. Tarballs, release binaries, or any other release artifacts must be uploaded to; GitHub. This can be done using the github-upload-release.py script in utils/release. ::. $ github-upload-release.py upload --token <github-token> --release X.Y.Z-rcN --files <release_files>. ::. $ ./export.sh -release X.Y.Z -rc $RC. This will generate source tarballs for each LLVM project being validated, which; can be uploaded to github for further testing. Build The Binary Distribution; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Creating the binary distribution requires following the instructions; :doc:`here <ReleaseProcess>`. That process will perform both Release+Asserts and Release builds but only; pack the Release build for upload. You should use the Release+Asserts sysroot,; normally under ``final/Phase3/Release+Asserts/llvmCore-3.8.1-RCn.install/``,; for test-suite and run-time benchmarks, to make sure nothing serious has; passed through the net. For compile-time benchmarks, use the Release version. The minimum required version of the tools you'll need are :doc:`here <GettingStarted>`. Release Qualification Criteria; ------------------------------. There are no official release qualification criteria. It is up to the; the release manager to determine when a release is ready. The release manager; should pay attention to the results of community testing, the number of outstanding",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:5417,validat,validated,5417,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['validat'],['validated']
Security,"ionally `--with-png=no --with-bzip2=no` flags are passed to freetype; configuration script. Default values for these options are auto.; `freetype` finds `libpng` and `libbzip2` on the system and builds extra; modules. Then attempting to link against `freetype` one would need to link; `-lpng -lbzip2` explicitly otherwise linking will returns in undefined; references. Otherwise we would need to check for `libpng` and `libbzip2` on the system; and adjust `FREETYPE_LIBRARIES` to include `-lpng` and `-lbzip2`.; The current solution goes for the minimal configuration. The original request for; this update was posted [here](https://sft.its.cern.ch/jira/browse/ROOT-7631). ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### THttpServer. Support of POST HTTP requests. For example, ROOT objects can be send with POST request and used as arguments of; objects method execution in exe.bin and exe.json requests. Request and response HTTP headers are now directly accessible in THttpCallArg class. When command is registered with THttpServer::RegisterCommand() method,; one could configure additional arguments which should be submitted when; command is executed with cmd.json requests. Introduce restriction rules for objects access with THttpServer::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.jso",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:18931,access,accessible,18931,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['access'],['accessible']
Security,"ions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to pr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848370,access,accessed,848370,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"ions join the relationships. Since; the LLVM ``memfence`` instruction does not allow an address space to be; specified the OpenCL fence has to conservatively assume both local and; global address space was specified. However, optimizations can often be; done to eliminate the additional ``s_waitcnt`` instructions when there are; no intervening memory instructions which access the corresponding address; space. The code sequences in the table indicate what can be omitted for the; OpenCL memory. The target triple environment is used to determine if the; source language is OpenCL (see :ref:`amdgpu-opencl`). ``ds/flat_load/store/atomic`` instructions to local memory are termed LDS; operations. ``buffer/global/flat_load/store/atomic`` instructions to global memory are; termed vector memory operations. Private address space uses ``buffer_load/store`` using the scratch V#; (GFX6-GFX8), or ``scratch_load/store`` (GFX9-GFX11). Since only a single thread; is accessing the memory, atomic memory orderings are not meaningful, and all; accesses are treated as non-atomic. Constant address space uses ``buffer/global_load`` instructions (or equivalent; scalar memory instructions). Since the constant address space contents do not; change during the execution of a kernel dispatch it is not legal to perform; stores, and atomic memory orderings are not meaningful, and all accesses are; treated as non-atomic. A memory synchronization scope wider than work-group is not meaningful for the; group (LDS) address space and is treated as work-group. The memory model does not support the region address space which is treated as; non-atomic. Acquire memory ordering is not meaningful on store atomic instructions and is; treated as non-atomic. Release memory ordering is not meaningful on load atomic instructions and is; treated a non-atomic. Acquire-release memory ordering is not meaningful on load or store atomic; instructions and is treated as acquire and release respectively. The memory order also",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:203163,access,accessing,203163,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],"['accesses', 'accessing']"
Security,"ions will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even with this representational change, wide pointers act syntactically as; normal pointers to allow standard pointer operations, such as pointer; dereference (``*p``), array subscript (``p[i]``), member access (``p->``), and; pointer arithmetic, with some restrictions on bounds-unsafe uses. ``-fbounds-safety`` has a set of ""internal"" bounds annotations to turn pointers; into wide pointers. These are ``__bidi_indexable`` and ``__indexable``. When a; pointer has either of these annotations, the compiler changes the pointer to the; corresponding wide pointer. This means these annotations will break the ABI and; will not be compatible with plain C, and thus they should generally not be used; in ABI surfaces. * ``__bidi_indexable`` : A pointer with this annotation becomes a wide pointer; to carry the upper bound and the lower bound, the layout of which is; equivalent to ``struct { T *ptr; T *upper_bound; T *lower_bound; };``. As the; name indicates, pointers with this annotation are ""bidirectionally indexable"",; meaning that they can be indexed with either a negative or a positive offset; and the pointers can be incremented or decre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:13721,access,access,13721,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['access']
Security,"iple threads with the `RNTupleParallelWriter`.; Once committed (e.g. by releasing the RNTupleWriter), the RNTuple is immutable and cannot be amended.; An RNTuple that is currently being written cannot be read. ### RNTupleReader; The RNTupleReader is the primary interface to read and inspect an RNTuple.; An RNTupleReader owns a model: either a model created from the on-disk information or an imposed, user-provided model.; The user-provided model can be limited to a subset of fields.; Data is populated to an explicit `REntry` or the model's default entry through `RNTupleReader::LoadEntry()`. The reader can create `RNTupleView` objects for the independent reading of individual fields.; The reader can create `RBulk` objects for bulk reading of individual fields. Additionally, the reader provides access to a cached copy of the descriptor.; It can display individual entries (`RNTupleReader::Show()`) and summary information (`RNTupleReader::PrintInfo()`). ### RNTupleView<T>; RNTuple views provide read access to individual fields.; Views are created from an RNTupleReader.; Views are templated; for simple types (e.g., `float`, `int`), views provide read-only access directly to an RNTuple page in memory.; Complex types and void views require additional memory copies to populate an object in memory from the column data. A view can iterate over the entry range, over the field range, and over the range of a collection within an entry.; For instance, for a field `std::vector<float> pt`, a view can iterate over all `pt` values of all entries, or over the `pt` values of a particular entry. A view can safely outlive its originating reader.; Once the reader is deconstructed, any attempt to read data will throw an exception, but the view is still properly destructed. Views that originate from the same reader _cannot_ be used concurrently by different threads. Internal Classes; ----------------. ### RNTupleDS; The `RNTupleDS` class is an internal class that provides an RNTuple data sou",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:13518,access,access,13518,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"is a summary of the changes made. All of these changes are; transparent to end-use cases ; ; ; New implementation of RooFit data types. The implementation of data stored in RooDataSet and RooDataHist; was historically handled by ROOT TTrees (though class RooTreeDataStore). The default storage type; has now been changed to class RooVectorDataStore which stores the information in STL arrays. Existing; datasets based on trees can be read in transparently, and are converted to vector form in the ; persistent-to-transient conversion (the datafile is not modified in this operation); ; The vector store has two important advantages: 1) faster data access (raw data access times are 70 times ; faster than for TTrees), 2) ability to rewrite columns on the fly. The first advantage is important; for the existing constant-term precalculation optimization in roofit likelihoods as these are now; also stored in vectors rather than trees. The faster access speed of vectors make that the constant; term optimization inside likelihoods results in a larger speed increase. This is particulatly noticeable in pdfs with; many constant expressions from pdfs that were moderately fast to begin with (e.g. RooHistPdf).; The second advantages allows new types of algorithmic likelihood optimization in RooFit detailed below. New algorithmic optimization in the caching of pdfs. So far - in the likelihood - two classes of; objects are identified: those that change with every event (i.e. the pdf) and those that change; only with the parameters (typically pdf normalization integrals). Pdfs are always recalculated; for every event, whereas integrals are only evaluated when needed. The exception to the first type are pdfs; that only depend on constant parameters (or no parameters) - these are identified at the beginning, and precalculated once ; to avoid recalculating an expression with the same outcome for every iteration of the likelihood calculation. For composite pdfs a further optimization has been i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html:1312,access,access,1312,roofit/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v532/index.html,2,['access'],['access']
Security,"is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m))), ""()""). Reference: ranges, stencils, edits, rules; -----------------------------------------. The above examples demonstrate just the basics of rewrite rules. Every element; we touched on has more available constructors: range selectors, stencils, edits; and rules. In this section, we'll briefly review each in turn, with references; to the source headers for up-to-date information. First, though, we clarify what; rewrite rules are actually rewriting. Rewriting ASTs to... Text?; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The astute reader may have noticed that we've been somewhat vague in our; explanation of what the rewrite rules are actually rewriting. We've referred to; ""code"", but code can be represented both as raw source text and as an abstract; syntax tree. So, which one is it?. Ideally, we'd be rewriting the input AST to a new AST, but clang's AST is not; terribly amenable to this kind of transformation. So, we compromise: we express; our patterns and the names that they bind in te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:8846,access,access,8846,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['access'],['access']
Security,"is either down or unresponsive. We should take advantage of one of the services out there (GitHub, GitLab,; and BitBucket, among others) that offer better service (24/7 stability, disk; space, Git server, code browsing, forking facilities, etc) for free. Why Git?; --------. Many new coders nowadays start with Git, and a lot of people have never used; SVN, CVS, or anything else. Websites like GitHub have changed the landscape; of open source contributions, reducing the cost of first contribution and; fostering collaboration. Git is also the version control many LLVM developers use. Despite the; sources being stored in a SVN server, these developers are already using Git; through the Git-SVN integration. Git allows you to:. * Commit, squash, merge, and fork locally without touching the remote server.; * Maintain local branches, enabling multiple threads of development.; * Collaborate on these branches (e.g. through your own fork of llvm on GitHub).; * Inspect the repository history (blame, log, bisect) without Internet access.; * Maintain remote forks and branches on Git hosting services and; integrate back to the main repository. In addition, because Git seems to be replacing many OSS projects' version; control systems, there are many tools that are built over Git.; Future tooling may support Git first (if not only). Why GitHub?; -----------. GitHub, like GitLab and BitBucket, provides free code hosting for open source; projects. Any of these could replace the code-hosting infrastructure that we; have today. These services also have a dedicated team to monitor, migrate, improve and; distribute the contents of the repositories depending on region and load. GitHub has one important advantage over GitLab and; BitBucket: it offers read-write **SVN** access to the repository; (https://github.com/blog/626-announcing-svn-support).; This would enable people to continue working post-migration as though our code; were still canonically in an SVN repository. In addition, there ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:2826,access,access,2826,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['access'],['access']
Security,"is instance random numbers distributed according to; different probability density functions, like the Uniform one at; lines *27-29*. See the on-line documentation to appreciate the full; power of this ROOT feature. - Line *8*: You are already familiar with the `TF1` class. This is; its two-dimensional version. At line *16* two random numbers; distributed according to the `TF2` formula are drawn with the method; `TF2::GetRandom2(double& a, double&b)`. - Line *27-29*: Fitting a 2-dimensional function just works like in; the one-dimensional case, i.e. initialisation of parameters and; calling of the `Fit()` method. - Line *34*: The *Surf1* option draws the `TF2` objects (but also; bi-dimensional histograms) as coloured surfaces with a wire-frame on; three-dimensional canvases. See Figure [4.3](#f43). - Line *35-40*: Retrieve the axis pointer and define the axis titles. - Line *41*: Draw the cloud of points on top of the coloured surface. - Line *43-49*: Here you learn how to create a canvas, partition it in; two sub-pads and access them. It is very handy to show multiple; plots in the same window or image. [f43]: figures/fitted2dFunction.png ""f43""; <a name=""f43""></a>. ![A dataset fitted with a bidimensional function visualised as a colored; surface.\label{f43}][f43]. \newpage. ## Multiple graphs ##. The class `TMultigraph` allows to manipulate a set of graphs as a single entity.; It is a collection of `TGraph` (or derived) objects. When drawn, the X and Y axis; ranges are automatically computed such as all the graphs will be visible. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/multigraph.C; ```; - Line *6* creates the multigraph. - Line *9-28*: create two graphs with errors and add them in the multigraph. - Line *30-32*: draw the multigraph. The axis limits are computed automatically; to make sure all the graphs' points will be in range. [f44]: figures/multigraph.png ""f44""; <a name=""f44""></a>. ![A set of graphs grouped in a multigraph.\label{f44}][f44]. [^3] ht",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md:4444,access,access,4444,documentation/primer/graphs.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/graphs.md,1,['access'],['access']
Security,"is is useful for cases where the number of; elements is known in advance; their actual initialization is expensive; and; they are sparsely used. This utility uses page-granular lazy initialization; when the element is accessed. When the number of used pages is small; significant memory savings can be achieved. The main advantage is that a ``PagedVector`` allows to delay the actual; allocation of the page until it's needed, at the extra cost of one pointer per; page and one extra indirection when accessing elements with their positional; index. In order to minimise the memory footprint of this container, it's important to; balance the PageSize so that it's not too small (otherwise the overhead of the; pointer per page might become too high) and not too big (otherwise the memory; is wasted if the page is not fully used). Moreover, while retaining the order of the elements based on their insertion; index, like a vector, iterating over the elements via ``begin()`` and ``end()``; is not provided in the API, due to the fact accessing the elements in order; would allocate all the iterated pages, defeating memory savings and the purpose; of the ``PagedVector``. Finally a ``materialized_begin()`` and ``materialized_end`` iterators are; provided to access the elements associated to the accessed pages, which could; speed up operations that need to iterate over initialized elements in a; non-ordered manner. .. _dss_vector:. <vector>; ^^^^^^^^. ``std::vector<T>`` is well loved and respected. However, ``SmallVector<T, 0>``; is often a better option due to the advantages listed above. std::vector is; still useful when you need to store more than ``UINT32_MAX`` elements or when; interfacing with code that expects vectors :). One worthwhile note about std::vector: avoid code like this:. .. code-block:: c++. for ( ... ) {; std::vector<foo> V;; // make use of V.; }. Instead, write this as:. .. code-block:: c++. std::vector<foo> V;; for ( ... ) {; // make use of V.; V.clear();; }. Doing",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:64265,access,accessing,64265,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessing']
Security,"is option belongs to. This is; used by various tools to categorize and sometimes filter options.; * ``Flags`` may contain ""tags"" associated with the option. These may affect how; the option is rendered, or if it's hidden in some contexts.; * ``Visibility`` should be used to specify the drivers in which a particular; option would be available. This attribute will impact tool --help; * ``Alias`` denotes that the option is an alias of another option. This may be; combined with ``AliasArgs`` that holds the implied value. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; + Group<f_Group>, Visibility<[ClangOption, CC1Option]>,; + HelpText<""Load pass plugin from a dynamic shared object file."">;. New options are recognized by the ``clang`` driver mode if ``Visibility`` is; not specified or contains ``ClangOption``. Options intended for ``clang -cc1``; must be explicitly marked with the ``CC1Option`` flag. Flags that specify; ``CC1Option`` but not ``ClangOption`` will only be accessible via ``-cc1``.; This is similar for other driver modes, such as ``clang-cl`` or ``flang``. Next, parse (or manufacture) the command line arguments in the Clang driver and; use them to construct the ``-cc1`` job:. .. code-block:: diff. void Clang::ConstructJob(const ArgList &Args /*...*/) const {; ArgStringList CmdArgs;; // ... + for (const Arg *A : Args.filtered(OPT_fpass_plugin_EQ)) {; + CmdArgs.push_back(Args.MakeArgString(Twine(""-fpass-plugin="") + A->getValue()));; + A->claim();; + }; }. The last step is implementing the ``-cc1`` command line argument; parsing/generation that initializes/serializes the option class (in our case; ``CodeGenOptions``) stored within ``CompilerInvocation``. This can be done; automatically by using the marshalling annotations on the option definition:. .. code-block:: diff. // Options.td. def fpass_plugin_EQ : Joined<[""-""], ""fpass-plugin="">,; Group<f_Group>, Flags<[CC1Option]>,; HelpText<""Load pass plugin from a dynamic s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:31218,access,accessible,31218,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['access'],['accessible']
Security,"is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that for GFX7-GFX9 ``flat_load/store/atomic`` instructions can report out of; vector memory order if they access LDS memory, and out of LDS operation order; if they access global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore, no special action is required for coherence between the; lanes of a single wavefront, or for coherence between wavefronts in the same; work-group. A ``buffer_wbinvl1_vol`` is required for coherence between; wavefronts executing in different work-groups as they may be executing on; different CUs.; * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a group of CUs. The scalar and vector L1 caches are not coherent. However,; scalar operations are used in a restricted way so do not impact the memory; model. See :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory operations use an L2 cache shared by all CUs on; the same agent.; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each CU has a separate request queue per channel. Therefore, the vector and; scalar memory operations performed by wavefronts executing in different; work-groups (which m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:207719,access,access,207719,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"is the next crossed one, but the physical path (state) AFTER crossing; the boundary is not determined. In order to find out this new state, one; has to propagate the point with a distance slightly bigger that the; computed step value (which is accurate within numerical precision). A; method that performs this task finding the next location is; `TGeoManager::Step()`, described in "" Making a Step "", but users may; implement more precise methods to insure post-step boundary crossing. ## Geometry Graphical User Interface. The geombuilder package allows you to create and edit geometries. The; package provides a library of all GUI classes related to geometry. Each; editable geometry class **`TGeoXXX`** have a correspondent editor; **`TGeoXXXEditor`** that provides a graphics user interface allowing to; edit some (or all) parameters of a geometry object. The editable objects; are geometry manager, volumes, nodes, shapes, media, materials and; matrices. The interfaces provide also access to specific functionality; of geometry objects. The editing mechanism is based on ROOT GED; (Graphics Editors) functionality and the library is loaded using the; plug-in mechanism. ### Editing a Geometry. There are two different use cases having different ways of invoking the; geometry editors. The first one applies when starting with geometry from; scratch and using the builder functionality to create new geometry; objects. In this case, one should use the sequence:. ``` {.cpp}; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; ```. The lines above will create a new **`TGeoManager`** class, create an; empty canvas and start the editor in the left-sided editor frame; attached to the canvas. To open the editor in a separate frame one; should provide a non-empty string as option to the `Edit()` method. ![The geometry manager editor](pictures/030001E9.png). ### The Geometry Manager Editor. ![Accessing/creating different categories o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:165699,access,access,165699,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['access']
Security,"is true.; * ``origin_history_size`` -- The limit of origin chain length. Non-positive values; mean unlimited. Its default value is 16.; * ``origin_history_per_stack_limit`` -- The limit of origin node's references count.; Non-positive values mean unlimited. Its default value is 20000.; * ``store_context_size`` -- The depth limit of origin tracking stack traces. Its; default value is 20.; * ``zero_in_malloc`` -- Whether to zero shadow space of new allocated memory. Its; default value is true.; * ``zero_in_free`` --- Whether to zero shadow space of deallocated memory. Its; default value is true. Example; =======. DataFlowSanitizer supports up to 8 labels, to achieve low CPU and code; size overhead. Base labels are simply 8-bit unsigned integers that are; powers of 2 (i.e. 1, 2, 4, 8, ..., 128), and union labels are created; by ORing base labels. The following program demonstrates label propagation by checking that; the correct labels are propagated. .. code-block:: c++. #include <sanitizer/dfsan_interface.h>; #include <assert.h>. int main(void) {; int i = 100;; int j = 200;; int k = 300;; dfsan_label i_label = 1;; dfsan_label j_label = 2;; dfsan_label k_label = 4;; dfsan_set_label(i_label, &i, sizeof(i));; dfsan_set_label(j_label, &j, sizeof(j));; dfsan_set_label(k_label, &k, sizeof(k));. dfsan_label ij_label = dfsan_get_label(i + j);. assert(ij_label & i_label); // ij_label has i_label; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:11038,sanitiz,sanitizer,11038,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['sanitiz'],['sanitizer']
Security,"issive,; [MIT license](http://en.wikipedia.org/wiki/MIT_License); - Free from copy-left licenses, like GPL, because you should innovate without; restrictions.; - Forked from [Mongoose](https://code.google.com/p/mongoose/) in 2013, before; it changed the licence from MIT to commercial + GPL. A lot of enhancements; have been added since that time, see; [RELEASE_NOTES.md](https://github.com/civetweb/civetweb/blob/master/RELEASE_NOTES.md).; - Works on Windows, Mac, Linux, UNIX, iPhone, Android, Buildroot, and many; other platforms.; - Scripting and database support (CGI, SQLite database, Lua Server Pages,; Server side Lua scripts, Server side JavaScript).; This provides a ready to go, powerful web development platform in a one; single-click executable with **no dependencies**.0; - Support for CGI, SSI, HTTP digest (MD5) authorization, WebSocket,; WebDAV.; - HTTPS (SSL/TLS) support using [OpenSSL](https://www.openssl.org/).; - Optional support for authentication using client side X.509 certificates.; - Resumed download, URL rewrite, file blacklist, IP-based ACL.; - May run as Windows service.; - Download speed limit based on client subnet or URI pattern.; - Simple and clean embedding API.; - The source is in single file to make things easy.; - Embedding examples included.; - HTTP client capable of sending arbitrary HTTP/HTTPS requests.; - Websocket client functionality available (WS/WSS). ### Optionally included software. [![Lua](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/lua-logo.jpg ""Lua Logo"")](http://lua.org). [![Sqlite3](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/sqlite3-logo.jpg ""Sqlite3 Logo"")](http://sqlite.org). [![LuaFileSystem](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/luafilesystem-logo.jpg ""LuaFileSystem Logo"")](http://keplerproject.github.io/luafilesystem/). [![LuaSQLite3](https://raw.githubusercontent.com/civetweb/civetweb/master/resources/luasqlite-logo.jpg ""LuaSQLite3 Logo"")](h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md:6308,certificate,certificates,6308,net/http/civetweb/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/civetweb/README.md,1,['certificate'],['certificates']
Security,"isspeculating.; movl (%rsi,%rcx), %edi; ```. This will result in a negative address near zero or in `offset` wrapping the; address space back to a small positive address. Small, negative addresses will; fault in user-mode for most operating systems, but targets which need the high; address space to be user accessible may need to adjust the exact sequence used; above. Additionally, the low addresses will need to be marked unreadable by the; OS to fully harden the load. ###### RIP-relative addressing is even easier to break. There is a common addressing mode idiom that is substantially harder to check:; addressing relative to the instruction pointer. We cannot change the value of; the instruction pointer register and so we have the harder problem of forcing; `%base + scale * %index + offset` to be an invalid address, by *only* changing; `%index`. The only advantage we have is that the attacker also cannot modify; `%base`. If we use the fast instruction sequence above, but only apply it to; the index, we will always access `%rip + (scale * -1) + offset`. If the; attacker can find a load which with this address happens to point to secret; data, then they can reach it. However, the loader and base libraries can also; simply refuse to map the heap, data segments, or stack within 2gb of any of the; text in the program, much like it can reserve the low 2gb of address space. ###### The flag registers again make everything hard. Unfortunately, the technique of using `orq`-instructions has a serious flaw on; x86. The very thing that makes it easy to accumulate state, the flag registers; containing predicates, causes serious problems here because they may be alive; and used by the loading instruction or subsequent instructions. On x86, the; `orq` instruction **sets** the flags and will override anything already there.; This makes inserting them into the instruction stream very hazardous.; Unfortunately, unlike when hardening the loaded value, we have no fallback here; and so we",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:30807,access,access,30807,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['access'],['access']
Security,istinct values; N/A. 56; NAD; Floating-point representation precision requirements; Yes. 57; NAD; Is there an integral type for every pointer?; Yes. 58; NAD; Is there a limit on the number of digits processed by scanf and strtdo?; N/A. 59; NAD; Do types have to be completed?; Yes. 60; C89; Array initialization from a string literal; Yes. 61; NAD; Whitespace in scanf format string; N/A. 62; NAD; Can the rename function be defined to fail?; N/A. 63; Dup; Floating-point representation precision requirements; Duplicate of 56. 64; NAD; Null pointer constants; Yes. 65; C89; Questions on locales; N/A. 66; NAD; Another question on locales; N/A. 67; NAD; Integer and integral type confusion; Yes. 68; NAD; 'char' and signed vs unsigned integer types; Yes. 69; NAD; Questions about the representation of integer types; Yes. 70; NAD; Interchangeability of function arguments; Yes. 71; C89; Enumerated types; Yes. 72; NAD; Definition of object and pointer arithmetic; Unknown. 73; NAD; Definition of object and array access; Unknown. 74; NAD; Alignment and structure padding; Unknown. 75; NAD; Alignment of allocated memory; N/A. 76; Open; Pointers to the end of arrays; Not resolved. 77; NAD; Stability of addresses; Yes. 78; NAD; Uniqueness of addresses; Unknown. 79; NAD; Constancy of system library function addresses; N/A. 80; C89; Merging of string constants; Yes. 81; NAD; Left shift operator; Yes. 82; C89; Multiple varargs; Unknown. 83; C89; Use of library functions; N/A. 84; NAD; Incomplete type in function declaration; Yes. 85; C89; Returning from main; Yes. 86; NAD; Object-like macros in system headers; Yes. 87; NAD; Order of evaluation; Unknown. 88; NAD; Compatibility of incomplete types; Yes. 89; C89; Multiple definitions of macros; Yes. 90; NAD; Multibyte characters in formats; N/A. 91; NAD; Multibyte encodings; Yes. 92; Dup; Partial initialization of strings; Duplicate of 60. 93; C89; Reservation of identifiers; Yes. 94; NAD; Are constraints on function return the same as assign,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:5787,access,access,5787,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,2,['access'],['access']
Security,istogram.; The tutorial `tutorials/multicore/mt304_fillHistos.C` gives an example of how to use the functionality with; `TThreadedObject<TH1D>` . The `power-2` binning is currently available only for 1D histograms. ## Math Libraries; - The Fitting functions now support vectorization and parallelization.; - Added padding in the fit data classes for correct loading of SIMD arrays. ## RooFit Libraries. - Apply several fixes from the ATLAS Higgs combination branch of RooFit. These fixes include; - fix for computing the contraint normalization. This requires now the option GlobalObservables when creating the NLL.; - All the `RooAbsPdf::createNLL` used in The RooStats classes have been updated to include the `GlobalObservables` option.; - Remove the `Roo1DMomentMorphFunction` and replace it with `RooMomentMorphFunction` and `RooMomentMorphFunctionND`. ## TMVA Library. - Improvement and fixes in ROCCurve class.; - Add support for event weights in the DNN; - Add in the DNN the option to use a validation data set independent of the training/test set used for training the DNN.; - Add option to suppress correlation outputs; - Improvements in the support for multi-class classification.; - Improvements in the Gradient Boostig Trees; - Deprecate the TMVA DNN Reference Implementation. Support now only CPU and GPU implementations. . ## 2D Graphics Libraries; - The method TColor::InvertPalette inverts the current palette. The top color becomes; bottom and vice versa. This was [suggested by Karl Smith](https://root-forum.cern.ch/t/inverted-color-palettes/24826/2).; - New method `TColor::SetColorThreshold(Float_t t)` to specify the color; threshold used by GetColor to retrieve a color.; - Improvements in candle plots:; - LogZ for violins; - scaling of candles and violins with respect to each other; - static functions for WhiskerRange and BoxRange; - In some case it was not possible to zoom a 1D histogram using the mouse; on the X axis. This was described; [here](https://root-forum.cer,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md:18997,validat,validation,18997,README/ReleaseNotes/v612/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v612/index.md,1,['validat'],['validation']
Security,"istribution.; Supports Importance Sampling: Improves sampling the tails of a distribution by generating toys from a user supplied importance density and a reweighing procedure of the result.; Supports Adaptive Sampling: extends the run until a given number of toys is reached in the tail(s).; Parallelization using PROOF(-Lite) is supported. It is enabled by supplying a ProofConfig instance. BayesianCalculator. Improve the way the class performs the numerical integration to; find the interval and/or the posterior function.; In case of complex; numerical calculation add the method SetScanOfPosterior(nbins) for; scanning the posterior function in a givn number of nbins; Add possibility to compute lower/upper limits using the method; SetLeftSideTailFraction(fraction); Add possibility to compute shortest interval using; SetShortestInterval. MCMCCalculator. Various improvements including possibility to compute; lower/central/upper limits using; SetLeftSideTailFraction(fraction). New Tutorials. New Demos that take name for file, workspace, modelconfig, and data, then use the corresponding calculator tool. If the file is not specified it will read an file produced from running the HistFactory tutorial example. StandardProfileLikelihoodDemo.C: ; StandardFeldmanCousinsDemo.C: ; StandardBayesianMCMCDemo.C: ; StandardBayesianNumericalDemo.C: ; StandardProfileInspectorDemo.C: . Demonstrate some new PDFs. TestNonCentral.C: demonstrates non central chi-square; JeffreysPriorDemo.C: demonstrates Jeffreys Prior. Instructional Examples. IntervalExamples.C: Standard Gaussian with known answer using 4 techniques; FourBinInstructional.C: Example of a standard data-driven approach for estimating backgrounds. A lot of discussion.; HybridInstructional.C: Example of prototype on/off problem with a data-driven background estimate. A lot of discussion; HybridStandardForm.C: Variant on above in 'standard form'; MultivariateGaussianTest.C: A validation example with an N-D multivariate Gaussian . ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html:9583,validat,validation,9583,roofit/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v528/index.html,2,['validat'],['validation']
Security,"it is an arbitrary data value. #### '`llvm.ptrauth.blend`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.blend(i64 <address discriminator>, i64 <integer discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.blend`' intrinsic blends a pointer address discriminator; with a small integer discriminator to produce a new ""blended"" discriminator. ##### Arguments:. The `address discriminator` argument is a pointer value.; The `integer discriminator` argument is a small integer, as specified by the; target. ##### Semantics:. The '`llvm.ptrauth.blend`' intrinsic combines a small integer discriminator; with a pointer address discriminator, in a way that is specified by the target; implementation. ### Operand Bundle. Function pointers used as indirect call targets can be signed when materialized,; and authenticated before calls. This can be accomplished with the; [`llvm.ptrauth.auth`](#llvm-ptrauth-auth) intrinsic, feeding its result to; an indirect call. However, that exposes the intermediate, unauthenticated pointer, e.g., if it; gets spilled to the stack. An attacker can then overwrite the pointer in; memory, negating the security benefit provided by pointer authentication.; To prevent that, the `ptrauth` operand bundle may be used: it guarantees that; the intermediate call target is kept in a register and never stored to memory.; This hardening benefit is similar to that provided by; [`llvm.ptrauth.resign`](#llvm-ptrauth-resign)). Concretely:. ```llvm; define void @f(void ()* %fp) {; call void %fp() [ ""ptrauth""(i32 <key>, i64 <data>) ]; ret void; }; ```. is functionally equivalent to:. ```llvm; define void @f(void ()* %fp) {; %fp_i = ptrtoint void ()* %fp to i64; %fp_auth = call i64 @llvm.ptrauth.auth(i64 %fp_i, i32 <key>, i64 <data>); %fp_auth_p = inttoptr i64 %fp_auth to void ()*; call void %fp_auth_p(); ret void; }; ```. but with the added guarantee that `%fp_i`, `%fp_auth`, and `%fp_auth_p`; are not stored to (and reloaded from) memory. ## AArch64 Support. AArc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:6682,expose,exposes,6682,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,1,['expose'],['exposes']
Security,"it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitiz",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2788,sanitiz,sanitize-recover,2788,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitize-recover']
Security,"itcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that for GFX7-GFX9 ``flat_load/store/atomic`` instructions can report out of; vector memory order if they access LDS memory, and out of LDS operation order; if they access global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore, no special action is required for coherence between the; lanes of a single wavefront, or for coherence between wavefronts in the same; work-group. A ``buffer_wbinvl1_vol`` is required for coherence between; wavefronts executing in different work-groups as they may be executing on; different CUs.; * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a group of CUs. The scalar and vector L1 caches are not coherent. However,; scalar operations are used in a restricted way so do not impact the memory; model. See :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory operations use an L2 cache shared by all CUs on; the same agent.; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each CU has a separate request queue per channel. Therefore, the vector and; scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different CUs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0)`` is required to; ensure synchronization between vector memory operations of different CUs. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire and release.; * The L2",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:208118,access,access,208118,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"ith byte; alignment) followed by a uint64_t (with 8-byte alignment), then the block; will have 8-byte alignment with an alignment offset of 7. * list of ``Edge`` instances. An iterator range for this list is returned by; the ``edges`` method. The ``Edge`` class is described in more detail below. * ``Symbol`` -- An offset from an ``Addressable`` (often a ``Block``), with an; optional ``Name``, a ``Linkage``, a ``Scope``, a ``Callable`` flag, and a; ``Live`` flag. Symbols make it possible to name content (blocks and addressables are; anonymous), or target content with an ``Edge``. * ``Name`` is represented as an ``llvm::StringRef`` (equal to; ``llvm::StringRef()`` if the symbol has no name), and accessible via the; ``getName`` method. * ``Linkage`` is one of *Strong* or *Weak*, and is accessible via the; ``getLinkage`` method. The ``JITLinkContext`` can use this flag to determine; whether this symbol definition should be kept or dropped. * ``Scope`` is one of *Default*, *Hidden*, or *Local*, and is accessible via; the ``getScope`` method. The ``JITLinkContext`` can use this to determine; who should be able to see the symbol. A symbol with default scope should be; globally visible. A symbol with hidden scope should be visible to other; definitions within the same simulated dylib (e.g. ORC ``JITDylib``) or; executable, but not from elsewhere. A symbol with local scope should only be; visible within the current ``LinkGraph``. * ``Callable`` is a boolean which is set to true if this symbol can be called,; and is accessible via the ``isCallable`` method. This can be used to; automate the introduction of call-stubs for lazy compilation. * ``Live`` is a boolean that can be set to mark this symbol as root for; dead-stripping purposes (see :ref:`generic_link_algorithm`). JITLink's; dead-stripping algorithm will propagate liveness flags through the graph to; all reachable symbols before deleting any symbols (and blocks) that are not; marked live. * ``Edge`` -- A quad of an ``Off",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:10517,access,accessible,10517,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security,"ith; IR-level operations. For example, it may be desirable to; know the structure/union name and the original user-level field; indices. Such information got lost in IR GetElementPtr instruction; since the IR types are different from debugInfo types and unions; are converted to structs in IR. '``llvm.preserve.array.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.array.access.index.p0s_union.anons.p0a10s_union.anons(<type> base,; i32 dim,; i32 index). Overview:; """""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic returns the getelementptr address; based on array base ``base``, array dimension ``dim`` and the last access index ``index``; into the array. The return type ``ret_type`` is a pointer type to the array element.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{dim's 0's, index}``. '``llvm.preserve.union.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <type>; @llvm.preserve.union.access.index.p0s_union.anons.p0s_union.anons(<typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:973174,access,access,973174,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ith; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78436,sanitiz,sanitizer,78436,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitizer']
Security,"itial adjustment. .. code-block:: c++. enum RelocationType {; reloc_pcrel_word = 0, // add reloc value after adjusting for the PC loc; reloc_picrel_word = 1, // add reloc value after adjusting for the PIC base; reloc_absolute_word = 2, // absolute relocation; no additional adjustment; reloc_absolute_dword = 3 // absolute relocation; no additional adjustment; };. Target JIT Info; ---------------. ``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific; code-generation activities, such as emitting machine code and stubs. At; minimum, a target-specific version of ``XXXJITInfo`` implements the following:. * ``getLazyResolverFunction`` --- Initializes the JIT, gives the target a; function that is used for compilation. * ``emitFunctionStub`` --- Returns a native function with a specified address; for a callback function. * ``relocate`` --- Changes the addresses of referenced globals, based on; relocation types. * Callback function that are wrappers to a function stub that is used when the; real target is not initially known. ``getLazyResolverFunction`` is generally trivial to implement. It makes the; incoming parameter as the global ``JITCompilerFunction`` and returns the; callback function that will be used a function wrapper. For the Alpha target; (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` implementation is; simply:. .. code-block:: c++. TargetJITInfo::LazyResolverFn AlphaJITInfo::getLazyResolverFunction(; JITCompilerFn F) {; JITCompilerFunction = F;; return AlphaCompilationCallback;; }. For the X86 target, the ``getLazyResolverFunction`` implementation is a little; more complicated, because it returns a different callback function for; processors with SSE instructions and XMM registers. The callback function initially saves and later restores the callee register; values, incoming arguments, and frame and return address. The callback; function needs low-level access to the registers or stack, so it is typically; implemented with assembler.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst:83586,access,access,83586,interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMBackend.rst,1,['access'],['access']
Security,"itializers; P0329R4; Clang 10. template-parameter-list for generic lambdas; P0428R2; Clang 9. Concepts; P0734R0; Clang 10. ; P0857R0; Clang 16. ; P1084R2; Clang 10. P1141R2. ; P0848R3. Clang 16 (Partial); Because of other concepts implementation deficits, the __cpp_concepts macro is not yet set to 202002L.; Also, the related defect reports DR1496 and; DR1734 are not yet implemented. Accordingly, deleted; special member functions are treated as eligible even though they shouldn't be.; . P1616R1; Clang 10. P1452R2. ; P1972R0; Clang 10. P1980R0. ; P2103R0. ; P2493R0. P2092R0; Clang 16. P2113R0; Clang 16. Range-based for statements with initializer; P0614R1; Clang 8. ADL and function templates that are not visible; P0846R0; Clang 9. const mismatch with defaulted copy constructor; P0641R2; Clang 8. Consistent comparison (operator<=>); P0515R3; Clang 10. ; P0905R1. ; P1120R0. ; P1185R2. ; P1186R3. P1630R1. ; P1946R0. P1959R0. ; P2002R1; Clang 17. P2085R0; Clang 14. Access checking on specializations; P0692R1; Clang 14. Default constructible and assignable stateless lambdas; P0624R2; Clang 8. Lambdas in unevaluated contexts; P0315R4; Clang 17. [[no_unique_address]] attribute; P0840R2; Clang 9. [[likely]] and [[unlikely]] attributes; P0479R5; Clang 12. typename optional in more contexts; P0634R3; Clang 16. Pack expansion in lambda init-capture; P0780R2; Clang 9. Class types as non-type template parameters; P0732R2; Clang 12. ; Generalized non-type template parameters of scalar type; P1907R1. Clang 18 (Partial); Reference type template arguments referring to instantiation-dependent objects and subobjects; (i.e. declared inside a template but neither type- nor value-dependent) aren't fully supported.; . Destroying operator delete; P0722R3; Clang 6. Relaxations of constexpr restrictions; P1064R0; Clang 9. ; P1002R1; Clang 8. P1327R1; Clang 9. P1330R0. ; P1331R2; Clang 10. P1668R1. P0784R7. Prohibit aggregates with user-declared constructors; P1008R1; Clang 8. Feature test macro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html:7063,Access,Access,7063,interpreter/llvm-project/clang/www/cxx_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_status.html,1,['Access'],['Access']
Security,"itizer are not undefined behavior,; but are often unintentional.; - ``-fsanitize=integer-divide-by-zero``: Integer division by zero.; - ``-fsanitize=nonnull-attribute``: Passing null pointer as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7172,access,accessed,7172,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['access'],['accessed']
Security,itizer_addrhashmap_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_chained_origin_depot_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_dense_map_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_flat_map_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_hash_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_leb128_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_lzw_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_stackdepot_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_stack_store_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_stoptheworld_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_test_main.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_type_traits_test.cpp; compiler-rt/lib/scudo/standalone/allocator_config.h; compiler-rt/lib/scudo/standalone/atomic_helpers.h; compiler-rt/lib/scudo/standalone/bytemap.h; compiler-rt/lib/scudo/standalone/checksum.cpp; compiler-rt/lib/scudo/standalone/checksum.h; compiler-rt/lib/scudo/standalone/chunk.h; compiler-rt/lib/scudo/standalone/combined.h; compiler-rt/lib/scudo/standalone/common.cpp; compiler-rt/lib/scudo/standalone/common.h; compiler-rt/lib/scudo/standalone/crc32_hw.cpp; compiler-rt/lib/scudo/standalone/flags.cpp; compiler-rt/lib/scudo/standalone/flags.h; compiler-rt/lib/scudo/standalone/flags_parser.cpp; compiler-rt/lib/scudo/standalone/flags_parser.h; compiler-rt/lib/scudo/standalone/fuchsia.cpp; compiler-rt/lib/scudo/standalone/fuchsia.h; compiler-rt/lib/scudo/standalone/internal_defs.h; compiler-rt/lib/scudo/standalone/linux.cpp; compiler-rt/lib/scudo/standalone/linux.h; compiler-rt/lib/scudo/standalone/list.h; compiler-rt/lib/scudo/standalone/local_cache.h; compiler-rt/lib/scudo/standalone/memtag.h; compiler-rt/lib/scudo/standalone/mutex.h; compiler-rt/lib/scudo/standalone/options.h; compiler-rt/lib/scudo/standalone/platform.h; compiler-rt/lib/scudo/standalone/primary32.h; compiler-rt/lib/scudo/standalon,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:100129,checksum,checksum,100129,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['checksum'],['checksum']
Security,"itnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3874,access,access,3874,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,1,['access'],['access']
Security,"ivate; segment address when using the Scratch Segment Buffer (see; :ref:`amdgpu-amdhsa-kernel-prolog-private-segment-buffer`). * If the *Target Properties* column of :ref:`amdgpu-processor-table`; specifies *Architected flat scratch*:. If ENABLE_PRIVATE_SEGMENT is enabled in; :ref:`amdgpu-amdhsa-compute_pgm_rsrc2-gfx6-gfx12-table` then the FLAT_SCRATCH; register pair will be initialized to the 64-bit address of the base of scratch; backing memory being managed by SPI for the queue executing the kernel; dispatch plus the value of the wave's Scratch Wavefront Offset for use as the; flat scratch base in flat memory instructions. .. _amdgpu-amdhsa-kernel-prolog-private-segment-buffer:. Private Segment Buffer; ++++++++++++++++++++++. If the *Target Properties* column of :ref:`amdgpu-processor-table` specifies; *Architected flat scratch* then a Private Segment Buffer is not supported.; Instead the flat SCRATCH instructions are used. Otherwise, Private Segment Buffer SGPR register is used to initialize 4 SGPRs; that are used as a V# to access scratch. CP uses the value provided by the; runtime. It is used, together with Scratch Wavefront Offset as an offset, to; access the private memory space using a segment address. See; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`. The scratch V# is a four-aligned SGPR and always selected for the kernel as; follows:. - If it is known during instruction selection that there is stack usage,; SGPR0-3 is reserved for use as the scratch V#. Stack usage is assumed if; optimizations are disabled (``-O0``), if stack objects already exist (for; locals, etc.), or if there are any function calls. - Otherwise, four high numbered SGPRs beginning at a four-aligned SGPR index; are reserved for the tentative scratch V#. These will be used if it is; determined that spilling is needed. - If no use is made of the tentative scratch V#, then it is unreserved,; and the register count is determined ignoring it.; - If use is made of the tentative scratc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:198427,access,access,198427,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"ization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4263,attack,attacker,4263,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['attack'],['attacker']
Security,"izer restriction which applies in; concurrent environments, which gets a bit more of an extended description; because any optimization dealing with stores needs to be aware of it. From the optimizer's point of view, the rule is that if there are not any; instructions with atomic ordering involved, concurrency does not matter, with; one exception: if a variable might be visible to another thread or signal; handler, a store cannot be inserted along a path where it might not execute; otherwise. Take the following example:. .. code-block:: c. /* C code, for readability; run through clang -O2 -S -emit-llvm to get; equivalent IR */; int x;; void f(int* a) {; for (int i = 0; i < 100; i++) {; if (a[i]); x += 1;; }; }. The following is equivalent in non-concurrent situations:. .. code-block:: c. int x;; void f(int* a) {; int xtemp = x;; for (int i = 0; i < 100; i++) {; if (a[i]); xtemp += 1;; }; x = xtemp;; }. However, LLVM is not allowed to transform the former to the latter: it could; indirectly introduce undefined behavior if another thread can access ``x`` at; the same time. That thread would read `undef` instead of the value it was; expecting, which can lead to undefined behavior down the line. (This example is; particularly of interest because before the concurrency model was implemented,; LLVM would perform this transformation.). Note that speculative loads are allowed; a load which is part of a race returns; ``undef``, but does not have undefined behavior. Atomic instructions; ===================. For cases where simple loads and stores are not sufficient, LLVM provides; various atomic instructions. The exact guarantees provided depend on the; ordering; see `Atomic orderings`_. ``load atomic`` and ``store atomic`` provide the same basic functionality as; non-atomic loads and stores, but provide additional guarantees in situations; where threads and signals are involved. ``cmpxchg`` and ``atomicrmw`` are essentially like an atomic load followed by an; atomic store (wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:3720,access,access,3720,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['access'],['access']
Security,izer-list constructors; Unknown. 1509; C++14; Definition of “non-template function”; Unknown. 1510; CD3; cv-qualified references via decltype; Unknown. 1511; CD3; const volatile variables and the one-definition rule; Unknown. 1512; CD3; Pointer comparison vs qualification conversions; Clang 4. 1513; drafting; initializer_list deduction failure; Not resolved. 1514; C++14; Ambiguity between enumeration definition and zero-length bit-field; Clang 11. 1515; CD3; Modulo 2n arithmetic for implicitly-unsigned types; Unknown. 1516; CD3; Definition of “virtual function call”; Unknown. 1517; drafting; Unclear/missing description of behavior during construction/destruction; Not resolved. 1518; CD4; Explicit default constructors and copy-list-initialization; Clang 4. 1519; NAD; Conflicting default and variadic constructors; Unknown. 1520; NAD; Alias template specialization vs pack expansion; Unknown. 1521; drafting; T{expr} with reference types; Not resolved. 1522; CD3; Access checking for initializer_list array initialization; Unknown. 1523; CD5; Point of declaration in range-based for; Unknown. 1524; drafting; Incompletely-defined class template base; Not resolved. 1525; NAD; Array bound inference in temporary array; Unknown. 1526; dup; Dependent-class lookup in the current instantiation; Unknown. 1527; CD3; Assignment from braced-init-list; Unknown. 1528; CD3; Repeated cv-qualifiers in declarators; Unknown. 1529; drafting; Nomenclature for variable vs reference non-static data member; Not resolved. 1530; drafting; Member access in out-of-lifetime objects; Not resolved. 1531; CD3; Definition of “access” (verb); Unknown. 1532; CD3; Explicit instantiation and member templates; Unknown. 1533; CD3; Function pack expansion for member initialization; Unknown. 1534; dup; cv-qualification of prvalue of type “array of class”; Unknown. 1535; CD3; typeid in core constant expressions; Unknown. 1536; drafting; Overload resolution with temporary from initializer list; Not resolved. 1537; CD,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:102412,Access,Access,102412,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"ject member functions with the same parameter-type-lists; Unknown. 2693; open; Escape sequences for the string-literal of #line; Not resolved. 2694; open; string-literals of the _Pragma operator; Not resolved. 2695; C++23; Semantic ignorability of attributes; Unknown. 2696; dup; Relational comparisons of pointers to void; Unknown. 2697; DRWP; Deduction guides using abbreviated function syntax; Unknown. 2698; DRWP; Using extended integer types with z suffix; Unknown. 2699; DRWP; Inconsistency of throw-expression specification; Unknown. 2700; review; #error disallows existing implementation practice; Not resolved. 2701; open; Default arguments in multiple scopes / inheritance of array bounds in the same scope; Not resolved. 2702; open; Constant destruction of reference members; Not resolved. 2703; review; Three-way comparison requiring strong ordering for floating-point types, take 2; Not resolved. 2704; open; Clarify meaning of ""bind directly""; Not resolved. 2705; open; Accessing ambiguous subobjects; Not resolved. 2706; open; Repeated structured binding declarations; Not resolved. 2707; tentatively ready; Deduction guides cannot have a trailing requires-clause; Unknown. 2708; DRWP; Parenthesized initialization of arrays; Unknown. 2709; NAD; Parenthesized initialization of reference-to-aggregate; Unknown. 2710; DRWP; Loops in constant expressions; Unknown. 2711; DRWP; Source for copy-initializing the exception object; Unknown. 2712; DRWP; Simplify restrictions on built-in assignment operator candidates; Unknown. 2713; DRWP; Initialization of reference-to-aggregate from designated initializer list; Unknown. 2714; open; Implicit deduction guides omit properties from the parameter-declaration-clause of a constructor; Not resolved. 2715; DRWP; ""calling function"" for parameter initialization may not exist; Unknown. 2716; DRWP; Rule about self-or-base conversion is normatively redundant; Unknown. 2717; DRWP; Pack expansion for alignment-specifier; Unknown. 2718; DRWP; Type",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:186868,Access,Accessing,186868,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Accessing']
Security,ject/issues/78128>`_). - Clang now allows parenthesized initialization of arrays in `operator new[]`.; Fixes: (`#68198 <https://github.com/llvm/llvm-project/issues/68198>`_). - Fixes CTAD for aggregates on nested template classes. Fixes:; (`#77599 <https://github.com/llvm/llvm-project/issues/77599>`_). - Fix crash when importing the same module with an dynamic initializer twice; in different visibility.; Fixes (`#67893 <https://github.com/llvm/llvm-project/issues/67893>`_). - Remove recorded `#pragma once` state for headers included in named modules.; Fixes (`#77995 <https://github.com/llvm/llvm-project/issues/77995>`_). - Set the ``__cpp_auto_cast`` feature test macro in C++23 mode. - Fix crash for inconsistent deducing state of function return types; in importing modules.; Fixes (`#78830 <https://github.com/llvm/llvm-project/issues/78830>`_); Fixes (`#60085 <https://github.com/llvm/llvm-project/issues/60085>`_). - Fixed a bug where variables referenced by requires-clauses inside; nested generic lambdas were not properly injected into the constraint scope.; (`#73418 <https://github.com/llvm/llvm-project/issues/73418>`_). - Fix incorrect code generation caused by the object argument of ``static operator()`` and ``static operator[]`` calls not being evaluated.; Fixes (`#67976 <https://github.com/llvm/llvm-project/issues/67976>`_). - Fix crash when using an immediate-escalated function at global scope.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Correctly immediate-escalate lambda conversion functions.; (`#82258 <https://github.com/llvm/llvm-project/issues/82258>`_); - Fix a crash when an unresolved overload set is encountered on the RHS of a ``.*`` operator.; (`#53815 <https://github.com/llvm/llvm-project/issues/53815>`_). - Fixed a regression in CTAD that a friend declaration that befriends itself may cause; incorrect constraint substitution.; (`#86769 <https://github.com/llvm/llvm-project/issues/86769>`_). Bug Fixes to AST Handling; ^^^^^^^^,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:55314,inject,injected,55314,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['inject'],['injected']
Security,"k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=und",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2401,sanitiz,sanitize-recover,2401,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitize-recover']
Security,"k in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:4119,integrity,integrity,4119,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['integrity'],['integrity']
Security,"k traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More Information; ----------------; `<https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:5195,sanitiz,sanitizers,5195,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,1,['sanitiz'],['sanitizers']
Security,"kGraph`` type represents these concepts as a decorated; graph. Nodes in the graph represent symbols and content, and edges represent; relocations. Each of the elements of the graph is listed here:. * ``Addressable`` -- A node in the link graph that can be assigned an address; in the executor process's virtual address space. Absolute and external symbols are represented using plain ``Addressable``; instances. Content defined inside the object file is represented using the; ``Block`` subclass. * ``Block`` -- An ``Addressable`` node that has ``Content`` (or is marked as; zero-filled), a parent ``Section``, a ``Size``, an ``Alignment`` (and an; ``AlignmentOffset``), and a list of ``Edge`` instances. Blocks provide a container for binary content which must remain contiguous in; the target address space (a *layout unit*). Many interesting low level; operations on ``LinkGraph`` instances involve inspecting or mutating block; content or edges. * ``Content`` is represented as an ``llvm::StringRef``, and accessible via; the ``getContent`` method. Content is only available for content blocks,; and not for zero-fill blocks (use ``isZeroFill`` to check, and prefer; ``getSize`` when only the block size is needed as it works for both; zero-fill and content blocks). * ``Section`` is represented as a ``Section&`` reference, and accessible via; the ``getSection`` method. The ``Section`` class is described in more detail; below. * ``Size`` is represented as a ``size_t``, and is accessible via the; ``getSize`` method for both content and zero-filled blocks. * ``Alignment`` is represented as a ``uint64_t``, and available via the; ``getAlignment`` method. It represents the minimum alignment requirement (in; bytes) of the start of the block. * ``AlignmentOffset`` is represented as a ``uint64_t``, and accessible via the; ``getAlignmentOffset`` method. It represents the offset from the alignment; required for the start of the block. This is required to support blocks; whose minimum alignment",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:8398,access,accessible,8398,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security,"k_lo] Low 32 bits of *xnack mask* register (an SP3 syntax).; [xnack_mask_hi] High 32 bits of *xnack mask* register (an SP3 syntax).; ===================== ==============================================================. .. _amdgpu_synid_vcc:; .. _amdgpu_synid_vcc_lo:. vcc; ---. Vector condition code, 64-bits wide. A bit mask with one bit per thread;; it holds the result of a vector compare operation. Note that GFX10+ H/W does not use high 32 bits of *vcc* in *wave32* mode. ================ =========================================================================; Syntax Description; ================ =========================================================================; vcc 64-bit *vector condition code* register.; [vcc] 64-bit *vector condition code* register (an SP3 syntax).; [vcc_lo,vcc_hi] 64-bit *vector condition code* register (an SP3 syntax).; ================ =========================================================================. High and low 32 bits of *vector condition code* may be accessed as separate registers:. ================ =========================================================================; Syntax Description; ================ =========================================================================; vcc_lo Low 32 bits of *vector condition code* register.; vcc_hi High 32 bits of *vector condition code* register.; [vcc_lo] Low 32 bits of *vector condition code* register (an SP3 syntax).; [vcc_hi] High 32 bits of *vector condition code* register (an SP3 syntax).; ================ =========================================================================. .. _amdgpu_synid_m0:. m0; --. A 32-bit memory register. It has various uses,; including register indexing and bounds checking. =========== ===================================================; Syntax Description; =========== ===================================================; m0 A 32-bit *memory* register.; [m0] A 32-bit *memory* register (an SP3 syntax).; =========== ======================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:18168,access,accessed,18168,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['access'],['accessed']
Security,"kdir test-suite-build; % cd test-suite-build; % cmake -DCMAKE_C_COMPILER=<path to llvm build>/bin/clang \; -C../test-suite/cmake/caches/O3.cmake \; ../test-suite; ```. **NOTE!** if you are using your built clang, and you want to build and run the; MicroBenchmarks/XRay microbenchmarks, you need to add `compiler-rt` to your; `LLVM_ENABLE_RUNTIMES` cmake flag. 4. Build the benchmarks:. ```text; % make; Scanning dependencies of target timeit-target; [ 0%] Building C object tools/CMakeFiles/timeit-target.dir/timeit.c.o; [ 0%] Linking C executable timeit-target; ...; ```. 5. Run the tests with lit:. ```text; % llvm-lit -v -j 1 -o results.json .; -- Testing: 474 tests, 1 threads --; PASS: test-suite :: MultiSource/Applications/ALAC/decode/alacconvert-decode.test (1 of 474); ********** TEST 'test-suite :: MultiSource/Applications/ALAC/decode/alacconvert-decode.test' RESULTS **********; compile_time: 0.2192; exec_time: 0.0462; hash: ""59620e187c6ac38b36382685ccd2b63b""; size: 83348; **********; PASS: test-suite :: MultiSource/Applications/ALAC/encode/alacconvert-encode.test (2 of 474); ...; ```. 6. Show and compare result files (optional):. ```bash; # Make sure pandas and scipy are installed. Prepend `sudo` if necessary.; % pip install pandas scipy; # Show a single result file:; % test-suite/utils/compare.py results.json; # Compare two result files:; % test-suite/utils/compare.py results_a.json results_b.json; ```. Structure; ---------. The test-suite contains benchmark and test programs. The programs come with; reference outputs so that their correctness can be checked. The suite comes; with tools to collect metrics such as benchmark runtime, compilation time and; code size. The test-suite is divided into several directories:. - `SingleSource/`. Contains test programs that are only a single source file in size. A; subdirectory may contain several programs. - `MultiSource/`. Contains subdirectories which entire programs with multiple source files.; Large benchmarks and whole ap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md:1759,hash,hash,1759,interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestSuiteGuide.md,1,['hash'],['hash']
Security,"ker symbols*.; All cppyy uses, the basic and the more advanced, are variations on the; theme of bringing these two together at the point of use. Definitions typically live in header files and symbols in libraries.; Headers can be loaded with ``cppyy.include`` and libraries with the; ``cppyy.load_library`` call.; Loading the header is sufficient to start exploring, with ``cppyy.gbl`` the; starting point of all things C++, while the linker symbols are only needed at ; the point of first use. Here is an example using the `zlib`_ library, which is likely available on; your system:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('zlib.h') # bring in C++ definitions; >>> cppyy.load_library('libz') # load linker symbols; >>> cppyy.gbl.zlibVersion() # use a zlib API; '1.2.11'; >>>. Since header files can include other header files, it is easy to aggregate; all relevant ones into a single header to include.; If there are project-specific include paths, you can add those paths through; ``cppyy.add_include_path``.; If a header is C-only and not set for use with C++, use ``cppyy.c_include``,; which adds ``extern ""C""`` around the header. Library files can be aggregated by linking all relevant ones to a single; library to load.; Using the linker for this purpose allows regular system features such as; ``rpath`` and envars such as ``LD_LIBRARY_PATH`` to be applied as usual.; Note that any mechanism that exposes the library symbols will work.; For example, you could also use the standard module ``ctypes`` through; ``ctypes.CDLL`` with the ``ctypes.RTLD_GLOBAL`` option. To explore, start from ``cppyy.gbl`` to access your namespaces, classes,; functions, etc., etc. directly; or use python's ``dir`` (or tab-completion); to see what is available.; Use python's ``help`` to see list the methods and data members of classes and; see the interfaces of functions. Now try this out for some of your own headers, libraries, and APIs!. .. _`zlib`: https://en.wikipedia.org/wiki/Zlib; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst:2307,expose,exposes,2307,bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/starting.rst,2,"['access', 'expose']","['access', 'exposes']"
Security,"ker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefine",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2122,sanitiz,sanitize,2122,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitize']
Security,"known to be dereferenceable; prior to a call to a function with the ``nofree`` attribute are still; known to be dereferenceable after the call. The capturing condition is; necessary in environments where the function might communicate the; pointer to another thread which then deallocates the memory. Alternatively,; ``nosync`` would ensure such communication cannot happen and even captured; pointers cannot be freed by the function. A ``nofree`` function is explicitly allowed to free memory which it; allocated or (if not ``nosync``) arrange for another thread to free; memory on it's behalf. As a result, perhaps surprisingly, a ``nofree``; function can return a pointer to a previously deallocated memory object.; ``noimplicitfloat``; Disallows implicit floating-point code. This inhibits optimizations that; use floating-point code and floating-point registers for operations that are; not nominally floating-point. LLVM instructions that perform floating-point; operations or require access to floating-point registers may still cause; floating-point code to be generated. Also inhibits optimizations that create SIMD/vector code and registers from; scalar code such as vectorization or memcpy/memset optimization. This; includes integer vectors. Vector instructions present in IR may still cause; vector code to be generated.; ``noinline``; This attribute indicates that the inliner should never inline this; function in any situation. This attribute may not be used together; with the ``alwaysinline`` attribute.; ``nomerge``; This attribute indicates that calls to this function should never be merged; during optimization. For example, it will prevent tail merging otherwise; identical code sequences that raise an exception or terminate the program.; Tail merging normally reduces the precision of source location information,; making stack traces less useful for debugging. This attribute gives the; user control over the tradeoff between code size and debug information; precision.; ``n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:90360,access,access,90360,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"l be; preserved by the callee across the call. This doesn't apply for values; returned in callee-saved registers. - On X86-64 the callee preserves all general purpose registers, except for; R11. R11 can be used as a scratch register. Furthermore it also preserves; all floating-point registers (XMMs/YMMs). - On AArch64 the callee preserve all general purpose registers, except X0-X8; and X16-X18. Furthermore it also preserves lower 128 bits of V8-V31 SIMD -; floating point registers. The idea behind this convention is to support calls to runtime functions; that don't need to call out to any other functions. This calling convention, like the `PreserveMost` calling convention, will be; used by a future version of the ObjectiveC runtime and should be considered; experimental at this time.; ""``cxx_fast_tlscc``"" - The `CXX_FAST_TLS` calling convention for access functions; Clang generates an access function to access C++-style TLS. The access; function generally has an entry block, an exit block and an initialization; block that is run at the first time. The entry and exit blocks can access; a few TLS IR variables, each access will be lowered to a platform-specific; sequence. This calling convention aims to minimize overhead in the caller by; preserving as many registers as possible (all the registers that are; preserved on the fast path, composed of the entry and exit blocks). This calling convention behaves identical to the `C` calling convention on; how arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. Given that each platform has its own lowering sequence, hence its own set; of preserved registers, we can't use the existing `PreserveMost`. - On X86-64 the callee preserves all general purpose registers, except for; RDI and RAX.; ""``tailcc``"" - Tail callable calling convention; This calling convention ensures that calls in tail position will always be; tail call optimized. This calling convention is equivalent to fastcc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:20026,access,access,20026,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"l operations like plotting and storing of results happen in; `SlaveTerminate()` or `Terminate()`. The entry points `SlaveBegin()` and `SlaveTerminate()` are called on; so-called slave nodes only if parallel processing via `PROOF` or; `PROOF lite` is enabled, as will be explained below. A simple example of a selector class is shown in the macro; `MySelector.C`. The example is executed with the following sequence of; commands:. ``` {.cpp}; > TChain *ch=new TChain(""cond_data"", ""Chain for Example N-Tuple"");; > ch->Add(""conductivity_experiment*.root"");; > ch->Process(""MySelector.C+"");; ```. As usual, the ""`+`"" appended to the name of the macro to be executed; initiates the compilation of the `MySelector.C` with the system compiler; in order to improve performance. The code in `MySelector.C`, shown in the listing below, books some; histograms in `SlaveBegin()` and adds them to the instance `fOutput`,; which is of the class `TList` [^6]. The final processing in; `Terminate()` allows to access histograms and store, display or save; them as pictures. This is shown in the example via the `TList`; `fOutput`. See the commented listing below for more details; most of the; text is actually comments generated automatically by; `TTree::MakeSelector`. ``` {.cpp}; @ROOT_INCLUDE_FILE macros/MySelector.C; ```. ### *For power-users:* Multi-core processing with `PROOF lite` ###. The processing of n-tuples via a selector function of type `TSelector`; through `TChain::Process()`, as described at the end of the previous; section, offers an additional advantage in particular for very large; data sets: on distributed systems or multi-core architectures, portions; of data can be processed in parallel, thus significantly reducing the; execution time. On modern computers with multi-core CPUs or; hardware-threading enabled, this allows a much faster turnaround of; analyses, since all the available CPU power is used. On distributed systems, a PROOF server and worker nodes have to be set; up, as des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md:8526,access,access,8526,documentation/primer/filio.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/filio.md,1,['access'],['access']
Security,"l section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22718,access,access,22718,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['access'],['access']
Security,"l table. .. option:: --dynamic-table, --dynamic, -d. Display the dynamic table. .. option:: --cg-profile. Display the callgraph profile section. .. option:: --histogram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output is an expanded and structured format.; ``GNU`` (the default) output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --extra-sym-info. Display extra information (section name) when showing symbols. .. option:: --section-groups, -g. Display section groups. .. option:: --expand-relocs. When used with :option:`--relocations`, display each relocation in an expanded; multi-line format. .. option:: --file-header, -h. Display file headers. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dynamic symbols. .. option:: --headers, -e. Equivalent to setting: :option:`--file-header`, :option:`--program-headers`,; and :option:`--sections`. .. option:: --help. Display a summary of command line options. .. option:: --hex-dump=<section[,section,...]>, -x. Display the specified section(s) as hexadecimal bytes. ``section`` may be a; section index or section name. .. option:: --memtag. Display information about memory tagging present in the binary. This includes; various memtag-specific dynamic entries, decoded global descriptor sections,; and decoded Android-specific ELF notes. .. option:: --needed-libs. Display the needed libraries. .. option:: --no-demangle. Do not display demangled symbol names in the output. On by default. .. option:: --notes, -n. Display all notes. .. option:: -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst:2403,hash,hash-table,2403,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,1,['hash'],['hash-table']
Security,"l to that of RooMinuit; with two extensions. The setMinimizer(const char*) method allows to choose between ""minuit"" and ""minuit2""); as implementation for migrad(),hesse(),minos() etc...; The minimizer(const char* package, const char* alg) provides a completely generic interface; to all minimizers, where package is the package (minuit,GSLminimizer) and alg is the algorithm (migrad) to be used. By default, RooMinuit is still used when RooAbsPdf::fitTo() is called, but can be overridden with; a Minimizer() named argument. // Minimization with MINUIT/MIGRAD through RooMinuit; pdf->fitTo(data) ;. // Minimization with MINUIT/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit"")) ;. // Minimization with MINUIT2/MIGRAD through RooMinimizer; pdf->fitTo(data,Minimizer(""minuit2"")) ;. // Minimization with GSLMultiMin/conjugatefr through RooMinimizer; pdf->fitTo(data,Minimizer(""GSLMultiMin"",""conjugatefr"")) ;. Note that installation of GSL and the ROOT MathMore package is needed to access the GSL Minimizers and that the GSL; Minimizer do not implement error analysis. New numeric integration algorithms available; RooFit can now interface all MathCore numeric integration; algorithms. In this release ROOT::Math::AdaptiveIntegratorMultiDim,; which implements the 'Genz & Malik' algorithm has been interfaced; in RooAdaptiveIntegratorND and is now the default numeric integrator; for numeric integrations in two or more dimensions. This new default integrator has much improved stability and speed; for relatively smooth p.d.f.s in two or three dimensions and can; generally be used well for p.d.f. normalization integrals without; causing MINUIT converge problems due to numeric precision issues. In future release some more numeric integrators will be migrated to; a MathCore implementation. Interface to TFoam adaptive MC sampler added; RooFit can now use the TFoam adaptive MC sampler for event generation of p.d.f.s that; do not have an internal generator. The TFoam generator adapti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:4436,access,access,4436,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['access'],['access']
Security,"l variations or *subtargets* of the PowerPC; ISA; including ppc32, ppc64 and altivec. LLVM PowerPC ABI; ^^^^^^^^^^^^^^^^. LLVM follows the AIX PowerPC ABI, with two deviations. LLVM uses a PC relative; (PIC) or static addressing for accessing global values, so no TOC (r2) is; used. Second, r31 is used as a frame pointer to allow dynamic growth of a stack; frame. LLVM takes advantage of having no TOC to provide space to save the frame; pointer in the PowerPC linkage area of the caller frame. Other details of; PowerPC ABI can be found at `PowerPC ABI; <http://developer.apple.com/documentation/DeveloperTools/Conceptual/LowLevelABI/Articles/32bitPowerPC.html>`_\; . Note: This link describes the 32 bit ABI. The 64 bit ABI is similar except; space for GPRs are 8 bytes wide (not 4) and r13 is reserved for system use. Frame Layout; ^^^^^^^^^^^^. The size of a PowerPC frame is usually fixed for the duration of a function's; invocation. Since the frame is fixed size, all references into the frame can be; accessed via fixed offsets from the stack pointer. The exception to this is; when dynamic alloca or variable sized arrays are present, then a base pointer; (r31) is used as a proxy for the stack pointer and stack pointer is free to grow; or shrink. A base pointer is also used if llvm-gcc is not passed the; -fomit-frame-pointer flag. The stack pointer is always aligned to 16 bytes, so; that space allocated for altivec vectors will be properly aligned. An invocation frame is laid out as follows (low memory at top):. :raw-html:`<table border=""1"" cellspacing=""0"">`; :raw-html:`<tr>`; :raw-html:`<td>Linkage<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Parameter area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Dynamic area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Locals area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr>`; :raw-html:`<td>Saved registers area<br><br></td>`; :raw-html:`</tr>`; :raw-html:`<tr sty",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:95350,access,accessed,95350,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accessed']
Security,"l volumes down; to the selected depth. ""*Leaves*"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""*Only*"" will allow drawing only the edited; volume. The check button ""*Raytrace*"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. ![Volume visualisation settings and division interface for volumes](pictures/020001F7.jpg); ![Volume visualisation settings and division interface for volumes](pictures/020001F8.jpg). - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""*From*"", ""*Step*""; and ""*Nslices*"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""*Materials*"" shutter item; category. Generally, for creating objects, the interface is always in; the **`TGeoManagerEditor`** in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""*Shapes*"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""*Medium*"" category. You will notice that some categories as ""*Volume*""; and ""*Medium*"" are inactive at the beginning because at that time there; is no mater",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:174070,validat,validate,174070,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['validat'],['validate']
Security,"l:. Ways to Contribute; ==================. Bug Reports; -----------; If you are working with LLVM and run into a bug, we definitely want to know; about it. Please let us know and follow the instructions in; :doc:`HowToSubmitABug` to create a bug report. Bug Fixes; ---------; If you are interested in contributing code to LLVM, bugs labeled with the; `good first issue`_ keyword in the `bug tracker`_ are a good way to get familiar with; the code base. If you are interested in fixing a bug please comment on it to; let people know you are working on it. Then try to reproduce and fix the bug with upstream LLVM. Start by building; LLVM from source as described in :doc:`GettingStarted` and; use the built binaries to reproduce the failure described in the bug. Use; a debug build (`-DCMAKE_BUILD_TYPE=Debug`) or a build with assertions; (`-DLLVM_ENABLE_ASSERTIONS=On`, enabled for Debug builds). Reporting a Security Issue; --------------------------. There is a separate process to submit security-related bugs, see :ref:`report-security-issue`. Bigger Pieces of Work; ---------------------; In case you are interested in taking on a bigger piece of work, a list of; interesting projects is maintained at the `LLVM's Open Projects page`_. In case; you are interested in working on any of these projects, please post on the; `Forum`_, so that we know the project is being worked on. .. _submit_patch:. How to Submit a Patch; =====================; Once you have a patch ready, it is time to submit it. The patch should:. * include a small unit test; * conform to the :doc:`CodingStandards`. You can use the `clang-format-diff.py`_ or `git-clang-format`_ tools to automatically format your patch properly.; * not contain any unrelated changes; * be an isolated change. Independent changes should be submitted as separate patches as this makes reviewing easier.; * have a single commit (unless stacked on another Differential), up-to-date with the upstream ``origin/main`` branch, and don't have merge",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst:1497,secur,security-related,1497,interpreter/llvm-project/llvm/docs/Contributing.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Contributing.rst,2,['secur'],"['security-issue', 'security-related']"
Security,"l; assert(ij_label & j_label); // ij_label has j_label; assert(!(ij_label & k_label)); // ij_label doesn't have k_label; assert(ij_label == 3); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ij_label, i_label));; assert(dfsan_has_label(ij_label, j_label));; assert(!dfsan_has_label(ij_label, k_label));. dfsan_label ijk_label = dfsan_get_label(i + j + k);. assert(ijk_label & i_label); // ijk_label has i_label; assert(ijk_label & j_label); // ijk_label has j_label; assert(ijk_label & k_label); // ijk_label has k_label; assert(ijk_label == 7); // Verifies all of the above. // Or, equivalently:; assert(dfsan_has_label(ijk_label, i_label));; assert(dfsan_has_label(ijk_label, j_label));; assert(dfsan_has_label(ijk_label, k_label));. return 0;; }. Origin Tracking; ===============. DataFlowSanitizer can track origins of labeled values. This feature is enabled by; ``-mllvm -dfsan-track-origins=1``. For example,. .. code-block:: console. % cat test.cc; #include <sanitizer/dfsan_interface.h>; #include <stdio.h>. int main(int argc, char** argv) {; int i = 0;; dfsan_set_label(i_label, &i, sizeof(i));; int j = i + 1;; dfsan_print_origin_trace(&j, ""A flow from i to j"");; return 0;; }. % clang++ -fsanitize=dataflow -mllvm -dfsan-track-origins=1 -fno-omit-frame-pointer -g -O2 test.cc; % ./a.out; Taint value 0x1 (at 0x7ffd42bf415c) origin tracking (A flow from i to j); Origin value: 0x13900001, Taint value was stored to memory at; #0 0x55676db85a62 in main test.cc:7:7; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. Origin value: 0x9e00001, Taint value was created at; #0 0x55676db85a08 in main test.cc:6:3; #1 0x7f0083611bbc in __libc_start_main libc-start.c:285. By ``-mllvm -dfsan-track-origins=1`` DataFlowSanitizer collects only; intermediate stores a labeled value went through. Origin tracking slows down; program execution by a factor of 2x on top of the usual DataFlowSanitizer; slowdown and increases memory overhead by 1x. By ``-mllvm -dfsan-tra",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:12445,sanitiz,sanitizer,12445,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,1,['sanitiz'],['sanitizer']
Security,"lStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side channels.; The intent is that the Android runtime `will do this`_, but the platform will; first need to be `changed`_ to avoid using ``setrlimit(RLIMIT_AS)`` to limit; memory allocations in certain processes, as this also limits the number of; guard regions that can be allocated. .. _`will do this`: https://android-review.googlesource.com/c/platform/bionic/+/891622; .. _`changed`: https://android-review.googlesource.com/c/platform/frameworks/av/+/837745. The runtime will need the address of the shadow call stack in order to; deallocate it when destroying the thread. If the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5720,attack,attacker,5720,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['attack'],['attacker']
Security,"larations of both; c and d. Matcher<Type>enumTypeMatcher<EnumType>...; Matches enum types. Given; enum C { Green };; enum class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48793,inject,injected,48793,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['inject'],['injected']
Security,"late path if you do a load or store with; lower-than-natural alignment. To avoid this, LLVM will emit a slower; sequence of loads, shifts and masks (or load-right + load-left on MIPS) for; all cases where the load / store does not have a sufficiently high alignment; in the IR. The alignment is used to guarantee the alignment on allocas and globals,; though in most cases this is unnecessary (most targets have a sufficiently; high default alignment that they’ll be fine). It is also used to provide a; contract to the back end saying ‘either this load/store has this alignment, or; it is undefined behavior’. This means that the back end is free to emit; instructions that rely on that alignment (and mid-level optimizers are free to; perform transforms that require that alignment). For x86, it doesn’t make; much difference, as almost all instructions are alignment-independent. For; MIPS, it can make a big difference. Note that if your loads and stores are atomic, the backend will be unable to; lower an under aligned access into a sequence of natively aligned accesses.; As a result, alignment is mandatory for atomic loads and stores. Other Things to Consider; ^^^^^^^^^^^^^^^^^^^^^^^^. #. Use ptrtoint/inttoptr sparingly (they interfere with pointer aliasing; analysis), prefer GEPs. #. Prefer globals over inttoptr of a constant address - this gives you; dereferencability information. In MCJIT, use getSymbolAddress to provide; actual address. #. Be wary of ordered and atomic memory operations. They are hard to optimize; and may not be well optimized by the current optimizer. Depending on your; source language, you may consider using fences instead. #. If calling a function which is known to throw an exception (unwind), use; an invoke with a normal destination which contains an unreachable; instruction. This form conveys to the optimizer that the call returns; abnormally. For an invoke which neither returns normally or requires unwind; code in the current function, you can use ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst:5857,access,access,5857,interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Frontend/PerformanceTips.rst,2,['access'],"['access', 'accesses']"
Security,"lated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63285,secur,security-ReturnPtrRange,63285,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security-ReturnPtrRange']
Security,lates; Yes. 589; CD2; Direct binding of class and array rvalues in reference initialization; Yes. 590; C++11; Nested classes and the “current instantiation”; Yes. 591; CD4; When a dependent base class is the current instantiation; No. 592; CD1; Exceptions during construction of local static objects; N/A. 593; NAD; Falling off the end of a destructor's function-try-block handler; Unknown. 594; CD1; Coordinating issues 119 and 404 with delegating constructors; N/A. 595; dup; Exception specifications in templates instantiated from class bodies; Duplicate of 1330. 596; NAD; Replacing an exception object; Unknown. 597; CD3; Conversions applied to out-of-lifetime non-POD lvalues; N/A. 598; CD2; Associated namespaces of overloaded functions and function templates; Yes. 599; CD2; Deleting a null function pointer; Partial. 600; CD6; Does access control apply to members or to names?; Clang 2.8. 601; CD2; Type of literals in preprocessing expressions; Yes. 602; C++11; When is the injected-class-name of a class template a template?; Yes. 603; CD1; Type equivalence and unsigned overflow; Yes. 604; CD2; Argument list for overload resolution in copy-initialization; N/A. 605; C++11; Linkage of explicit specializations; Unknown. 606; CD1; Template argument deduction for rvalue references; Clang 3.0. 607; CD6; Lookup of mem-initializer-ids; Yes. 608; CD2; Determining the final overrider of a virtual function; Yes. 609; CD4; What is a “top-level” cv-qualifier?; Unknown. 610; NAD; Computing the negative of 0U; Yes. 611; CD2; Zero-initializing references; Yes. 612; CD2; Requirements on a conforming implementation; N/A. 613; CD1; Unevaluated uses of non-static class members; Yes (C++11 onwards). 614; CD1; Results of integer / and %; Yes. 615; C++11; Incorrect description of variables that can be initialized; Yes. 616; CD3; Definition of “indeterminate value”; Clang 4. 617; NAD; Lvalue-to-rvalue conversions of uninitialized char objects; Unknown. 618; CD2; Casts in preprocessor conditiona,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:41297,inject,injected-class-name,41297,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injected-class-name']
Security,"lations requires adaption to; work with SafeStack. One example is mark-and-sweep garbage collection; implementations for C/C++ (e.g., Oilpan in chromium/blink), which must be; changed to look for the live pointers on both safe and unsafe stacks. SafeStack supports linking statically modules that are compiled with and; without SafeStack. An executable compiled with SafeStack can load dynamic; libraries that are not compiled with SafeStack. At the moment, compiling; dynamic libraries with SafeStack is not supported. Signal handlers that use ``sigaltstack()`` must not use the unsafe stack (see; ``__attribute__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity prote",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3203,access,accessed,3203,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['access'],['accessed']
Security,"ld plugin`_. To allow the checks to be implemented efficiently, the program must; be structured such that certain object files are compiled with CFI; enabled, and are statically linked into the program. This may preclude; the use of shared libraries in some cases. The compiler will only produce CFI checks for a class if it can infer hidden; LTO visibility for that class. LTO visibility is a property of a class that; is inferred from flags and attributes. For more details, see the documentation; for :doc:`LTO visibility <LTOVisibility>`. The ``-fsanitize=cfi-{vcall,nvcall,derived-cast,unrelated-cast}`` flags; require that a ``-fvisibility=`` flag also be specified. This is because the; default visibility setting is ``-fvisibility=default``, which would disable; CFI checks for classes without visibility attributes. Most users will want; to specify ``-fvisibility=hidden``, which enables CFI checks for such classes. Experimental support for :ref:`cross-DSO control flow integrity; <cfi-cross-dso>` exists that does not require classes to have hidden LTO; visibility. This cross-DSO support has unstable ABI at this time. .. _gold plugin: https://llvm.org/docs/GoldPlugin.html. .. _cfi-schemes:. Available schemes; =================. Available schemes are:. - ``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks; <cfi-strictness>`.; - ``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong; dynamic type.; - ``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:1845,integrity,integrity,1845,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['integrity'],['integrity']
Security,"le atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Intel MCU ABI; -mllvm <value> Additional arguments to forward to LLVM's option processing; -nobuiltininc Disable builtin #include directories; -Qunused-arguments Don't emit warning for unused driver arguments; -R<remark> Enable the specified remark; --target=<value> Generate code for the given target; --version Print version information; -v Show commands to run and use verbose output; -W<warning> Enable the specified warning; -Xclang <arg> Pass <arg> to the clang compiler. The /clang: Option; ^^^^^^^^^^^^^^^^^^. When clang-cl is run with a set of ``/clang:<arg>`` options, it will gather all; of the ``<arg>`` arguments and process them as if they were passed to the clang; driver. This mechanism allows you to pass flags that are not exposed in the; clang-cl options o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:185547,hash,hashes,185547,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['hash'],['hashes']
Security,"le, and each pair in the map is store in a single allocation (the string data; is stored in the same allocation as the Value of a pair). StringMap also provides query methods that take byte ranges, so it only ever; copies a string if a value is inserted into the table. StringMap iteration order, however, is not guaranteed to be deterministic, so; any uses which require that should instead use a std::map. .. _dss_indexmap:. llvm/ADT/IndexedMap.h; ^^^^^^^^^^^^^^^^^^^^^. IndexedMap is a specialized container for mapping small dense integers (or; values that can be mapped to small dense integers) to some other type. It is; internally implemented as a vector with a mapping function that maps the keys; to the dense integer range. This is useful for cases like virtual registers in the LLVM code generator: they; have a dense mapping that is offset by a compile-time constant (the first; virtual register ID). .. _dss_densemap:. llvm/ADT/DenseMap.h; ^^^^^^^^^^^^^^^^^^^. DenseMap is a simple quadratically probed hash table. It excels at supporting; small keys and values: it uses a single allocation to hold all of the pairs; that are currently inserted in the map. DenseMap is a great way to map; pointers to pointers, or map other small types to each other. There are several aspects of DenseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key typ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:90709,hash,hash,90709,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['hash'],['hash']
Security,"le, permission to use the GNU C Library in; non-free programs enables many more people to use the whole GNU; operating system, as well as its variant, the GNU/Linux operating; system. Although the Lesser General Public License is Less protective of the; users' freedom, it does ensure that the user of a program that is; linked with the Library has the freedom and the wherewithal to run; that program using a modified version of the Library. The precise terms and conditions for copying, distribution and; modification follow. Pay close attention to the difference between a; ""work based on the library"" and a ""work that uses the library"". The; former contains code derived from the library, whereas the latter must; be combined with the library in order to run. GNU LESSER GENERAL PUBLIC LICENSE; TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION. 0. This License Agreement applies to any software library or other; program which contains a notice placed by the copyright holder or; other authorized party saying it may be distributed under the terms of; this Lesser General Public License (also called ""this License"").; Each licensee is addressed as ""you"". A ""library"" means a collection of software functions and/or data; prepared so as to be conveniently linked with application programs; (which use some of those functions and data) to form executables. The ""Library"", below, refers to any such software library or work; which has been distributed under these terms. A ""work based on the; Library"" means either the Library or any derivative work under; copyright law: that is to say, a work containing the Library or a; portion of it, either verbatim or with modifications and/or translated; straightforwardly into another language. (Hereinafter, translation is; included without limitation in the term ""modification"".). ""Source code"" for a work means the preferred form of the work for; making modifications to it. For a library, complete source code means; all the source code fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT:8466,authoriz,authorized,8466,interpreter/cling/LICENSE.TXT,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/LICENSE.TXT,1,['authoriz'],['authorized']
Security,"le. An example program that hashes bytes from standard input and prints the; result:. Using the C++ API:. ```c++; #include ""llvm/Support/BLAKE3.h""; #include <errno.h>; #include <stdio.h>; #include <stdlib.h>; #include <string.h>; #include <unistd.h>. int main() {; // Initialize the hasher.; llvm::BLAKE3 hasher;. // Read input bytes from stdin.; char buf[65536];; while (1) {; ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));; if (n > 0) {; hasher.update(llvm::StringRef(buf, n));; } else if (n == 0) {; break; // end of file; } else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. Default output length is 32 bytes.; auto output = hasher.final();. // Print the hash as hexadecimal.; for (uint8_t byte : output) {; printf(""%02x"", byte);; }; printf(""\n"");; return 0;; }; ```. Using the C API:. ```c; #include ""llvm-c/blake3.h""; #include <errno.h>; #include <stdio.h>; #include <stdlib.h>; #include <string.h>; #include <unistd.h>. int main() {; // Initialize the hasher.; llvm_blake3_hasher hasher;; llvm_blake3_hasher_init(&hasher);. // Read input bytes from stdin.; unsigned char buf[65536];; while (1) {; ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));; if (n > 0) {; llvm_blake3_hasher_update(&hasher, buf, n);; } else if (n == 0) {; break; // end of file; } else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. LLVM_BLAKE3_OUT_LEN is the default output length, 32 bytes.; uint8_t output[LLVM_BLAKE3_OUT_LEN];; llvm_blake3_hasher_finalize(&hasher, output, LLVM_BLAKE3_OUT_LEN);. // Print the hash as hexadecimal.; for (size_t i = 0; i < LLVM_BLAKE3_OUT_LEN; i++) {; printf(""%02x"", output[i]);; }; printf(""\n"");; return 0;; }; ```. # API. ## The Class/Struct. ```c++; class BLAKE3 {; // API; private:; llvm_blake3_hasher Hasher;; };; ```; ```c; typedef struct {; // private fields; } llvm_blake3_hasher;; ```. An incremental BLAKE3 hashing state, which can accept any number of; updates. This imp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:1115,hash,hasher,1115,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['hash'],['hasher']
Security,"led function's return type is; void, in which case the operand bundle is ignored. .. code-block:: llvm. ; The marker instruction and a runtime function call are inserted after the call; ; to @foo.; call ptr @foo() [ ""clang.arc.attachedcall""(ptr @objc_retainAutoreleasedReturnValue) ]; call ptr @foo() [ ""clang.arc.attachedcall""(ptr @objc_unsafeClaimAutoreleasedReturnValue) ]. The operand bundle is needed to ensure the call is immediately followed by the; marker instruction and the ObjC runtime call in the final output. .. _ob_ptrauth:. Pointer Authentication Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Pointer Authentication operand bundles are characterized by the; ``""ptrauth""`` operand bundle tag. They are described in the; `Pointer Authentication <PointerAuth.html#operand-bundle>`__ document. .. _ob_kcfi:. KCFI Operand Bundles; ^^^^^^^^^^^^^^^^^^^^. A ``""kcfi""`` operand bundle on an indirect call indicates that the call will; be preceded by a runtime type check, which validates that the call target is; prefixed with a :ref:`type identifier<md_kcfi_type>` that matches the operand; bundle attribute. For example:. .. code-block:: llvm. call void %0() [""kcfi""(i32 1234)]. Clang emits KCFI operand bundles and the necessary metadata with; ``-fsanitize=kcfi``. .. _convergencectrl:. Convergence Control Operand Bundles; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A ""convergencectrl"" operand bundle is only valid on a ``convergent`` operation.; When present, the operand bundle must contain exactly one value of token type.; See the :doc:`ConvergentOperations` document for details. .. _moduleasm:. Module-Level Inline Assembly; ----------------------------. Modules may contain ""module-level inline asm"" blocks, which corresponds; to the GCC ""file scope inline asm"" blocks. These blocks are internally; concatenated by LLVM and treated as a single unit, but may be separated; in the ``.ll`` file if desired. The syntax is very simple:. .. code-block:: llvm. module asm ""inline asm c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:129528,validat,validates,129528,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['validat'],['validates']
Security,"lem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:15473,expose,expose,15473,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['expose'],['expose']
Security,"lement.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{dim's 0's, index}``. '``llvm.preserve.union.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <type>; @llvm.preserve.union.access.index.p0s_union.anons.p0s_union.anons(<type> base,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic carries the debuginfo field index; ``di_index`` and returns the ``base`` address.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide union debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``type`` is the same as the ``base`` type. Arguments:; """""""""""""""""""". The ``base`` is the union base address. The ``di_index`` is the field index in debuginfo. Semantics:; """""""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic returns the ``base`` address. '``llvm.preserve.struct.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:973993,access,access,973993,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"lements. The comma-separated; sub-expressions of an array literal can be any Objective-C object; pointer typed expression. Immutable dictionary expression:. .. code-block:: objc. NSDictionary *dictionary = @{; @""name"" : NSUserName(),; @""date"" : [NSDate date],; @""processInfo"" : [NSProcessInfo processInfo]; };. This creates an ``NSDictionary`` with 3 key/value pairs. Value; sub-expressions of a dictionary literal must be Objective-C object; pointer typed, as in array literals. Key sub-expressions must be of an; Objective-C object pointer type that implements the; ``<NSCopying>`` protocol. Discussion; ----------. Neither keys nor values can have the value ``nil`` in containers. If the; compiler can prove that a key or value is ``nil`` at compile time, then; a warning will be emitted. Otherwise, a runtime error will occur. Using array and dictionary literals is safer than the variadic creation; forms commonly in use today. Array literal expressions expand to calls; to ``+[NSArray arrayWithObjects:count:]``, which validates that all; objects are non-``nil``. The variadic form,; ``+[NSArray arrayWithObjects:]`` uses ``nil`` as an argument list; terminator, which can lead to malformed array objects. Dictionary; literals are similarly created with; ``+[NSDictionary dictionaryWithObjects:forKeys:count:]`` which validates; all objects and keys, unlike; ``+[NSDictionary dictionaryWithObjectsAndKeys:]`` which also uses a; ``nil`` parameter as an argument list terminator. Object Subscripting; ===================. Objective-C object pointer values can now be used with C's subscripting; operator. Examples; --------. The following code demonstrates the use of object subscripting syntax; with ``NSMutableArray`` and ``NSMutableDictionary`` objects:. .. code-block:: objc. NSMutableArray *array = ...;; NSUInteger idx = ...;; id newObject = ...;; id oldObject = array[idx];; array[idx] = newObject; // replace oldObject with newObject. NSMutableDictionary *dictionary = ...;; NSString *key ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst:10411,validat,validates,10411,interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ObjectiveCLiterals.rst,1,['validat'],['validates']
Security,"les like ""``unistd.h``"", ""``windows.h``"", ""``stdio.h``"", and ""``string.h``""; are forbidden to be included by LLVM source code outside the implementation of; ``lib/Support``. To obtain system-dependent functionality, existing interfaces to the system; found in ``include/llvm/Support`` should be used. If an appropriate interface is; not available, it should be added to ``include/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:3281,expose,exposed,3281,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['expose'],['exposed']
Security,"les; to generate: ``sync`` for normal unwind tables, ``async`` for asynchronous; (instruction precise) unwind tables. Without the parameter, the attribute; ``uwtable`` is equivalent to ``uwtable(async)``.; ``nocf_check``; This attribute indicates that no control-flow check will be performed on; the attributed entity. It disables -fcf-protection=<> for a specific; entity to fine grain the HW control flow protection mechanism. The flag; is target independent and currently appertains to a function or function; pointer.; ``shadowcallstack``; This attribute indicates that the ShadowCallStack checks are enabled for; the function. The instrumentation checks that the return address for the; function has not changed between the function prolog and epilog. It is; currently x86_64-specific. .. _langref_mustprogress:. ``mustprogress``; This attribute indicates that the function is required to return, unwind,; or interact with the environment in an observable way e.g. via a volatile; memory access, I/O, or other synchronization. The ``mustprogress``; attribute is intended to model the requirements of the first section of; [intro.progress] of the C++ Standard. As a consequence, a loop in a; function with the `mustprogress` attribute can be assumed to terminate if; it does not interact with the environment in an observable way, and; terminating loops without side-effects can be removed. If a `mustprogress`; function does not satisfy this contract, the behavior is undefined. This; attribute does not apply transitively to callees, but does apply to call; sites within the function. Note that `willreturn` implies `mustprogress`.; ``""warn-stack-size""=""<threshold>""``; This attribute sets a threshold to emit diagnostics once the frame size is; known should the frame size exceed the specified value. It takes one; required integer value, which should be a non-negative integer, and less; than `UINT_MAX`. It's unspecified which threshold will be used when; duplicate definitions are linked to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:109970,access,access,109970,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"lete loss of speculative; execution (at a minimum). So far, the evidence we have of the performance cost; of using `lfence` indicates few if any hot code patterns where this trade off; would make sense. ###### Tempting optimizations that break the security model. Several optimizations were considered which didn't pan out due to failure to; uphold the security model. One in particular is worth discussing as many others; will reduce to it. We wondered whether only the *first* load in a basic block could be checked. If; the check works as intended, it forms an invalid pointer that doesn't even; virtual-address translate in the hardware. It should fault very early on in its; processing. Maybe that would stop things in time for the misspeculated path to; fail to leak any secrets. This doesn't end up working because the processor is; fundamentally out-of-order, even in its speculative domain. As a consequence,; the attacker could cause the initial address computation itself to stall and; allow an arbitrary number of unrelated loads (including attacked loads of; secret data) to pass through. #### Interprocedural Checking. Modern x86 processors may speculate into called functions and out of functions; to their return address. As a consequence, we need a way to check loads that; occur after a misspeculated predicate but where the load and the misspeculated; predicate are in different functions. In essence, we need some interprocedural; generalization of the predicate state tracking. A primary challenge to passing; the predicate state between functions is that we would like to not require a; change to the ABI or calling convention in order to make this mitigation more; deployable, and further would like code mitigated in this way to be easily; mixed with code not mitigated in this way and without completely losing the; value of the mitigation. ##### Embed the predicate state into the high bit(s) of the stack pointer. We can use the same technique that allows hardening pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:37593,attack,attacker,37593,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,2,['attack'],"['attacked', 'attacker']"
Security,"lete`` is exactly the same as a call to; ``::operator delete(args)``, except that it permits optimizations; and that the call is required to resolve to a; `replaceable global deallocation function; <https://en.cppreference.com/w/cpp/memory/new/operator_delete>`_. These builtins are intended for use in the implementation of ``std::allocator``; and other similar allocation libraries, and are only available in C++. Query for this feature with ``__has_builtin(__builtin_operator_new)`` or; ``__has_builtin(__builtin_operator_delete)``:. * If the value is at least ``201802L``, the builtins behave as described above. * If the value is non-zero, the builtins may not support calling arbitrary; replaceable global (de)allocation functions, but do support calling at least; ``::operator new(size_t)`` and ``::operator delete(void*)``. ``__builtin_preserve_access_index``; -----------------------------------. ``__builtin_preserve_access_index`` specifies a code section where; array subscript access and structure/union member access are relocatable; under bpf compile-once run-everywhere framework. Debuginfo (typically; with ``-g``) is needed, otherwise, the compiler will exit with an error.; The return type for the intrinsic is the same as the type of the; argument. **Syntax**:. .. code-block:: c. type __builtin_preserve_access_index(type arg). **Example of Use**:. .. code-block:: c. struct t {; int i;; int j;; union {; int a;; int b;; } c[4];; };; struct t *v = ...;; int *pb =__builtin_preserve_access_index(&v->c[3].b);; __builtin_preserve_access_index(v->j);. ``__builtin_debugtrap``; -----------------------. ``__builtin_debugtrap`` causes the program to stop its execution in such a way that a debugger can catch it. **Syntax**:. .. code-block:: c++. __builtin_debugtrap(). **Description**. ``__builtin_debugtrap`` is lowered to the ` ``llvm.debugtrap`` <https://llvm.org/docs/LangRef.html#llvm-debugtrap-intrinsic>`_ builtin. It should have the same effect as setting a breakpoint on the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:120556,access,access,120556,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,2,['access'],['access']
Security,"leted before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire and release.; * The L2 cache can be kept coherent with other agents on some targets, or ranges; of virtual addresses can be set up to bypass it to ensure system coherence. Scalar memory operations are only used to access memory that is proven to not; change during the execution of the kernel dispatch. This includes constant; address space and global address space for program scope ``const`` variables.; Therefore, the kernel machine code does not have to maintain the scalar cache to; ensure it is coherent with the vector caches. The scalar and vector caches are; invalidated between kernel dispatches by CP since constant address space data; may change between kernel dispatch executions. See; :ref:`amdgpu-amdhsa-memory-spaces`. The one exception is if scalar writes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is allocated in host memory accessed as; MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also; causes it to be treated as non-volatile and so is not invalidated by; ``*_vol``.; * On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent); and so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:210006,access,accessed,210006,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"level. Sometimes either frontends or backends will want to inject passes into the; pipeline. For example, frontends may want to add instrumentation, and target; backends may want to add passes that lower custom intrinsics. For these; cases, ``PassBuilder`` exposes callbacks that allow injecting passes into; certain parts of the pipeline. For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying for an analysis will cause the manager to check if; it has already computed the result for the requested IR. If it already has and; the result is still valid, it will return",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6285,sanitiz,sanitizer,6285,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['sanitiz'],['sanitizer']
Security,"library for JIT'd code:. class MyJIT {; public:; void log(const char *Msg);; };. void log(const char *Msg) { ((MyJIT*)0x1234)->log(Msg); }. We can turn this into a symbolic reference in the JIT standard library:. .. code-block:: c++. extern MyJIT *__MyJITInstance;. void log(const char *Msg) { __MyJITInstance->log(Msg); }. And then make our JIT object visible to the JIT standard library with an; absolute symbol definition when the JIT is started:. .. code-block:: c++. MyJIT J = ...;. auto &JITStdLibJD = ... ;. JITStdLibJD.define(absoluteSymbols(SymbolMap({; { Mangle(""__MyJITInstance""),; { ExecutorAddr::fromPtr(&J), JITSymbolFlags() } }; });. Aliases and Reexports; ---------------------. Aliases and reexports allow you to define new symbols that map to existing; symbols. This can be useful for changing linkage relationships between symbols; across sessions without having to recompile code. For example, imagine that; JIT'd code has access to a log function, ``void log(const char*)`` for which; there are two implementations in the JIT standard library: ``log_fast`` and; ``log_detailed``. Your JIT can choose which one of these definitions will be; used when the ``log`` symbol is referenced by setting up an alias at JIT startup; time:. .. code-block:: c++. auto &JITStdLibJD = ... ;. auto LogImplementationSymbol =; Verbose ? Mangle(""log_detailed"") : Mangle(""log_fast"");. JITStdLibJD.define(; symbolAliases(SymbolAliasMap({; { Mangle(""log""),; { LogImplementationSymbol; JITSymbolFlags::Exported | JITSymbolFlags::Callable } }; });. The ``symbolAliases`` function allows you to define aliases within a single; JITDylib. The ``reexports`` function provides the same functionality, but; operates across JITDylib boundaries. E.g. .. code-block:: c++. auto &JD1 = ... ;; auto &JD2 = ... ;. // Make 'bar' in JD2 an alias for 'foo' from JD1.; JD2.define(; reexports(JD1, SymbolAliasMap({; { Mangle(""bar""), { Mangle(""foo""), JITSymbolFlags::Exported } }; });. The reexports utility can be handy ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:15396,access,access,15396,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['access'],['access']
Security,"lidated by changes to inner level IR. These invalidations happen after the; inner pass manager finishes, so accessing mutable analyses would give invalid; results. The exception to not being able to access outer level analyses is accessing; function analyses in loop passes. Loop passes often use function analyses such; as the dominator tree. Loop passes inherently require modifying the function the; loop is in, and that includes some function analyses the loop analyses depend; on. This discounts future concurrency over separate loops in a function, but; that's a tradeoff due to how tightly a loop and its function are coupled. To; make sure the function analyses that loop passes use are valid, they are; manually updated in the loop passes to ensure that invalidation is not; necessary. There is a set of common function analyses that loop passes and; analyses have access to which is passed into loop passes as a; ``LoopStandardAnalysisResults`` parameter. Other mutable function analyses are; not accessible from loop passes. As with any caching mechanism, we need some way to tell analysis managers; when results are no longer valid. Much of the analysis manager complexity; comes from trying to invalidate as few analysis results as possible to keep; compile times as low as possible. There are two ways to deal with potentially invalid analysis results. One is; to simply force clear the results. This should generally only be used when; the IR that the result is keyed on becomes invalid. For example, a function; is deleted, or a CGSCC has become invalid due to call graph changes. The typical way to invalidate analysis results is for a pass to declare what; types of analyses it preserves and what types it does not. When transforming; IR, a pass either has the option to update analyses alongside the IR; transformation, or tell the analysis manager that analyses are no longer; valid and should be invalidated. If a pass wants to keep some specific; analysis up to date, such as wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:11374,access,accessible,11374,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['access'],['accessible']
Security,"lignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78729,sanitiz,sanitize-coverage,78729,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize-coverage']
Security,"linux-gnu/4.9; Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.9.2; Selected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/4.9; Candidate multilib: .;@m64; Selected multilib: .;@m64. Which image should I choose?; ============================; We currently provide two images: Debian10-based and nvidia-cuda-based. They; differ in the base image that they use, i.e. they have a different set of; preinstalled binaries. Debian8 is very minimal, nvidia-cuda is larger, but has; preinstalled CUDA libraries and allows to access a GPU, installed on your; machine. If you need a minimal linux distribution with only clang and libstdc++ included,; you should try Debian10-based image. If you want to use CUDA libraries and have access to a GPU on your machine,; you should choose nvidia-cuda-based image and use `nvidia-docker; <https://github.com/NVIDIA/nvidia-docker>`_ to run your docker containers. Note; that you don't need nvidia-docker to build the images, but you need it in order; to have an access to GPU from a docker container that is running the built; image. If you have a different use-case, you could create your own image based on; ``example/`` folder. Any docker image can be built and run using only the docker binary, i.e. you can; run debian10 build on Fedora or any other Linux distribution. You don't need to; install CMake, compilers or any other clang dependencies. It is all handled; during the build process inside Docker's isolated environment. Stable build; ============; If you want a somewhat recent and somewhat stable build, use the; ``branches/google/stable`` branch, i.e. the following command will produce a; Debian10-based image using the latest ``google/stable`` sources for you:. .. code-block:: bash. ./llvm/utils/docker/build_docker_image.sh \; 	-s debian10 --d clang-debian10 -t ""staging"" \; 	--branch branches/google/stable \; 	-p clang -i install-clang -i install-clang-resource-headers \; 	-- \; 	-DCMAKE_BUILD_TYPE=Release. Minimizing docker",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:6392,access,access,6392,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,1,['access'],['access']
Security,"list of all public disclosures, as well as statistics on time to fix issues, length of embargo periods, and so on. The transparency reports are published at :doc:`SecurityTransparencyReports`. Privileges and Responsibilities of LLVM Security Group Members; ==============================================================. Access; ------. LLVM Security Group members will be subscribed to a private `Discussion Medium`_ (*FUTURE*: see section below). It will be used for technical discussions of security issues, as well as process discussions about matters such as disclosure timelines and group membership. Members have access to all security issues. Confidentiality; ---------------. Members of the LLVM Security Group will be expected to treat LLVM security issue information shared with the group as confidential until publicly disclosed:. * Members should not disclose security issue information to non-members unless both members are employed by the same vendor of a LLVM based product, in which case information can be shared within that organization on a need-to-know basis and handled as confidential information normally is within that organization.; * If the LLVM Security Group agrees, designated members may share issues with vendors of non-LLVM based products if their product suffers from the same issue. The non-LLVM vendor should be asked to respect the issue’s embargo date, and to not share the information beyond the need-to-know people within their organization.; * If the LLVM Security Group agrees, key experts can be brought in to help address particular issues. The key expert should be asked to respect the issue’s embargo date, and to not share the information. Disclosure; ----------. Following the process below, the LLVM Security Group decides on embargo date for public disclosure for each Security issue. An embargo may be lifted before the agreed-upon date if all vendors planning to ship a fix have already done so, and if the reporter does not object. Collaboration;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:9056,secur,security,9056,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,2,"['confidential', 'secur']","['confidential', 'security']"
Security,"lity and it supports only dense layer. The new features of `MethodDL` are:. - Support training and evaluation of Convolutional layer on GPU; - Several ML optimizers are now included and they can be used in addition to SGD. These are ADAM (the new default), ADAGRAD,; RMSPROP, ADADELTA. A new option, *Optimizer* has been added in the option string used to define the training strategy options.; - Add support for regression in MethodDL; - Use single precision (float) types as the fundamental type for the neural network architecture. Double precision could be enabled, but it will require recompiling TMVA. ; - Support inference (network evaluation) in batch mode in addition to single event. Batch mode evaluation is now the default when used within the `TMVA::Factory` class (i.e. when calling; `Factory::TestAllMethod()` or `Factory::EvaluateAllMethods()`; - Support splitting the overall training data in Train and Validation data. The train data is used for finding the optimal network weight and the validation data is used to monitor the validation; error. The weights which are giving a minimal validation error will be stored. For the splitting a new option, *ValidationSize* has been added to the global options for `MethodDL`.; The same option is also available in the `PyKeras` method of `PyMVA`; - The fast tanh implementation from VDT is now used as activation function when training the network on CPU.; - Using `Cblas` from the GSL library is supported for CPU training when no other Blas libraries are found. However, it is strongly recommended, to use an optimized Blas implementation such as `libopenblas`, that is; available in cvmfs.; - Add several performance optimizations for both CPU and GPU versions of `MethodDL`. . ### Other New TMVA Features. - Add a new option to the `DataLoader` to switch off computation of correlation matrix. The new option is called *CalcCorrelations* and it should be used when a large number of input variables are; provided, otherwise TMVA will",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:14380,validat,validation,14380,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,2,['validat'],['validation']
Security,"ll SGPR registers except the clobbered registers of SGPR4-31.; * VGPR40-47; * VGPR56-63; * VGPR72-79; * VGPR88-95; * VGPR104-111; * VGPR120-127; * VGPR136-143; * VGPR152-159; * VGPR168-175; * VGPR184-191; * VGPR200-207; * VGPR216-223; * VGPR232-239; * VGPR248-255. .. note::. Except the argument registers, the VGPRs clobbered and the preserved; registers are intermixed at regular intervals in order to keep a; similar ratio independent of the number of allocated VGPRs. * GFX90A: All AGPR registers except the clobbered registers AGPR0-31.; * Lanes of all VGPRs that are inactive at the call site. For the AMDGPU backend, an inter-procedural register allocation (IPRA); optimization may mark some of clobbered SGPR and VGPR registers as; preserved if it can be determined that the called function does not change; their value. 2. The PC is set to the RA provided on entry.; 3. MODE register: *TBD*.; 4. All other registers are clobbered.; 5. Any necessary ``s_waitcnt`` has been performed to ensure memory accessed by; function is available to the caller. .. TODO::. - How are function results returned? The address of structured types is passed; by reference, but what about other types?. The function input arguments are made up of the formal arguments explicitly; declared by the source language function plus the implicit input arguments used; by the implementation. The source language input arguments are:. 1. Any source language implicit ``this`` or ``self`` argument comes first as a; pointer type.; 2. Followed by the function formal arguments in left to right source order. The source language result arguments are:. 1. The function result argument. The source language input or result struct type arguments that are less than or; equal to 16 bytes, are decomposed recursively into their base type fields, and; each field is passed as if a separate argument. For input arguments, if the; called function requires the struct to be in memory, for example because its; address is taken, then",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:391508,access,accessed,391508,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"ll SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L0 and L1 caches at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is accessed as MTYPE UC (uncached) to avoid; needing to invalidate the L2 cache.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC (non-coherent). Since the private address space is only accessed; by a single thread, and is always write-before-read, there is never a need to; invalidate these entries from the L0 or L1 caches. Wavefronts are executed in native mode with in-order reporting of loads and; sample instructions. In this mode vmcnt reports completion of load, atomic with; return and sample instructions in order, and the vscnt reports the completion of; store and atomic without return in order. See ``MEM_ORDERED`` field in; :ref:`amdgpu-amdhsa-compute_pgm_rsrc1-gfx6-gfx12-table`. Wavefronts can be executed in WGP or CU wavefront execution mode:. * In WGP wavefront execution mode the wavefronts of a work-group are executed; on the SIMDs of both CUs of the WGP. Therefore, explicit management of the per; CU L0 caches is required for work-group synchronization. Also accesses to L1; at work-group scope need to be explicitly ordered as the accesses from; different CUs are ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:341598,access,accessed,341598,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"ll behave correctly even if a; thread of execution enters the function while one or more threads are; already executing within the function. These could be the same thread,; in the case of recursion, or different threads, in the case of; concurrency. **`Thread-specific data`** (**`TSD`**) is also known as thread-local; storage (TLS). Normally, any data that has lifetime beyond the local; variables on the thread's private stack are shared among all threads; within the process. Thread-specific data is a form of static or global; data that is maintained on a per-thread basis. That is, each thread gets; its own private copy of the data. Left to their own devices, threads execute independently.; **`Synchronization`** is the work that must be done when there are, in; fact, interdependencies that require some form of communication among; threads. Synchronization tools include mutexes, semaphores, condition; variables, and other variations on locking. A **`critical section`** is a section of code that accesses a; non-sharable resource. To ensure correct code, only one thread at a time; may execute in a critical section. In other words, the section is not; reentrant. A **`mutex`**, or mutual exclusion lock, is a synchronization object; with two states locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continue",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:21604,access,accesses,21604,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['access'],['accesses']
Security,"ll dereference; return 0;; }. osx.coreFoundation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:20994,Secur,Security,20994,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['Secur'],['Security']
Security,"ll followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310346,access,access,310346,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],"['access', 'accesses']"
Security,"ll of the DWARF; sections and keeps the hash table size down. Another benefit to having the; compiler generate all strings as DW_FORM_strp in the debug info, is that; DWARF parsing can be made much faster. After a lookup is made, we get an offset into the hash data. The hash data; needs to be able to deal with 32 bit hash collisions, so the chunk of data; at the offset in the hash data consists of a triple:. .. code-block:: c. uint32_t str_offset; uint32_t hash_data_count; HashData[hash_data_count]. If ""str_offset"" is zero, then the bucket contents are done. 99.9% of the; hash data chunks contain a single item (no 32 bit hash collision):. .. code-block:: none. .------------.; | 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] => ""main""); | 0x00000004 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x........ | uint32_t HashData[2] DIE offset; | 0x........ | uint32_t HashData[3] DIE offset; | 0x00000000 | uint32_t KeyType (end of hash chain); `------------'. If there are collisions, you will have multiple valid string offsets:. .. code-block:: none. .------------.; | 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] => ""main""); | 0x00000004 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x........ | uint32_t HashData[2] DIE offset; | 0x........ | uint32_t HashData[3] DIE offset; | 0x00002023 | uint32_t KeyType (.debug_str[0x0002023] => ""print""); | 0x00000002 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x00000000 | uint32_t KeyType (end of hash chain); `------------'. Current testing with real world C++ binaries has shown that there is around 1; 32 bit hash collision per 100,000 name entries. Contents; ^^^^^^^^. As we said, we want to strictly define exactly what is included in the; different tables. For DWARF, we have 3 tables: ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:76279,hash,hash,76279,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"ll page budget is reached,; pages larger than the page at hand are flushed before the page at hand is flushed.; For the parallel writer, every fill context maintains the page memory budget independently. Note that the total amount of memory consumed for writing is usually larger than the write page budget.; For instance, if buffered writing is used (the default), additional memory is required.; Use RNTupleModel::EstimateWriteMemoryUsage() for the total estimated memory use for writing. The default values are tuned for a total write memory of around 300 MB per writer resp. fill context.; In order to decrease the memory consumption,; users should decrease the target cluster size before tuning more intricate memory settings. Notes; =====. Approximation of the compressed cluster size; --------------------------------------------. The estimator for the compressed cluster size uses the average compression factor; of the so far written clusters.; This has been choosen as a simple, yet expectedly accurate enough estimator (to be validated).; The following alternative strategies were discussed:. - The average compression factor of all so-far written pages.; Easy to implement.; It would better prevent outlier clusters from skewing the estimate of the successor clusters.; It would be slower though in adjusting to systematic changes in the data set,; e.g. ones that are caused by changing experimental conditions during data taking. - The average over a window of the last $k$ clusters, possibly with exponential smoothing.; More code compared to the average compression factor or all so-far written clusters.; It would be faster in adjusting to systematic changes in the data set,; e.g. ones that are caused by changing experimental conditions during data taking.; Could be a viable option if cluster compression ratios turn out to change significantly in a single file. - Calculate the cluster compression ratio from column-based individual estimators.; More complex to implement and to r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md:3401,validat,validated,3401,tree/ntuple/v7/doc/tuning.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/tuning.md,1,['validat'],['validated']
Security,"lling for the; token includes a trigraph or escaped newline. Since this is uncommon,; many pieces of code can fast-path on tokens that did not need cleaning. One interesting (and somewhat unusual) aspect of normal tokens is that they; don't contain any semantic information about the lexed value. For example, if; the token was a pp-number token, we do not represent the value of the number; that was lexed (this is left for later pieces of code to decide).; Additionally, the lexer library has no notion of typedef names vs variable; names: both are returned as identifiers, and the parser is left to decide; whether a specific identifier is a typedef or a variable (tracking this; requires scope information among other things). The parser can do this; translation by replacing tokens returned by the preprocessor with ""Annotation; Tokens"". .. _AnnotationToken:. Annotation Tokens; -----------------. Annotation tokens are tokens that are synthesized by the parser and injected; into the preprocessor's token stream (replacing existing tokens) to record; semantic information found by the parser. For example, if ""``foo``"" is found; to be a typedef, the ""``foo``"" ``tok::identifier`` token is replaced with an; ``tok::annot_typename``. This is useful for a couple of reasons: 1) this makes; it easy to handle qualified type names (e.g., ""``foo::bar::baz<42>::t``"") in; C++ as a single ""token"" in the parser. 2) if the parser backtracks, the; reparse does not need to redo semantic analysis to determine whether a token; sequence is a variable, type, template, etc. Annotation tokens are created by the parser and reinjected into the parser's; token stream (when backtracking is enabled). Because they can only exist in; tokens that the preprocessor-proper is done with, it doesn't need to keep; around flags like ""start of line"" that the preprocessor uses to do its job.; Additionally, an annotation token may ""cover"" a sequence of preprocessor tokens; (e.g., ""``a::b::c``"" is five preprocessor tok",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:48887,inject,injected,48887,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['inject'],['injected']
Security,"lls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on system-enforced ASLR and shares; its known security limitations. The safe stack pointer hiding is not perfect; yet either: system library functions such as ``swapcontext``, exception; handling mechanisms, intrinsics such as ``__builtin_frame_address``, or; low-level bugs in runtime support could leak the safe stack pointer. In the; future, such leaks could be detected by static or dynamic analysis tools and; prevented by adjusting such functions to either encrypt the stack pointer when; storing it in the heap (as already done e.g., by ``setjmp``/``longjmp``; implementation in glibc), or store it in a safe region instead. The `CPI paper <https://dslab.epfl.ch/pubs/cpi.pdf>`_ describes two alternative,; stronger safe stack protection mechanisms, that rely on software fault; isolation, or hardware segmentation (as available on x86-32 and some x86-64; CPUs). At the moment, SafeStack assumes that the compiler's implementation is correct.; This has not been verified except through manual code inspection, and could; always regress in the future. It's therefore desirable to have a separate; static or dynamic binary verification tool that would check the correctness of; the SafeStack instrumentation in final binaries. Usage; =====. To enable SafeStack, just pass ``-fsanitize=safe-stack`` flag to both compile; and link command lines. Supported Platforms; -------------------. SafeStack was tested on Linux, NetBSD, Fre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:5203,encrypt,encrypt,5203,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,1,['encrypt'],['encrypt']
Security,"llvm-exegesis - LLVM Machine Instruction Benchmark; ==================================================. .. program:: llvm-exegesis. SYNOPSIS; --------. :program:`llvm-exegesis` [*options*]. DESCRIPTION; -----------. :program:`llvm-exegesis` is a benchmarking tool that uses information available; in LLVM to measure host machine instruction characteristics like latency,; throughput, or port decomposition. Given an LLVM opcode name and a benchmarking mode, :program:`llvm-exegesis`; generates a code snippet that makes execution as serial (resp. as parallel) as; possible so that we can measure the latency (resp. inverse throughput/uop decomposition); of the instruction.; The code snippet is jitted and, unless requested not to, executed on the; host subtarget. The time taken (resp. resource usage) is measured using; hardware performance counters. The result is printed out as YAML; to the standard output. The main goal of this tool is to automatically (in)validate the LLVM's TableDef; scheduling models. To that end, we also provide analysis of the results. :program:`llvm-exegesis` can also benchmark arbitrary user-provided code; snippets. SUPPORTED PLATFORMS; -------------------. :program:`llvm-exegesis` currently only supports X86 (64-bit only), ARM (AArch64; only), MIPS, and PowerPC (PowerPC64LE only) on Linux for benchmarking. Not all; benchmarking functionality is guaranteed to work on every platform.; :program:`llvm-exegesis` also has a separate analysis mode that is supported; on every platform that LLVM is. SNIPPET ANNOTATIONS; -------------------. :program:`llvm-exegesis` supports benchmarking arbitrary snippets of assembly.; However, benchmarking these snippets often requires some setup so that they; can execute properly. :program:`llvm-exegesis` has five annotations and some; additional utilities to help with setup so that snippets can be benchmarked; properly. * `LLVM-EXEGESIS-DEFREG <register name>` - Adding this annotation to the text; assembly snippet to be be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst:963,validat,validate,963,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-exegesis.rst,1,['validat'],['validate']
Security,"llvm/llvm-project/pull/66358>`_). - Checkers can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:76974,secur,security,76974,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['secur'],['security']
Security,"lly allocated when the hardware creates work-groups of wavefronts, and; freed when all the wavefronts of a work-group have terminated. The data store; (DS) instructions can be used to access it. The private memory space uses the hardware scratch memory support. If the kernel; uses scratch, then the hardware allocates memory that is accessed using; wavefront lane dword (4 byte) interleaving. The mapping used from private; address to physical address is:. ``wavefront-scratch-base +; (private-address * wavefront-size * 4) +; (wavefront-lane-id * 4)``. There are different ways that the wavefront scratch base address is determined; by a wavefront (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). This; memory can be accessed in an interleaved manner using buffer instruction with; the scratch buffer descriptor and per wavefront scratch offset, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS requires; hardware aperture setup and M0 (GFX7-GFX8) register setup (see; :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a segment address and a flat address the base address of the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:155115,access,accesses,155115,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],"['accessed', 'accesses']"
Security,"lly stores secret data must ensure the; memory regions used for secret data are necessarily dynamic mappings or heap; allocations. This is an area which can be tuned to provide more comprehensive; protection at the cost of performance.; * [Hardened loads](#hardening-the-address-of-the-load) may still load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; block misspeculated loads was developed as part of a HACS 2018 discussion; between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other; individuals.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on fu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:8407,attack,attack,8407,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attack']
Security,"lobal address space. All named address spaces are disjoint and sub-sets of default address space. The SPIR target allocates SYCL namespace scope variables in the global address; space. Pointers to default address space should get lowered into a pointer to a generic; address space (or flat to reuse more general terminology). But depending on the; allocation context, the default address space of a non-pointer type is assigned; to a specific address space. This is described in; `common address space deduction rules <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:commonAddressSpace>`_; section. This is also in line with the behaviour of CUDA (`small example; <https://godbolt.org/z/veqTfo9PK>`_). ``multi_ptr`` class implementation example:. .. code-block:: C++. // check that SYCL mode is ON and we can use non-standard decorations; #if defined(__SYCL_DEVICE_ONLY__); // GPU/accelerator implementation; template <typename T, address_space AS> class multi_ptr {; // DecoratedType applies corresponding address space attribute to the type T; // DecoratedType<T, global_space>::type == ""__attribute__((opencl_global)) T""; // See sycl/include/CL/sycl/access/access.hpp for more details; using pointer_t = typename DecoratedType<T, AS>::type *;. pointer_t m_Pointer;; public:; pointer_t get() { return m_Pointer; }; T& operator* () { return *reinterpret_cast<T*>(m_Pointer); }; }; #else; // CPU/host implementation; template <typename T, address_space AS> class multi_ptr {; T *m_Pointer; // regular undecorated pointer; public:; T *get() { return m_Pointer; }; T& operator* () { return *m_Pointer; }; }; #endif. Depending on the compiler mode, ``multi_ptr`` will either decorate its internal; data with the address space attribute or not. To utilize clang's existing functionality, we reuse the following OpenCL address; space attributes for pointers:. .. list-table::; :header-rows: 1. * - Address space attribute; - SYCL address_space enumeration; * - ``__attribu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:3611,access,access,3611,interpreter/llvm-project/clang/docs/SYCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst,2,['access'],['access']
Security,"locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX90A are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table`. .. table:: AMDHSA Memory Model Code Sequences GFX90A; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX90A; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; ------------------------------------------------------------------------------------; load *none* *none* - global - !volatile & !nontemporal; - generic; - private 1. buffer/global/flat_load; - constant; - !volatile & nontemporal. 1. buffer/global/flat_load",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:241631,access,accessed,241631,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX940, GFX941, GFX942; are defined in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table`. .. table:: AMDHSA Memory Model Code Sequences GFX940, GFX941, GFX942; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX940, GFX941, GFX942; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; ------------------------------------------------------------------------------------; load *none* *none* - global - !volatile & !nontemporal; - generic; - private 1. buffer/global/",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:291649,access,accessed,291649,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"locations. Without this flags, all remarks are kept. .. option:: --remarks-output-format <format>. Specify the format to be used when serializing the linked remarks. .. option:: --remarks-prepend-path <path>. Specify a directory to prepend the paths of the external remark files. .. option:: --reproducer <mode>. Specify the reproducer generation mode. Valid options are 'GenerateOnExit',; 'GenerateOnCrash', 'Use', 'Off'. .. option:: --statistics. Print statistics about the contribution of each object file to the linked; debug info. This prints a table after linking with the object file name, the; size of the debug info in the object file (in bytes) and the size contributed; (in bytes) to the linked dSYM. The table is sorted by the output size listing; the object files with the largest contribution first. .. option:: --symbol-map <bcsymbolmap>. Update the existing dSYMs inplace using symbol map specified. .. option:: -s, --symtab. Dumps the symbol table found in *executable* or object file(s) and exits. .. option:: -S. Output textual assembly instead of a binary dSYM companion file. .. option:: --toolchain <toolchain>. Embed the toolchain in the dSYM bundle's property list. .. option:: -u, --update. Update an existing dSYM file to contain the latest accelerator tables and; other DWARF optimizations. This option will rebuild the '.apple_names' and; '.apple_types' hashed accelerator tables. .. option:: --use-reproducer <path>. Use the object files from the given reproducer path. Alias for; --reproducer=Use. .. option:: --verbose. Display verbose information when linking. .. option:: --verify. Run the DWARF verifier on the linked DWARF debug info. .. option:: -v, --version. Display the version of the tool. .. option:: -y. Treat *executable* as a YAML debug-map rather than an executable. EXIT STATUS; -----------. :program:`dsymutil` returns 0 if the DWARF debug information was linked; successfully. Otherwise, it returns 1. SEE ALSO; --------. :manpage:`llvm-dwarfdump(1)`; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst:5352,hash,hashed,5352,interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/dsymutil.rst,1,['hash'],['hashed']
Security,"lock:: c++. bool FooAnalysisResult::invalidate(Function &F, const PreservedAnalyses &PA,; FunctionAnalysisManager::Invalidator &) {; // Check whether the analysis has been explicitly invalidated. Otherwise, it's; // stateless and remains preserved.; auto PAC = PA.getChecker<FooAnalysis>();; return !PAC.preservedWhenStateless();; }. If an analysis depends on other analyses, those analyses also need to be; checked if they are invalidated:. .. code-block:: c++. bool FooAnalysisResult::invalidate(Function &F, const PreservedAnalyses &PA,; FunctionAnalysisManager::Invalidator &Inv) {; auto PAC = PA.getChecker<FooAnalysis>();; if (!PAC.preserved() && !PAC.preservedSet<AllAnalysesOn<Function>>()); return true;. // Check transitive dependencies.; return Inv.invalidate<BarAnalysis>(F, PA) ||; Inv.invalidate<BazAnalysis>(F, PA);; }. Combining invalidation and analysis manager proxies results in some; complexity. For example, when we invalidate all analyses in a module pass,; we have to make sure that we also invalidate function analyses accessible via; any existing inner proxies. The inner proxy's ``invalidate()`` first checks; if the proxy itself should be invalidated. If so, that means the proxy may; contain pointers to IR that is no longer valid, meaning that the inner proxy; needs to completely clear all relevant analysis results. Otherwise the proxy; simply forwards the invalidation to the inner analysis manager. Generally for outer proxies, analysis results from the outer analysis manager; should be immutable, so invalidation shouldn't be a concern. However, it is; possible for some inner analysis to depend on some outer analysis, and when; the outer analysis is invalidated, we need to make sure that dependent inner; analyses are also invalidated. This actually happens with alias analysis; results. Alias analysis is a function-level analysis, but there are; module-level implementations of specific types of alias analysis. Currently; ``GlobalsAA`` is the only module-level",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:17170,access,accessible,17170,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['access'],['accessible']
Security,"lock_byref`` heap data structure. For example,. .. code-block:: c++. __block FOO blockStorageFoo;. requires the normal constructor for the embedded ``blockStorageFoo`` object:. .. code-block:: c++. FOO_ctor(& _block_byref_blockStorageFoo->blockStorageFoo);. and at scope termination the destructor:. .. code-block:: c++. FOO_dtor(& _block_byref_blockStorageFoo->blockStorageFoo);. Note that the forwarding indirection is *NOT* used. The compiler would need to generate (if used from a block literal) the following; copy/dispose helpers:. .. code-block:: c++. void _block_byref_obj_keep(struct _block_byref_blockStorageFoo *dst, struct _block_byref_blockStorageFoo *src) {; FOO_ctor(&dst->blockStorageFoo, &src->blockStorageFoo);; }. void _block_byref_obj_dispose(struct _block_byref_blockStorageFoo *src) {; FOO_dtor(&src->blockStorageFoo);; }. for the appropriately named constructor and destructor for the class/struct; ``FOO``. To support member variable and function access the compiler will synthesize a; ``const`` pointer to a block version of the ``this`` pointer. .. _RuntimeHelperFunctions:. Runtime Helper Functions; ========================. The runtime helper functions are described in; ``/usr/local/include/Block_private.h``. To summarize their use, a ``Block``; requires copy/dispose helpers if it imports any block variables, ``__block``; storage variables, ``__attribute__((NSObject))`` variables, or C++ ``const``; copied objects with constructor/destructors. The (1<<26) bit is set and; functions are generated. The block copy helper function should, for each of the variables of the type; mentioned above, call:. .. code-block:: c. _Block_object_assign(&dst->target, src->target, BLOCK_FIELD_<apropos>);. in the copy helper and:. .. code-block:: c. _Block_object_dispose(->target, BLOCK_FIELD_<apropos>);. in the dispose helper where ``<apropos>`` is:. .. code-block:: c. enum {; BLOCK_FIELD_IS_OBJECT = 3, // id, NSObject, __attribute__((NSObject)), block, ...; BLOCK_FIELD_IS_BLO",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:27520,access,access,27520,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['access'],['access']
Security,"lookup by name table, and in the CFI Common Information Entry; (CIE). See :ref:`amdgpu-dwarf-full-and-partial-compilation-unit-entries`,; :ref:`amdgpu-dwarf-name-index-section-header`, and; :ref:`amdgpu-dwarf-structure_of-call-frame-information`. 2.16 Support Embedding Source Text for Online Compilation; ---------------------------------------------------------. AMDGPU supports programming languages that include online compilation where the; source text may be created at runtime. For example, the OpenCL and HIP language; runtimes support online compilation. To support is, a way to embed the source; text in the debug information is provided. See :ref:`amdgpu-dwarf-line-number-information`. 2.17 Allow MD5 Checksums to be Optionally Present; -------------------------------------------------. In DWARF Version 5 the file timestamp and file size can be optional, but if the; MD5 checksum is present it must be valid for all files. This is a problem if; using link time optimization to combine compilation units where some have MD5; checksums and some do not. Therefore, sSupport to allow MD5 checksums to be; optionally present in the line table is added. See :ref:`amdgpu-dwarf-line-number-information`. 2.18 Add the HIP Programing Language; ------------------------------------. The HIP programming language [:ref:`HIP <amdgpu-dwarf-HIP>`], which is supported; by the AMDGPU, is added. See :ref:`amdgpu-dwarf-language-names-table`. 2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution; --------------------------------------------------------------------------------------------. A compiler can perform loop optimizations that result in the generated code; executing multiple iterations concurrently. For example, software pipelining; schedules multiple iterations in an interleaved fashion to allow the; instructions of one iteration to hide the latencies of the instructions of; another iteration. Another example is vectorization that can exploit SI",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:32252,checksum,checksums,32252,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['checksum'],['checksums']
Security,"loop (15 mins) after client disconnectionsAvoid potential deadlocks when trying to remove a node from a clusterCorrect matching of incoming connection with previously dropped connectionCorrect export of cluster identificationCorrectly propagate information about files that could not be stagedPrevent endsess deadlock when parallel streams stall due to large WAN RTTFix infinite wait for primary login that will never; happen if you are a manager without a meta-managerPrevent annoying (but not deadly) infinite loop should a; server go offline that is subject to a locate request display.Client sideBetter handling of errno, especially for parallel streamsAllow the client to cycle through all the remaining valid security protocols in the list of protocols returned by the serverMake the readahead strategy more conservativeFix a rare race condition happening when destroying instances with outstanding open requestsEnforce cache coherency in the case of reads+writes in the same fileCorrectly guess the filesize of a file opened for writing in sync modeMake server host name check more flexible for GSI authenticationFix some relevant issues with cache handling on the client, including a rare but fatal bug in; determining the cache holes list and the end of a cache lookupMore complete detection of async read errorsGeneralFix problem in handling the return code; of X509_REQ_verify; in XrdCryptosslX509Req.ccAvoid SEGV when doing an lsd admin command with; authenticated xrootd clientsClose race conditions that allowed a supervisor/manager; to subscribe without declaring a data port. Initialize nostage state in; XrdCmsState to prevent erroneous state declaration during; initialization.Fix a problem with the subject name of proxies of level; > 1; this was creating a failure when a Globus application was; trying to use the proxy certificateFix a problem with cache refreshing in XrdSutCache; affecting automatic reloading of password filesFor now, turn off IPV6 processing as it seems to cr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html:2042,secur,security,2042,net/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v524/index.html,4,"['authenticat', 'secur']","['authenticationFix', 'security']"
Security,"lors can be found at `colors; <http://www.graphviz.org/doc/info/colors.html>`_.) More complex node attributes; can be provided with ``call DAG.setGraphAttrs(node, ""attributes"")`` (choices can; be found at `Graph attributes <http://www.graphviz.org/doc/info/attrs.html>`_.); If you want to restart and clear all the current graph attributes, then you can; ``call DAG.clearGraphAttrs()``. Note that graph visualization features are compiled out of Release builds to; reduce file size. This means that you need a Debug+Asserts or Release+Asserts; build to use these features. .. _datastructure:. Picking the Right Data Structure for a Task; ===========================================. LLVM has a plethora of data structures in the ``llvm/ADT/`` directory, and we; commonly use STL data structures. This section describes the trade-offs you; should consider when you pick one. The first step is a choose your own adventure: do you want a sequential; container, a set-like container, or a map-like container? The most important; thing when choosing a container is the algorithmic properties of how you plan to; access the container. Based on that, you should use:. * a :ref:`map-like <ds_map>` container if you need efficient look-up of a; value based on another value. Map-like containers also support efficient; queries for containment (whether a key is in the map). Map-like containers; generally do not support efficient reverse mapping (values to keys). If you; need that, use two maps. Some map-like containers also support efficient; iteration through the keys in sorted order. Map-like containers are the most; expensive sort, only use them if you need one of these capabilities. * a :ref:`set-like <ds_set>` container if you need to put a bunch of stuff into; a container that automatically eliminates duplicates. Some set-like; containers support efficient iteration through the elements in sorted order.; Set-like containers are more expensive than sequential containers. * a :ref:`sequential <",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:55288,access,access,55288,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"low can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded at the start of any session.; Download it, save it under the name ``features.h``, and load it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. `Basics`; --------. All bound C++ code starts off from the global C++ namespace, represented in; Python by ``gbl``.; This namespace, as any other namespace, is treated as a module after it has; been loaded.; Thus, we can import C++ classes that live underneath it:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> Concrete; <class cppyy.gbl.Concrete at 0x2058e30>; >>>. Placing classes in the same structure as imposed by C++ guarantees identity,; even if multiple Python modules bind the same class.; There is, however, no necessity to expose that structure to end-users: when; developing a Python package that exposes C++ classes through ``cppyy``,; consider ``cppyy.gbl`` an ""internal"" module, and expose the classes in any; structure you see fit.; The C++ names will continue to follow the C++ structure, however, as is needed; for e.g. pickling:. .. code-block:: python. >>> from cppyy.gbl import Namespace; >>> Concrete == Namespace.Concrete; False; >>> n = Namespace.Concrete.NestedClass(); >>> type(n); <class cppyy.gbl.Namespace.Concrete.NestedClass at 0x22114c0>; >>> type(n).__name__; NestedClass; >>> type(n).__module__; cppyy.gbl.Namespace.Concrete; >>> type(n).__cpp_name__; Namespace::Concrete::NestedClass; >>>. `Constructors`; --------------. Python and C++ both make a distinction between allocation (``__new__`` in; Python, ``operator new`` in C++) and initialization (``__init__`` in Python,; the constructor call in C++).; When binding, however, there comes a subtle semantic difference: the Python; ``__new__`` allocates memory for the proxy object only, and ``__init__``; initializes the proxy by creating or binding the C++ object.; Thus, no C++ memory is allocated until ``__init__``.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:1231,expose,expose,1231,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['expose'],['expose']
Security,"low``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shift-base`` or; ``-fsanitize=shift-exponent`` to check only left-hand side or; right-hand side of shift operation, respectively.; - ``-fsanitize=unsigned-shift-base``: check that an unsigned left-hand side of; a left shift operation doesn't overflow. Issues caught by this sanitizer are; not undefined behavior, but are often unintentional.; - ``-fsanitize=signed-integer-overflow``: Signed integer overflow, where the; result of a signed integer computation cannot be represented in its type.; This includes all the checks covered by ``-ftrapv``, as well as checks for; signed division overflow (``INT_MIN/-1``), but not checks for; lossy implicit conversions performed before the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=impli",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:8566,sanitiz,sanitizer,8566,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitizer']
Security,"lowed automatically for these objects:. * objects of dynamic storage duration created in other memory, such as; that returned by ``malloc``; * union members. .. admonition:: Rationale. ARC must perform special operations when initializing an object and; when destroying it. In many common situations, ARC knows when an; object is created and when it is destroyed and can ensure that these; operations are performed correctly. Otherwise, however, ARC requires; programmer cooperation to establish its initialization invariants; because it is infeasible for ARC to dynamically infer whether they; are intact. For example, there is no syntactic difference in C between; an assignment that is intended by the programmer to initialize a variable; and one that is intended to replace the existing value stored there,; but ARC must perform one operation or the other. ARC chooses to always; assume that objects are initialized (except when it is in charge of; initializing them) because the only workable alternative would be to; ban all code patterns that could potentially be used to access; uninitialized memory, and that would be too limiting. In practice,; this is rarely a problem because programmers do not generally need to; work with objects for which the requirements are not handled; automatically. Note that dynamically-allocated Objective-C++ arrays of; nontrivially-ownership-qualified type are not ABI-compatible with non-ARC; code because the non-ARC code will consider the element type to be POD.; Such arrays that are ``new[]``'d in ARC translation units cannot be; ``delete[]``'d in non-ARC translation units and vice-versa. .. _arc.ownership.restrictions.pass_by_writeback:. Passing to an out parameter by writeback; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If the argument passed to a parameter of type ``T __autoreleasing *`` has type; ``U oq *``, where ``oq`` is an ownership qualifier, then the argument is a; candidate for :arc-term:`pass-by-writeback`` if:. * ``oq`` is ``__strong",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:47823,access,access,47823,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['access']
Security,"lowing; clients to retrieve remarks and their associated metadata directly from; intermediate products. ``SeparateRemarksFile: the remark entries emitted separately``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_REMARK_VERSION <bitstreamremarksrecordmetaremarkversion>`. This container type expects 0 or more :ref:`REMARK_BLOCK <bitstreamremarksremarkblock>`. Typically, this is emitted in a side-file alongside an object file, and is; made to be able to stream to without increasing the memory consumption of; the compiler. This is referenced by the :ref:`RECORD_META_EXTERNAL_FILE; <bitstreamremarksrecordmetaexternalfile>` entry in the; :ref:`SeparateRemarksMeta <bitstreamremarksseparateremarksmeta>` container. When the parser tries to parse a container that contains the metadata for the; separate remarks, it should parse the version and type, then keep the string; table in memory while opening the external file, validating its metadata and; parsing the remark entries. The container versions from the separate container should match in order to; have a well-formed file. ``Standalone: the metadata and the remark entries emitted together``. This container type expects only a :ref:`META_BLOCK <bitstreamremarksmetablock>` containing only:. * :ref:`RECORD_META_CONTAINER_INFO <bitstreamremarksrecordmetacontainerinfo>`; * :ref:`RECORD_META_REMARK_VERSION <bitstreamremarksrecordmetaremarkversion>`; * :ref:`RECORD_META_STRTAB <bitstreamremarksrecordmetastrtab>`. This container type expects 0 or more :ref:`REMARK_BLOCK <bitstreamremarksremarkblock>`. A complete output of :program:`llvm-bcanalyzer` on the different container types:. ``SeparateRemarksMeta``. .. code-block:: none. <BLOCKINFO_BLOCK/>; <Meta BlockID=8 NumWords=13 BlockCodeSize=3>; <Container info codeid=1 abbrevid=4 op0=5 op1=0/>; <String table codeid=3 abbrevid=5/> blo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst:12507,validat,validating,12507,interpreter/llvm-project/llvm/docs/Remarks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Remarks.rst,1,['validat'],['validating']
Security,"ls.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reported. ### Indirect Branches, Calls, and Returns. It is possible to attack control flow other than conditional branches with; variant #1 style mispredictions.; * A prediction towards a hot call target of a virtual method can lead to it; being speculatively executed when an expected type is used (often called; ""type confusion"").; * A hot case may be speculatively executed due to prediction instead of the; correct case for a switch statement implemented as a jump table.; * A hot common return address may be predicted incorrectly when returning from; a function. These code patterns are also vulnerable to Spectre variant #2, and as such are; best mitigated with a; [retpoline](https://support.google.com/faqs/answer/7625886) on x86 platforms.; When a mitigation technique like retpoline is used, speculation simply cannot; proceed through an indirect control flow edge (or it cannot be mispredicted in; the case of a filled RSB) and so it is also protected from variant #1 style; attacks. However, some architectures, micro-architectures, or vendors do not; employ the retpoline mitigation, and on future x86 hardware (both Intel and; AMD) it is expected to become unnecessary due to hardware-based mitigation. When not using a retpoline, these edges will need independent protection from; variant #1 style attacks. The analogous approach to that used for conditional; control flow should work:; ```; uintptr_t all_ones_mask = std::numerical_limits<uintptr_t>::max();; uintptr_t all_zeros_mask = 0;; void leak(int data);; void example(int* pointer1, int* pointer2) {; uintptr_t predicate_state = all_ones_mask;; switch (condition) {; case 0:; // Assuming ?: is implemented using branchless logic...; predicate_state = (condition != 0) ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predica",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:9323,attack,attacks,9323,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacks']
Security,"lso be subject to CFI protections. Non-virtual; calls (``-fsanitize=cfi-nvcall``) and cast checks (``-fsanitize=cfi-*cast*``); are not implemented due to a lack of information provided by the bytecode. The tool would operate by searching for indirect control flow instructions in; the disassembly. A control flow graph would be generated from a small buffer of; the instructions surrounding the 'target' control flow instruction. If the; target instruction is branched-to, the fallthrough of the branch should be the; CFI trap (on x86, this is a ``ud2`` instruction). If the target instruction is; the fallthrough (i.e. immediately succeeds) of a conditional jump, the; conditional jump target should be the CFI trap. If an indirect control flow; instruction does not conform to one of these formats, the target will be noted; as being CFI-unprotected. Note that in the second case outlined above (where the target instruction is the; fallthrough of a conditional jump), if the target represents a vcall that takes; arguments, these arguments may be pushed to the stack after the branch but; before the target instruction. In these cases, a secondary 'spill graph' in; constructed, to ensure the register argument used by the indirect jump/call is; not spilled from the stack at any point in the interim period. If there are no; spills that affect the target register, the target is marked as CFI-protected. Other Design Notes; ~~~~~~~~~~~~~~~~~~. Only machine code sections that are marked as executable will be subject to this; analysis. Non-executable sections do not require analysis as any execution; present in these sections has already violated the control flow integrity. Suitable extensions may be made at a later date to include analysis for indirect; control flow operations across DSO boundaries. Currently, these CFI features are; only experimental with an unstable ABI, making them unsuitable for analysis. The tool currently only supports the x86, x86_64, and AArch64 architectures.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst:4170,integrity,integrity,4170,interpreter/llvm-project/llvm/docs/CFIVerify.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst,1,['integrity'],['integrity']
Security,"lt preference,; 1: `Iterative strategy`, and; 2: `DPP`.; If target does not support the DPP operations (e.g. gfx6/7),; reduction will be performed using default iterative strategy.; Intrinsic is currently only implemented for i32. llvm.amdgcn.wave.reduce.umax Performs an arithmetic unsigned max reduction on the unsigned values; provided by each lane in the wavefront.; Intrinsic takes a hint for reduction strategy using second operand; 0: Target default preference,; 1: `Iterative strategy`, and; 2: `DPP`.; If target does not support the DPP operations (e.g. gfx6/7),; reduction will be performed using default iterative strategy.; Intrinsic is currently only implemented for i32. llvm.amdgcn.udot2 Provides direct access to v_dot2_u32_u16 across targets which; support such instructions. This performs unsigned dot product; with two v2i16 operands, summed with the third i32 operand. The; i1 fourth operand is used to clamp the output. llvm.amdgcn.udot4 Provides direct access to v_dot4_u32_u8 across targets which; support such instructions. This performs unsigned dot product; with two i32 operands (holding a vector of 4 8bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output. llvm.amdgcn.udot8 Provides direct access to v_dot8_u32_u4 across targets which; support such instructions. This performs unsigned dot product; with two i32 operands (holding a vector of 8 4bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output. llvm.amdgcn.sdot2 Provides direct access to v_dot2_i32_i16 across targets which; support such instructions. This performs signed dot product; with two v2i16 operands, summed with the third i32 operand. The; i1 fourth operand is used to clamp the output.; When applicable (e.g. no clamping), this is lowered into; v_dot2c_i32_i16 for targets which support it. llvm.amdgcn.sdot4 Provides direct access to v_dot4_i32_i8 across targets which; support such instructions. This performs",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:39426,access,access,39426,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"lue; | data[n] | HashData for this bucket; |------------|; 0x00003500: | 0x00003550 | next pointer; | 0x29273623 | 32 bit hash; | ""dump"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003550: | 0x00000000 | next pointer; | 0x82638293 | 32 bit hash; | ""main"" | string value; | data[n] | HashData for this bucket; `------------'. The problem with this layout for debuggers is that we need to optimize for the; negative lookup case where the symbol we're searching for is not present. So; if we were to lookup ""``printf``"" in the table above, we would make a 32-bit; hash for ""``printf``"", it might match ``bucket[3]``. We would need to go to; the offset 0x000034f0 and start looking to see if our 32 bit hash matches. To; do so, we need to read the next pointer, then read the hash, compare it, and; skip to the next bucket. Each time we are skipping many bytes in memory and; touching new pages just to do the compare on the full 32 bit hash. All of; these accesses then tell us that we didn't have a match. Name Hash Tables; """""""""""""""""""""""""""""""". To solve the issues mentioned above we have structured the hash tables a bit; differently: a header, buckets, an array of all unique 32 bit hash values,; followed by an array of hash value data offsets, one for each hash value, then; the data for all hash values:. .. code-block:: none. .-------------.; | HEADER |; |-------------|; | BUCKETS |; |-------------|; | HASHES |; |-------------|; | OFFSETS |; |-------------|; | DATA |; `-------------'. The ``BUCKETS`` in the name tables are an index into the ``HASHES`` array. By; making all of the full 32 bit hash values contiguous in memory, we allow; ourselves to efficiently check for a match while touching as little memory as; possible. Most often checking the 32 bit hash values is as far as the lookup; goes. If it does match, it usually is a match with no collisions. So for a; table with ""``n_buckets``"" buckets, and ""``n_hashes``"" unique 32 bit hash; values, we can clarif",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:62730,access,accesses,62730,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['access'],['accesses']
Security,"lvm's SmallPtrSet.h; # somehow lands in our cling libraries on OS X and doesn't get hidden; # by visibility-inlines-hidden, so we suddenly have a global weak symbol; # from LLVM in cling which our visiblity=hidden compiled LLVM libraries; # reference. This is triggering some build system warnings like this:; # ld: warning: direct access in function '(anonymous namespace)::NewGVN::runGVN()'; # from file 'interpreter/llvm-project/llvm/lib/libLLVMScalarOpts.a(NewGVN.cpp.o)' to global weak symbol; # 'llvm::ReverseIterate<bool>::value' from file 'interpreter/llvm-project/llvm/lib/libclingUtils.a(AST.cpp.o)'; # means the weak symbol cannot be overridden at runtime. This was likely caused by different; # translation units being compiled with different visibility settings.; # There is no apparent reason why this is happening and it looks like a compiler bug,; # so let's just disable the part of the code that provides this symbol.; # As it's in the validation part of LLVM and not in something that providing functionality,; # this shouldn't cause any problems.; # TODO: We maybe can remove this code once we upgrade to LLVM>=6.0 as this symbol; # was introduced quite recently into LLVM 5.0 and probably is also causing problems; # for some other projects.; set(LLVM_ENABLE_ABI_BREAKING_CHECKS OFF CACHE BOOL """" FORCE); set(LLVM_ABI_BREAKING_CHECKS FORCE_OFF CACHE BOOL """" FORCE). set(CMAKE_REQUIRED_QUIET 1) # Make the configuration of LLVM quiet. if(ROOT_ARCHITECTURE MATCHES arm64); set(ROOT_CLING_TARGET ""AArch64""); elseif(ROOT_ARCHITECTURE MATCHES arm); set(ROOT_CLING_TARGET ""ARM""); elseif(ROOT_ARCHITECTURE MATCHES ppc64); set(ROOT_CLING_TARGET ""PowerPC""); elseif(ROOT_ARCHITECTURE MATCHES s390); set(ROOT_CLING_TARGET ""SystemZ""); elseif(ROOT_ARCHITECTURE MATCHES riscv64); set(ROOT_CLING_TARGET ""RISCV""); elseif(ROOT_ARCHITECTURE MATCHES freebsd OR ROOT_ARCHITECTURE MATCHES linux OR ROOT_ARCHITECTURE MATCHES macosx); set(ROOT_CLING_TARGET ""X86""); elseif(ROOT_ARCHITECTURE MATCHES win32",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:4074,validat,validation,4074,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['validat'],['validation']
Security,"lvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311510,access,access,311510,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"lvm.preserve.struct.access.index.p0i8.p0s_struct.anon.0s(<type> base,; i32 gep_index,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.struct.access.index``' intrinsic returns the getelementptr address; based on struct base ``base`` and IR struct member index ``gep_index``.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide struct debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``ret_type`` is a pointer type to the structure member. Arguments:; """""""""""""""""""". The ``base`` is the structure base address. The ``gep_index`` is the struct member index; based on IR structures. The ``di_index`` is the struct member index based on debuginfo. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.struct.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{0, gep_index}``. '``llvm.fptrunc.round``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.fptrunc.round(<type> <value>, metadata <rounding mode>). Overview:; """""""""""""""""". The '``llvm.fptrunc.round``' intrinsic truncates; :ref:`floating-point <t_floating>` ``value`` to type ``ty2``; with a specified rounding mode. Arguments:; """""""""""""""""""". The '``llvm.fptrunc.round``' intrinsic takes a :ref:`floating-point; <t_floating>` value to cast and a :ref:`floating-point <t_floating>` type; to cast it to. This argument must be larger in size than the result. The second argument specifies the rounding mode as described in the constrained; intrinsics section.; For this intrinsic, the ""round.dynamic"" mode is not supported. Semantics:; """""""""""""""""""". The '``llvm.fptrunc.round``' intrinsic casts a ``value`` from a larger; :ref:`floating-point",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:975995,access,access,975995,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"lvm.ptrauth.sign(i64 <value>, i32 <key>, i64 <discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.sign`' intrinsic signs a raw pointer. ##### Arguments:. The `value` argument is the raw pointer value to be signed.; The `key` argument is the identifier of the key to be used to generate the; signed value.; The `discriminator` argument is the additional diversity data to be used as a; discriminator (an integer, an address, or a blend of the two). ##### Semantics:. The '`llvm.ptrauth.sign`' intrinsic implements the `sign`_ operation.; It returns a signed value. If `value` is already a signed value, the behavior is undefined. If `value` is not a pointer value for which `key` is appropriate, the; behavior is undefined. #### '`llvm.ptrauth.auth`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.auth(i64 <value>, i32 <key>, i64 <discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.auth`' intrinsic authenticates a signed pointer. ##### Arguments:. The `value` argument is the signed pointer value to be authenticated.; The `key` argument is the identifier of the key that was used to generate; the signed value.; The `discriminator` argument is the additional diversity data to be used as a; discriminator. ##### Semantics:. The '`llvm.ptrauth.auth`' intrinsic implements the `auth`_ operation.; It returns a raw pointer value.; If `value` does not have a correct signature for `key` and `discriminator`,; the intrinsic traps in a target-specific way. #### '`llvm.ptrauth.strip`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.strip(i64 <value>, i32 <key>); ```. ##### Overview:. The '`llvm.ptrauth.strip`' intrinsic strips the embedded signature out of a; possibly-signed pointer. ##### Arguments:. The `value` argument is the signed pointer value to be stripped.; The `key` argument is the identifier of the key that was used to generate; the signed value. ##### Semantics:. The '`llvm.ptrauth.strip`' intrinsic implements the `strip`_ operation.; It returns a raw pointer val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:2237,authenticat,authenticated,2237,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,1,['authenticat'],['authenticated']
Security,"lvm/issues/detail?id=5; * https://bugs.chromium.org/p/llvm/issues/detail?id=11. Both issues were addressed with source changes: #5 in clangd/vscode-clangd, and; #11 in llvm-project. No dedicated LLVM release was made for either. We believe that with the publishing of this first annual transparency report,; the security group now has implemented all necessary processes for the group to; operate as promised. The group's processes can be improved further, and we do; expect further improvements to get implemented in 2022. Many of the potential; improvements end up being discussed on the `monthly public call on LLVM's; security group <https://llvm.org/docs/GettingInvolved.html#online-sync-ups>`_. 2022; ----. In this section we report on the issues the group received in 2022, or on issues; that were received earlier, but were disclosed in 2022. In 2022, the llvm security group received 15 issues that have been disclosed at; the time of writing this transparency report. 5 of these were judged to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=17 reports a miscompile in; LLVM that can result in the frame pointer and return address being; overwritten. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=19 reports a vulnerability; in `std::filesystem::remove_all` in libc++. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=23 reports a new Spectre; gadget variant that Speculative Load Hardening (SLH) does not mitigate. No; extension to SLH was implemented to also mitigate against this variant. * https://bugs.chromium.org/p/llvm/issues/detail?id=30 reports missing memory; safety protection on the (C++) exception handling path. A number of fixes; were implemented. * https://bugs.chromium.org/p/llvm/issues/detail?id=33 reports the RETBLEED; vulnerability. The outcome was clang growing a new security hardening feature; `-mfunction-return=thunk-extern`, see https://reviews.llvm.org/D129572. No dedicated LLVM releases were m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst:2392,secur,security,2392,interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,1,['secur'],['security']
Security,"ly 2 and 3). `ASGA` is a special key that cannot be explicitly specified, and is only ever; used implicitly, to implement the; [`llvm.ptrauth.sign_generic`](#llvm-ptrauth-sign-generic) intrinsic. #### Instructions. The IR [Intrinsics](#intrinsics) described above map onto these; instructions as such:; * [`llvm.ptrauth.sign`](#llvm-ptrauth-sign): `PAC{I,D}{A,B}{Z,SP,}`; * [`llvm.ptrauth.auth`](#llvm-ptrauth-auth): `AUT{I,D}{A,B}{Z,SP,}`; * [`llvm.ptrauth.strip`](#llvm-ptrauth-strip): `XPAC{I,D}`; * [`llvm.ptrauth.blend`](#llvm-ptrauth-blend): The semantics of the blend; operation are specified by the ABI. In both the ELF PAuth ABI Extension and; arm64e, it's a `MOVK` into the high 16 bits. Consequently, this limits; the width of the integer discriminator used in blends to 16 bits.; * [`llvm.ptrauth.sign_generic`](#llvm-ptrauth-sign-generic): `PACGA`; * [`llvm.ptrauth.resign`](#llvm-ptrauth-resign): `AUT*+PAC*`. These are; represented as a single pseudo-instruction in the backend to guarantee that; the intermediate raw pointer value is not spilled and attackable. #### Assembly Representation. At the assembly level, authenticated relocations are represented; using the `@AUTH` modifier:. ```asm; .quad _target@AUTH(<key>,<discriminator>[,addr]); ```. where:; * `key` is the Armv8.3-A key identifier (`ia`, `ib`, `da`, `db`); * `discriminator` is the 16-bit unsigned discriminator value; * `addr` signifies that the authenticated pointer is address-discriminated; (that is, that the relocation's target address is to be blended into the; `discriminator` before it is used in the sign operation. For example:; ```asm; _authenticated_reference_to_sym:; .quad _sym@AUTH(db,0); _authenticated_reference_to_sym_addr_disc:; .quad _sym@AUTH(ia,12,addr); ```. #### ELF Object File Representation. At the object file level, authenticated relocations are represented; using the `R_AARCH64_AUTH_ABS64` relocation kind (with value `0xE100`). The signing schema is encoded in the place of relocation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:9373,attack,attackable,9373,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,1,['attack'],['attackable']
Security,"ly be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the experiment's software you; need. For instance, in the CMS use case, only one file is needed:; `~/.vaf/common.before`, which contains something like:. ``` {.bash}; # Version of CMSSW (as reported by ""scram list""); export VafCmsswVersion='CMSSW_5_3_9_sherpa2beta2'; ```. ### Entering the VAF environment. Open a terminal on your client machine (can be either your local; computer or a remote user interface) and type:. vaf-enter <username>@cloud-gw-213.to.infn.it. You'll substitute `<username>` with the username that either your system; administrator or the web authentication (if you used it) provided you. You'll be presented with a neat shell which looks like the following:. Entering VAF environment: dberzano@cloud-gw-213.to.infn.it; Remember: you are still in a shell on your local computer!; pod://dberzano@cloud-gw-213.to.infn.it [~] >. This shell runs on your local computer and it has the environment; properly set up. PoD and PROOF workflow; ----------------------. > The following operations are valid inside the `vaf-enter` environment. ### Start your PoD server. With PROOF on Demand, each user has the control of its own personal; PROOF cluster. The first thing to do is to start the PoD server and the; PROOF master like this:. vafctl --start. A successful output will be similar to:. ** Starting remote PoD server on dberzano@cloud-gw-213.to.infn.it:/cvmfs/sft.cern.ch/lcg/external/PoD/3.12/x86_64-slc5-gcc41-python24-boost1.53; ** Server is started. Use ""pod-info -sd"" to check the status of the server. ### Request a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:9951,authenticat,authentication,9951,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['authenticat'],['authentication']
Security,"ly degrade also handle; this problem (e.g. GlobalsAA), but they run into the issue of having to be; manually recomputed somewhere in the optimization pipeline if we want precision,; and they block potential future concurrency. The second reason is to keep in mind potential future pass concurrency, for; example parallelizing function passes over different functions in a CGSCC or; module. Since passes can ask for a cached analysis result, allowing passes to; trigger outer level analysis computation could result in non-determinism if; concurrency was supported. A related limitation is that outer level IR analyses; that are used must be immutable, or else they could be invalidated by changes to; inner level IR. Outer analyses unused by inner passes can and often will be; invalidated by changes to inner level IR. These invalidations happen after the; inner pass manager finishes, so accessing mutable analyses would give invalid; results. The exception to not being able to access outer level analyses is accessing; function analyses in loop passes. Loop passes often use function analyses such; as the dominator tree. Loop passes inherently require modifying the function the; loop is in, and that includes some function analyses the loop analyses depend; on. This discounts future concurrency over separate loops in a function, but; that's a tradeoff due to how tightly a loop and its function are coupled. To; make sure the function analyses that loop passes use are valid, they are; manually updated in the loop passes to ensure that invalidation is not; necessary. There is a set of common function analyses that loop passes and; analyses have access to which is passed into loop passes as a; ``LoopStandardAnalysisResults`` parameter. Other mutable function analyses are; not accessible from loop passes. As with any caching mechanism, we need some way to tell analysis managers; when results are no longer valid. Much of the analysis manager complexity; comes from trying to invalidate a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:10566,access,access,10566,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,2,['access'],"['access', 'accessing']"
Security,"ly if buffered writing is turned off.; The parallel writer assumes exclusive access to the underlying file during all operations on the writer (e.g. construction and destruction) and all operations on any created fill context (e.g. `Fill()` and `FlushCluster()`).; Notable exceptions are `FlushColumns()` and `FillNoFlush()` which are guaranteed to never access the underlying `TFile` during parallel writing (which is always buffered). A `TFile` does not take ownership of any `RNTuple` objects. When reading data, RNTuple uses the `RMiniFile` and `RRawFile` classes to open a given storage path and find the `RNTuple` anchor.; When creating a `RNTupleReader` from an existing anchor object, RNTuple uses `RRawFile` only for files of dynamic type `TFile`, `TDavixFile`, and `TNetXNGFile`.; In either case, the `RRawFile` owns its own file descriptor and does not interfere with `TFile` objects concurrently reading the file.; For anchors from files of other dynamic type, including all other `TFile` subclasses, the file is wrapped in a `RRawFileTFile` and access is shared. On-Disk Encoding; ----------------. ### Writing Case; The following steps are taken to write RNTuple data to disk:. 1. On creation of the RNTupleWriter, the header is written to disk; 2. Upon `RNTupleWriter::Fill()`, the RField<T> class _serializes_ the object into its column representation.; To this end, it uses the `RColumn` class to append elements to the columns page buffer (`RPage`); 3. When a page buffer is full (cf. tuning.md), it is sent to the page sink for writing it to disk.; Note that page boundaries do _not_ need to align with entry boundaries,; e.g. information from a single entry can span multiple pages.; 1. The page is _packed_:; depending on the type of the page, a light encoding is applied to facilitate compression, e.g., byte splitting (`RColumnElement`).; Big-endian / little-endian conversion takes place here.; 2. The packed page is _compressed_ according to the user-provided compression set",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:19098,access,access,19098,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"ly when web page is opened.; One also can configure to display several items at once. For that one also can configure layout of the drawing area:. ```cpp; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; ```. One also can change appearance of hierarchy browser on the left side of the web page:. ```cpp; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; ```. If necessary, one also can automatically open ROOT file when web page is opened:. ```cpp; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; ```. ## Configuring user access. By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the **htdigest** utility. ```bash; [shell] htdigest -c .htdigest domain_name user_name; ```. It is recommended not to use special symbols in domain or user names. Several users can be add to the "".htdigest"" file. When starting the server, the following arguments should be specified:. ```cpp; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; ```. After that, the web browser will automatically request to input a name/password for the domain ""domain_name"". Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using `THttpServer::Restrict()` method. For instance, one could hide complete folder from 'guest' account:. ```cpp; serv->Restrict(""/Folder"", ""hidden=guest"");; ```. Or one could hide from all but 'admin' account:. ```cpp; serv->Restrict(""/Folder"", ""visible=admin"");; ```. Hidden folders or object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:8206,access,access,8206,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,2,"['access', 'authenticat']","['access', 'authenticated']"
Security,"m - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are marked with a red bar. Of course you won't see any protected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it using GetName() as defined in its base; class TNamed. If you want to see; all available members, and not just the ones defined in the current class, in the; display options. They will be prefixed with the name of; the class they are defined in. Class Charts; The class charts are shown in a tabbed box; click on the names ontop to select a tab. Inheritance; This chart shows the inheritance hierarchy for the current class. Arrows point to; base classes. You can click the classes to get to their reference page. Inherited Members; The second chart shows a list of all members of all base classes. You can see at what; level they are defined or at what level they are defined. Members that are accessible; (public) have a green background, protected ones have a yellow background, and private; members have a red background. Members with a dark gray background are re-implemented; or hidden by a derived class. Includes; The Includes chart shows which files are indirectly included by including t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:6592,access,access,6592,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,2,['access'],['access']
Security,"m-online.cern.ch/dashboard), click on the; **Create new context...** dropdown and select **Virtual Analysis Facility; node**. There's only a few parameters to configure. Context name; : A name for your context (such as *VAF Master for ATLAS*). Any name; will work. Role; : Use this to configure either a *master* or a *slave*. VAF master (only available when configuring a slave); : IP address or FQDN of the Virtual Analysis Facility master. Auth method; : Choose between *ALICE LDAP* (useful only for ALICE users) or *Pool; accounts* (good for authenticating all the other Grid users). Num. pool accounts (only available when using pool accounts auth); : Number of pool accounts to create. Proxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same cluster should have the same value of this; field. It is used to mutually authenticate VMs and it is used like a; password. Context password; : Current profile will be saved on the [CernVM Online; repository](http://cernvm-online.cern.ch/). If you don't want the; information there to be publicly available to other users, type in; a value for protecting the context with an encryption password. You will have to create a profile for the **master** and the **slave**. Since; most of the configuration variables are the same (like the *HTCondor; shared secret*) you can create one, clone it and change only what's; needed to change. Deploy it on the cloud; ----------------------. Provided you have access to a certain cloud API, you'll need to; instantiate a certain number of CernVM batch images with proper; contextualization: one for the master, as many as you want as slaves. CernVM supports contextualization through the ""user data"" field; supported by all cloud infrastructures. Each cloud infrastructure has a different method of setting the ""user; data"". The following descriptio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:2974,authenticat,authenticate,2974,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,2,"['authenticat', 'password']","['authenticate', 'password']"
Security,"m.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310508,access,access,310508,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"m.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310682,access,access,310682,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['access']
Security,"m.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; metadata for the outer loop; !3 = distinct !{} ; access group for instructions in the inner loop (which are implicitly contained in outer loop as well); !4 = distinct !{} ; access group for instructions in the outer, but not the inner loop. .. _langref_llvm_loop_mustprogress:. '``llvm.loop.mustprogress``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.mustpro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313603,access,access,313603,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"m.objc.storeWeak(ptr, ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_storeWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-storeweak>`_. Preserving Debug Information Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These intrinsics are used to carry certain debuginfo together with; IR-level operations. For example, it may be desirable to; know the structure/union name and the original user-level field; indices. Such information got lost in IR GetElementPtr instruction; since the IR types are different from debugInfo types and unions; are converted to structs in IR. '``llvm.preserve.array.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.array.access.index.p0s_union.anons.p0a10s_union.anons(<type> base,; i32 dim,; i32 index). Overview:; """""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic returns the getelementptr address; based on array base ``base``, array dimension ``dim`` and the last access index ``index``; into the array. The return type ``ret_type`` is a pointer type to the array element.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.array.access.index``' in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:972895,access,access,972895,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"mailing list you have the opportunity to reply only to the sender of; the email, not to the entire list. That is not supported when replying via; email on Discourse. However you can send someone a private message via the; Web UI: Click on the user's name above a post and then on `Message`. Also Discourse does not expose users' email addresses , so your private; replies have to go through their platform (unless you happen to know the; email address of the user.). ### How can my script/tool send automatic messages?**. In case you want to [create a new; post/topic](https://docs.discourse.org/#tag/Posts/paths/~1posts.json/post); automatically from a script or tool, you can use the; [Discourse API](https://docs.discourse.org/). ### Who are the admins for Discourse?. See https://llvm.discourse.group/about. ### What is the reason for the migration?. See; [this email](https://lists.llvm.org/pipermail/llvm-dev/2021-June/150823.html). ### How do I set up a private mailing list?. If needed categories can have individual [security; settings](https://meta.discourse.org/t/how-to-use-category-security-settings-to-create-private-categories/87678); to limit visibility and write permissions. Contact the; [admins](https://llvm.discourse.group/about) if you need such a category. ### What will happen to our email archives?. The Mailman archives will remain on the web server for now. ### What are advantages of Discourse over the current mailing lists?. * Users can post to any category, also without being subscribed.; * Full text search on the Web UI.; * Sending/replying via the Web UI (email is still possible).; * View entire thread on one page.; * Categories are a more light-weight option to structure the discussions than; creating new mailing lists.; * Single sign on with GitHub.; * User email addresses are kept private. ### I have another question not covered here. What should I do?. Please contact iwg@llvm.org or raise a; [ticket on GitHub](https://github.com/llvm/llvm-iwg/issues).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md:11283,secur,security,11283,interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DiscourseMigrationGuide.md,2,['secur'],"['security', 'security-settings-to-create-private-categories']"
Security,"main() {; // Initialize the hasher.; llvm::BLAKE3 hasher;. // Read input bytes from stdin.; char buf[65536];; while (1) {; ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));; if (n > 0) {; hasher.update(llvm::StringRef(buf, n));; } else if (n == 0) {; break; // end of file; } else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. Default output length is 32 bytes.; auto output = hasher.final();. // Print the hash as hexadecimal.; for (uint8_t byte : output) {; printf(""%02x"", byte);; }; printf(""\n"");; return 0;; }; ```. Using the C API:. ```c; #include ""llvm-c/blake3.h""; #include <errno.h>; #include <stdio.h>; #include <stdlib.h>; #include <string.h>; #include <unistd.h>. int main() {; // Initialize the hasher.; llvm_blake3_hasher hasher;; llvm_blake3_hasher_init(&hasher);. // Read input bytes from stdin.; unsigned char buf[65536];; while (1) {; ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));; if (n > 0) {; llvm_blake3_hasher_update(&hasher, buf, n);; } else if (n == 0) {; break; // end of file; } else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. LLVM_BLAKE3_OUT_LEN is the default output length, 32 bytes.; uint8_t output[LLVM_BLAKE3_OUT_LEN];; llvm_blake3_hasher_finalize(&hasher, output, LLVM_BLAKE3_OUT_LEN);. // Print the hash as hexadecimal.; for (size_t i = 0; i < LLVM_BLAKE3_OUT_LEN; i++) {; printf(""%02x"", output[i]);; }; printf(""\n"");; return 0;; }; ```. # API. ## The Class/Struct. ```c++; class BLAKE3 {; // API; private:; llvm_blake3_hasher Hasher;; };; ```; ```c; typedef struct {; // private fields; } llvm_blake3_hasher;; ```. An incremental BLAKE3 hashing state, which can accept any number of; updates. This implementation doesn't allocate any heap memory, but; `sizeof(llvm_blake3_hasher)` itself is relatively large, currently 1912 bytes; on x86-64. This size can be reduced by restricting the maximum input; length, as described in Section 5.4 of [the BLAKE3; spe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:1352,hash,hasher,1352,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['hash'],['hasher']
Security,"makes it easier to change things. In particular,; if tables and other things are all emitted by ``tblgen``, we only need a change; in one place (``tblgen``) to update all of the targets to a new interface. .. _Abstract target description:; .. _target description:. Target description classes; ==========================. The LLVM target description classes (located in the ``include/llvm/Target``; directory) provide an abstract description of the target machine independent of; any particular client. These classes are designed to capture the *abstract*; properties of the target (such as the instructions and registers it has), and do; not incorporate any particular pieces of code generation algorithms. All of the target description classes (except the :raw-html:`<tt>` `DataLayout`_; :raw-html:`</tt>` class) are designed to be subclassed by the concrete target; implementation, and have virtual methods implemented. To get to these; implementations, the :raw-html:`<tt>` `TargetMachine`_ :raw-html:`</tt>` class; provides accessors that should be implemented by the target. .. _TargetMachine:. The ``TargetMachine`` class; ---------------------------. The ``TargetMachine`` class provides virtual methods that are used to access the; target-specific implementations of the various target description classes via; the ``get*Info`` methods (``getInstrInfo``, ``getRegisterInfo``,; ``getFrameInfo``, etc.). This class is designed to be specialized by a concrete; target implementation (e.g., ``X86TargetMachine``) which implements the various; virtual methods. The only required target description class is the; :raw-html:`<tt>` `DataLayout`_ :raw-html:`</tt>` class, but if the code; generator components are to be used, the other interfaces should be implemented; as well. .. _DataLayout:. The ``DataLayout`` class; ------------------------. The ``DataLayout`` class is the only required target description class, and it; is the only class that is not extensible (you cannot derive a new class f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:10193,access,accessors,10193,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accessors']
Security,"mal Python rules apply:. .. code-block:: python. >>> c.abstract_method(); called Concrete::abstract_method; >>> c.concrete_method(); called Concrete::concrete_method; >>> m = c.abstract_method; >>> m(); called Concrete::abstract_method; >>>. `Data members`; --------------. Data members are implemented as properties, using descriptors.; For example, The ``Concrete`` instances have a public data member ``m_int``:. .. code-block:: python. >>> c.m_int, d.m_int; (42, 13); >>>. Note however, that the data members are typed: setting them results in a; memory write on the C++ side.; This is different in Python, where references are replaced, and thus any; type will do:. .. code-block:: python. >>> c.m_int = 3.14 # a float does not fit in an int; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: int/long conversion expects an integer object; >>> c.m_int = int(3.14); >>> c.m_int, d.m_int; (3, 13); >>>. Private and protected data members are not accessible, contrary to Python; data members, and C++ const-ness is respected:. .. code-block:: python. >>> c.m_const_int = 71 # declared 'const int' in class definition; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: assignment to const data not allowed; >>>. Static C++ data members act like Python class-level data members.; They are also represented by property objects and both read and write access; behave as expected:. .. code-block:: python. >>> Concrete.s_int # access through class; 321; >>> c.s_int = 123 # access through instance; >>> Concrete.s_int; 123. .. _sec-operators-label:. `Structs/Unions`; ----------------. Structs and unions are both supported, named or anonymous.; If the latter, the field are accessible through the parent scope by their; declared name.; For example:. .. code-block:: python. >>> cppyy.cppdef(""""""\; ... struct PointXYZ {; ... PointXYZI() : intensity(5.) {}; ... double x, y, z;; ... union {; ... int offset1;; ... struct {; ... int offse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:8347,access,accessible,8347,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['access'],['accessible']
Security,"mapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63836,secur,security,63836,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"mary technique is known as ""Bounds Check Bypass Store"" and is discussed; in this research paper: https://people.csail.mit.edu/vlk/spectre11.pdf. We will analyze these two variants independently. First, variant #1.1 works by; speculatively storing over the return address after a bounds check bypass. This; speculative store then ends up being used by the CPU during speculative; execution of the return, potentially directing speculative execution to; arbitrary gadgets in the binary. Let's look at an example.; ```; unsigned char local_buffer[4];; unsigned char *untrusted_data_from_caller = ...;; unsigned long untrusted_size_from_caller = ...;; if (untrusted_size_from_caller < sizeof(local_buffer)) {; // Speculative execution enters here with a too-large size.; memcpy(local_buffer, untrusted_data_from_caller,; untrusted_size_from_caller);; // The stack has now been smashed, writing an attacker-controlled; // address over the return address.; minor_processing(local_buffer);; return;; // Control will speculate to the attacker-written address.; }; ```. However, this can be mitigated by hardening the load of the return address just; like any other load. This is sometimes complicated because x86 for example; *implicitly* loads the return address off the stack. However, the; implementation technique below is specifically designed to mitigate this; implicit load by using the stack pointer to communicate misspeculation between; functions. This additionally causes a misspeculation to have an invalid stack; pointer and never be able to read the speculatively stored return address. See; the detailed discussion below. For variant #1.2, the attacker speculatively stores into the vtable or jump; table used to implement an indirect call or indirect jump. Because this is; speculative, this will often be possible even when these are stored in; read-only pages. For example:; ```; class FancyObject : public BaseObject {; public:; void DoSomething() override;; };; void f(unsigned long attac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:12123,attack,attacker-written,12123,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacker-written']
Security,"mation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient. The; tracks will be drawn over the geometry. The geometry itself will be; animated (camera moving and rotating in order to ""catch"" the majority of; current track segments.). `/S:`Save all frames in gif format in the current folder. This option; allows creating a movie based on individual frames. \anchor GP03; ## Checking the Geometry. Several checking methods are accessible from the context menu of volume; objects or of the manager class. They generally apply only to the; visible parts of the drawn geometry in order to ease geometry checking,; and their implementation is in the TGeoChecker class. The checking; package contains an overlap checker and several utility methods that; generally have visualization outputs. \anchor GP03a; ### The Overlap Checker. An overlap is any region in the Euclidian space being contained by more; than one positioned volume. Due to the containment scheme used by the; modeller, all points inside a volume have to be also contained by the; mother therefore are overlapping in that sense. This category of; overlaps is ignored due to the fact that any such point is treated as; belonging to the deepest node in the hierarchy. \image html geometry007.png ""Extruding volumes"". A volume containment region is in fact the result of the subtraction of; all daughters. On the other hand, there are two other categories of; overlaps that are considered ill",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:89849,access,accessible,89849,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['accessible']
Security,"mation`. For AMDGPU, the Common Information Entry (CIE) fields have the following values:. 1. ``augmentation`` string contains the following null-terminated UTF-8 string:. ::. [amd:v0.0]. The ``vX.Y`` specifies the major X and minor Y version number of the AMDGPU; extensions used in this CIE or to the FDEs that use it. The version number; conforms to [SEMVER]_. 2. ``address_size`` for the ``Global`` address space is defined in; :ref:`amdgpu-dwarf-address-space-identifier`. 3. ``segment_selector_size`` is 0 as AMDGPU does not use a segment selector. 4. ``code_alignment_factor`` is 4 bytes. .. TODO::. Add to :ref:`amdgpu-processor-table` table. 5. ``data_alignment_factor`` is 4 bytes. .. TODO::. Add to :ref:`amdgpu-processor-table` table. 6. ``return_address_register`` is ``PC_32`` for 32-bit processes and ``PC_64``; for 64-bit processes defined in :ref:`amdgpu-dwarf-register-identifier`. 7. ``initial_instructions`` Since a subprogram X with fewer registers can be; called from subprogram Y that has more allocated, X will not change any of; the extra registers as it cannot access them. Therefore, the default rule; for all columns is ``same value``. For AMDGPU the register number follows the numbering defined in; :ref:`amdgpu-dwarf-register-identifier`. For AMDGPU the instructions are variable size. A consumer can subtract 1 from; the return address to get the address of a byte within the call site; instructions. See DWARF Version 5 section 6.4.4. Accelerated Access; ------------------. See DWARF Version 5 section 6.1. Lookup By Name Section Header; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. See DWARF Version 5 section 6.1.1.4.1 and :ref:`amdgpu-dwarf-lookup-by-name`. For AMDGPU the lookup by name section header table:. ``augmentation_string_size`` (uword). Set to the length of the ``augmentation_string`` value which is always a; multiple of 4. ``augmentation_string`` (sequence of UTF-8 characters). Contains the following UTF-8 string null padded to a multiple of 4 bytes:. ::. [amdg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:112081,access,access,112081,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a structure.*. .. note::. This operation could be removed and the object location description; specified as the initial stack as for ``DW_AT_data_member_location``. Or this operation could be used instead of needing to specify an initial; stack. The latter approach is more composable as access to the object may; be needed at any point of the expression, and passing it as the initial; stack requires the entire expression to be aware where on the stack it is.; If this were done, ``DW_AT_use_location`` would require a; ``DW_OP_push_object2_address`` operation for the second object. Or a more general way to pass an arbitrary number of arguments in and an; operation to get the Nth one such as ``DW_OP_arg N``. A vector of; arguments would then be passed in the expression context rather than an; initial stack. This could also resolve the issues with ``DW_OP_call*`` by; allowing a specific number of arguments passed in and returned to be; specified. The ``DW_OP_call*`` operation could then always execute on a; separate stack: the number of arguments would be specified in a new call; operation and taken from the callers stack, and similarly the number of; return results specified and copied from the called stack back to the; callee stack when the called expression was complete. The only attribute that specifies a current object is; ``DW_AT_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:100914,access,access,100914,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security,"me library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-components=-2``: ``library/file.cpp``. More Information; ================. * From Oracle blog, including a discussion of error messages:; `Improving Application Security with UndefinedBehaviorSanitizer (UBSan) and GCC; <https://blogs.oracle.com/linux/improving-application-security-with-undefinedbehaviorsanitizer-ubsan-and-gcc>`_; * From LLVM project blog:; `What Every C Programmer Should Know About Undefined Behavior; <http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>`_; * From John Regehr's *Embedded in Academia* blog:; `A Guide to Undefined Behavior in C and C++; <https://blog.regehr.org/archives/213>`_; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:17271,secur,security-with-undefinedbehaviorsanitizer-ubsan-and-gcc,17271,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['secur'],['security-with-undefinedbehaviorsanitizer-ubsan-and-gcc']
Security,"me performance and increase thread scalability the override ability of `TFile::GetStreamerInfoList` is replaced by an override of `TFile::GetStreamerInfoListImp` with updated return type and arguments. If a class override `TFile::GetStreamerInfoList` you will now see a compilation error like:. ```; /opt/build/root_builds/rootcling.cmake/include/TSQLFile.h:225:19: error: declaration of 'GetStreamerInfoList' overrides a 'final' function; virtual TList *GetStreamerInfoList();; ^; /opt/build/root_builds/rootcling.cmake/include/TFile.h:231:24: note: overridden virtual function is here; virtual TList *GetStreamerInfoList() final; // Note: to override behavior, please override GetStreamerInfoListImpl; ^; ```. Instead you need to override the protected method:. ```; InfoListRet GetStreamerInfoListImpl(bool lookupSICache);; ```. which can be implemented as. ```; InfoListRet DerivedClass::GetStreamerInfoListImpl(bool /*lookupSICache*/) {; ROOT::Internal::RConcurrentHashColl::HashValue hash;; TList *infolist = nullptr;; //; // Body of the former Derived::GetStreamerInfoList with the; // return statement replaced with something like:. // The second element indicates success or failure of the load.; // (i.e. {nullptr, 0, hash} indicates the list has already been processed; // {nullptr, 1, hash} indicates the list failed to be loaded; return {infolist, 0, hash};; }; ```. See `TFile::GetStreamerInfoListImpl` implementation for an example on how to implement the caching. * ZLIB (with compression level 1) is now the default compression algorithm for new ROOT files (LZ4 was default compression algorithm in 6.14). Because of reported ""corner cases"" for LZ4, we are working on the fix to be landed in a next release and return back LZ4 as a default compression algorithm. * Introducing a possibility for ROOT to use generic compression algorithm/level/settings, by introducing new generic class RCompressionSetting together with new structs ELevel (compression level), EDefaults (default comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:4956,hash,hash,4956,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['hash'],['hash']
Security,"me()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.; - Add support for std::array_view also for C++11 builds. The implementation has been modified to work before C++14.; - Added TCollection::Notify to allow notifying more than one object.; ```{.cpp}; TList formulas;; // Add several TTreeFormula to the list;; chain.SetNotify(&formulas);; ```; - For classes that need the `ClassDef` support, `ClassDefInline(ClassName, Version)` now provides it without the need for a dictionary source: all members injected by this `ClassDef` flavor are generated by the interpreter. ### `TObjString` to `TString`. `TObjString::GetString()` now returns a `const TString&` to the `TString` inside the `TObjString`, instead of copying it.; This is to prevent very common misunderstanding of the interface. In several cases, the misunderstanding of the interface caused invalid memory accesses to the already destructed; temporary `TString` returned by `GetString()`, e.g. `objStr->GetString().Data()`. This will be fixed automatically by the; new return type. In rare cases, the caller expected `GetString()` to return a (non-const) reference to the embedded `TString`, e.g.; `objString->GetString().ReplaceAll(""a"", ""b""); // WRONG!` This will now fail to compile, instead of not doing what the author of the; code expected. Please fix that code by using the `TObjString::String()` interface, which returns a non-const `TString&`:; `objString->String().ReplaceAll(""a"", ""b"");`. In extremely rare cases, this change breaks a valid use where the temporary `TString` was modified and then captured in a new `TString`; object before the destruction of the temporary: `TString str = objStr->GetString().ReplaceAll(""a"", ""b"");`. In these rare cases,; please use the new function `CopyString()` which clearly indicates that it involves a temporary. ## Histogram Libraries. - New class `THnChain` w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:3257,access,accesses,3257,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['access'],['accesses']
Security,"me). In practice, there are usually only a small number; of named streams and these are enumerated in the table of streams in :doc:`index`.; A corollary of this is if a stream does have a name (and as such is in the named; stream map) then consulting the Named Stream Map is likely to be the only way to; discover the stream's MSF stream index. Several important streams (such as the; global string table, which is called ``/names``) can only be located this way, and; so it is important to both produce and consume this correctly as tools will not; function correctly without it. .. important::; Some streams are located by fixed indices (e.g TPI Stream has index 2), but; other streams are located by fixed names (e.g. the string table is called; ``/names``) and can only be located by consulting the Named Stream Map. The on-disk layout of the Named Stream Map consists of 2 components. The first is; a buffer of string data prefixed by a 32-bit length. The second is a serialized; hash table whose key and value types are both ``uint32_t``. The key is the offset; of a null-terminated string in the string data buffer specifying the name of the; stream, and the value is the MSF stream index of the stream with said name.; Note that although the key is an integer, the hash function used to find the right; bucket hashes the string at the corresponding offset in the string data buffer. The on-disk layout of the serialized hash table is described at :doc:`HashTable`. Note that the entire Named Stream Map is not length-prefixed, so the only way to; get to the data following it is to de-serialize it in its entirety. .. _pdb_stream_features:. PDB Feature Codes; =================; Following the Named Stream Map, and consuming all remaining bytes of the PDB; Stream is a list of values from the following enumeration:. .. code-block:: c++. enum class PdbRaw_FeatureSig : uint32_t {; VC110 = 20091201,; VC140 = 20140508,; NoTypeMerge = 0x4D544F4E,; MinimalDebugInfo = 0x494E494D,; };. The meanin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst:3371,hash,hash,3371,interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,1,['hash'],['hash']
Security,"members is displayed: you can e.g. show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. Access (public / protected / private); Not all members are available to everyone (check any C++ introduction to learn why).; Public members have a green bar on their left, protected ones have a yellow one, and; private members are marked with a red bar. Of course you won't see any protected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it using GetName() as defined in its base; class TNamed. If you want to see; all available members, and not just the ones defined in the current class, in the; display options. They will be prefixed with the name of; the class they are defined in. Class Charts; The class charts are shown in a tabbed box; click on the names ontop to select a tab. Inheritance; This chart shows the inheritance hierarchy for the current class. Arrows point to; base classes. You can click the classes to get to their reference page. Inherited Members; The second chart shows a list of all members of all base classes. You can see at what; level they are defined or at what level they are defined. Members that are accessible; (public) have a green background, protected ones have a yellow background, and private; members have a red background. Members with a dark gray background are re-implemente",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:6448,access,access,6448,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,2,['access'],['access']
Security,"memory to be reclaimed as soon as; the Modules referring to it are destroyed. ThreadSafeContexts can be explicitly constructed from a; std::unique_ptr<LLVMContext>:. .. code-block:: c++. ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());. ThreadSafeModules can be constructed from a pair of a std::unique_ptr<Module>; and a ThreadSafeContext value. ThreadSafeContext values may be shared between; multiple ThreadSafeModules:. .. code-block:: c++. ThreadSafeModule TSM1(; std::make_unique<Module>(""M1"", *TSCtx.getContext()), TSCtx);. ThreadSafeModule TSM2(; std::make_unique<Module>(""M2"", *TSCtx.getContext()), TSCtx);. Before using a ThreadSafeContext, clients should ensure that either the context; is only accessible on the current thread, or that the context is locked. In the; example above (where the context is never locked) we rely on the fact that both; ``TSM1`` and ``TSM2``, and TSCtx are all created on one thread. If a context is; going to be shared between threads then it must be locked before any accessing; or creating any Modules attached to it. E.g. .. code-block:: c++. ThreadSafeContext TSCtx(std::make_unique<LLVMContext>());. ThreadPool TP(NumThreads);; JITStack J;. for (auto &ModulePath : ModulePaths) {; TP.async(; [&]() {; auto Lock = TSCtx.getLock();; auto M = loadModuleOnContext(ModulePath, TSCtx.getContext());; J.addModule(ThreadSafeModule(std::move(M), TSCtx));; });; }. TP.wait();. To make exclusive access to Modules easier to manage the ThreadSafeModule class; provides a convenience function, ``withModuleDo``, that implicitly (1) locks the; associated context, (2) runs a given function object, (3) unlocks the context,; and (3) returns the result generated by the function object. E.g. .. code-block:: c++. ThreadSafeModule TSM = getModule(...);. // Dump the module:; size_t NumFunctionsInModule =; TSM.withModuleDo(; [](Module &M) { // <- Context locked before entering lambda.; return M.size();; } // <- Context unlocked after leaving.; );. Clients wishi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:29499,access,accessing,29499,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['access'],['accessing']
Security,"memory write on the C++ side.; This is different in Python, where references are replaced, and thus any; type will do:. .. code-block:: python. >>> c.m_int = 3.14 # a float does not fit in an int; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: int/long conversion expects an integer object; >>> c.m_int = int(3.14); >>> c.m_int, d.m_int; (3, 13); >>>. Private and protected data members are not accessible, contrary to Python; data members, and C++ const-ness is respected:. .. code-block:: python. >>> c.m_const_int = 71 # declared 'const int' in class definition; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: assignment to const data not allowed; >>>. Static C++ data members act like Python class-level data members.; They are also represented by property objects and both read and write access; behave as expected:. .. code-block:: python. >>> Concrete.s_int # access through class; 321; >>> c.s_int = 123 # access through instance; >>> Concrete.s_int; 123. .. _sec-operators-label:. `Structs/Unions`; ----------------. Structs and unions are both supported, named or anonymous.; If the latter, the field are accessible through the parent scope by their; declared name.; For example:. .. code-block:: python. >>> cppyy.cppdef(""""""\; ... struct PointXYZ {; ... PointXYZI() : intensity(5.) {}; ... double x, y, z;; ... union {; ... int offset1;; ... struct {; ... int offset2;; ... float intensity;; ... };; ... float data_c[4];; ... };; ... };""""""); True; >>> p = cppyy.gbl.PointXYZI(); >>> type(p.x); <class 'float'>; >>> p.intensity; 5.0; >>> type(p.data_c[1]); <class 'float'>; >>> p.data_c[1] = 3.0; >>> p.intensity; 3.0; >>>. `Operators`; -----------. Many C++ operators can be mapped to their Python equivalent.; When the operators are part of the C++ class definition, this is done; directly.; If they are defined globally, the lookup is done lazily (ie. can resolve; after the class definition by loading the global",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:8903,access,access,8903,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['access'],['access']
Security,"ment ""axisg"" and ""haxisg"" to draw axes with grids; 7. Support TH1 marker, text and line drawing superimposed with ""haxis""; 8. Support `TBox`, `TLatex`, `TLine`, `TMarker` drawing on ""frame"", support drawing on swapped axes; 9. `TProfile` and `TProfile2D` projections https://github.com/root-project/root/issues/15851; 10. Draw total histogram from TEfficiency when draw option starts with 'b'; 11. Let redraw TEfficiency, THStack and TMultiGraph with different draw options via hist context menu; 12. Support 'pads' draw options for TMultiGraph, support context menu for it; 13. Let drop object on sub-pads; 14. Properly loads ES6 modules for web canvas; 15. Improve performance of TH3/RH3 drawing by using THREE.InstancedMesh; 16. Implement batch mode with '&batch' URL parameter to create SVG/PNG images with default GUI; 17. Adjust node.js implementation to produce identical output with normal browser; 18. Create necessary infrastructure for testing with 'puppeteer'; 19. Support inject of ES6 modules via '&inject=path.mjs'; 20. Using importmap for 'jsroot' in all major HTML files and in demos; 21. Implement `settings.CutAxisLabels` flag to remove labels which may exceed graphical range; 22. Let disable usage of TAxis custom labels via context menu; 23. Let configure default draw options via context menu, they can be preserved in the local storage; 24. Let save canvas as JSON file from context menu, object as JSON from inspector; 25. Upgrade three.js r162 -> r168, use r162 only in node.js because of ""gl"" module; 26. Create unified svg2pdf/jspdf ES6 modules, integrate in jsroot builds; 27. Let create multipage PDF document - in TWebCanvas batch mode; 28. Let add external links via `#url[link]{label}` syntax - including jsPDF support; 29. Support TAttMarker style with line width bigger than 1; 30. Internals - upgrade to eslint 9; 31. Internals - do not select pad (aka gPad) for objects drawing, always use assigned pad painter; 32. Fix - properly save zoomed ranges in drawingJSON",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:1333,inject,inject,1333,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,2,['inject'],['inject']
Security,"ment ``expr`` is expected to take; the value of its second argument ``val`` with probability ``p``. ``p`` must be; within ``[0.0 ; 1.0]`` bounds. This builtin always returns the value of ``expr``. Query for this feature with ``__has_builtin(__builtin_expect_with_probability)``. ``__builtin_prefetch``; ----------------------. ``__builtin_prefetch`` is used to communicate with the cache handler to bring; data into the cache before it gets used. **Syntax**:. .. code-block:: c++. void __builtin_prefetch(const void *addr, int rw=0, int locality=3). **Example of use**:. .. code-block:: c++. __builtin_prefetch(a + i);. **Description**:. The ``__builtin_prefetch(addr, rw, locality)`` builtin is expected to be used to; avoid cache misses when the developer has a good understanding of which data; are going to be used next. ``addr`` is the address that needs to be brought into; the cache. ``rw`` indicates the expected access mode: ``0`` for *read* and ``1``; for *write*. In case of *read write* access, ``1`` is to be used. ``locality``; indicates the expected persistence of data in cache, from ``0`` which means that; data can be discarded from cache after its next use to ``3`` which means that; data is going to be reused a lot once in cache. ``1`` and ``2`` provide; intermediate behavior between these two extremes. Query for this feature with ``__has_builtin(__builtin_prefetch)``. ``__sync_swap``; ---------------. ``__sync_swap`` is used to atomically swap integers or pointers in memory. **Syntax**:. .. code-block:: c++. type __sync_swap(type *ptr, type value, ...). **Example of Use**:. .. code-block:: c++. int old_value = __sync_swap(&value, new_value);. **Description**:. The ``__sync_swap()`` builtin extends the existing ``__sync_*()`` family of; atomic intrinsics to allow code to atomically swap the current value with the; new value. More importantly, it helps developers write more efficient and; correct code by avoiding expensive loops around; ``__sync_bool_compare_and_swap",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:116180,access,access,116180,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access']
Security,"ments:; """""""""""""""""""". The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. It must be a power of two constant integer value. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements. Semantics:; """""""""""""""""""". The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:847386,access,access,847386,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"mes are not; duplicated. We also want to make sure the table is ready to be used as-is by; simply mapping the table into memory with minimal header parsing. The name lookups need to be fast and optimized for the kinds of lookups that; debuggers tend to do. Optimally we would like to touch as few parts of the; mapped table as possible when doing a name lookup and be able to quickly find; the name entry we are looking for, or discover there are no matches. In the; case of debuggers we optimized for lookups that fail most of the time. Each table that is defined should have strict rules on exactly what is in the; accelerator tables and documented so clients can rely on the content. Hash Tables; ^^^^^^^^^^^. Standard Hash Tables; """""""""""""""""""""""""""""""""""""""". Typical hash tables have a header, buckets, and each bucket points to the; bucket contents:. .. code-block:: none. .------------.; | HEADER |; |------------|; | BUCKETS |; |------------|; | DATA |; `------------'. The BUCKETS are an array of offsets to DATA for each hash:. .. code-block:: none. .------------.; | 0x00001000 | BUCKETS[0]; | 0x00002000 | BUCKETS[1]; | 0x00002200 | BUCKETS[2]; | 0x000034f0 | BUCKETS[3]; | | ...; | 0xXXXXXXXX | BUCKETS[n_buckets]; '------------'. So for ``bucket[3]`` in the example above, we have an offset into the table; 0x000034f0 which points to a chain of entries for the bucket. Each bucket must; contain a next pointer, full 32 bit hash value, the string itself, and the data; for the current string value. .. code-block:: none. .------------.; 0x000034f0: | 0x00003500 | next pointer; | 0x12345678 | 32 bit hash; | ""erase"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003500: | 0x00003550 | next pointer; | 0x29273623 | 32 bit hash; | ""dump"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003550: | 0x00000000 | next pointer; | 0x82638293 | 32 bit hash; | ""main"" | string value; | data[n] | HashData for this bucket; `------------'. The problem ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:61138,hash,hash,61138,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"mes in the output. .. option:: --dependent-libraries. Display the dependent libraries section. .. option:: --dyn-relocations. Display the dynamic relocation entries. .. option:: --dyn-symbols, --dyn-syms, --dt. Display the dynamic symbol table. .. option:: --dynamic-table, --dynamic, -d. Display the dynamic table. .. option:: --cg-profile. Display the callgraph profile section. .. option:: --histogram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output (the default) is an expanded and; structured format. ``GNU`` output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --section-groups, -g. Display section groups. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dynamic symbols. .. option:: --memtag. Display information about memory tagging present in the binary. This includes; various dynamic entries, decoded global descriptor sections, and decoded; Android-specific ELF notes. .. option:: --notes, -n. Display all notes. .. option:: --pretty-print. When used with :option:`--elf-output-style`, JSON output will be formatted in; a more readable format. .. option:: --program-headers, --segments, -l. Display the program headers. .. option:: --raw-relr. Do not decode relocations in RELR relocation sections when displaying them. .. option:: --section-mapping. Display the section to segment mapping. .. option:: --stack-sizes. Display the contents of the stack sizes section(s), i.e. pairs of function; names and the size of their stack frames. Currently only implemented for GNU; style output.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst:5867,hash,hash,5867,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,1,['hash'],['hash']
Security,"milar to dead instruction elimination, but it; rechecks instructions that were used by removed instructions to see if they; are newly dead. ``deadargelim``: Dead Argument Elimination; ------------------------------------------. This pass deletes dead arguments from internal functions. Dead argument; elimination removes arguments which are directly dead, as well as arguments; only passed into function calls as dead arguments of other functions. This; pass also deletes dead arguments in a similar way. This pass is often useful as a cleanup pass to run after aggressive; interprocedural passes, which add possibly-dead arguments. ``dse``: Dead Store Elimination; -------------------------------. A trivial dead store elimination that only considers basic-block local; redundant stores. .. _passes-function-attrs:. ``function-attrs``: Deduce function attributes; ----------------------------------------------. A simple interprocedural pass which walks the call-graph, looking for functions; which do not access or only read non-local memory, and marking them; ``readnone``/``readonly``. In addition, it marks function arguments (of; pointer type) ""``nocapture``"" if a call to the function does not create any; copies of the pointer value that outlive the call. This more or less means; that the pointer is only dereferenced, and not returned from the function or; stored in a global. This pass is implemented as a bottom-up traversal of the; call-graph. ``globaldce``: Dead Global Elimination; --------------------------------------. This transform is designed to eliminate unreachable internal globals from the; program. It uses an aggressive algorithm, searching out globals that are known; to be alive. After it finds all of the globals which are needed, it deletes; whatever is left over. This allows it to delete recursive chunks of the; program which are unreachable. ``globalopt``: Global Variable Optimizer; ----------------------------------------. This pass transforms simple global varia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:16168,access,access,16168,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['access'],['access']
Security,"mium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:11966,confidential,confidential,11966,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['confidential'],['confidential']
Security,"mmetric matrix; // ( 1 2 4; // 2 3 5; // 4 5 6 ). // create a a general matrix from a symmetric matrix. The opposite will not compile; SMatrix33 m2 = s;; ~~~. Example to create a symmetric matrix from a ROOT::Math::SVector containing the lower/upper data block:. ~~~ {.cpp}; ROOT::Math::SVector<double, 6> v(1,2,3,4,5,6);; SMatrixSym3 s1(v); // lower block (default); // this will produce the symmetric matrix; // ( 1 2 4; // 2 3 5; // 4 5 6 ). SMatrixSym3 s2(v,false); // upper block; // this will produce the symmetric matrix; // ( 1 2 3; // 2 4 5; // 3 5 6 ); ~~~. ### Accessing and Setting Methods. The matrix elements can be set using the _operator()(irow,icol)_, where irow and icol are; the row and column indexes or by using the iterator interface. Notice that the indexes start; from zero and not from one as in FORTRAN. All the matrix elements can be set also by using; the ROOT::Math::SetElements function passing a generic iterator.; The elements can be accessed by these same methods and also by using the; ROOT::Math::SMatrix::apply function. The _apply(i)_ function has exactly the same behavior; for general and symmetric matrices, in contrast to the iterator access methods which behave; differently (it follows the data order). ~~~ {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m. double x = m(2,1); // return the element in third row and first column; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices (note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1).; x = m.apply(7); // returns again the (row=2,col=1) element; ~~~. There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns; in (from) a matrix. In addition one",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SMatrixClass.md:5082,access,accessed,5082,math/smatrix/doc/SMatrixClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SMatrixClass.md,1,['access'],['accessed']
Security,"mmit, and this; concern would have been significant enough to warrant a conversation during; pre-commit review (including around the need for more design discussions),; they may ask for a revert to the original author who is responsible to revert; the patch promptly. Developers often disagree, and erring on the side of the; developer asking for more review prevents any lingering disagreement over; code in the tree. This does not indicate any fault from the patch author,; this is inherent to our post-commit review practices.; Reverting a patch ensures that design discussions can happen without blocking; other development; it's entirely possible the patch will end up being reapplied; essentially as-is once concerns have been resolved. Before being recommitted, the patch generally should undergo further review.; The community member who identified the problem is expected to engage; actively in the review. In cases where the problem is identified by a buildbot,; a community member with access to hardware similar to that on the buildbot is; expected to engage in the review. Please note: The bar for post-commit feedback is not higher than for pre-commit; feedback. Don't delay unnecessarily in providing feedback. However, if you see; something after code has been committed about which you would have commented; pre-commit (had you noticed it earlier), please feel free to provide that; feedback at any time. That having been said, if a substantial period of time has passed since the; original change was committed, it may be better to create a new patch to; address the issues than comment on the original commit. The original patch; author, for example, might no longer be an active contributor to the project. What Tools Are Used for Code Review?; ------------------------------------. Pre-commit code reviews are conducted on GitHub with Pull Requests. See; :ref:`GitHub <github-reviews>` documentation. When Is an RFC Required?; ------------------------. Some changes are too signi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst:3022,access,access,3022,interpreter/llvm-project/llvm/docs/CodeReview.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeReview.rst,1,['access'],['access']
Security,"mmon scripts and their purposes/applications in generating; assertions:. .. code-block:: none. update_analyze_test_checks.py; opt -passes='print<cost-model>'. update_cc_test_checks.py; C/C++, or clang/clang++ (IR checks). update_llc_test_checks.py; llc (assembly checks). update_mca_test_checks.py; llvm-mca. update_mir_test_checks.py; llc (MIR checks). update_test_checks.py; opt. Precommit workflow for tests; ----------------------------. If the test does not crash, assert, or infinite loop, commit the test with; baseline check-lines first. That is, the test will show a miscompile or; missing optimization. Add a ""TODO"" or ""FIXME"" comment to indicate that; something is expected to change in a test. A follow-up patch with code changes to the compiler will then show check-line; differences to the tests, so it is easier to see the effect of the patch.; Remove TODO/FIXME comments added in the previous step if a problem is solved. Baseline tests (no-functional-change or NFC patch) may be pushed to main; without pre-commit review if you have commit access. Best practices for regression tests; -----------------------------------. - Use auto-generated check lines (produced by the scripts mentioned above); whenever feasible.; - Include comments about what is tested/expected in a particular test. If there; are relevant issues in the bug tracker, add references to those bug reports; (for example, ""See PR999 for more details"").; - Avoid undefined behavior and poison/undef values unless necessary. For; example, do not use patterns like ``br i1 undef``, which are likely to break; as a result of future optimizations.; - Minimize tests by removing unnecessary instructions, metadata, attributes,; etc. Tools like ``llvm-reduce`` can help automate this.; - Outside PhaseOrdering tests, only run a minimal set of passes. For example,; prefer ``opt -S -passes=instcombine`` over ``opt -S -O3``.; - Avoid unnamed instructions/blocks (such as ``%0`` or ``1:``), because they may; require renumber",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst:13380,access,access,13380,interpreter/llvm-project/llvm/docs/TestingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TestingGuide.rst,1,['access'],['access']
Security,"mounts, and. * various high-level characteristics, like whether it is profitable to turn; division by a constant into a multiplication sequence. .. _TargetRegisterInfo:. The ``TargetRegisterInfo`` class; --------------------------------. The ``TargetRegisterInfo`` class is used to describe the register file of the; target and any interactions between the registers. Registers are represented in the code generator by unsigned integers. Physical; registers (those that actually exist in the target description) are unique; small numbers, and virtual registers are generally large. Note that; register ``#0`` is reserved as a flag value. Each register in the processor description has an associated; ``TargetRegisterDesc`` entry, which provides a textual name for the register; (used for assembly output and debugging dumps) and a set of aliases (used to; indicate whether one register overlaps with another). In addition to the per-register description, the ``TargetRegisterInfo`` class; exposes a set of processor specific register classes (instances of the; ``TargetRegisterClass`` class). Each register class contains sets of registers; that have the same properties (for example, they are all 32-bit integer; registers). Each SSA virtual register created by the instruction selector has; an associated register class. When the register allocator runs, it replaces; virtual registers with a physical register in the set. The target-specific implementations of these classes is auto-generated from a; :doc:`TableGen/index` description of the register file. .. _TargetInstrInfo:. The ``TargetInstrInfo`` class; -----------------------------. The ``TargetInstrInfo`` class is used to describe the machine instructions; supported by the target. Descriptions define things like the mnemonic for; the opcode, the number of operands, the list of implicit register uses and defs,; whether the instruction has certain target-independent properties (accesses; memory, is commutable, etc), and holds any targ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:12892,expose,exposes,12892,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['expose'],['exposes']
Security,"mpilation-unit-entries`,; :ref:`amdgpu-dwarf-name-index-section-header`, and; :ref:`amdgpu-dwarf-structure_of-call-frame-information`. 2.16 Support Embedding Source Text for Online Compilation; ---------------------------------------------------------. AMDGPU supports programming languages that include online compilation where the; source text may be created at runtime. For example, the OpenCL and HIP language; runtimes support online compilation. To support is, a way to embed the source; text in the debug information is provided. See :ref:`amdgpu-dwarf-line-number-information`. 2.17 Allow MD5 Checksums to be Optionally Present; -------------------------------------------------. In DWARF Version 5 the file timestamp and file size can be optional, but if the; MD5 checksum is present it must be valid for all files. This is a problem if; using link time optimization to combine compilation units where some have MD5; checksums and some do not. Therefore, sSupport to allow MD5 checksums to be; optionally present in the line table is added. See :ref:`amdgpu-dwarf-line-number-information`. 2.18 Add the HIP Programing Language; ------------------------------------. The HIP programming language [:ref:`HIP <amdgpu-dwarf-HIP>`], which is supported; by the AMDGPU, is added. See :ref:`amdgpu-dwarf-language-names-table`. 2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution; --------------------------------------------------------------------------------------------. A compiler can perform loop optimizations that result in the generated code; executing multiple iterations concurrently. For example, software pipelining; schedules multiple iterations in an interleaved fashion to allow the; instructions of one iteration to hide the latencies of the instructions of; another iteration. Another example is vectorization that can exploit SIMD; hardware to allow a single instruction to execute multiple iterations using; vector registers. Note that alth",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:32312,checksum,checksums,32312,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['checksum'],['checksums']
Security,"mpilation. * ``Live`` is a boolean that can be set to mark this symbol as root for; dead-stripping purposes (see :ref:`generic_link_algorithm`). JITLink's; dead-stripping algorithm will propagate liveness flags through the graph to; all reachable symbols before deleting any symbols (and blocks) that are not; marked live. * ``Edge`` -- A quad of an ``Offset`` (implicitly from the start of the; containing ``Block``), a ``Kind`` (describing the relocation type), a; ``Target``, and an ``Addend``. Edges represent relocations, and occasionally other relationships, between; blocks and symbols. * ``Offset``, accessible via ``getOffset``, is an offset from the start of the; ``Block`` containing the ``Edge``. * ``Kind``, accessible via ``getKind`` is a relocation type -- it describes; what kinds of changes (if any) should be made to block content at the given; ``Offset`` based on the address of the ``Target``. * ``Target``, accessible via ``getTarget``, is a pointer to a ``Symbol``,; representing whose address is relevant to the fixup calculation specified by; the edge's ``Kind``. * ``Addend``, accessible via ``getAddend``, is a constant whose interpretation; is determined by the edge's ``Kind``. * ``Section`` -- A set of ``Symbol`` instances, plus a set of ``Block``; instances, with a ``Name``, a set of ``ProtectionFlags``, and an ``Ordinal``. Sections make it easy to iterate over the symbols or blocks associated with; a particular section in the source object file. * ``blocks()`` returns an iterator over the set of blocks defined in the; section (as ``Block*`` pointers). * ``symbols()`` returns an iterator over the set of symbols defined in the; section (as ``Symbol*`` pointers). * ``Name`` is represented as an ``llvm::StringRef``, and is accessible via the; ``getName`` method. * ``ProtectionFlags`` are represented as a sys::Memory::ProtectionFlags enum,; and accessible via the ``getProtectionFlags`` method. These flags describe; whether the section is readable, writable, e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:12079,access,accessible,12079,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security,"mpiler IR, as an on-disk bitcode representation; (suitable for fast loading by a Just-In-Time compiler), and as a human; readable assembly language representation. This allows LLVM to provide a; powerful intermediate representation for efficient compiler; transformations and analysis, while providing a natural means to debug; and visualize the transformations. The three different forms of LLVM are; all equivalent. This document describes the human readable; representation and notation. The LLVM representation aims to be light-weight and low-level while; being expressive, typed, and extensible at the same time. It aims to be; a ""universal IR"" of sorts, by being at a low enough level that; high-level ideas may be cleanly mapped to it (similar to how; microprocessors are ""universal IR's"", allowing many source languages to; be mapped to them). By providing type information, LLVM can be used as; the target of optimizations: for example, through pointer analysis, it; can be proven that a C automatic variable is never accessed outside of; the current function, allowing it to be promoted to a simple SSA value; instead of a memory location. .. _wellformed:. Well-Formedness; ---------------. It is important to note that this document describes 'well formed' LLVM; assembly language. There is a difference between what the parser accepts; and what is considered 'well formed'. For example, the following; instruction is syntactically okay, but not well formed:. .. code-block:: llvm. %x = add i32 1, %x. because the definition of ``%x`` does not dominate all of its uses. The; LLVM infrastructure provides a verification pass that may be used to; verify that an LLVM module is well formed. This pass is automatically; run by the parser after parsing input assembly and by the optimizer; before it outputs bitcode. The violations pointed out by the verifier; pass indicate bugs in transformation passes or input to the parser. .. _identifiers:. Identifiers; ===========. LLVM identifiers come",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:1669,access,accessed,1669,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"mpiler/linker flags.; (For work on MS Windows, this `helper script`_ may be useful.); To continue the example, assuming Linux::. $ g++ `cling-config --cppflags` -fPIC -O2 -shared MyClass_rflx.cxx -o MyClassDict.so. Instead of loading the header text into ``cling``, you can now load the; dictionary:. .. code-block:: python. >>> import cppyy; >>> cppyy.load_reflection_info('MyClassDict'); >>> cppyy.gbl.MyClass(42); <cppyy.gbl.MyClass object at 0x7ffb9f230950>; >>> print(_.get_int()); 42; >>>. and use the selected C++ entities as if the header was loaded. The dictionary shared library can be relocated, as long as it can be found; by the dynamic loader (e.g. through ``LD_LIBRARY_PATH``) and the header file; is fully embedded or still accessible (e.g. through a path added to; ``cppyy.add_include_path`` at run-time, or with ``-I`` to; ``rootcling``/``genreflex`` during build time).; When relocating the shared library, move the .pcm with it.; Once support for C++ modules is fully fleshed out, access to the header file; will no longer be needed. .. _`rootcling manual`: https://root.cern.ch/root/html/guides/users-guide/AddingaClass.html#the-linkdef.h-file; .. _`helper script`: https://github.com/wlav/cppyy/blob/master/test/make_dict_win32.py. Class loader; ^^^^^^^^^^^^. Explicitly loading dictionaries is fine if this is hidden under the hood of; a Python package and thus transparently done on ``import``.; Otherwise, the automatic class loader is more convenient, as it allows direct; use without having to manually find and load dictionaries (assuming these are; locatable by the dynamic loader). The class loader utilizes so-called rootmap files, which by convention should; live alongside the dictionary shared library (and C++ module file).; These are simple text files, which map C++ entities (such as classes) to the; dictionaries and other libraries that need to be loaded for their use. With ``genreflex``, the mapping file can be automatically created with; ``--rootmap-lib=MyCl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:7900,access,access,7900,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['access'],['access']
Security,"mplements the storage of the; data. This new class structure allows multiple data storage implementations to; be applied efficiently to both RooDataSet and RooDataHist; At present a single implementation of RooAbsDataStore exists,; class RooTreeDataStore, that contains the storage implementation; formerly implement in class RooTreeData. Methods in class RooTreeData; that were not specific to the storage technology have been moved to; class RooAbsData. If your user code only uses the classes RooDataSet,RooDataHist and RooAbsData; nothing will change: Existing RooDataSets and RooDataHists; (that inherit from RooTreeData) can be read in without problems in; RooFit 3.00 and will be converted on the fly to the new dataset structure; in memory. User code that explicitly uses RooTreeData pointers should; be changed to RooAbsData pointers. This change should be transparent; for all uses, with the exception of the RooTreeData::tree() method.; Explicit access to tree implementation can still be obtained; through the RooTreeDataStore::tree() method. (A pointer to the datastore; can be obtained through the RooAbsData::store() method.); Note that in future releases it is no longer guaranteed that all datasets are implemented; with a plain TTree implementation, so any user code that uses the tree; implementation directly should implement checks that the implementation; is indeed tree-based (data->store()->InheritsFrom(RooTreeDataStore::Class())==true)). In future release additional implementations of RooAbsDataStore will; be provided that will support new dataset functionality such as the; ability to construct 'joint' dataset from two input datasets without; the need to copy the input data and 'filtered' datasets that represent; a reduced view (in dimensions or by selecting events) of a dataset; without the need to copy content. Various workspace improvements. A number of smaller and larger improvements has been made to the RooWorkspace class. Direct interactive access to content",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:15148,access,access,15148,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['access'],['access']
Security,"mprovements from the previous release and new feature work. Note that if you are reading this file from a git checkout or the main Cling; web page, this document applies to the *next* release, not the current one. What's New in Cling 1.2?; ========================. Some of the major new features and improvements to Cling are listed; here. Generic improvements to Cling as a whole or to its underlying; infrastructure are described first. External Dependencies; ---------------------; * Upgrade to LLVM r0000000. Major New Features; ------------------; * A major new feature. Misc; ----; * A misc feature. Experimental Features; ---------------------; * An experimental feature. Jupyter; -------; * A Jupyter feature. Fixed Bugs; ----------; [ROOT-XXXX](https://sft.its.cern.ch/jira/browse/ROOT-XXXX). <!---Get release bugs; git log v1.1..master | grep -i ""fix"" | grep '#' | sed -E 's,.*\#([0-9]*).*,\[\1\]\(https://github.com/root-project/cling/issues/\1\),g' | sort; --->; <!---Standard MarkDown doesn't support neither variables nor <base>; [ROOT-XXX](https://sft.its.cern.ch/jira/browse/ROOT-XXX); --->. <!---Additional Information; ----------------------; A wide variety of additional information is available on the; [Cling web page](http://root.cern/cling). The web page contains versions of; the API documentation which are up-to-date with the git version of the source; code. You can access versions of these documents specific to this release by; going into the “clang/docs/” directory in the Cling source tree. If you have any questions or comments about Cling, please feel free to contact; us via the mailing list.--->. Special Kudos; =============; This release wouldn't have happened without the efforts of our contributors,; listed in the form of Firstname Lastname (#contributions):. FirstName LastName (#commits). <!---Find contributor list for this release; git log --pretty=format:""%an"" v1.1...master | sort | uniq -c | sort -rn |\; sed -E 's,^ *([0-9]+) (.*)$,\2 \(\1\),'; --->; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/ReleaseNotes.md:1703,access,access,1703,interpreter/cling/docs/ReleaseNotes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/docs/ReleaseNotes.md,1,['access'],['access']
Security,"n 'h()', that is (or calls) noreturn and eventually; // 'g()' is never called.; f(g(malloc(1)), h()); // warn: 'g()' may never be called.; }. void f(int, int);; int g(int *);; int h() { throw 1; };. void test() {; // It is possible that 'new int' is called first,; // then 'h()', that throws an exception and eventually; // 'g()' is never called.; f(g(new int), h()); // warn: 'g()' may never be called.; }. memory.DstBufferTooSmall; (C, C++); Destination buffer passed to memory function is too small.; Note: security.insecureAPI.strcpy currently warns; on usage of strcpy and suggests to replace it.; Note: alpha.unix.CStringChecker contains some similar checks.; Source: CWE-120. void test() {; const char* s1 = ""abc"";; char *s2 = new char;; strcpy(s2, s1); // warn; }. void test() {; int* p1 = new int[3];; int* p2 = new int;; memcpy(p2, p1, 3); // warn; }. memory.NegativeArraySize; (C, C++); 'n' is used to specify the buffer size may be negative.; Note: possibly an enhancement to ; alpha.security.MallocOverflow.; Source: CWE-20,; Example 2. void test() {; int *p;; int n1 = -1;; p = new int[n1]; // warn; }. memory.ZeroAlloc; (C, C++); Allocation of zero bytes.; Note: an enhancement to unix.Malloc.; Note: unix.API perform C-checks for zero; allocation. This should be moved to unix.Malloc.; Source: C++03 3.7.3.1p2; C++11 3.7.4.1p2. #include <stdlib.h>. void test() {; int *p = malloc(0); // warn; free(p);; }. void test() {; int *p = new int[0]; // warn; delete[] p;; }. D6178. constructors/destructors. Name, DescriptionExampleProgress. ctordtor.ExptInsideDtor; (C++); It is dangerous to let an exception leave a destructor.; Using try..catch solves the problem.; Source: Scott Meyers ""More Effective C++"", item 11: Prevent exceptions from; leaving destructors. class A {; A() {}; ~A() { throw 1; } // warn; };. void f() throw(int);. class A {; A() {}; ~A() { f(); } // warn; };. ctordtor.PlacementSelfCopy; (C++11); For a placement copy or move, it is almost certainly an error if the; c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html:1680,secur,security,1680,interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/potential_checkers.html,2,['secur'],['security']
Security,"n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63317,secur,security,63317,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"n *id*. Stream *id* is an integer in the range from 0 to 3. Numeric values may be specified as positive :ref:`integer numbers<amdgpu_synid_integer_number>`; or :ref:`absolute expressions<amdgpu_synid_absolute_expression>`. Each message type supports specific operations:. ====================== ========== ============================== ============ ==========; Message name Message Id Supported Operations Operation Id Stream Id; ====================== ========== ============================== ============ ==========; MSG_INTERRUPT 1 \- \- \-; MSG_GS 2 GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_GS_DONE 3 GS_OP_NOP 0 \-; \ GS_OP_CUT 1 Optional; \ GS_OP_EMIT 2 Optional; \ GS_OP_EMIT_CUT 3 Optional; MSG_SAVEWAVE 4 \- \- \-; MSG_STALL_WAVE_GEN 5 \- \- \-; MSG_HALT_WAVES 6 \- \- \-; MSG_ORDERED_PS_DONE 7 \- \- \-; MSG_EARLY_PRIM_DEALLOC 8 \- \- \-; MSG_GS_ALLOC_REQ 9 \- \- \-; MSG_GET_DOORBELL 10 \- \- \-; MSG_SYSMSG 15 SYSMSG_OP_ECC_ERR_INTERRUPT 1 \-; \ SYSMSG_OP_REG_RD 2 \-; \ SYSMSG_OP_TTRACE_PC 4 \-; ====================== ========== ============================== ============ ==========. *Sendmsg* arguments are validated depending on how *type* value is specified:. * If message *type* is specified by name, arguments values must satisfy limitations detailed in the table above.; * If message *type* is specified as a number, each argument must not exceed the corresponding value range (see the first table). Examples:. .. parsed-literal::. // numeric message code; msg = 0x10; s_sendmsg 0x12; s_sendmsg msg + 2. // sendmsg with strict arguments validation; s_sendmsg sendmsg(MSG_INTERRUPT); s_sendmsg sendmsg(MSG_GS, GS_OP_EMIT); s_sendmsg sendmsg(MSG_GS, 2); s_sendmsg sendmsg(MSG_GS_DONE, GS_OP_EMIT_CUT, 1); s_sendmsg sendmsg(MSG_SYSMSG, SYSMSG_OP_TTRACE_PC); s_sendmsg sendmsg(MSG_GET_DOORBELL). // sendmsg with validation of value range only; msg = 2; op = 3; stream = 1; s_sendmsg sendmsg(msg, op, stream); s_sendmsg sendmsg(2, GS_OP_CUT); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst:2728,validat,validated,2728,interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPU/gfx90a_msg.rst,9,['validat'],"['validated', 'validation']"
Security,"n 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. 4. During this process, the :ref:`reporter will be informed of the; resolution<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:2787,threat,threats,2787,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['threat'],['threats']
Security,"n 5.16, 5.18 and version 5.20 in addition to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities. Binaries for all supported platforms are available at:. http://root.cern.ch/root/Version521.html; Versions for AFS have also been updated. See the list of supported; platforms:; http://root.cern.ch/Welcome.html. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Ilka Antcheva,; Jean-Fran�ois Bastien, ; Bertrand Bellenot,; Rene Brun,; Philippe Canal,; Olivier Couet,; Kyle Cranmer,; Valeri Fine,; Leo Franco, ; Gerri Ganis,; Andrei Gheata,; Mihaela Gheata,; David Gonzalez Maline, ; Andreas Hoecker, ; Jan Iwaszkiewicz, ; Lukasz Janyst, ; Anna Kreshuk, ; Wim Lavrijsen,; Josef Leydold,; Sergei Linev,; Anar Manafov, ; Diego Marcos-Segura, ; Lorenzo Moneta,; Axel Naumann,; Eddy Offermann, ; Timur Pocheptsov,; Fons Rademakers,; Paul Russo, ; Gregory Schott,; Stefan Schmitt,; Alja Tadel, ; Matevz Tadel, ; Wouter Verkerke, ; Had",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v522/index.html:1127,authenticat,authentication,1127,doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v522/index.html,2,['authenticat'],['authentication']
Security,"n L\ :sub:`2` at the time of the call made; by the call site. The result of these attributes is undefined if the current call frame is not; for the subprogram containing the ``DW_TAG_call_site_parameter`` debugger; information entry or the current program location is not for the call site; containing the ``DW_TAG_call_site_parameter`` debugger information entry in; the current call frame. *The consumer may have to virtually unwind to the call site (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) in order to evaluate these; attributes. This will ensure the source language thread of execution upon; which the user is focused corresponds to the call site needed to evaluate; the expression.*. If it is not possible to avoid the expressions of these attributes from; accessing registers or memory locations that might be clobbered by the; subprogram being called by the call site, then the associated attribute; should not be provided. *The reason for the restriction is that the parameter may need to be; accessed during the execution of the callee. The consumer may virtually; unwind from the called subprogram back to the caller and then evaluate the; attribute expressions. The call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) will not be able to restore; registers that have been clobbered, and clobbered memory will no longer have; the value at the time of the call.*. 3. Each call site parameter entry may also have a ``DW_AT_call_parameter``; attribute which contains a reference to a ``DW_TAG_formal_parameter`` entry,; ``DW_AT_type attribute`` referencing the type of the parameter or; ``DW_AT_name`` attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3.5 Lexical Block Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section is the same as DWARF Version 5 section 3.5. A.4 Data Object and Object List Entries; ---------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:171068,access,accessed,171068,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessed']
Security,"n bitcasting a pointer value to an arbitrary; pointer type. The types in a GEP serve only to define the parameters for the; underlying integer computation. They need not correspond with the actual type of; the underlying object. Furthermore, loads and stores don't have to use the same types as the type of; the underlying object. Types in this context serve only to specify memory size; and alignment. Beyond that there are merely a hint to the optimizer indicating; how the value will likely be used. Can I cast an object's address to integer and add it to null?; -------------------------------------------------------------. You can compute an address that way, but if you use GEP to do the add, you can't; use that pointer to actually access the object, unless the object is managed; outside of LLVM. The underlying integer computation is sufficiently defined; null has a defined; value --- zero --- and you can add whatever value you want to it. However, it's invalid to access (load from or store to) an LLVM-aware object; with such a pointer. This includes ``GlobalVariables``, ``Allocas``, and objects; pointed to by noalias pointers. If you really need this functionality, you can do the arithmetic with explicit; integer instructions, and use inttoptr to convert the result to an address. Most; of GEP's special aliasing rules do not apply to pointers computed from ptrtoint,; arithmetic, and inttoptr sequences. Can I compute the distance between two objects, and add that value to one address to compute the other address?; ---------------------------------------------------------------------------------------------------------------. As with arithmetic on null, you can use GEP to compute an address that way, but; you can't use that pointer to actually access the object if you do, unless the; object is managed outside of LLVM. Also as above, ptrtoint and inttoptr provide an alternative way to do this which; do not have this restriction. Can I do type-based alias analysis on LLVM ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:15840,access,access,15840,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['access']
Security,"n classes; ==========================. The LLVM target description classes (located in the ``include/llvm/Target``; directory) provide an abstract description of the target machine independent of; any particular client. These classes are designed to capture the *abstract*; properties of the target (such as the instructions and registers it has), and do; not incorporate any particular pieces of code generation algorithms. All of the target description classes (except the :raw-html:`<tt>` `DataLayout`_; :raw-html:`</tt>` class) are designed to be subclassed by the concrete target; implementation, and have virtual methods implemented. To get to these; implementations, the :raw-html:`<tt>` `TargetMachine`_ :raw-html:`</tt>` class; provides accessors that should be implemented by the target. .. _TargetMachine:. The ``TargetMachine`` class; ---------------------------. The ``TargetMachine`` class provides virtual methods that are used to access the; target-specific implementations of the various target description classes via; the ``get*Info`` methods (``getInstrInfo``, ``getRegisterInfo``,; ``getFrameInfo``, etc.). This class is designed to be specialized by a concrete; target implementation (e.g., ``X86TargetMachine``) which implements the various; virtual methods. The only required target description class is the; :raw-html:`<tt>` `DataLayout`_ :raw-html:`</tt>` class, but if the code; generator components are to be used, the other interfaces should be implemented; as well. .. _DataLayout:. The ``DataLayout`` class; ------------------------. The ``DataLayout`` class is the only required target description class, and it; is the only class that is not extensible (you cannot derive a new class from; it). ``DataLayout`` specifies information about how the target lays out memory; for structures, the alignment requirements for various data types, the size of; pointers in the target, and whether the target is little-endian or; big-endian. .. _TargetLowering:. The ``TargetLowe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:10393,access,access,10393,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['access']
Security,"n create an; LLVM `ret instruction <../../LangRef.html#ret-instruction>`_, which completes the function.; Once the function is built, we call ``verifyFunction``, which is; provided by LLVM. This function does a variety of consistency checks on; the generated code, to determine if our compiler is doing everything; right. Using this is important: it can catch a lot of bugs. Once the; function is finished and validated, we return it. .. code-block:: c++. // Error reading body, remove function.; TheFunction->eraseFromParent();; return nullptr;; }. The only piece left here is handling of the error case. For simplicity,; we handle this by merely deleting the function we produced with the; ``eraseFromParent`` method. This allows the user to redefine a function; that they incorrectly typed in before: if we didn't delete it, it would; live in the symbol table, with a body, preventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. extern foo(a); # ok, defines foo.; def foo(b) b; # Error: Unknown variable name. (decl using 'a' takes precedence). Driver Changes and Closing Thoughts; ===================================. For now, code generation to LLVM doesn't really get us much, except that; we can look at the pretty IR calls. The sample code inserts calls to; codegen into the ""``HandleDefinition``"", ""``HandleExtern``"" etc; functions, and then dumps out the LLVM IR. This gives a nice way to look; at the LLVM IR for simple functions. For example:. ::. ready> 4+5;; Read top-level expression:; define double @0() {; entry:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:16969,validat,validate,16969,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['validat'],['validate']
Security,"n for any potentially-throwing instructions; within the region. `llvm.seh.scope.end` is used to mark when the scope ends; and the EH cleanup is no longer required (e.g. because the destructor is being; called). .. _int_read_register:; .. _int_read_volatile_register:; .. _int_write_register:. '``llvm.read_register``', '``llvm.read_volatile_register``', and '``llvm.write_register``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 @llvm.read_register.i32(metadata); declare i64 @llvm.read_register.i64(metadata); declare i32 @llvm.read_volatile_register.i32(metadata); declare i64 @llvm.read_volatile_register.i64(metadata); declare void @llvm.write_register.i32(metadata, i32 @value); declare void @llvm.write_register.i64(metadata, i64 @value); !0 = !{!""sp\00""}. Overview:; """""""""""""""""". The '``llvm.read_register``', '``llvm.read_volatile_register``', and; '``llvm.write_register``' intrinsics provide access to the named register.; The register must be valid on the architecture being compiled to. The type; needs to be compatible with the register being read. Semantics:; """""""""""""""""""". The '``llvm.read_register``' and '``llvm.read_volatile_register``' intrinsics; return the current value of the register, where possible. The; '``llvm.write_register``' intrinsic sets the current value of the register,; where possible. A call to '``llvm.read_volatile_register``' is assumed to have side-effects; and possibly return a different value each time (e.g. for a timer register). This is useful to implement named register global variables that need; to always be mapped to a specific register, as is common practice on; bare-metal programs including OS kernels. The compiler doesn't check for register availability or use of the used; register in surrounding code, including inline assembly. Because of that,; allocatable registers are not supported. Warning: So far it only works with the stack pointe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:518281,access,access,518281,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"n idea of a; coroutine reaching the end. From the compiler perspective, it is an optimization; opportunity for reducing number of resume points (and therefore switch cases) in; the resume function. The following is an example of a function that keeps resuming the coroutine; until the final suspend point is reached after which point the coroutine is; destroyed:. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); br label %while; while:; call void @llvm.coro.resume(ptr %hdl); %done = call i1 @llvm.coro.done(ptr %hdl); br i1 %done, label %end, label %while; end:; call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. Usually, final suspend point is a frontend injected suspend point that does not; correspond to any explicitly authored suspend point of the high level language.; For example, for a Python generator that has only one suspend point:. .. code-block:: python. def coroutine(n):; for i in range(n):; yield i. Python frontend would inject two more suspend points, so that the actual code; looks like this:. .. code-block:: c. void* coroutine(int n) {; int current_value;; <designate current_value to be coroutine promise>; <SUSPEND> // injected suspend point, so that the coroutine starts suspended; for (int i = 0; i < n; ++i) {; current_value = i; <SUSPEND>; // corresponds to ""yield i""; }; <SUSPEND final=true> // injected final suspend point; }. and python iterator `__next__` would look like:. .. code-block:: c++. int __next__(void* hdl) {; coro.resume(hdl);; if (coro.done(hdl)) throw StopIteration();; return *(int*)coro.promise(hdl, 4, false);; }. Intrinsics; ==========. Coroutine Manipulation Intrinsics; ---------------------------------. Intrinsics described in this section are used to manipulate an existing; coroutine. They can be used in any function which happen to have a pointer; to a `coroutine frame`_ or a pointer to a `coroutine promise`_. .. _coro.destroy:. 'llvm.coro.destroy' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:26073,inject,inject,26073,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['inject'],['inject']
Security,"n identical debug; location. Examples of transformations that should follow this rule include:. * Moving instructions between basic blocks. For example, if instruction ``I1``; in ``BB1`` is moved before ``I2`` in ``BB2``, the source location of ``I1``; can be preserved if it has the same source location as ``I2``. .. _WhenToMergeLocation:. When to merge instruction locations; -----------------------------------. A transformation should merge instruction locations if it replaces multiple; instructions with a single merged instruction, *and* that merged instruction; does not correspond to any of the original instructions' locations. The API to; use is ``Instruction::applyMergedLocation``. The purpose of this rule is to ensure that a) the single merged instruction; has a location with an accurate scope attached, and b) to prevent misleading; single-stepping (or breakpoint) behavior. Often, merged instructions are memory; accesses which can trap: having an accurate scope attached greatly assists in; crash triage by identifying the (possibly inlined) function where the bad; memory access occurred. This rule is also meant to assist SamplePGO by banning; scenarios in which a sample of a block containing a merged instruction is; misattributed to a block containing one of the instructions-to-be-merged. Examples of transformations that should follow this rule include:. * Merging identical loads/stores which occur on both sides of a CFG diamond; (see the ``MergedLoadStoreMotion`` pass). * Merging identical loop-invariant stores (see the LICM utility; ``llvm::promoteLoopAccessesToScalars``). * Peephole optimizations which combine multiple instructions together, like; ``(add (mul A B) C) => llvm.fma.f32(A, B, C)``. Note that the location of; the ``fma`` does not exactly correspond to the locations of either the; ``mul`` or the ``add`` instructions. Examples of transformations for which this rule *does not* apply include:. * Block-local peepholes which delete redundant instruction",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst:3631,access,accesses,3631,interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToUpdateDebugInfo.rst,2,['access'],"['access', 'accesses']"
Security,"n kernel dispatches. **Region**; The region address space uses the hardware Global Data Store (GDS). All; wavefronts executing on the same device will access the same memory for any; given region address. However, the same region address accessed by wavefronts; executing on different devices will access different memory. It is higher; performance than global memory. It is allocated by the runtime. The data; store (DS) instructions can be used to access it. **Local**; The local address space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates the wavefronts of a; work-group, and freed when all the wavefronts of a work-group have; terminated. All wavefronts belonging to the same work-group will access the; same memory for any given local address. However, the same local address; accessed by wavefronts belonging to different work-groups will access; different memory. It is higher performance than global memory. The data store; (DS) instructions can be used to access it. **Private**; The private address space uses the hardware scratch memory support which; automatically allocates memory when it creates a wavefront and frees it when; a wavefronts terminates. The memory accessed by a lane of a wavefront for any; given private address will be different to the memory accessed by another lane; of the same or different wavefront for the same private address. If a kernel dispatch uses scratch, then the hardware allocates memory from a; pool of backing memory allocated by the runtime for each wavefront. The lanes; of the wavefront access this using dword (4 byte) interleaving. The mapping; used from private address to backing memory address is:. ``wavefront-scratch-base +; ((private-address / 4) * wavefront-size * 4) +; (wavefront-lane-id * 4) + (private-address % 4)``. If each lane of a wavefront accesses the same private address, the; interleaving results in adjacent dwords being accessed and hence requires; fewer cache lines t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:26487,access,access,26487,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"n language is statically typed, using a simple but complete type; system. Types are used to check for errors, to perform implicit conversions,; and to help interface designers constrain the allowed input. Every value is; required to have an associated type. TableGen supports a mixture of low-level types (e.g., ``bit``) and; high-level types (e.g., ``dag``). This flexibility allows you to describe a; wide range of records conveniently and compactly. .. productionlist::; Type: ""bit"" | ""int"" | ""string"" | ""dag""; :| ""bits"" ""<"" `TokInteger` "">""; :| ""list"" ""<"" `Type` "">""; :| `ClassID`; ClassID: `TokIdentifier`. ``bit``; A ``bit`` is a boolean value that can be 0 or 1. ``int``; The ``int`` type represents a simple 64-bit integer value, such as 5 or; -42. ``string``; The ``string`` type represents an ordered sequence of characters of arbitrary; length. ``bits<``\ *n*\ ``>``; The ``bits`` type is a fixed-sized integer of arbitrary length *n* that; is treated as separate bits. These bits can be accessed individually.; A field of this type is useful for representing an instruction operation; code, register number, or address mode/register/displacement. The bits of; the field can be set individually or as subfields. For example, in an; instruction address, the addressing mode, base register number, and; displacement can be set separately. ``list<``\ *type*\ ``>``; This type represents a list whose elements are of the *type* specified in; angle brackets. The element type is arbitrary; it can even be another; list type. List elements are indexed from 0. ``dag``; This type represents a nestable directed acyclic graph (DAG) of nodes.; Each node has an *operator* and zero or more *arguments* (or *operands*).; An argument can be; another ``dag`` object, allowing an arbitrary tree of nodes and edges.; As an example, DAGs are used to represent code patterns for use by; the code generator instruction selection algorithms. See `Directed; acyclic graphs (DAGs)`_ for more details;. :token:`C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst:11187,access,accessed,11187,interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TableGen/ProgRef.rst,1,['access'],['accessed']
Security,"n object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code-generation>` flag. Forward-Edge CFI for Virtual Calls; ==================================. This scheme checks that virtual calls take place using a vptr of the correct; dynamic type; that is, the dynamic type of the called object must be a; derived class of the static type of the object used to make the call.; This CFI scheme can be enabled on its own using ``-fsanitize=cfi-vcall``. For this scheme to work, all translation units cont",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3413,sanitiz,sanitize-trap,3413,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['sanitiz'],['sanitize-trap']
Security,"n parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:5989,hash,hash,5989,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['hash'],['hash']
Security,"n suites like ToolingTests. Re-run like this:. .. code:: console. $ ninja ToolingTests && tools/clang/unittests/Tooling/ToolingTests; --gtest_filter=ReplacementTest.CanDeleteAllText. Commit locally; --------------. We'll save the change to a local git branch. This lets us work on other; things while the change is being reviewed. Changes should have a; description, to explain to reviewers and future readers of the code why; the change was made. .. code:: console. $ git checkout -b myfirstpatch; $ git commit -am ""[Diagnostic] Clarify -Winfinite-recursion message"". Now we're ready to send this change out into the world! By the way,; There is an unwritten convention of using tag for your commit. Tags; usually represent modules that you intend to modify. If you don't know; the tags for your modules, you can look at the commit history :; https://github.com/llvm/llvm-project/commits/main. Code review; ===========. Finding a reviewer; ------------------. Changes can be reviewed by anyone in the LLVM community who has commit; access.For larger and more complicated changes, it's important that the; reviewer has experience with the area of LLVM and knows the design goals; well. The author of a change will often assign a specific reviewer (git; blame and git log can be useful to find one). As our change is fairly simple, we'll add the cfe-commits mailing list; as a subscriber; anyone who works on clang can likely pick up the; review. (For changes outside clang, llvm-commits is the usual list. See; `http://lists.llvm.org/ <http://lists.llvm.org/mailman/listinfo>`__ for; all the \*-commits mailing lists). Uploading a change for review; -----------------------------. LLVM code reviews happen through pull-request on GitHub, see; :ref:`GitHub <github-reviews>` documentation for how to open; a pull-request on GitHub. Review process; --------------. When you open a pull-request, some automation will add a comment and; notify different member of the projects depending on the component ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:9021,access,access,9021,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['access'],['access']
Security,"n the translation unit, the program is ill-formed but; no diagnostic is required. A ``goto`` or ``switch`` is ill-formed if it jumps into the scope of; an object of automatic storage duration whose type is non-trivial to; destroy. C specifies that it is generally undefined behavior to access an l-value; if there is no object of that type at that location. Implementations; are often lenient about this, but non-trivial types generally require; it to be enforced more strictly. The following rules apply:. The *static subobjects* of a type ``T`` at a location ``L`` are:. - an object of type ``T`` spanning from ``L`` to ``L + sizeof(T)``;. - if ``T`` is a struct type, then for each field ``f`` of that struct,; the static subobjects of ``T`` at location ``L + offsetof(T, .f)``; and. - if ``T`` is the array type ``E[N]``, then for each ``i`` satisfying; ``0 <= i < N``, the static subobjects of ``E`` at location; ``L + i * sizeof(E)``. If an l-value is converted to an r-value, then all static subobjects; whose types are non-trivial to copy are accessed. If an l-value is; assigned to, or if an object of automatic storage duration goes out of; scope, then all static subobjects of types that are non-trivial to destroy; are accessed. A dynamic object is created at a location if an initialization initializes; an object of that type there. A dynamic object ceases to exist at a; location if the memory is repurposed. Memory is repurposed if it is; freed or if a different dynamic object is created there, for example by; assigning into a different union member. An implementation may provide; additional rules for what constitutes creating or destroying a dynamic; object. If an object is accessed under these rules at a location where no such; dynamic object exists, the program has undefined behavior.; If memory for a location is repurposed while a dynamic object that is; non-trivial to destroy exists at that location, the program has; undefined behavior. .. admonition:: Rationale. While",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:57388,access,accessed,57388,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['accessed']
Security,"n the translation unit. .. code-block:: c. #define _CLANG_DISABLE_CRT_DEPRECATION_WARNINGS; #include <stdint.h> // Clang CRT deprecation warnings are disabled.; #include <stdatomic.h> // Clang CRT deprecation warnings are disabled. .. _diagnostics_enable_everything:. Enabling All Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^. In addition to the traditional ``-W`` flags, one can enable **all** diagnostics; by passing :option:`-Weverything`. This works as expected with; :option:`-Werror`, and also includes the warnings from :option:`-pedantic`. Some; diagnostics contradict each other, therefore, users of :option:`-Weverything`; often disable many diagnostics such as `-Wno-c++98-compat` and `-Wno-c++-compat`; because they contradict recent C++ standards. Since :option:`-Weverything` enables every diagnostic, we generally don't; recommend using it. `-Wall` `-Wextra` are a better choice for most projects.; Using :option:`-Weverything` means that updating your compiler is more difficult; because you're exposed to experimental diagnostics which might be of lower; quality than the default ones. If you do use :option:`-Weverything` then we; advise that you address all new compiler diagnostics as they get added to Clang,; either by fixing everything they find or explicitly disabling that diagnostic; with its corresponding `Wno-` option. Note that when combined with :option:`-w` (which disables all warnings),; disabling all warnings wins. Controlling Static Analyzer Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While not strictly part of the compiler, the diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Prec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:44674,expose,exposed,44674,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['expose'],['exposed']
Security,n to T&; Unknown. 1363; CD3; Triviality vs multiple default constructors; Unknown. 1364; CD3; constexpr function parameters; Unknown. 1365; CD3; Calling undefined constexpr functions; Unknown. 1366; CD3; Deleted constexpr constructors and virtual base classes; Unknown. 1367; CD3; Use of this in a constant expression; Unknown. 1368; CD3; Value initialization and defaulted constructors (part 2); Unknown. 1369; CD3; Function invocation substitution of this; Unknown. 1370; CD3; identifier-list cannot contain ellipsis; Unknown. 1371; NAD; Deduction from T&& in return types; Unknown. 1372; CD3; Cross-references incorrect in conversion function template argument deduction; Unknown. 1373; dup; Overload resolution changes matching reference-binding changes; Unknown. 1374; CD3; Qualification conversion vs difference in reference binding; Unknown. 1375; CD3; Reference to anonymous union?; Unknown. 1376; C++14; static_cast of temporary to rvalue reference; Unknown. 1377; dup; Access declarations not mentioned in Annex C; Unknown. 1378; CD5; When is an instantiation required?; Unknown. 1379; NAD; Is std::initializer_list an aggregate?; Unknown. 1380; CD3; Type definitions in template-parameter parameter-declarations; Unknown. 1381; CD3; Implicitly-declared special member functions and default nothrow; Unknown. 1382; CD3; Dead code for constructor names; Unknown. 1383; CD3; Clarifying discarded-value expressions; Unknown. 1384; NAD; reinterpret_cast in constant expressions; Unknown. 1385; CD3; Syntactic forms of conversion functions for surrogate call functions; Unknown. 1386; NAD; Explicitly-specified partial argument list with multiple parameter packs; Unknown. 1387; CD3; Missing non-deduced context for decltype; Unknown. 1388; CD3; Missing non-deduced context following a function parameter pack; Clang 4. 1389; NAD; Recursive reference in trailing-return-type; Unknown. 1390; drafting; Dependency of alias template specializations; Not resolved. 1391; CD4; Conversions to paramete,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:92223,Access,Access,92223,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"n't it ?. If you like, you can easily extend the example to also plot the; interference pattern of a single slit, using function `double single`,; or of a grid with narrow slits, function `double nslit0`, in `TF1`; instances. Here, we used a macro, some sort of lightweight program, that the; interpreter distributed with ROOT, Cling, is able to execute. This is a; rather extraordinary situation, since `C++` is not natively an interpreted; language! There is much more to say: chapter is indeed dedicated to; macros. ## Controlling ROOT ##. One more remark at this point: as every command you type into ROOT is; usually interpreted by Cling, an ""escape character"" is needed to pass; commands to ROOT directly. This character is the dot at the beginning of; a line:. ``` {.cpp}; root [1] .<command>; ```. This is a selection of the most common commands. - **quit root**, simply type `.q` or `.quit` or `.exit`. - obtain the full **list of commands**, use `.?` or `.help`. - **access the shell** of the operating system, type `.!<OS_command>`;; try, e.g. `.!ls` or `.!pwd`. - **execute a macro**, enter `.x <file_name>`; in the above example,; you might have used `.x slits.C` at the ROOT prompt. - **load a macro**, type `.L <file_name>`; in the above example, you; might instead have used the command `.L slits.C` followed by the; function call `slits();`. Note that after loading a macro all; functions and procedures defined therein are available at the ROOT; prompt. - **compile a macro**, type `.L <file_name>+`; ROOT is able to manage; for you the `C++` compiler behind the scenes and to produce machine; code starting from your macro. One could decide to compile a macro; in order to obtain better performance or to get nearer to the; production environment. ## Plotting Measurements ##. To display measurements in ROOT, including errors, there exists a; powerful class `TGraphErrors` with different types of constructors. In; the example here, we use data from the file `ExampleData.txt` in ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:8002,access,access,8002,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['access'],['access']
Security,"n(""expo.dat"");; root [4] while (inp >> x) { h.Fill(x); }; root [5] h.Draw();; root [6] inp.close();; ```. Histograms and random numbers are very important tools in statistical; data analysis, a whole chapter will be dedicated to this topic. ## Interactive ROOT ##. Look at one of your plots again and move the mouse across. You will; notice that this is much more than a static picture, as the mouse; pointer changes its shape when touching objects on the plot. When the; mouse is over an object, a right-click opens a pull-down menu displaying; in the top line the name of the ROOT class you are dealing with, e.g.; `TCanvas` for the display window itself, `TFrame` for the frame of the; plot, `TAxis` for the axes, `TPaveText` for the plot name. Depending on; which plot you are investigating, menus for the ROOT classes `TF1`,; `TGraphErrors` or `TH1F` will show up when a right-click is performed on; the respective graphical representations. The menu items allow direct; access to the members of the various classes, and you can even modify; them, e.g. change colour and size of the axis ticks or labels, the; function lines, marker types and so on. Try it!. [f24]: figures/ROOTPanel_SetParameters.png ""f24""; <a name=""f24""></a>. ![Interactive ROOT panel for setting function parameters.\label{f24}][f24]. You will probably like the following: in the output produced by the; example `slits.C`, right-click on the function line and select; ""SetLineAttributes"", then left-click on ""Set Parameters"". This gives; access to a panel allowing you to interactively change the parameters of; the function, as shown in Figure [2.4](#f24). Change the slit width, or go from one to; two and then three or more slits, just as you like. When clicking on; ""Apply"", the function plot is updated to reflect the actual value of the; parameters you have set. [f25]: figures/ROOTPanel_FitPanel.png ""f25""; <a name=""f25""></a>. ![Fit Panel. \label{f25}][f25]. Another very useful interactive tool is the `FitPanel`, avai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:13823,access,access,13823,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['access'],['access']
Security,"n, as it; runs just before the pass that we are trying to test:. ``llc -stop-after=machine-cp bug-trigger.ll -o test.mir``. If the same pass is run multiple times, a run index can be included; after the name with a comma. ``llc -stop-after=dead-mi-elimination,1 bug-trigger.ll -o test.mir``. After generating the input MIR file, you'll have to add a run line that uses; the ``-run-pass`` option to it. In order to test the post register allocation; pseudo instruction expansion pass on X86-64, a run line like the one shown; below can be used:. ``# RUN: llc -o - %s -mtriple=x86_64-- -run-pass=postrapseudos | FileCheck %s``. The MIR files are target dependent, so they have to be placed in the target; specific test directories (``lib/CodeGen/TARGETNAME``). They also need to; specify a target triple or a target architecture either in the run line or in; the embedded LLVM IR module. Simplifying MIR files; ^^^^^^^^^^^^^^^^^^^^^. The MIR code coming out of ``-stop-after``/``-stop-before`` is very verbose;; Tests are more accessible and future proof when simplified:. - Use the ``-simplify-mir`` option with llc. - Machine function attributes often have default values or the test works just; as well with default values. Typical candidates for this are: `alignment:`,; `exposesReturnsTwice`, `legalized`, `regBankSelected`, `selected`.; The whole `frameInfo` section is often unnecessary if there is no special; frame usage in the function. `tracksRegLiveness` on the other hand is often; necessary for some passes that care about block livein lists. - The (global) `liveins:` list is typically only interesting for early; instruction selection passes and can be removed when testing later passes.; The per-block `liveins:` on the other hand are necessary if; `tracksRegLiveness` is true. - Branch probability data in block `successors:` lists can be dropped if the; test doesn't depend on it. Example:; `successors: %bb.1(0x40000000), %bb.2(0x40000000)` can be replaced with; `successors: %bb.1, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst:3103,access,accessible,3103,interpreter/llvm-project/llvm/docs/MIRLangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MIRLangRef.rst,1,['access'],['accessible']
Security,n-object prvalues and constant expressions; Unknown. 2130; CD4; Over-aligned types in new-expressions; Unknown. 2131; drafting; Ambiguity with opaque-enum-declaration; Not resolved. 2132; NAD; Deprecated default generated copy constructors; Unknown. 2133; CD5; Converting std::nullptr_t to bool; Unknown. 2134; NAD; Objectless references to non-static member functions; Unknown. 2135; NAD; mem-initializers for virtual bases of abstract classes; Unknown. 2136; NAD; Argument-dependent lookup and initializer lists; Unknown. 2137; CD4; List-initialization from object of same type; Unknown. 2138; NAD; Explicit member specialization vs implicit instantiation; Unknown. 2139; NAD; Floating-point requirements for integer representation; Unknown. 2140; CD4; Lvalue-to-rvalue conversion of std::nullptr_t; Clang 9. 2141; CD4; Ambiguity in new-expression with elaborated-type-specifier; Clang 17. 2142; NAD; Missing definition of associated classes and namespaces; Unknown. 2143; C++17; Value-dependency via injected-class-name; Unknown. 2144; drafting; Function/variable declaration ambiguity; Not resolved. 2145; CD4; Parenthesized declarator in function definition; Unknown. 2146; CD4; Scalar object vs memory location in definition of “unsequenced”; Unknown. 2147; CD4; Initializer-list arguments and pack deduction; Unknown. 2148; drafting; Thread storage duration and order of initialization; Not resolved. 2149; drafting; Brace elision and array length deduction; Not resolved. 2150; CD3; Initializer list array lifetime; Unknown. 2151; CD4; Exception object is not created; Unknown. 2152; NAD; Can an alternative token be used as a ud-suffix?; Unknown. 2153; CD4; pure-specifier in friend declaration; Unknown. 2154; CD4; Ambiguity of pure-specifier; Unknown. 2155; C++17; Defining classes and enumerations via using-declarations; Unknown. 2156; CD4; Definition of enumeration declared by using-declaration; Unknown. 2157; CD4; Further disambiguation of enumeration elaborated-type-specifier; Clan,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:145974,inject,injected-class-name,145974,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injected-class-name']
Security,"n-trivial types in C; is that there are no language mechanisms (akin to C++'s placement; ``new`` and explicit destructor calls) for explicitly creating and; destroying objects. Clang should consider adding builtins for this; purpose, as well as for common optimizations like destructive; relocation. Application of the formal C rules to nontrivial ownership qualifiers; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Nontrivially ownership-qualified types are considered non-trivial; to copy, destroy, and default-initialize. A dynamic object of nontrivially ownership-qualified type contingently; exists at a location if the memory is filled with a zero pattern, e.g.; by ``calloc`` or ``bzero``. Such an object can be safely accessed in; all of the cases above, but its memory can also be safely repurposed.; Assigning a null pointer into an l-value of ``__weak`` or; ``__strong``-qualified type accesses the dynamic object there (and thus; may have undefined behavior if no such object exists), but afterwards; the object's memory is guaranteed to be filled with a zero pattern; and thus may be either further accessed or repurposed as needed.; The upshot is that programs may safely initialize dynamically-allocated; memory for nontrivially ownership-qualified types by ensuring it is zero-initialized, and they may safely deinitialize memory before; freeing it by storing ``nil`` into any ``__strong`` or ``__weak``; references previously created in that memory. C/C++ compatibility for structs and unions with non-trivial members; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Structs and unions with non-trivial members are compatible in; different language modes (e.g. between Objective-C and Objective-C++,; or between ARC and non-ARC modes) under the following conditions:. - The types must be compatible ignoring ownership qualifiers according; to the baseline, non-ARC rules (e.g. C struct compatibility or C++'s; ODR). This condition implies ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:60289,access,accesses,60289,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,2,['access'],"['accessed', 'accesses']"
Security,n. 1540; NAD; Use of address constants in constant expressions; Unknown. 1541; CD3; cv void return types; Unknown. 1542; drafting; Compound assignment of braced-init-list; Not resolved. 1543; CD3; Implicit conversion sequence for empty initializer list; Unknown. 1544; CD3; Linkage of member of unnamed namespace; Unknown. 1545; NAD; friend function templates defined in class templates; Unknown. 1546; NAD; Errors in function template default arguments; Unknown. 1547; NAD; typename keyword in alias-declarations; Unknown. 1548; drafting; Copy/move construction and conversion functions; Not resolved. 1549; open; Overloaded comma operator with void operand; Not resolved. 1550; CD3; Parenthesized throw-expression operand of conditional-expression; Clang 3.4. 1551; C++14; Wording problems in using-declaration specification; Unknown. 1552; CD4; exception-specifications and defaulted special member functions; Unknown. 1553; CD3; sizeof and xvalue bit-fields; Unknown. 1554; drafting; Access and alias templates; Not resolved. 1555; NAD; Language linkage and function type compatibility; Unknown. 1556; CD3; Constructors and explicit conversion functions in direct initialization; Unknown. 1557; CD3; Language linkage of converted lambda function pointer; Unknown. 1558; CD4; Unused arguments in alias template specializations; Clang 12. 1559; CD3; String too long in initializer list of new-expression; Unknown. 1560; CD3; Gratuitous lvalue-to-rvalue conversion in conditional-expression with throw-expression operand; Clang 3.5. 1561; CD4; Aggregates with empty base classes; Unknown. 1562; C++14; Non-static data member initializers and union ctor-initializer; Unknown. 1563; CD3; List-initialization and overloaded function disambiguation; Yes. 1564; NAD; Template argument deduction from an initializer list; Unknown. 1565; NAD; Copy elision and lifetime of initializer_list underlying array; Unknown. 1566; NAD; Should new std::initializer_list<T> be ill-formed?; Unknown. 1567; C++14; Inher,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:104612,Access,Access,104612,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"n. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22611,secur,security,22611,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['secur'],['security']
Security,"n; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:11726,inject,injection,11726,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,4,"['access', 'inject']","['access', 'injection']"
Security,n; Unknown. 2017; CD4; Flowing off end is not equivalent to no-expression return; Unknown. 2018; dup; Qualification conversion vs reference binding; Unknown. 2019; CD4; Member references omitted from description of storage duration; Unknown. 2020; CD5; Inadequate description of odr-use of implicitly-invoked functions; Unknown. 2021; dup; Function template redeclaration via alias template; Unknown. 2022; CD4; Copy elision in constant expressions; Unknown. 2023; drafting; Composite reference result type of conditional operator; Not resolved. 2024; CD4; Dependent types and unexpanded parameter packs; Unknown. 2025; dup; Declaration matching via alias templates; Unknown. 2026; CD4; Zero-initialization and constexpr; Clang 11. 2027; CD4; Unclear requirements for multiple alignas specifiers; Unknown. 2028; drafting; Converting constructors in rvalue reference initialization; Not resolved. 2029; dup; Abstract class return type in decltype operand; Unknown. 2030; NAD; Access of injected-class-name with template arguments; Unknown. 2031; CD4; Missing incompatibility for &&; Unknown. 2032; CD4; Default template-arguments of variable templates; Unknown. 2033; CD4; Redundant restriction on partial specialization argument; Unknown. 2034; NAD; Deprecating uncaught_exception(); Unknown. 2035; CD3; Multi-section example is confusing; Unknown. 2036; NAD; Refactoring parameters-and-qualifiers; Unknown. 2037; drafting; Alias templates and template declaration matching; Not resolved. 2038; CD4; Document C++14 incompatibility of new braced deduction rule; Unknown. 2039; CD4; Constant conversions to bool; Unknown. 2040; CD4; trailing-return-type no longer ambiguous; Unknown. 2041; CD4; Namespace for explicit class template specialization; Unknown. 2042; drafting; Exceptions and deallocation functions; Not resolved. 2043; drafting; Generalized template arguments and array-to-pointer decay; Not resolved. 2044; CD4; decltype(auto) and void; Unknown. 2045; CD5; “Identical” template parameter ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:138023,inject,injected-class-name,138023,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,3,"['Access', 'inject']","['Access', 'injected-class-name']"
Security,"n; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValueOfObjCType:at:size:]. void test(NSCoder *decoder) {; // This would be a vulnerability on 64-bit platforms; // but not on 32-bit platforms.; NSUInteger x;; [decoder decodeValueOfObjCType:""I"" at:&x]; // warn; }. Unix Checkers. Name, DescriptionExample. unix.API; (C); Check calls to various UNIX/POSIX functions:; open; pthread_once; calloc; malloc; realloc; alloca. // Currently the check is performed for apple targets only.; void test(const char *path) {; int fd = open(path, O_CREAT);; // warn: call to 'open' requires a third argument when the; // 'O_CREAT' flag is set; }. void f();. void test() {; pthread_once_t pred = {0x30B1BCBA, {0}};; pthread_once(&pred, f);; // warn: call to 'pthread_once' uses the local variable; }. void t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22766,secur,security,22766,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['secur'],['security']
Security,"n; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32_t offsets[Header.hashes_count]; // An offset that corresponds to each item in the ""hashes[]"" array above; };. ``buckets`` is an array of 32 bit indexes into the ``hashes`` array. The; ``hashes`` array contains all of the 32 bit hash values for all names in the; hash table. Each hash in the ``hashes`` table has an offset in the ``offsets``; array that points to the data for the hash value. This table setup makes it very easy to repurpose these tables to contain; different data, while keeping the lookup mechanism the same for all tables.; This layout also makes it possible to save the table to disk and map it in; later and do very efficient name lookups with little or no parsing. DWARF lookup tables can be implemented in a variety of ways and can store a lot; of information for each name. We want to make the DWARF tables extensible and; able to store the data efficiently so we have used some of the DWARF features; that enable efficient data storage to define exactly what kind of data we store; for each name. The ``HeaderData`` contains a definition of the contents of each HashData chunk.; We might want to store an offset to all of the debug information entries (DIEs); for each name. To keep things extensible,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:71004,hash,hashes,71004,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,3,['hash'],"['hash', 'hashes']"
Security,"nLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow. Bin\# 1 contains the first bin with low-edge ( `xlow` INCLUDED). The second to last bin (bin\# `nbins`) contains the upper-edge; (`xup` EXCLUDED). The Last bin (bin\# `nbins+1)` contains the overflow. In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram `h` with `binx`, `biny`, `binz`,; the function returns a global/linear bin number. ``` {.cpp}; Int_t bin = h->GetBin(binx, biny, binz);; ```. This global bin is useful to access the bin information independently; of the dimension. ### Re-binning; \index{histogram!rebin}. At any time, a histogram can be re-binned via the **`TH1`**`::Rebin()`; method. It returns a new histogram with the re-binned contents. If bin; errors were stored, they are recomputed during the re-binning. ## Filling Histograms. A histogram is typically filled with statements like:. ``` {.cpp}; h1->Fill(x);; h1->Fill(x,w); // with weight; h2->Fill(x,y);; h2->Fill(x,y,w);; h3->Fill(x,y,z);; h3->Fill(x,y,z,w);; ```. The `Fill` method computes the bin number corresponding to the given; x, y or z argument and increments this bin by the given weight. The; `Fill()` method returns the bin number for 1-D histograms or global; bin number for 2-D and 3-D histograms. If **`TH1`**`::Sumw2()` has; been called before filling, the sum of squares is also stored. One can; increment a bin number directly by calling; **`TH1`**`::AddBinContent()`, replace the existing content via; **`TH1`**`::SetBinContent()` , and acce",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:6933,access,access,6933,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['access'],['access']
Security,"n_entry_count; """""""""""""""""""""""""""""""""""""""". Function entry count metadata can be attached to function definitions; to record the number of times the function is called. Used with BFI; information, it is also used to derive the basic block profile count.; For more information, see :doc:`BranchWeightMetadata`. .. _prof_node_VP:. VP; """". VP (value profile) metadata can be attached to instructions that have; value profile information. Currently this is indirect calls (where it; records the hottest callees) and calls to memory intrinsics such as memcpy,; memmove, and memset (where it records the hottest byte lengths). Each VP metadata node contains ""VP"" string, then a uint32_t value for the value; profiling kind, a uint64_t value for the total number of times the instruction; is executed, followed by uint64_t value and execution count pairs.; The value profiling kind is 0 for indirect call targets and 1 for memory; operations. For indirect call targets, each profile value is a hash; of the callee function name, and for memory operations each value is the; byte length. Note that the value counts do not need to add up to the total count; listed in the third operand (in practice only the top hottest values; are tracked and reported). Indirect call example:. .. code-block:: llvm. call void %f(), !prof !1; !1 = !{!""VP"", i32 0, i64 1600, i64 7651369219802541373, i64 1030, i64 -4377547752858689819, i64 410}. Note that the VP type is 0 (the second operand), which indicates this is; an indirect call value profile data. The third operand indicates that the; indirect call executed 1600 times. The 4th and 6th operands give the; hashes of the 2 hottest target functions' names (this is the same hash used; to represent function names in the profile database), and the 5th and 7th; operands give the execution count that each of the respective prior target; functions was called. .. _md_annotation:. '``annotation``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``annotation`` metadata can be used to a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:321135,hash,hash,321135,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security,"nal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:12931,secur,security,12931,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"nalogy with a tree structure). On the other hand, any volume is a small world by itself - what we need; to do is to take it out and to ignore all the rest since it is a; self-contained object. In fact, the modeller can act like this,; considering a given volume as temporary MARS, but we will describe this; feature later on. Let us focus on the biggest pack - it is mandatory to; define one. Consider the simplest geometry that is made of a single box.; Here is an example on how to build it:. \anchor GP00a; ### Example 1: Creating the World. We first need to load the geometry library. This is not needed if one; does ""make map"" in root folder. ~~~{.cpp}; root[] gSystem->Load(""libGeom"");; ~~~. Second, we have to create an instance of the geometry manager class.; This takes care of all the modeller components, performing several tasks; to insure geometry validity and containing the user interface for; building and interacting with the geometry. After its creation, the; geometry manager class can be accessed with the global; `gGeoManager`:. ~~~{.cpp}; root[] new TGeoManager(""world"", ""the simplest geometry"");; ~~~. We want to create a single volume in our geometry, but since any volume; needs to have an associated medium, we will create a dummy one. You can; safely ignore the following lines for the time being, since materials; and media will be explained in detail later on. ~~~{.cpp}; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; ~~~. We can finally make our volume having a box shape. Note that the world; volume does not need to be a box - it can be any other shape. Generally,; boxes and tubes are the most recommendable shapes for this purpose due; to their fast navigation algorithms. ~~~{.cpp}; root[] TGeoVolume *top=gGeoManager->MakeBox(""Top"",med,10.,10.,10.);; ~~~. The default units are in centimeters. Now we want to make this volume; our world. We have to do this operation **before** closing the g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:5370,access,accessed,5370,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['accessed']
Security,"nalysis,; ie. your analysis logic or framework is taking up the time.; The best way to decrease the runtime would be to optimize your code (or the framework's),; parallelize it onto multiple threads if possible (for example with; [RDataFrame](https://root.cern/doc/master/classROOT_1_1RDataFrame.html); and [EnableImplicitMT](https://root.cern/doc/master/namespaceROOT.html#a06f2b8b216b615e5abbc872c9feff40f)); or switch to a machine with a more performant CPU.; - The 'Real Time' is significantly higher than 'CPU Time / number of threads'*.; If the real time is higher than the CPU time per core it implies the reading of data is the; bottleneck, as the CPU cores are wasting time waiting for data to arrive from your disk/drive; or network connection in order to decompress it.; The best way to decrease your runtime would be transferring the data you need onto a faster; storage medium (ie. a faster disk/drive such as an SSD, or connecting to a faster network; for remote file access), or to use a compression algorithm with a higher compression ratio,; possibly at the cost of the decompression rate.; Changing the number of threads is unlikely to help, and in fact using too many threads may; degrade performance if they make requests to different regions of your local storage. ; * If no '--threads' argument was provided this is 1, otherwise it is the minimum of the value; provided and the number of threads your CPU can run in parallel. It is worth noting that -; on shared systems or if running other heavy applications - the number of your own threads; running at any time may be lower than the limit due to demand on the CPU.; - The 'Real Time' is similar to 'CPU Time / number of threads' AND 'Compressed Throughput' is lower than expected; for your storage medium: this would imply that your CPU threads aren't decompressing data as fast as your storage; medium can provide it, and so decompression is the bottleneck.; The best way to decrease your runtime would be to utilise a syste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/README.md:2182,access,access,2182,tree/readspeed/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/readspeed/README.md,1,['access'],['access']
Security,"nalysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63801,secur,security-cert-pos-checkers,63801,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security-cert-pos-checkers']
Security,"name, a namespace name, a typedef or alias or a header file name.; - Single line comments, which start with a ""#"" character. At ROOT startup, a check is performed on autoload keys. If the same key (which is not a template instantiation) refers to two different libraries (or sets of libraries) a warning is issued.; A typical Rootmap file look like:; ``` {.cpp}; { decls }; fwd declaration 1;; fwd declaration 2;; [...]; fwd declaration N;. [ libraryName1 libraryName2 ... ]; class className1; class className2; ...; typedef typedefName1; typedef typedefName2; ...; header headerName1; header headerName2; ... ```. ### TROOT. The list returned by `GetListOfTypes` is no longer filled when the dictionary; are loaded but instead are filled on demand, when the user explicitly (directly; or indirectly) request each typedef. In particular this means that. ``` {.cpp}; gROOT->GetListOfTypes()->ls(); // or Print(); ```. no longer prints the list of all available typedef but instead list only the; typedefs that have been previously accessed throught the list (plus the builtins; types). ### ACliC. ACLiC has the following backward incompatibilities:. - Since rootcling no longer re-\#defines the private and protected; keyword to public, the code compiled by ACLIC no longer has access; to protected and private members of a class (except where allowed by; the C++ standard). ### Collection. New collection `TListOfTypes` that implements on demand creation; of the `TDataType` describing a typedef. ### TUnixSystem. - Simplify `Setenv` coding.; - Implement `Unsetenv` using the system function `unsetenv`. ### TMacOSXSystem. - The file descriptors' management improved/fixed. ### TColor. - 5 new predefined palettes with 255 colors are available vis; `gStyle->SetPalette(n)`:. - n = 51 a Deep Sea palette is used.; - n = 52 a Grey Scale palette is used.; - n = 53 a Dark Body Radiator palette is used.; - n = 54 a two-color hue palette palette is used.(dark blue; through neutral gray to bright yellow)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:11052,access,accessed,11052,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['access'],['accessed']
Security,"name, and content identifier should be unique in the list.; However, not every type needs to provide additional type information. The following kinds of content are supported:. | Content identifier | Meaning of content |; |---------------------|-----------------------------------------------------|; | 0x00 | Serialized ROOT streamer info; see notes |. The serialized ROOT streamer info is not bound to a specific type.; It is the combined streamer information from all fields serialized by the ROOT streamer.; Writers set version from/to to zero and use an empty type name.; Readers should ignore the type-specific information.; The format of the content is a ROOT streamed `TList` of `TStreamerInfo` objects. ### Footer Envelope. The footer envelope has the following structure:. - Feature flags; - Header checksum (XxHash-3 64bit); - Schema extension record frame; - List frame of column group record frames; - List frame of cluster group record frames. The header checksum can be used to cross-check that header and footer belong together.; The meaning of the feature flags is the same as for the header.; The header flags do not need to be repeated.; Readers should combine (logical `or` of the bits) the feature flags from header and footer for the full set of flags. #### Schema Extension Record Frame. The schema extension record frame contains an additional schema description that is incremental; with respect to the schema contained in the header (see Section Header Envelope).; Specifically, it is a record frame with the following four fields; (identical to the last four fields in Header Envelope):. - List frame: list of field record frames; - List frame: list of column record frames; - List frame: list of alias column record frames; - List frame: list of extra type information. In general, a schema extension is optional, and thus this record frame might be empty.; The interpretation of the information contained therein should be identical; as if it was found directly at the end",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:28491,checksum,checksum,28491,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['checksum'],['checksum']
Security,"namic_shared_pointer"".; "".address_space"" string Kernel argument address space; qualifier. Only present if; "".value_kind"" is ""global_buffer"" or; ""dynamic_shared_pointer"". Values; are:. - ""private""; - ""global""; - ""constant""; - ""local""; - ""generic""; - ""region"". .. TODO::. Is ""global_buffer"" only ""global""; or ""constant""? Is; ""dynamic_shared_pointer"" always; ""local""? Can HCC allow ""generic""?; How can ""private"" or ""region""; ever happen?. "".access"" string Kernel argument access; qualifier. Only present if; "".value_kind"" is ""image"" or; ""pipe"". Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". .. TODO::. Does this apply to; ""global_buffer""?. "".actual_access"" string The actual memory accesses; performed by the kernel on the; kernel argument. Only present if; "".value_kind"" is ""global_buffer"",; ""image"", or ""pipe"". This may be; more restrictive than indicated; by "".access"" to reflect what the; kernel actual does. If not; present then the runtime must; assume what is implied by; "".access"" and "".is_const"" . Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". "".is_const"" boolean Indicates if the kernel argument; is const qualified. Only present; if "".value_kind"" is; ""global_buffer"". "".is_restrict"" boolean Indicates if the kernel argument; is restrict qualified. Only; present if "".value_kind"" is; ""global_buffer"". "".is_volatile"" boolean Indicates if the kernel argument; is volatile qualified. Only; present if "".value_kind"" is; ""global_buffer"". "".is_pipe"" boolean Indicates if the kernel argument; is pipe qualified. Only present; if "".value_kind"" is ""pipe"". .. TODO::. Can ""global_buffer"" be pipe; qualified?. ====================== ============== ========= ================================. .. _amdgpu-amdhsa-code-object-metadata-v4:. Code Object V4 Metadata; +++++++++++++++++++++++. . warning::; Code object V4 is not the default code object version emitted by this version; of LLVM. Code object V4 metadata is the same as; :ref:`amdgpu-amdhsa-code-object-metadata-v3` wi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:140078,access,access,140078,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"natural semantics of value propagation, where; all basic operations on the type come down to copies and destroys,; and everything else is just an optimization on top of those. The most glaring weakness of programming with non-trivial types in C; is that there are no language mechanisms (akin to C++'s placement; ``new`` and explicit destructor calls) for explicitly creating and; destroying objects. Clang should consider adding builtins for this; purpose, as well as for common optimizations like destructive; relocation. Application of the formal C rules to nontrivial ownership qualifiers; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Nontrivially ownership-qualified types are considered non-trivial; to copy, destroy, and default-initialize. A dynamic object of nontrivially ownership-qualified type contingently; exists at a location if the memory is filled with a zero pattern, e.g.; by ``calloc`` or ``bzero``. Such an object can be safely accessed in; all of the cases above, but its memory can also be safely repurposed.; Assigning a null pointer into an l-value of ``__weak`` or; ``__strong``-qualified type accesses the dynamic object there (and thus; may have undefined behavior if no such object exists), but afterwards; the object's memory is guaranteed to be filled with a zero pattern; and thus may be either further accessed or repurposed as needed.; The upshot is that programs may safely initialize dynamically-allocated; memory for nontrivially ownership-qualified types by ensuring it is zero-initialized, and they may safely deinitialize memory before; freeing it by storing ``nil`` into any ``__strong`` or ``__weak``; references previously created in that memory. C/C++ compatibility for structs and unions with non-trivial members; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Structs and unions with non-trivial members are compatible in; different language modes (e.g. between Objective-C and Objective-C++,; or between AR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:60118,access,accessed,60118,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['accessed']
Security,"nch->Fill();; }; t3->Write("""",TObject::kOverwrite); // save only the new version of; // the tree; }; ```. Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the fri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:52857,access,access,52857,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['access']
Security,"ncorrect example for ill-formed non-type template arguments; Clang 17. 2651; C++23; Conversion function templates and ""noexcept""; Unknown. 2652; C++23; Overbroad definition of __STDCPP_BFLOAT16_T__; Unknown. 2653; C++23; Can an explicit object parameter have a default argument?; Clang 18. 2654; C++23; Un-deprecation of compound volatile assignments; Clang 16. 2655; NAD; Instantiation of default arguments in lambda-expressions; Unknown. 2656; drafting; Converting consteval lambda to function pointer in non-immediate context; Not resolved. 2657; tentatively ready; Cv-qualification adjustment when binding reference to temporary; Unknown. 2658; C++23; Trivial copying of unions in core constant expressions; Unknown. 2659; C++23; Missing feature-test macro for lifetime extension in range-for loop; Unknown. 2660; open; Confusing term ""this parameter""; Not resolved. 2661; open; Missing disambiguation rule for pure-specifier vs. brace-or-equal-initializer; Not resolved. 2662; C++23; Example for member access control vs. overload resolution; Unknown. 2663; DRWP; Example for member redeclarations with using-declarations; Unknown. 2664; C++23; Deduction failure in CTAD for alias templates; Unknown. 2665; NAD; Replacing a subobject with a complete object; Unknown. 2666; open; Lifetime extension through static_cast; Not resolved. 2667; C++23; Named module imports do not import macros; Unknown. 2668; tentatively ready; co_await in a lambda-expression; Unknown. 2669; open; Lifetime extension for aggregate initialization; Not resolved. 2670; open; Programs and translation units; Not resolved. 2671; open; friend named by a template-id; Not resolved. 2672; DR; Lambda body SFINAE is still required, contrary to intent and note; Clang 18. 2673; C++23; User-declared spaceship vs. built-in operators; Unknown. 2674; C++23; Prohibit explicit object parameters for constructors; Unknown. 2675; open; start_lifetime_as, placement-new, and active union members; Not resolved. 2676; open; Replacing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:183650,access,access,183650,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"nd does not contain `gSystem->ProcessEvents()` calls, two method are available. ### Asynchronous timer. The first method is to configure an asynchronous timer for the server, like for example:. ```cpp; serv->SetTimer(100, kFALSE);; ```. Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of **`TH1::Fill()`** calls and an histogram object may be incomplete. Therefore such method is not recommended. ### Regular calls of THttpServer::ProcessRequests() method. The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:. ```cpp; serv->ProcessRequests();; ```. In such case, one can fully disable the timer of the server:. ```cpp; serv->SetTimer(0, kTRUE);; ```. ## Data access from command shell. The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts. If one starts a server and register an object like for example:. ```cpp; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; ```. One could request a JSON representation of such object with the command:. ```bash; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json; ```. Then, its representation will look like:. ```json; {; ""_typename"" : ""TNamed"",; ""fUniqueID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; ```. The following requests can be performed:. | Name | Description |; | :----------- | :---------------- |; | `root.bin` | binary data produced by object streaming with `TBufferFile` |; | `root.json` | ROOT JSON representation for object and objec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:14371,access,access,14371,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['access']
Security,"nd involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; WGP. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations.; Completion of load/store/sample operations are reported to a wavefront in; execution order of other load/store/sample operations performed by that; wavefront.; * The vector memory operations access a vector L0 cache. There is a single L0; cache per CU. Each SIMD of a CU accesses the same L0 cache. Therefore, no; special action is required for coherence between the lanes of a single; wavefront. However, a ``buffer_gl0_inv`` is required for coherence between; wavefronts executing in the same work-group as they may be executing on SIMDs; of different CUs that access different L0s. A ``buffer_gl0_inv`` is also; required for coherence between wavefronts executing in different work-groups; as they may be executing on different WGPs.; * The scalar memory operations access a scalar L0 cache shared by all wavefronts; on a WGP. The scalar and vector L0 caches are not coherent. However, scalar; operations are used in a restricted way so do not impact the memory model. See; :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory L0 caches use an L1 cache shared by all WGPs on; the same SA. Therefore, no special action is required for coherence between; the wavefronts of a single work-group. However, a ``buffer_gl1_inv`` is; required for coherence between ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:336856,access,accesses,336856,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"nd is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a startin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2120,expose,exposes,2120,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['expose'],['exposes']
Security,nd new-expressions; N/A. 131; TC1; Typo in Lao characters; Superseded by P1949. 132; NAD; Local types and linkage; No. 133; dup; Exception specifications and checking; Duplicate of 87. 134; TC1; Template classes and declarator-ids; N/A. 135; TC1; Class type in in-class member function definitions; Yes. 136; CD1; Default arguments and friend declarations; Clang 3.4. 137; TC1; static_cast of cv void*; Yes. 138; CD6; Friend declaration name lookup; Unknown. 139; CD1; Error in friend lookup example; Yes. 140; CD1; Agreement of parameter declarations; Yes. 141; CD1; Non-member function templates in member access expressions; Clang 3.1. 142; TC1; Injection-related errors in access example; Clang 2.8. 143; CD1; Friends and Koenig lookup; Yes. 144; open; Position of friend specifier; Not resolved. 145; TC1; Deprecation of prefix ++; Yes. 146; open; Floating-point zero; Not resolved. 147; TC1; Naming the constructor; Yes. 148; TC1; POD classes and pointers to members; Yes. 149; TC1; Accessibility and ambiguity; N/A. 150; C++17; Template template parameters and default arguments; Unknown. 151; TC1; Terminology of zero-initialization; Clang 3.1. 152; TC1; explicit copy constructors; Yes. 153; TC1; Misleading wording (rank of conversion); N/A. 154; NAD; Anonymous unions in unnamed namespaces; Yes. 155; dup; Brace initializer for scalar; Duplicate of 632. 156; NAD; Name lookup for conversion functions; Unknown. 157; open; Omitted typedef declarator; Not resolved. 158; CD1; Aliasing and qualification conversions; Yes. 159; TC1; Namespace qualification in declarators; Clang 3.5. 160; CD1; Missing std:: qualification; N/A. 161; TC1; Access to protected nested type; Clang 3.1. 162; CD1; (&C::f)() with nonstatic members; No. 163; TC1; Description of subaggregate initializer; N/A. 164; TC1; Overlap between Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static f,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:10294,Access,Accessibility,10294,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Accessibility']
Security,"nd one to track how many times a; ""false"" branch condition is taken. There are two differences between versions 4 and 3:. * Function records are now named symbols, and are marked *linkonce_odr*. This; allows linkers to merge duplicate function records. Merging of duplicate; *dummy* records (emitted for functions included-but-not-used in a translation; unit) reduces size bloat in the coverage mapping data. As part of this; change, region mapping information for a function is now included within the; function record, instead of being affixed to the coverage header. * The filename list for a translation unit may optionally be zlib-compressed. The only difference between versions 3 and 2 is that a special encoding for; column end locations was introduced to indicate gap regions. In version 1, the function record for *foo* was defined as follows:. .. code-block:: llvm. { i8*, i32, i32, i64 } { i8* getelementptr inbounds ([3 x i8]* @__profn_foo, i32 0, i32 0), ; Function's name; i32 3, ; Function's name length; i32 9, ; Function's encoded coverage mapping data string length; i64 0 ; Function's structural hash; }. In version 2, the function record for *foo* was defined as follows:. .. code-block:: llvm. { i64, i32, i64 } {; i64 0x5cf8c24cdb18bdac, ; Function's name MD5; i32 9, ; Function's encoded coverage mapping data string length; i64 0 ; Function's structural hash. Coverage Mapping Header:; ------------------------. As shown above, the coverage mapping header has the following fields:. * The number of function records affixed to the coverage header. Always 0, but present for backwards compatibility. * The length of the string in the third field of *__llvm_coverage_mapping* that contains the encoded translation unit filenames. * The length of the string in the third field of *__llvm_coverage_mapping* that contains any encoded coverage mapping data affixed to the coverage header. Always 0, but present for backwards compatibility. * The format version. The current version",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst:17084,hash,hash,17084,interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CoverageMappingFormat.rst,1,['hash'],['hash']
Security,"nd strings, and; possibly to find the base address of a subprogram’s call frame or the return; address of a subprogram. Furthermore, to meet the needs of recent computer; architectures and optimization techniques, debugging information must be able to; describe the location of an object whose location changes over the object’s; lifetime, and may reside at multiple locations simultaneously during parts of an; object's lifetime.*. Information about the location of program objects is provided by location; descriptions. Location descriptions can consist of one or more single location descriptions. A single location description specifies the location storage that holds a; program object and a position within the location storage where the program; object starts. The position within the location storage is expressed as a bit; offset relative to the start of the location storage. A location storage is a linear stream of bits that can hold values. Each; location storage has a size in bits and can be accessed using a zero-based bit; offset. The ordering of bits within a location storage uses the bit numbering; and direction conventions that are appropriate to the current language on the; target architecture. There are five kinds of location storage:. *memory location storage*; Corresponds to the target architecture memory address spaces. *register location storage*; Corresponds to the target architecture registers. *implicit location storage*; Corresponds to fixed values that can only be read. *undefined location storage*; Indicates no value is available and therefore cannot be read or written. *composite location storage*; Allows a mixture of these where some bits come from one location storage and; some from another location storage, or from disjoint parts of the same; location storage. .. note::. It may be better to add an implicit pointer location storage kind used by the; ``DW_OP_implicit_pointer`` and ``DW_OP_LLVM_aspace_implicit_pointer``; operations. It would specify",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:57944,access,accessed,57944,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessed']
Security,"nd which members; are re-implemented, which files get indirectly included by including the class's; header, and which libraries this class depends on. The remainder of the page contains; the functions' documentation. And there is a little tool box floating around, which; gives you some display options and a link to this help page. We will now go through all these parts in detail. Link Box; On the top of the page you can find a list of links. The first line contains the current; ""location"", giving the home page, the module name, and the class name.; The second line links to generic pages, like ROOT's home page, the; Class Index, and the Class Hierarchy.; The last line allows you to jump to the sections of the current page and a colored; version of the class's header and source file. Info Box; There is a little info box, usually floating on the right side of the page; (update your browser if it's not). It shows the name of the class you are currently; looking at, which library you have to link against to get access to the class, and; which header file you have to #include. It also contains options that influence how; the list of members is displayed. you can show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. The two links in the bottom of the box get you to the top of the page and to this help; page. You can hide the info box by clicking on the little ""-"" in the top right corner; of the box, and show it again by clicking on the ""+"". List of Data and Function Members; The cent",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:3731,access,access,3731,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,2,['access'],['access']
Security,"nd, which; gives you some display options and a link to this help page. We will now go through all these parts in detail. Link Box; On the top of the page you can find a list of links. The first line contains the current; ""location"", giving the home page, the module name, and the class name.; The second line links to generic pages, like ROOT's home page, the; Class Index, and the Class Hierarchy.; The last line allows you to jump to the sections of the current page and a colored; version of the class's header and source file. Info Box; There is a little info box, usually floating on the right side of the page; (update your browser if it's not). It shows the name of the class you are currently; looking at, which library you have to link against to get access to the class, and; which header file you have to #include. It also contains options that influence how; the list of members is displayed. you can show or hide non-public methods. If you; just want to use ROOT you should hide them - you cannot access protected or private; members anyway. And you can select whether member that are inherited from a base class; should be shown. Again, if you just want to use ROOT you should probably show them,; as you often want to use them whether they are defined in the current class or in one; of its base classes. Whatever you set these options to should be stored in a cookie,; so you will have the same setting next time you look at the class documentation. The two links in the bottom of the box get you to the top of the page and to this help; page. You can hide the info box by clicking on the little ""-"" in the top right corner; of the box, and show it again by clicking on the ""+"". List of Data and Function Members; The central part of a class are its members. Some are available to you; some; are hidden from you, because they are only meant to be used internally.; As an example, a class might allow you to set, access, and print its values, or store; them into a file.; Because metho",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:3981,access,access,3981,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,2,['access'],['access']
Security,"nd:. .. code-block:: c. ^ { printf(""hello world\n""); }. are exactly equivalent constructs for the same expression. The type_expression extends C expression parsing to accommodate Block; reference declarations as it accommodates function pointer; declarations. Given:. .. code-block:: c. typedef int (*pointerToFunctionThatReturnsIntWithCharArg)(char);; pointerToFunctionThatReturnsIntWithCharArg functionPointer;; ^ pointerToFunctionThatReturnsIntWithCharArg (float x) { return functionPointer; }. and:. .. code-block:: c. ^ int ((*)(float x))(char) { return functionPointer; }. are equivalent expressions, as is:. .. code-block:: c. ^(float x) { return functionPointer; }. [returnfunctionptr.c]. The compound statement body establishes a new lexical scope within; that of its parent. Variables used within the scope of the compound; statement are bound to the Block in the normal manner with the; exception of those in automatic (stack) storage. Thus one may access; functions and global variables as one would expect, as well as static; local variables. [testme]. Local automatic (stack) variables referenced within the compound; statement of a Block are imported and captured by the Block as const; copies. The capture (binding) is performed at the time of the Block; literal expression evaluation. The compiler is not required to capture a variable if it can prove; that no references to the variable will actually be evaluated.; Programmers can force a variable to be captured by referencing it in a; statement at the beginning of the Block, like so:. .. code-block:: c. (void) foo;. This matters when capturing the variable has side-effects, as it can; in Objective-C or C++. The lifetime of variables declared in a Block is that of a function;; each activation frame contains a new copy of variables declared within; the local scope of the Block. Such variable declarations should be; allowed anywhere [testme] rather than only when C99 parsing is; requested, including for statements. [testme]",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst:4420,access,access,4420,interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BlockLanguageSpec.rst,1,['access'],['access']
Security,"ndation.CFNumber; (C); Check for improper uses of CFNumberCreate. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. osx.coreFoundation.CFRetainRelease; (C); Check for null arguments to CFRetain, CFRelease,; CFMakeCollectable. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. osx.coreFoundation.containers.OutOfBounds; (C); Checks for index out-of-bounds when using CFArray API. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. osx.coreFoundation.containers.PointerSizedValues; (C); Warns if CFArray, CFDictionary, CFSet are; created with non-pointer-size values. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void **)x, 1,; &kCFTypeArrayCallBacks); // warn; }. Security Checkers. Name, DescriptionExample. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.inse",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:21039,secur,security,21039,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['secur'],['security']
Security,"ndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79234,sanitiz,sanitize-stats,79234,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize-stats']
Security,"ndex; ``di_index`` and returns the ``base`` address.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide union debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``type`` is the same as the ``base`` type. Arguments:; """""""""""""""""""". The ``base`` is the union base address. The ``di_index`` is the field index in debuginfo. Semantics:; """""""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic returns the ``base`` address. '``llvm.preserve.struct.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.struct.access.index.p0i8.p0s_struct.anon.0s(<type> base,; i32 gep_index,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.struct.access.index``' intrinsic returns the getelementptr address; based on struct base ``base`` and IR struct member index ``gep_index``.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide struct debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``ret_type`` is a pointer type to the structure member. Arguments:; """""""""""""""""""". The ``base`` is the structure base address. The ``gep_index`` is the struct member index; based on IR structures. The ``di_index`` is the struct member index based on debuginfo. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.struct.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{0, gep_index}``. '``llvm.fptrunc.round``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare <ty2>; @llvm.fptrunc.round(<type> <value>, metadata <rounding m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:975304,access,access,975304,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,nding via conversion function; Unknown. 1572; CD4; Incorrect example for rvalue reference binding via conversion function; Unknown. 1573; CD4; Inherited constructor characteristics; Clang 3.9. 1574; NAD; Explicitly-defaulted constexpr functions in wrapper templates; Unknown. 1575; C++14; Incorrect definition of “strict pointer safety”; Unknown. 1576; C++14; Discarded-value volatile xvalues; Unknown. 1577; NAD; Unnecessary restrictions on partial specializations; Unknown. 1578; NAD; Value-initialization of aggregates; Unknown. 1579; C++14; Return by converting move constructor; Clang 3.9. 1580; drafting; Default arguments in explicit instantiations; Not resolved. 1581; CD5; When are constexpr member functions defined?; Unknown. 1582; drafting; Template default arguments and deduction failure; Not resolved. 1583; C++14; Incorrect example of unspecified behavior; Unknown. 1584; drafting; Deducing function types from cv-qualified types; Not resolved. 1585; NAD; Value category of member access of rvalue reference member; Unknown. 1586; NAD; Naming a destructor via decltype; Unknown. 1587; C++14; constexpr initialization and nested anonymous unions; Unknown. 1588; CD3; Deducing cv-qualified auto; Unknown. 1589; CD4; Ambiguous ranking of list-initialization sequences; Clang 3.7 (C++11 onwards). 1590; CD4; Bypassing non-copy/move constructor copying; Unknown. 1591; CD4; Deducing array bound and element type from initializer list; Unknown. 1592; C++14; When do template parameters match?; Unknown. 1593; C++14; “Parameter type” of special member functions; Unknown. 1594; drafting; Lazy declaration of special members vs overload errors; Not resolved. 1595; C++14; Constructors “involved in” subobject initialization; Unknown. 1596; CD4; Non-array objects as array[1]; Unknown. 1597; CD3; Misleading constexpr example; Unknown. 1598; C++14; Criterion for equality of pointers to members; Unknown. 1599; CD4; Lifetime of initializer_list underlying array; Unknown. 1600; CD4; Erroneous ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:106950,access,access,106950,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"nds for each memory; operand of this form. This means that the ""load"" form of '``mov``' has the; following ``MachineOperand``\s in this order:. ::. Index: 0 | 1 2 3 4 5; Meaning: DestReg, | BaseReg, Scale, IndexReg, Displacement Segment; OperandTy: VirtReg, | VirtReg, UnsImm, VirtReg, SignExtImm PhysReg. Stores, and all other instructions, treat the four memory operands in the same; way and in the same order. If the segment register is unspecified (regno = 0),; then no segment override is generated. ""Lea"" operations do not have a segment; register specified, so they only have 4 operands for their memory reference. X86 address spaces supported; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. x86 has a feature which provides the ability to perform loads and stores to; different address spaces via the x86 segment registers. A segment override; prefix byte on an instruction causes the instruction's memory access to go to; the specified segment. LLVM address space 0 is the default address space, which; includes the stack, and any unqualified memory accesses in a program. Address; spaces 1-255 are currently reserved for user-defined code. The GS-segment is; represented by address space 256, the FS-segment is represented by address space; 257, and the SS-segment is represented by address space 258. Other x86 segments; have yet to be allocated address space numbers. While these address spaces may seem similar to TLS via the ``thread_local``; keyword, and often use the same underlying hardware, there are some fundamental; differences. The ``thread_local`` keyword applies to global variables and specifies that they; are to be allocated in thread-local memory. There are no type qualifiers; involved, and these variables can be pointed to with normal pointers and; accessed with normal loads and stores. The ``thread_local`` keyword is; target-independent at the LLVM IR level (though LLVM doesn't yet have; implementations of it for some configurations). Special address spaces, in contrast, apply to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:92089,access,accesses,92089,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accesses']
Security,"ne``, ``getw``, ``memcmp``,; ``memcpy``, ``memmem``, ``memmove``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72825,secur,security,72825,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"ned **`TMatrixDSym`**. The assignment operator behaves somewhat; different than of most other classes. The following lines will result in; an error:. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; ```. It required to first resize matrix b to the shape of `a`. ``` {.cpp}; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; ```. ## Matrix Properties. A matrix has five properties, which are all set in the constructor:. - `precision` - float or double. In the first case you will use the; **`TMatrixF`** class family, in the latter case the **`TMatrixD`**; one;. - `type` - general (**`TMatrixD`**), symmetric (**`TMatrixDSym`**) or; sparse (**`TMatrixDSparse`**);. - `size` - number of rows and columns;. - `index` - range start of row and column index. By default these; start at zero;. - `sparse` `map` - this property is only relevant for a sparse matrix.; It indicates where elements are unequal zero. ### Accessing Properties. The following table shows the methods to access the information about; the relevant matrix property:. +-----------------------------+----------------------------------------------+; | Method | Descriptions |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowLwb` `()` | row lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowUpb` `()` | row upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNrows` `()` | number of rows |; +-----------------------------+----------------------------------------------+; | `Int_t GetColLwb` `()` | column lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetColUpb` `()` | column upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNcols` `()` | number of columns |; +-----------------------------+-------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:3532,access,access,3532,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['access'],['access']
Security,"ned the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310114,access,accesses,310114,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security,"needed by the main macro file. The list is comma-separated; and the first file is considered as the main one. For example.        ; proof->Load(""<macropath>/mymacro.C+,<thispath>/thisheader.h,<thatpath>/thatheader.h""). will make sure that the files 'thisheader.h' and 'thatheader.h', needed; by 'mymacro.C' are available in the sandbox on the worker machines.; Note that 'thisheader.h' and 'thatheader.h' will be available remotely; in the sandbox, as 'mymacro.C'; so they should be included directly by; 'mymacro.C', e.g. '#include ""thisheader.h""' .; Import the dataset stager daemon 'afdsmgrd' into ROOT; this is used; to manage data staging based on the dataset information (see; http://code.google.com/p/afdsmgrd/ for more info). The daemon is; located under $ROOTSYS/proof/afdsmgrd .; New PROOF bench suite, a framework to run CPU and IO benchmarks with; default selectors/data or with user-provided ones. The code is located; under proof/proofbench.; Add the possibility to access the files on the workers via the same; port used by PROOF. This is useful for cases when it is not possible to; start a file server daemon on a different port (because, for eample, of; a firewall or just inconvenience) and workers do not share a file; system. Internally this works by forking a 'rootd' after identifying a; file request and trasferring the connection to it. The client side is a; TNetFile and it is triggered by the protocol ""rootd://"" (the just; implemented etc/plugins/TFile/P120_TNetFile.C includes this; protocol).; Add support for log file truncation. Truncation is disabled by; default. Enabling is controlled by the rootrc variable.           ; ProofServ.LogFileMaxSize  ; {<bytes>|<kilobytes>K|<megabytes>M|<gigabytes>G}.  indicating the max number of bytes. The number can be followed by; a {K,M,G} to indicate KBytes, MBytes or GBytes, respectively.; Add new derivation of TList (TProofOutputList) to be used on the; PROOF client to filter out PROOF internal objects when displaying or;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html:1093,access,access,1093,proof/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v530/index.html,2,['access'],['access']
Security,"neously, as long as no two threads operate on entities within the; same context. In practice, very few places in the API require the explicit specification of a; ``LLVMContext``, other than the ``Type`` creation/lookup APIs. Because every; ``Type`` carries a reference to its owning context, most other entities can; determine what context they belong to by looking at their own ``Type``. If you; are adding new entities to LLVM IR, please try to maintain this interface; design. .. _jitthreading:. Threads and the JIT; -------------------. LLVM's ""eager"" JIT compiler is safe to use in threaded programs. Multiple; threads can call ``ExecutionEngine::getPointerToFunction()`` or; ``ExecutionEngine::runFunction()`` concurrently, and multiple threads can run; code output by the JIT concurrently. The user must still ensure that only one; thread accesses IR in a given ``LLVMContext`` while another thread might be; modifying it. One way to do that is to always hold the JIT lock while accessing; IR outside the JIT (the JIT *modifies* the IR by adding ``CallbackVH``\ s).; Another way is to only call ``getPointerToFunction()`` from the; ``LLVMContext``'s thread. When the JIT is configured to compile lazily (using; ``ExecutionEngine::DisableLazyCompilation(false)``), there is currently a `race; condition <https://bugs.llvm.org/show_bug.cgi?id=5184>`_ in updating call sites; after a function is lazily-jitted. It's still possible to use the lazy JIT in a; threaded program if you ensure that only one thread at a time can call any; particular lazy stub and that the JIT lock guards any IR access, but we suggest; using only the eager JIT in threaded programs. .. _advanced:. Advanced Topics; ===============. This section describes some of the advanced or obscure API's that most clients; do not need to be aware of. These API's tend manage the inner workings of the; LLVM system, and only need to be accessed in unusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ----------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:124554,access,accessing,124554,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessing']
Security,"nfolding the load or paying some other high; cost. To understand how this works in practice, we need to examine the exact; semantics of the x86 addressing modes which, in its fully general form, looks; like `(%base,%index,scale)offset`. Here `%base` and `%index` are 64-bit; registers that can potentially be any value, and may be attacker controlled,; and `scale` and `offset` are fixed immediate values. `scale` must be `1`, `2`,; `4`, or `8`, and `offset` can be any 32-bit sign extended value. The exact; computation performed to find the address is then: `%base + (scale * %index) +; offset` under 64-bit 2's complement modular arithmetic. One issue with this approach is that, after hardening, the `%base + (scale *; %index)` subexpression will compute a value near zero (`-1 + (scale * -1)`) and; then a large, positive `offset` will index into memory within the first two; gigabytes of address space. While these offsets are not attacker controlled,; the attacker could chose to attack a load which happens to have the desired; offset and then successfully read memory in that region. This significantly; raises the burden on the attacker and limits the scope of attack but does not; eliminate it. To fully close the attack we must work with the operating system; to preclude mapping memory in the low two gigabytes of address space. ###### 64-bit load checking instructions. We can use the following instruction sequences to check loads. We set up `%r8`; in these examples to hold the special value of `-1` which will be `cmov`ed over; `%rax` in misspeculated paths. Single register addressing mode:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; orq %rax, %rsi # Mask the pointer if misspeculating.; movl (%rsi), %edi; ```. Two register addressing mode:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; orq %rax, %rsi # Mask the pointer if misspeculating.; orq %rax, %rcx # Mask the index if misspeculating.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:28730,attack,attacker,28730,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,3,['attack'],"['attack', 'attacker']"
Security,"ng Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if any) an issue is relevant to security, and determine if it is a security issue.; * Negotiate an embargo date for public disclosure, with a default minimum time limit of ninety days.; * Security Group members can recommend that key experts be pulled in to specific issue discussions. The key expert can be pulled in unless there are objections from other Security Group members.; * Patches are written and reviewed.; * Backporting security patches from recent versions to old versions cannot always work. It is up to the Security Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:12530,secur,security,12530,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,2,['secur'],['security']
Security,"ng a large register set before and after the call in the caller. If; the arguments are passed in callee-saved registers, then they will be; preserved by the callee across the call. This doesn't apply for values; returned in callee-saved registers. - On X86-64 the callee preserves all general purpose registers, except for; R11. R11 can be used as a scratch register. Furthermore it also preserves; all floating-point registers (XMMs/YMMs). - On AArch64 the callee preserve all general purpose registers, except X0-X8; and X16-X18. Furthermore it also preserves lower 128 bits of V8-V31 SIMD -; floating point registers. The idea behind this convention is to support calls to runtime functions; that don't need to call out to any other functions. This calling convention, like the `PreserveMost` calling convention, will be; used by a future version of the ObjectiveC runtime and should be considered; experimental at this time.; ""``cxx_fast_tlscc``"" - The `CXX_FAST_TLS` calling convention for access functions; Clang generates an access function to access C++-style TLS. The access; function generally has an entry block, an exit block and an initialization; block that is run at the first time. The entry and exit blocks can access; a few TLS IR variables, each access will be lowered to a platform-specific; sequence. This calling convention aims to minimize overhead in the caller by; preserving as many registers as possible (all the registers that are; preserved on the fast path, composed of the entry and exit blocks). This calling convention behaves identical to the `C` calling convention on; how arguments and return values are passed, but it uses a different set of; caller/callee-saved registers. Given that each platform has its own lowering sequence, hence its own set; of preserved registers, we can't use the existing `PreserveMost`. - On X86-64 the callee preserves all general purpose registers, except for; RDI and RAX.; ""``tailcc``"" - Tail callable calling convention; This call",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:19944,access,access,19944,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,3,['access'],['access']
Security,"ng around `RVec` objects. `RVecN<T, N>`; It aggregates `RVecImpl` and `SmallVectorStorage` (see below) through public inheritance.; `N` is the small buffer size. `RVec<T>`; Inherits from `RVecN` and fixes the small buffer size `N` to a reasonable default.; We expect most users to use this type and only very rarely switch to `RVecN` to tweak the small buffer size. ### Helper types. - `SmallVectorAlignmentAndSize`: used to figure out the offset of the first small-buffer element in; `SmallVectorTemplateCommon::getFirstEl`; - `SmallVectorStorage`: properly aligned ""small buffer"" storage. It's a separate type so that it can be specialized to; be properly aligned also for the case of small buffer size = 0; - `RVecInlineStorageSize`: calculates the size of the small buffer in `RVec`. ## Memory adoption. We need RVec to be able to act as a view over an existing buffer rather than use its own; to save copies and allocations when reading ROOT data into `RVec`s, e.g. in `RDataFrame`. The feature is exposed via a dedicated constructor: `RVec(pointer, size)`.; `RVec` then switches to its own storage as soon as a resize is requested.; `fCapacity == -1` indicates that we are in ""memory adoption mode"". ## Exception safety guarantees. As per [its docs](https://llvm.org/doxygen/classllvm_1_1SmallVector.html), LLVM's; `SmallVector` implementation ""does not attempt to be exception-safe"".; In its current implementation, `RVec` does not attempt to fix that.; This should not be a problem for `RVec`'s usecases (an exception thrown during; construction of an `RVec` typically means there is a bug to fix in the analysis code),; and we expect to be able to revisit the implementation and fix broken behavior if it; ever turns out to be problematic. Relevant discussion on GitHub:. - https://github.com/root-project/root/pull/7502#issuecomment-818864506; - https://github.com/root-project/root/pull/7502#issuecomment-818905333; - https://github.com/root-project/root/pull/7502#issuecomment-821054757. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md:4282,expose,exposed,4282,math/vecops/ARCHITECTURE.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/ARCHITECTURE.md,1,['expose'],['exposed']
Security,"ng as little memory as; possible. Most often checking the 32 bit hash values is as far as the lookup; goes. If it does match, it usually is a match with no collisions. So for a; table with ""``n_buckets``"" buckets, and ""``n_hashes``"" unique 32 bit hash; values, we can clarify the contents of the ``BUCKETS``, ``HASHES`` and; ``OFFSETS`` as:. .. code-block:: none. .-------------------------.; | HEADER.magic | uint32_t; | HEADER.version | uint16_t; | HEADER.hash_function | uint16_t; | HEADER.bucket_count | uint32_t; | HEADER.hashes_count | uint32_t; | HEADER.header_data_len | uint32_t; | HEADER_DATA | HeaderData; |-------------------------|; | BUCKETS | uint32_t[n_buckets] // 32 bit hash indexes; |-------------------------|; | HASHES | uint32_t[n_hashes] // 32 bit hash values; |-------------------------|; | OFFSETS | uint32_t[n_hashes] // 32 bit offsets to hash value data; |-------------------------|; | ALL HASH DATA |; `-------------------------'. So taking the exact same data from the standard hash example above we end up; with:. .. code-block:: none. .------------.; | HEADER |; |------------|; | 0 | BUCKETS[0]; | 2 | BUCKETS[1]; | 5 | BUCKETS[2]; | 6 | BUCKETS[3]; | | ...; | ... | BUCKETS[n_buckets]; |------------|; | 0x........ | HASHES[0]; | 0x........ | HASHES[1]; | 0x........ | HASHES[2]; | 0x........ | HASHES[3]; | 0x........ | HASHES[4]; | 0x........ | HASHES[5]; | 0x12345678 | HASHES[6] hash for BUCKETS[3]; | 0x29273623 | HASHES[7] hash for BUCKETS[3]; | 0x82638293 | HASHES[8] hash for BUCKETS[3]; | 0x........ | HASHES[9]; | 0x........ | HASHES[10]; | 0x........ | HASHES[11]; | 0x........ | HASHES[12]; | 0x........ | HASHES[13]; | 0x........ | HASHES[n_hashes]; |------------|; | 0x........ | OFFSETS[0]; | 0x........ | OFFSETS[1]; | 0x........ | OFFSETS[2]; | 0x........ | OFFSETS[3]; | 0x........ | OFFSETS[4]; | 0x........ | OFFSETS[5]; | 0x000034f0 | OFFSETS[6] offset for BUCKETS[3]; | 0x00003500 | OFFSETS[7] offset for BUCKETS[3]; | 0x00003550 | OFFSETS[8] off",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:64481,hash,hash,64481,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"ng id x = p->ivar;``, ARC must not; move the release of ``p`` to between the load of ``p->ivar`` and the; retain of that value for storing into ``x``. Dependency does not propagate through stores of dependent pointer; values because doing so would allow dependency to outlive the; full-expression which produced the original value. For example, the; address of an instance variable could be written to some global; location and then freely accessed during the lifetime of the local,; or a function could return an inner pointer of an object and store; it to a local. These cases would be potentially impossible to; reason about and so would basically prevent any optimizations based; on imprecise lifetime. There are also uncommon enough to make it; reasonable to require the precise-lifetime annotation if someone; really wants to rely on them. Dependency does propagate through return values of pointer type.; The compelling source of need for this rule is a property accessor; which returns an un-autoreleased result; the calling function must; have the chance to operate on the value, e.g. to retain it, before; ARC releases the original pointer. Note again, however, that; dependence does not survive a store, so ARC does not guarantee the; continued validity of the return value past the end of the; full-expression. .. _arc.optimization.object_lifetime:. No object lifetime extension; ----------------------------. If, in the formal computation history of the program, an object ``X``; has been deallocated by the time of an observable side-effect, then; ARC must cause ``X`` to be deallocated by no later than the occurrence; of that side-effect, except as influenced by the re-ordering of the; destruction of objects. .. admonition:: Rationale. This rule is intended to prohibit ARC from observably extending the; lifetime of a retainable object, other than as specified in this; document. Together with the rule limiting the transformation of; releases, this rule requires ARC to eliminate r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:82036,access,accessor,82036,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['accessor']
Security,"ng of wild cards in the dataset manager; for; example, issuing a GetDataSet(...) on a dataset URI containign wild; cards will return a grand dataset sum of all the datasets matching the; URI.; Add options to get a list of all dataset registered names; from ScanDataSets (option kList; the result is a TMap of {TObjString,; TObjString} with the second TObjString empty).Improved version of the PQ2 scripts; the scripts now invoke a dedicated ROOT application (named pq2) available under $ROOTSYS/bin .Add; support for recursive reading of group config files via the 'include; sub-file' directive. This allows to have a common part and, for; example, customize differently the quotas.Fix an issue with TTreeFriends. New tutorial showing how to use friends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:5884,validat,validation,5884,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['validat'],['validation']
Security,"ng on different SAs that access different L1s.; * The L1 caches have independent quadrants to service disjoint ranges of virtual; addresses.; * Each L0 cache has a separate request queue per L1 quadrant. Therefore, the; vector and scalar memory operations performed by different wavefronts, whether; executing in the same or different work-groups (which may be executing on; different CUs accessing different L0s), can be reordered relative to each; other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is required to ensure; synchronization between vector memory operations of different wavefronts. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L1 caches use an L2 cache shared by all SAs on the same agent.; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each L1 quadrant of a single SA accesses a different L2 channel. Each L1; quadrant has a separate request queue per L2 channel. Therefore, the vector; and scalar memory operations performed by wavefronts executing in different; work-groups (which may be executing on different SAs) of an agent can be; reordered relative to each other. A ``s_waitcnt vmcnt(0) & vscnt(0)`` is; required to ensure synchronization between vector memory operations of; different SAs. It ensures a previous vector memory operation has completed; before executing a subsequent vector memory and so can be used to meet the; requirements of acquire, release and sequential consistency.; * The L2 cache can be kept coherent with other agents on some targets, or ranges; of virtual addresses can be set up to bypass it to ensure system coherence.; * On GFX10.3 and GFX11 a memory attached last level (MALL) cache exists for GPU memory.; The MALL cache is fully coherent with GPU memory and has no impact on system; coherence. All agents (GPU and CPU) access",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:338931,access,accesses,338931,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"ng the; Geometry""). If tracking is performed using `TGeo`, the folder; `Tracks` might contain user-defined tracks that can be; visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in; the geometrical hierarchy, we will focus on the last two displayed items; `TOP `and `TOP_1`. These are the top volume and the corresponding top; node in the hierarchy. Double clicking on the `TOP` volume will unfold all different volumes; contained by the top volume. In the right panel, we will see all the; volumes contained by `TOP` (if the same is positioned 4 times we will; get 4 identical items). This rule will apply to any clicked volume in; the hierarchy. Note that right clicking a volume item activates the; volume context menu containing several specific methods. We will call; the volume hierarchy developed in this way as the; `logical geometry graph`. The volume objects are nodes inside this graph; and the same volume can be accessed starting from different branches. On the other hand, the real geometrical objects that are seen when; visualizing or tracking the geometry are depicted in the `TOP_1` branch.; These are the nodes of the `physical` `tree` of positioned volumes; represented by TGeoNode objects. This hierarchy is a tree since a; node can have only one parent and several daughters. For a better; understanding of the hierarchy, have a look at TGeoManage. Just close now the `X3D` window and focus at the wire frame picture; drawn in a pad. Activate Options/Event Status. Moving the mouse in the; pad, you will notice that objects are sometimes changing color to red.; Volumes are highlighted in this way whenever the mouse pointer is close; enough to one of its vertices. When this happens, the corresponding; volume is selected and you will see in the bottom right size of the %ROOT; canvas its name, shape type and corresponding path in the physical tree.; Right clicking on the screen when",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:12968,access,accessed,12968,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['accessed']
Security,"ng to the first data record, the byte offset; relative to the start of the counter section is calculated as ``CounterPtr1 - CounterDeltaInitVal``.; When profile reader advances to the second data record, note ``CounterDelta``; is updated to ``CounterDeltaInitVal - sizeof(ProfileData)``.; Thus the byte offset relative to the start of the counter section is calculated; as ``CounterPtr2 - (CounterDeltaInitVal - sizeof(ProfileData))``. .. _`bitmap`:. Bitmap; ^^^^^^^; This section is used for source-based `Modified Condition/Decision Coverage`_ code coverage. Check out `Bitmap RFC`_; for the design. .. _`Modified Condition/Decision Coverage`: https://en.wikipedia.org/wiki/Modified_condition/decision_coverage; .. _`Bitmap RFC`: https://discourse.llvm.org/t/rfc-source-based-mc-dc-code-coverage/59244. Names; ^^^^^^. This section contains possibly compressed concatenated string of functions' PGO; names. If compressed, zlib library is used. Function names serve as keys in the PGO data hash table when raw profiles are; converted into indexed profiles. They are also crucial for ``llvm-profdata`` to; show the profiles in a human-readable way. Value Profile Data; ^^^^^^^^^^^^^^^^^^^^. This section contains the profile data for value profiling. The value profiles corresponding to a profile metadata are serialized contiguously; as one record, and value profile records are stored in the same order as the; respective profile data, such that a raw profile reader `advances`_ the pointer to; profile data and the pointer to value profile records simutaneously [5]_ to find; value profiles for a per function, per `FuncHash`_ profile data. .. _`advances`: https://github.com/llvm/llvm-project/blob/7e15fa9161eda7497a5d6abf0d951a1d12d86550/llvm/include/llvm/ProfileData/InstrProfReader.h#L456-L457. Indexed Profile Format; ===========================. Indexed profiles are generated from ``llvm-profdata``. In the indexed profiles,; function data are organized as on-disk hash table such that compi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst:12276,hash,hash,12276,interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/InstrProfileFormat.rst,1,['hash'],['hash']
Security,"ng values for initial uncertainties; std::vector<double> init_err;; init_err.push_back(0.1);; init_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:80039,access,access,80039,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['access'],['access']
Security,"ng** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <DeriveLineEnding>`; This option is **deprecated**. See ``DeriveLF`` and ``DeriveCRLF`` of; ``LineEnding``. .. _DerivePointerAlignment:. **DerivePointerAlignment** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DerivePointerAlignment>`; If ``true``, analyze the formatted file for the most common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:60889,access,access,60889,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,ng==1.0.0b2 \; --hash=sha256:9ec55a47c90c8c002b5960c57492ec3021f5193cb26cebc2dc4ea226848651c9 \; --hash=sha256:eb09aedbabfb650607e9b4b68c9d240b90b1e1be221d6ad71d61c52e29f7932b; # via furo; sphinx-bootstrap-theme==0.8.1 \; --hash=sha256:683e3b735448dadd0149f76edecf95ff4bd9157787e9e77e0d048ca6f1d680df \; --hash=sha256:6ef36206c211846ea6cbdb45bc85645578e7c62d0a883361181708f8b6ea743b; # via -r requirements.txt; sphinx-markdown-tables==0.0.17 \; --hash=sha256:2bd0c30779653e4dd120300cbd9ca412c480738cc2241f6dea477a883f299e04 \; --hash=sha256:6bc6d3d400eaccfeebd288446bc08dd83083367c58b85d40fe6c12d77ef592f1; # via -r requirements.txt; sphinxcontrib-applehelp==1.0.4 \; --hash=sha256:29d341f67fb0f6f586b23ad80e072c8e6ad0b48417db2bde114a4c9746feb228 \; --hash=sha256:828f867945bbe39817c210a1abfd1bc4895c8b73fcaade56d45357a348a07d7e; # via; # -r requirements.txt; # sphinx; sphinxcontrib-devhelp==1.0.5 \; --hash=sha256:63b41e0d38207ca40ebbeabcf4d8e51f76c03e78cd61abe118cf4435c73d4212 \; --hash=sha256:fe8009aed765188f08fcaadbb3ea0d90ce8ae2d76710b7e29ea7d047177dae2f; # via sphinx; sphinxcontrib-htmlhelp==2.0.4 \; --hash=sha256:6c26a118a05b76000738429b724a0568dbde5b72391a688577da08f11891092a \; --hash=sha256:8001661c077a73c29beaf4a79968d0726103c5605e27db92b9ebed8bab1359e9; # via sphinx; sphinxcontrib-jsmath==1.0.1 \; --hash=sha256:2ec2eaebfb78f3f2078e73666b1415417a116cc848b72e5172e596c871103178 \; --hash=sha256:a9925e4a4587247ed2191a22df5f6970656cb8ca2bd6284309578f2153e0c4b8; # via sphinx; sphinxcontrib-qthelp==1.0.6 \; --hash=sha256:62b9d1a186ab7f5ee3356d906f648cacb7a6bdb94d201ee7adf26db55092982d \; --hash=sha256:bf76886ee7470b934e363da7a954ea2825650013d367728588732c7350f49ea4; # via sphinx; sphinxcontrib-serializinghtml==1.1.9 \; --hash=sha256:0c64ff898339e1fac29abd2bf5f11078f3ec413cfe9c046d3120d7ca65530b54 \; --hash=sha256:9b36e503703ff04f20e9675771df105e58aa029cfcbc23b8ed716019b7416ae1; # via sphinx; urllib3==2.1.0 \; --hash=sha256:55901e917a5896a349ff771be919f8bd99aff50b79fe58fec595,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt:22553,hash,hash,22553,interpreter/llvm-project/llvm/docs/requirements-hashed.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/requirements-hashed.txt,2,['hash'],['hash']
Security,"nge more than one use at a time. See the doxygen documentation for the; `Value Class <https://llvm.org/doxygen/classllvm_1_1Value.html>`_ and `User Class; <https://llvm.org/doxygen/classllvm_1_1User.html>`_, respectively, for more; information. .. _schanges_deletingGV:. Deleting GlobalVariables; ^^^^^^^^^^^^^^^^^^^^^^^^. Deleting a global variable from a module is just as easy as deleting an; Instruction. First, you must have a pointer to the global variable that you; wish to delete. You use this pointer to erase it from its parent, the module.; For example:. .. code-block:: c++. GlobalVariable *GV = .. ;. GV->eraseFromParent();. .. _threading:. Threads and LLVM; ================. This section describes the interaction of the LLVM APIs with multithreading,; both on the part of client applications, and in the JIT, in the hosted; application. Note that LLVM's support for multithreading is still relatively young. Up; through version 2.5, the execution of threaded hosted applications was; supported, but not threaded client access to the APIs. While this use case is; now supported, clients *must* adhere to the guidelines specified below to ensure; proper operation in multithreaded mode. Note that, on Unix-like platforms, LLVM requires the presence of GCC's atomic; intrinsics in order to support threaded operation. If you need a; multithreading-capable LLVM on a platform without a suitably modern system; compiler, consider compiling LLVM and LLVM-GCC in single-threaded mode, and; using the resultant compiler to build a copy of LLVM with multithreading; support. .. _shutdown:. Ending Execution with ``llvm_shutdown()``; -----------------------------------------. When you are done using the LLVM APIs, you should call ``llvm_shutdown()`` to; deallocate memory used for internal structures. .. _managedstatic:. Lazy Initialization with ``ManagedStatic``; ------------------------------------------. ``ManagedStatic`` is a utility class in LLVM used to implement static; initializat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:121232,access,access,121232,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"nging to one of the following types:. - Freely variable: allowed to take on any value. - Variable with double sided limits: allowed to vary only between two; limits specified by the user. - Variable with single sided limits: allowed to vary only between one; upper or one lower limit specified by the user and unlimited to the; other side. - Fixed: originally defined as variable, but now taking on only the; value the parameter had at the moment it was fixed, or a value later; assigned by the user. - Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are; free and unbound. The user, in their $\mbox{FCN}$, must of course be able to ""see"" all; types of defined parameters, and they therefore have access to what we call; the *external parameter list*, that is, the parameters as he defined; them. On the other hand, the internal M minimizing routines only want to; ""see"" variable parameters without limits, and so they have access only; to the *internal parameter list* which is created from the external list; by the following transformation:. - Squeeze out all parameters that are not variable. - Transform all variable parameters with limits, so that the; transformed parameter can vary without limits. (See the next section; for details concerning this transformation.) Because this; transformation is non-linear, it is recommended to avoid putting; limits on parameters where they are not needed. As an example, suppose that the user has defined the following; parameters:. - Parameter 0, constant. - Parameter 1, freely variable. - Parameter 2, variable with limits. - Parameter 3, constant. - Parameter 4, freely variable. Then the internal parameter list would be as follows:. - Internal parameter 0 = external parameter 1. - Internal parameter 1 = external parameter 2, transformed; appropriately. - Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external para",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:6107,access,access,6107,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['access'],['access']
Security,"ngs; ================. In order to achieve a balance between performance and necessary guarantees,; there are six levels of atomicity. They are listed in order of strength; each; level includes all the guarantees of the previous level except for; Acquire/Release. (See also `LangRef Ordering <LangRef.html#ordering>`_.). .. _NotAtomic:. NotAtomic; ---------. NotAtomic is the obvious, a load or store which is not atomic. (This isn't; really a level of atomicity, but is listed here for comparison.) This is; essentially a regular load or store. If there is a race on a given memory; location, loads from that location return undef. Relevant standard; This is intended to match shared variables in C/C++, and to be used in any; other context where memory access is necessary, and a race is impossible. (The; precise definition is in `LangRef Memory Model <LangRef.html#memmodel>`_.). Notes for frontends; The rule is essentially that all memory accessed with basic loads and stores; by multiple threads should be protected by a lock or other synchronization;; otherwise, you are likely to run into undefined behavior. If your frontend is; for a ""safe"" language like Java, use Unordered to load and store any shared; variable. Note that NotAtomic volatile loads and stores are not properly; atomic; do not try to use them as a substitute. (Per the C/C++ standards,; volatile does provide some limited guarantees around asynchronous signals, but; atomics are generally a better solution.). Notes for optimizers; Introducing loads to shared variables along a codepath where they would not; otherwise exist is allowed; introducing stores to shared variables is not. See; `Optimization outside atomic`_. Notes for code generation; The one interesting restriction here is that it is not allowed to write to; bytes outside of the bytes relevant to a store. This is mostly relevant to; unaligned stores: it is not allowed in general to convert an unaligned store; into two aligned stores of the same width as",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:6564,access,accessed,6564,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['access'],['accessed']
Security,"ning MyFooBar:; fun:*MyFooBar*; # Disable out-of-bound checks for global:; global:bad_array; # Disable out-of-bound checks for global instances of a given class ...; type:Namespace::BadClassName; # ... or a given struct. Use wildcard to deal with anonymous namespace.; type:Namespace2::*::BadStructName; # Disable initialization-order checks for globals:; global:bad_init_global=init; type:*BadInitClassSubstring*=init; src:bad/init/files/*=init. Suppressing memory leaks; ------------------------. Memory leak reports produced by :doc:`LeakSanitizer` (if it is run as a part; of AddressSanitizer) can be suppressed by a separate file passed as. .. code-block:: bash. LSAN_OPTIONS=suppressions=MyLSan.supp. which contains lines of the form `leak:<pattern>`. Memory leak will be; suppressed if pattern matches any function name, source file name, or; library name in the symbolized stack trace of the leak report. See; `full documentation; <https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer#suppressions>`_; for more details. Code generation control; =======================. Instrumentation code outlining; ------------------------------. By default AddressSanitizer inlines the instrumentation code to improve the; run-time performance, which leads to increased binary size. Using the; (clang flag ``-fsanitize-address-outline-instrumentation` default: ``false``); flag forces all code instrumentation to be outlined, which reduces the size; of the generated code, but also reduces the run-time performance. Limitations; ===========. * AddressSanitizer uses more real memory than a native run. Exact overhead; depends on the allocations sizes. The smaller the allocations you make the; bigger the overhead is.; * AddressSanitizer uses more stack memory. We have seen up to 3x increase.; * On 64-bit platforms AddressSanitizer maps (but not reserves) 16+ Terabytes of; virtual address space. This means that tools like ``ulimit`` may not work as; usually expected.; * Static link",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst:11636,sanitiz,sanitizers,11636,interpreter/llvm-project/clang/docs/AddressSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AddressSanitizer.rst,1,['sanitiz'],['sanitizers']
Security,"nitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point types which would overflow the; destination. Because the range of representable values for all; floating-point types supported by Clang is [-inf, +inf], the only; cases detected are conversions from floating point to integer types.; - ``-fsanitize=float-divide-by-zero``: Floating point division by; zer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3773,sanitiz,sanitizes,3773,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitizes']
Security,"nits that do not include the definition. As SSA values, global variables define pointer values that are in scope; (i.e. they dominate) all basic blocks in the program. Global variables; always define a pointer to their ""content"" type because they describe a; region of memory, and all memory objects in LLVM are accessed through; pointers. Global variables can be marked with ``unnamed_addr`` which indicates; that the address is not significant, only the content. Constants marked; like this can be merged with other constants if they have the same; initializer. Note that a constant with significant address *can* be; merged with a ``unnamed_addr`` constant, the result being a constant; whose address is significant. If the ``local_unnamed_addr`` attribute is given, the address is known to; not be significant within the module. A global variable may be declared to reside in a target-specific; numbered address space. For targets that support them, address spaces; may affect how optimizations are performed and/or what target; instructions are used to access the variable. The default address space; is zero. The address space qualifier must precede any other attributes. LLVM allows an explicit section to be specified for globals. If the; target supports it, it will emit globals to the section specified.; Additionally, the global can placed in a comdat if the target has the necessary; support. External declarations may have an explicit section specified. Section; information is retained in LLVM IR for targets that make use of this; information. Attaching section information to an external declaration is an; assertion that its definition is located in the specified section. If the; definition is located in a different section, the behavior is undefined. LLVM allows an explicit code model to be specified for globals. If the; target supports it, it will emit globals in the code model specified,; overriding the code model used to compile the translation unit.; The allowed values ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:32809,access,access,32809,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"nly 1 byte, i.e. VA.byte[7]. - Decimal (Unsigned) Truncate: bcdtrunc. bcdutrunc.; . Use instrinstics:; (set v1i128:$vD, (int_ppc_altivec_bcdso v1i128:$vA, v1i128:$vB, i1:$PS)); (set v1i128:$vD, (int_ppc_altivec_bcduso v1i128:$vA, v1i128:$vB)). . Note! Their VA is accessed only 2 byte, i.e. VA.hword[3] (VA.bit[48:63]). VSX:; - QP Copy Sign: xscpsgnqp; . Similar to xscpsgndp; . (set f128:$vT, (fcopysign f128:$vB, f128:$vA). - QP Absolute/Negative-Absolute/Negate: xsabsqp xsnabsqp xsnegqp; . Similar to xsabsdp/xsnabsdp/xsnegdp; . (set f128:$vT, (fabs f128:$vB)) // xsabsqp; (set f128:$vT, (fneg (fabs f128:$vB))) // xsnabsqp; (set f128:$vT, (fneg f128:$vB)) // xsnegqp. - QP Add/Divide/Multiply/Subtract/Square-Root:; xsaddqp xsdivqp xsmulqp xssubqp xssqrtqp; . Similar to xsadddp; . isCommutable = 1; (set f128:$vT, (fadd f128:$vA, f128:$vB)) // xsaddqp; (set f128:$vT, (fmul f128:$vA, f128:$vB)) // xsmulqp. . isCommutable = 0; (set f128:$vT, (fdiv f128:$vA, f128:$vB)) // xsdivqp; (set f128:$vT, (fsub f128:$vA, f128:$vB)) // xssubqp; (set f128:$vT, (fsqrt f128:$vB))) // xssqrtqp. - Round to Odd of QP Add/Divide/Multiply/Subtract/Square-Root:; xsaddqpo xsdivqpo xsmulqpo xssubqpo xssqrtqpo; . Similar to xsrsqrtedp??; def XSRSQRTEDP : XX2Form<60, 74,; (outs vsfrc:$XT), (ins vsfrc:$XB),; ""xsrsqrtedp $XT, $XB"", IIC_VecFP,; [(set f64:$XT, (PPCfrsqrte f64:$XB))]>;. . Define DAG Node in PPCInstrInfo.td:; def PPCfaddrto: SDNode<""PPCISD::FADDRTO"", SDTFPBinOp, []>;; def PPCfdivrto: SDNode<""PPCISD::FDIVRTO"", SDTFPBinOp, []>;; def PPCfmulrto: SDNode<""PPCISD::FMULRTO"", SDTFPBinOp, []>;; def PPCfsubrto: SDNode<""PPCISD::FSUBRTO"", SDTFPBinOp, []>;; def PPCfsqrtrto: SDNode<""PPCISD::FSQRTRTO"", SDTFPUnaryOp, []>;. DAG patterns of each instruction (PPCInstrVSX.td):; . isCommutable = 1; (set f128:$vT, (PPCfaddrto f128:$vA, f128:$vB)) // xsaddqpo; (set f128:$vT, (PPCfmulrto f128:$vA, f128:$vB)) // xsmulqpo. . isCommutable = 0; (set f128:$vT, (PPCfdivrto f128:$vA, f128:$vB)) // xsdivqpo; (set f128:$",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_P9.txt:6785,xss,xssubqp,6785,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_P9.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_P9.txt,2,['xss'],"['xssqrtqp', 'xssubqp']"
Security,"nly when they end; with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; extensions.; For these files a guessing of ""main"" include takes place; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C(); C();; }; };; void foo() { void foo() {; return 1; return 1;; } }. .. _IndentCaseBlocks:. **IndentCaseBlocks** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <IndentCaseBlocks>`; Indent case label blocks one level from the case label. When ``false``, the block following the case label uses the same; indentation level as for the case label, treating the case label the same; as an if-statement.; When ``true``, the block gets indented as a scope block. .. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:69905,access,access,69905,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"nly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22817,secur,security,22817,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"node.; It is also possible to combine some atomic nodes that have a simple; def-use dependency between them into larger nodes that contain multiple-; instructions. As described in [1]_ the DDG uses graph abstraction to group nodes; that are part of a strongly connected component of the graph; into special nodes called pi-blocks. pi-blocks represent cycles of data; dependency that prevent reordering transformations. Since any strongly; connected component of the graph is a maximal subgraph of all the nodes; that form a cycle, pi-blocks are at most one level deep. In other words,; no pi-blocks are nested inside another pi-block, resulting in a; hierarchical representation that is at most one level deep. For example, consider the following:. .. code-block:: c++. for (int i = 1; i < n; i++) {; b[i] = c[i] + b[i-1];; }. This code contains a statement that has a loop carried dependence on; itself creating a cycle in the DDG. The figure below illustrates; how the cycle of dependency is carried through multiple def-use relations; and a memory access dependency. .. image:: cycle.png. The DDG corresponding to this example would have a pi-block that contains; all the nodes participating in the cycle, as shown below:. .. image:: cycle_pi.png. Program Dependence Graph; ========================. The Program Dependence Graph (or PDG) has a similar structure as the; DDG, but it is capable of representing both data dependencies and; control-flow dependencies between program elements such as; instructions, groups of instructions, basic blocks or groups of; basic blocks. High-Level Design; =================. The DDG and the PDG are both directed graphs and they extend the; ``DirectedGraph`` class. Each implementation extends its corresponding; node and edge types resulting in the inheritance relationship depicted; in the UML diagram below:. .. image:: uml_nodes_and_edges.png. Graph Construction; ------------------. The graph build algorithm considers dependencies between elements of; a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst:1878,access,access,1878,interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DependenceGraphs/index.rst,1,['access'],['access']
Security,"non-kernel-functions` by setting; SGPR32 to the unswizzled scratch offset of the address past the last local; allocation. .. _amdgpu-amdhsa-kernel-prolog-frame-pointer:. Frame Pointer; +++++++++++++. If the kernel needs a frame pointer for the reasons defined in; ``SIFrameLowering`` then SGPR33 is used and is always set to ``0`` in the; kernel prolog. If a frame pointer is not required then all uses of the frame; pointer are replaced with immediate ``0`` offsets. .. _amdgpu-amdhsa-kernel-prolog-flat-scratch:. Flat Scratch; ++++++++++++. There are different methods used for initializing flat scratch:. * If the *Target Properties* column of :ref:`amdgpu-processor-table`; specifies *Does not support generic address space*:. Flat scratch is not supported and there is no flat scratch register pair. * If the *Target Properties* column of :ref:`amdgpu-processor-table`; specifies *Offset flat scratch*:. If the kernel or any function it calls may use flat operations to access; scratch memory, the prolog code must set up the FLAT_SCRATCH register pair; (FLAT_SCRATCH_LO/FLAT_SCRATCH_HI). Initialization uses Flat Scratch Init and; Scratch Wavefront Offset SGPR registers (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`):. 1. The low word of Flat Scratch Init is the 32-bit byte offset from; ``SH_HIDDEN_PRIVATE_BASE_VIMID`` to the base of scratch backing memory; being managed by SPI for the queue executing the kernel dispatch. This is; the same value used in the Scratch Segment Buffer V# base address. CP obtains this from the runtime. (The Scratch Segment Buffer base address; is ``SH_HIDDEN_PRIVATE_BASE_VIMID`` plus this offset.). The prolog must add the value of Scratch Wavefront Offset to get the; wavefront's byte scratch backing memory offset from; ``SH_HIDDEN_PRIVATE_BASE_VIMID``. The Scratch Wavefront Offset must also be used as an offset with Private; segment address when using the Scratch Segment Buffer. Since FLAT_SCRATCH_LO is in units of 256 bytes, the offset mus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:194225,access,access,194225,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"nons.p0s_union.anons(<type> base,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic carries the debuginfo field index; ``di_index`` and returns the ``base`` address.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide union debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``type`` is the same as the ``base`` type. Arguments:; """""""""""""""""""". The ``base`` is the union base address. The ``di_index`` is the field index in debuginfo. Semantics:; """""""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic returns the ``base`` address. '``llvm.preserve.struct.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.struct.access.index.p0i8.p0s_struct.anon.0s(<type> base,; i32 gep_index,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.struct.access.index``' intrinsic returns the getelementptr address; based on struct base ``base`` and IR struct member index ``gep_index``.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide struct debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``ret_type`` is a pointer type to the structure member. Arguments:; """""""""""""""""""". The ``base`` is the structure base address. The ``gep_index`` is the struct member index; based on IR structures. The ``di_index`` is the struct member index based on debuginfo. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.struct.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{0, gep_index}``. '``llvm.fptrunc.round``' Intr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:975150,access,access,975150,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"not use regex metacharacters such as ``(``, ``)``. They are unaffected by the; regex to glob transition. For more details, see `this discourse post; <https://discourse.llvm.org/t/use-glob-instead-of-regex-for-specialcaselists/71666>`_. Section names are globs written in square brackets that denote; which sanitizer the following entries apply to. For example, ``[address]``; specifies AddressSanitizer while ``[{cfi-vcall,cfi-icall}]`` specifies Control; Flow Integrity virtual and indirect call checking. Entries without a section; will be placed under the ``[*]`` section applying to all enabled sanitizers. Entries contain an entity type, followed by a colon and a glob,; specifying the names of the entities, optionally followed by an equals sign and; a tool-specific category, e.g. ``fun:*ExampleFunc=example_category``.; Two generic entity types are ``src`` and; ``fun``, which allow users to specify source files and functions, respectively.; Some sanitizer tools may introduce custom entity types and categories - refer to; tool-specific docs. .. code-block:: bash. # The line above is explained in the note above; # Lines starting with # are ignored.; # Turn off checks for the source file; # Entries without sections are placed into [*] and apply to all sanitizers; src:path/to/source/file.c; src:*/source/file.c; # Turn off checks for this main file, including files included by it.; # Useful when the main file instead of an included file should be ignored.; mainfile:file.c; # Turn off checks for a particular functions (use mangled names):; fun:_Z8MyFooBarv; # Glob brace expansions and character ranges are supported; fun:bad_{foo,bar}; src:bad_source[1-9].c; # ""*"" matches zero or more characters; src:bad/sources/*; fun:*BadFunction*; # Specific sanitizer tools may introduce categories.; src:/special/path/*=special_sources; # Sections can be used to limit ignorelist entries to specific sanitizers; [address]; fun:*BadASanFunc*; # Section names are globs; [{cfi-vcall,cfi-icall}]; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst:2875,sanitiz,sanitizer,2875,interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerSpecialCaseList.rst,1,['sanitiz'],['sanitizer']
Security,nown. 733; NAD; Reference qualification of copy assignment operators; Unknown. 734; CD2; Are unique addresses required for namespace-scope variables?; Unknown. 735; CD2; Missing case in specification of safely-derived pointers; Unknown. 736; NAD; Is the & ref-qualifier needed?; Unknown. 737; CD2; Uninitialized trailing characters in string initialization; Unknown. 738; C++11; constexpr not permitted by the syntax of constructor declarations; Unknown. 739; CD3; Signedness of plain bit-fields; Unknown. 740; CD2; Incorrect note on data races; Unknown. 741; C++11; “plain” long long bit-fields; Unknown. 742; open; Postfix increment/decrement with long bit-field operands; Not resolved. 743; CD2; Use of decltype in a nested-name-specifier; Unknown. 744; CD2; Matching template arguments with template template parameters with parameter packs; Unknown. 745; C++23; Effect of ill-formedness resulting from #error; Unknown. 746; CD2; Use of auto in new-expressions; Unknown. 747; dup; Access of protected base classes; Unknown. 749; CD2; References to function types with a cv-qualifier or ref-qualifier; Unknown. 750; CD2; Implementation constraints on reference-only closure objects; Unknown. 751; CD2; Deriving from closure classes; Unknown. 752; CD2; Name lookup in nested lambda-expressions; Unknown. 753; CD2; Array names in lambda capture sets; Unknown. 754; CD2; Lambda expressions in default arguments of block-scope function declarations; Unknown. 755; CD3; Generalized lambda-captures; Unknown. 756; CD2; Dropping cv-qualification on members of closure objects; Unknown. 757; CD2; Types without linkage in declarations; Unknown. 758; C++11; Missing cases of declarations that are not definitions; Unknown. 759; CD2; Destruction of closure objects; Unknown. 760; CD2; this inside a nested class of a non-static member function; Unknown. 761; CD2; Inferred return type of closure object call operator; Unknown. 762; CD2; Name lookup in the compound-statement of a lambda expression; Unknown. ,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:51201,Access,Access,51201,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"nows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm usin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24866,access,access,24866,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['access'],['access']
Security,"ns List of TF1, TF2, TF3; TSeqCollection* fTasks List of TTask; TSeqCollection* fColors List of TColor; TSeqCollection* fGeometries List of geometries; TSeqCollection* fBrowsers List of TBrowser; TSeqCollection* fSpecials List of special objects; TSeqCollection* fCleanups List of recursiveRemove collections; ```. These collections are also displayed in the root folder of the; `Object Browser`. Most of these collections are self explanatory. The; special cases are the collections of specials and cleanups. ### The Collection of Specials. This collection contains objects of the following classes:; **`TCutG`**, **`TMultiDimFit`**, **`TPrincipal`**, **`TChains`**. In; addition it contains the ***`gHtml`*** object, ***`gMinuit`***; objects, and the array of contours graphs (**`TGraph`**) created when; calling the `Draw` method of a histogram with the `""CONT`, `LIST""`; option. ### Access to the Collection Contents. The current content for a collection listed above can be accessed with; the corresponding `gROOT->GetListOf` method (for example; `gROOT->GetListOfCanvases`). In addition, `gROOT->GetListOfBrowsables`; returns a collection of all objects visible on the left side panel in; the browser. See the image of the Object Browser in the next figure. ![The ROOT Object Browser](pictures/03000094.png). ## Ownership by Other Objects. When an object creates another, the creating object is the owner of the; created one. For example:. ``` {.cpp}; myHisto->Fit(""gaus""); ```. The call to Fit copies the global **`TF1`** Gaussian function and; attaches the copy to the histogram. When the histogram is deleted, the; copy is deleted also. When a pad is deleted or cleared, all objects in the pad with the; `kCanDelete` bit set are deleted automatically. Currently the objects; created by the `DrawCopy` methods, have the `kCanDelete` bit set and; are therefore owned by the pad. ## Ownership by the User. The user owns all objects not described in one of the above cases.; **`TObject`** has two",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md:4251,access,accessed,4251,documentation/users-guide/ObjectOwnership.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ObjectOwnership.md,1,['access'],['accessed']
Security,"ns a full signature value (as opposed to a signed pointer value, with; an embedded partial signature). As opposed to [`llvm.ptrauth.sign`](#llvm-ptrauth-sign), it does not interpret; `value` as a pointer value. Instead, it is an arbitrary data value. #### '`llvm.ptrauth.blend`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.blend(i64 <address discriminator>, i64 <integer discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.blend`' intrinsic blends a pointer address discriminator; with a small integer discriminator to produce a new ""blended"" discriminator. ##### Arguments:. The `address discriminator` argument is a pointer value.; The `integer discriminator` argument is a small integer, as specified by the; target. ##### Semantics:. The '`llvm.ptrauth.blend`' intrinsic combines a small integer discriminator; with a pointer address discriminator, in a way that is specified by the target; implementation. ### Operand Bundle. Function pointers used as indirect call targets can be signed when materialized,; and authenticated before calls. This can be accomplished with the; [`llvm.ptrauth.auth`](#llvm-ptrauth-auth) intrinsic, feeding its result to; an indirect call. However, that exposes the intermediate, unauthenticated pointer, e.g., if it; gets spilled to the stack. An attacker can then overwrite the pointer in; memory, negating the security benefit provided by pointer authentication.; To prevent that, the `ptrauth` operand bundle may be used: it guarantees that; the intermediate call target is kept in a register and never stored to memory.; This hardening benefit is similar to that provided by; [`llvm.ptrauth.resign`](#llvm-ptrauth-resign)). Concretely:. ```llvm; define void @f(void ()* %fp) {; call void %fp() [ ""ptrauth""(i32 <key>, i64 <data>) ]; ret void; }; ```. is functionally equivalent to:. ```llvm; define void @f(void ()* %fp) {; %fp_i = ptrtoint void ()* %fp to i64; %fp_auth = call i64 @llvm.ptrauth.auth(i64 %fp_i, i32 <key>, i64 <data>); %fp_auth_p = ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:6511,authenticat,authenticated,6511,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,1,['authenticat'],['authenticated']
Security,"ns via the; function attribute ``__attribute__((no_sanitize(""coverage"")))``. Because this; attribute may not be supported by other compilers, it is recommended to use it; together with ``__has_feature(coverage_sanitizer)``. Disabling instrumentation without source modification; =====================================================. It is sometimes useful to tell SanitizerCoverage to instrument only a subset of the; functions in your target without modifying source files.; With ``-fsanitize-coverage-allowlist=allowlist.txt``; and ``-fsanitize-coverage-ignorelist=blocklist.txt``,; you can specify such a subset through the combination of an allowlist and a blocklist. SanitizerCoverage will only instrument functions that satisfy two conditions.; First, the function should belong to a source file with a path that is both allowlisted; and not blocklisted.; Second, the function should have a mangled name that is both allowlisted and not blocklisted. The allowlist and blocklist format is similar to that of the sanitizer blocklist format.; The default allowlist will match every source file and every function.; The default blocklist will match no source file and no function. A common use case is to have the allowlist list folders or source files for which you want; instrumentation and allow all function names, while the blocklist will opt out some specific; files or functions that the allowlist loosely allowed. Here is an example allowlist:. .. code-block:: none. # Enable instrumentation for a whole folder; src:bar/*; # Enable instrumentation for a specific source file; src:foo/a.cpp; # Enable instrumentation for all functions in those files; fun:*. And an example blocklist:. .. code-block:: none. # Disable instrumentation for a specific source file that the allowlist allowed; src:bar/b.cpp; # Disable instrumentation for a specific function that the allowlist allowed; fun:*myFunc*. The use of ``*`` wildcards above is required because function names are matched after mangling.;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:14318,sanitiz,sanitizer,14318,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['sanitiz'],['sanitizer']
Security,"ns). The ``debugInfoForProfiling:`` field is a boolean; indicating whether or not line-table discriminators are updated to provide; more-accurate debug info for profiling results. .. code-block:: text. !0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: ""clang"",; isOptimized: true, flags: ""-O2"", runtimeVersion: 2,; splitDebugFilename: ""abc.debug"", emissionKind: FullDebug,; enums: !2, retainedTypes: !3, globals: !4, imports: !5,; macros: !6, dwoId: 0x0abcd). Compile unit descriptors provide the root scope for objects declared in a; specific compilation unit. File descriptors are defined using this scope. These; descriptors are collected by a named metadata node ``!llvm.dbg.cu``. They keep; track of global variables, type information, and imported entities (declarations; and namespaces). .. _DIFile:. DIFile; """""""""""". ``DIFile`` nodes represent files. The ``filename:`` can include slashes. .. code-block:: none. !0 = !DIFile(filename: ""path/to/file"", directory: ""/path/to/dir"",; checksumkind: CSK_MD5,; checksum: ""000102030405060708090a0b0c0d0e0f""). Files are sometimes used in ``scope:`` fields, and are the only valid target; for ``file:`` fields. The ``checksum:`` and ``checksumkind:`` fields are optional. If one of these; fields is present, then the other is required to be present as well. Valid; values for ``checksumkind:`` field are: {CSK_MD5, CSK_SHA1, CSK_SHA256}. .. _DIBasicType:. DIBasicType; """""""""""""""""""""". ``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` and; ``float``. ``tag:`` defaults to ``DW_TAG_base_type``. .. code-block:: text. !0 = !DIBasicType(name: ""unsigned char"", size: 8, align: 8,; encoding: DW_ATE_unsigned_char); !1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: ""decltype(nullptr)""). The ``encoding:`` describes the details of the type. Usually it's one of the; following:. .. code-block:: text. DW_ATE_address = 1; DW_ATE_boolean = 2; DW_ATE_float = 4; DW_ATE_signed = 5; DW_ATE_signed_char = 6; DW_ATE_unsigned = 7;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:247487,checksum,checksumkind,247487,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['checksum'],"['checksum', 'checksumkind']"
Security,"ns. Path Tracking; =============. These checkers print information about the path taken by the analyzer engine. - debug.DumpCalls: Prints out every function or method call encountered during a; path traversal. This is indented to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could provide different information, making it diffic",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2425,secur,security,2425,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['secur'],['security']
Security,"nsecutive SGPRs starting at SGPR0 up to; SGPR29. If there are more arguments than will fit in these registers, the remaining; arguments are allocated on the stack in order on naturally aligned; addresses. Note that decomposed struct type arguments may have some fields passed in; registers and some in memory. .. TODO::. So, a struct which can pass some fields as decomposed register arguments, will; pass the rest as decomposed stack elements? But an argument that will not start; in registers will not be decomposed and will be passed as a non-decomposed; stack value?. The following is not part of the AMDGPU function calling convention but; describes how the AMDGPU implements function calls:. 1. SGPR33 is used as a frame pointer (FP) if necessary. Like the SP it is an; unswizzled scratch address. It is only needed if runtime sized ``alloca``; are used, or for the reasons defined in ``SIFrameLowering``.; 2. Runtime stack alignment is supported. SGPR34 is used as a base pointer (BP); to access the incoming stack arguments in the function. The BP is needed; only when the function requires the runtime stack alignment. 3. Allocating SGPR arguments on the stack are not supported. 4. No CFI is currently generated. See; :ref:`amdgpu-dwarf-call-frame-information`. .. note::. CFI will be generated that defines the CFA as the unswizzled address; relative to the wave scratch base in the unswizzled private address space; of the lowest address stack allocated local variable. ``DW_AT_frame_base`` will be defined as the swizzled address in the; swizzled private address space by dividing the CFA by the wavefront size; (since CFA is always at least dword aligned which matches the scratch; swizzle element size). If no dynamic stack alignment was performed, the stack allocated arguments; are accessed as negative offsets relative to ``DW_AT_frame_base``, and the; local variables and register spill slots are accessed as positive offsets; relative to ``DW_AT_frame_base``. 5. Function argument ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:398213,access,access,398213,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"nsformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a me",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310195,access,access,310195,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"nspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or traversing the list and calling a method for each of the; members. See the **`TCollection`** class description for the full set; of methods supported for a collection. For example, to find a canvas; called `c1 `you can do`:`. ``` {.cpp}; root[] gROOT->GetListOfCanvases()->FindObject(""c1""); ```. This returns a pointer to a **`TObject`**, and before you can use it",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32837,access,accessed,32837,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['accessed']
Security,"nspection tools from; being swamped by an enormous amount of classes, but they can no longer; be used to explore unknown parts of the system (e.g. to find out which; classes are available). Furthermore, because of this approach,; \<`tab`\>-completion will usually not be available until after the first; use (and hence creation) of a class. Access to class static functions, public data members, enums, etc. is as; expected. Many more example uses of ROOT classes from Python can be; found in the tutorials directory in the ROOT distribution. The recipes; section contains a description on working with your own classes (see; ""Using Your Own Classes""). #### Access to STL Classes. The STL classes live in the ROOT.std namespace (or, if you prefer to get; them from there, in the ROOT module directly, but doing so makes the; code less clear, of course). Be careful in their use, because Python; already has types called ""`string`"" and ""`list`."". In order to understand how to get access to a templated class, think of; the general template as a meta class. By instantiating the meta class; with the proper parameters, you get an actual class, which can then be; used to create object instances. An example usage:. ``` {.cpp}; >>> from ROOT import std; >>> v = std.vector(int)(); >>> for i in range(0,10):; ... v.push_back(i); ...; >>> for i in v:; ... print(i, end=' '); 1 2 3 4 5 6 7 8 9; >>>; >>> list(v); [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; >>>; ```. The parameters to the template instantiation can either be an actual; type or value (as is used here, ""int""), or a string representation of; the parameters (e.g. ""'double'""), or a mixture of both (e.g. ""'TCanvas,; 0'"" or ""'double', 0"" ). The ""std::vector\<int\>"" class is one of the; classes builtin by default into the Cling extension dlls. You will get a; non-functional class (instances of which can still be passed around to; C++) if the corresponding dictionary doesn't exist. #### Access to ROOT Globals. Most globals and global functions can be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:11827,access,access,11827,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['access'],['access']
Security,"nstants:. * Pi.; * Base of natural logarithm.; * Velocity of light.; * Gravitational constant (G).; * Standard acceleration of gravity (g).; * Standard acceleration of Gravity.; * Plank's contant.; * Boltzmann's and Steffan-Boltzmann's constants.; * Avogadro's number.; * Universal gas constant.; * Molecular weight of dry air.; * Dry air gas constant.; * Euler-Mascheroni Constant.; * Elementary charge. ### Elementary Functions. A set of miscellaneous elementary mathematical functions is provided along with a set of basic trigonometrical functions. Some of this functions refer to basic mathematical functions like the square root, the power to a number of the calculus of a logarithm, while others are used for number treatment, like rounding. Although there are some functions that are not in the standard C math library (like `Factorial`), most of the functionality offered here is just a wrapper of the first ones. Nevertheless, some of the them also offer some security checks or a better precision, like the trigonometrical functions `ASin(x)`, `ACos(x)` or `ATan(x)`. ```{.cpp}; // Generate a vector with 10 random numbers; vector<double> v(10);; std::generate(v.begin(), v.end(), rand);. // Find the minimum value of the vector (iterator version); vector<double>::iterator it;; it = TMath::LocMin(v.begin(), v.end());; std::cout << *it << std::endl;. // The same with the old-style version; int i;; i = TMath::LocMin(10, &v[0]);; std::cout << v[i] << std::endl;; ```. Another example of these functions can be found in $ROOTSYS/tutorials/permute.C. ### Statistic Functions Operating on Arrays. This set of functions processes arrays to calculate:. * Mean.; * Median.; * Geometrical mean.; * Sample Standard Deviation (*RMS*).; * The kth smallest element. These functions, as the array algorithms, have two different interfaces. An old-style one where the size of the array is passed as a first argument followed by a pointer to the array itself; and a modern C++-like interface that recei",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:7806,secur,security,7806,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['secur'],['security']
Security,"nstructions. | ``// 1 VMEM read``; | ``__builtin_amdgcn_sched_group_barrier(32, 1, 0)``; | ``// 1 VALU``; | ``__builtin_amdgcn_sched_group_barrier(2, 1, 0)``; | ``// 5 MFMA``; | ``__builtin_amdgcn_sched_group_barrier(8, 5, 0)``. llvm.amdgcn.iglp_opt An **experimental** intrinsic for instruction group level parallelism. The intrinsic; implements predefined intruction scheduling orderings. The intrinsic applies to the; surrounding scheduling region. The intrinsic takes a value that specifies the; strategy. The compiler implements two strategies. 0. Interleave DS and MFMA instructions for small GEMM kernels.; 1. Interleave DS and MFMA instructions for single wave small GEMM kernels. Only one iglp_opt intrinsic may be used in a scheduling region. The iglp_opt intrinsic; cannot be combined with sched_barrier or sched_group_barrier. The iglp_opt strategy implementations are subject to change. llvm.amdgcn.atomic.cond.sub.u32 Provides direct access to flat_atomic_cond_sub_u32, global_atomic_cond_sub_u32; and ds_cond_sub_u32 based on address space on gfx12 targets. This; performs subtraction only if the memory value is greater than or; equal to the data value. llvm.amdgcn.s.getpc Provides access to the s_getpc_b64 instruction, but with the return value; sign-extended from the width of the underlying PC hardware register even on; processors where the s_getpc_b64 instruction returns a zero-extended value. ============================================== ==========================================================. .. TODO::. List AMDGPU intrinsics. LLVM IR Attributes; ------------------. The AMDGPU backend supports the following LLVM IR attributes. .. table:: AMDGPU LLVM IR Attributes; :name: amdgpu-llvm-ir-attributes-table. ======================================= ==========================================================; LLVM Attribute Description; ======================================= ==========================================================; ""amdgpu-flat-work-group-size""=""m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:45278,access,access,45278,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"nsures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire and release.; * The L2 cache of one agent can be kept coherent with other agents by:; using the MTYPE RW (read-write) or MTYPE CC (cache-coherent) with the PTE; C-bit for memory local to the L2; and using the MTYPE NC (non-coherent) with; the PTE C-bit set or MTYPE UC (uncached) for memory not local to the L2. * Any local memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by coherent requests. Coherent requests are caused; by GPU accesses to pages with the PTE C-bit set, by CPU accesses over; XGMI, and by PCIe requests that are configured to be coherent requests.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter and and the PTE C-bit being set.; * Since all work-groups on the same agent share the same L2, no L2; invalidation or writeback is required for coherence.; * To ensure coherence of local and remote memory writes of work-groups in; different agents a ``buffer_wbl2`` is required. It will writeback dirty L2; cache lines of MTYPE RW (used for local coarse grain memory) and MTYPE NC; ()used for remote coarse grain memory). Note that MTYPE CC (used for local; fine grain memory) causes write through to DRAM, and MTYPE UC (used for; remote fine grain memory) bypasses the L2, so both will never result in; dirty L2 cache lines.; * To ensure coherence of local and remote memory reads of work-groups in; different agents a ``buffer_invl2`` is required. It will invalidate L2; cache lines with MTYPE NC (used for remote coarse grain memory). Note that; MTYPE CC (used for local fine grain memory) and MTYPE RW (used for local; coarse memory) cause local reads t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:238350,access,access,238350,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"nt implementation does roughly the following:. * The compiler instruments all CMP instructions with a callback that receives both CMP arguments.; * The callback computes `(caller_pc&4095) | (popcnt(Arg1 ^ Arg2) << 12)` and uses this value to set a bit in a bitset.; * Every new observed bit in the bitset is treated as new coverage. This feature has a potential to discover many interesting inputs,; but there are two downsides.; First, the extra instrumentation may bring up to 2x additional slowdown.; Second, the corpus may grow by several times. Fuzzer-friendly build mode; ---------------------------; Sometimes the code under test is not fuzzing-friendly. Examples:. - The target code uses a PRNG seeded e.g. by system time and; thus two consequent invocations may potentially execute different code paths; even if the end result will be the same. This will cause a fuzzer to treat; two similar inputs as significantly different and it will blow up the test corpus.; E.g. libxml uses ``rand()`` inside its hash table.; - The target code uses checksums to protect from invalid inputs.; E.g. png checks CRC for every chunk. In many cases it makes sense to build a special fuzzing-friendly build; with certain fuzzing-unfriendly features disabled. We propose to use a common build macro; for all such cases for consistency: ``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION``. .. code-block:: c++. void MyInitPRNG() {; #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION; // In fuzzing mode the behavior of the code should be deterministic.; srand(0);; #else; srand(time(0));; #endif; }. AFL compatibility; -----------------; LibFuzzer can be used together with AFL_ on the same test corpus.; Both fuzzers expect the test corpus to reside in a directory, one file per input.; You can run both fuzzers on the same corpus, one after another:. .. code-block:: console. ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@; ./llvm-fuzz testcase_dir findings_dir # Will write new tests to testcase_dir. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:21667,hash,hash,21667,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['hash'],['hash']
Security,"nt is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is an ID of a condition to track. This value is used as a; bit index into the condition bitmap. The fourth argument is the address of the condition bitmap. The fifth argument is the boolean value representing the evaluation of the; condition (true or false). Semantics:; """""""""""""""""""". This intrinsic represents the update of a condition bitmap that is local to a; function and will cause the ``-instrprof`` pass to generate the code to; instrument the control flow around each condition in a boolean expression. The; ID of each condition corresponds to a bit index in the condition bitmap which; is set based on the evaluation of the condition. '``llvm.instrprof.mcdc.tvbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.tvbitmap.update(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>); i32 <bitmap-index>,; ptr <mcdc-temp-addr>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.tvbitmap.update``' intrinsic is used to track MC/DC; test vector execution after each boolean expression has been fully executed.; The overall value of the condition bitmap, after it has been successively; updated using the '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic with; the true or false evaluation of each condition, uniquely identifies an executed; MC/DC test vector and is used as a bit index into the global test vector; bitmap. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vector",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:534947,hash,hash,534947,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security,"nt to provide users a way of avoiding these autoreleases.; Tying this to precise lifetime semantics is ideal, as for local variables; this requires a very explicit annotation, which allows ARC to trust the user; with good cheer. .. _arc.misc.c-retainable:. C retainable pointer types; --------------------------. A type is a :arc-term:`C retainable pointer type` if it is a pointer to; (possibly qualified) ``void`` or a pointer to a (possibly qualifier) ``struct``; or ``class`` type. .. admonition:: Rationale. ARC does not manage pointers of CoreFoundation type (or any of the related; families of retainable C pointers which interoperate with Objective-C for; retain/release operation). In fact, ARC does not even know how to; distinguish these types from arbitrary C pointer types. The intent of this; concept is to filter out some obviously non-object types while leaving a hook; for later tightening if a means of exhaustively marking CF types is made; available. .. _arc.misc.c-retainable.audit:. Auditing of C retainable pointer interfaces; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. :when-revised:`[beginning Apple 4.0, LLVM 3.1]`. A C function may be marked with the ``cf_audited_transfer`` attribute to; express that, except as otherwise marked with attributes, it obeys the; parameter (consuming vs. non-consuming) and return (retained vs. non-retained); conventions for a C function of its name, namely:. * A parameter of C retainable pointer type is assumed to not be consumed; unless it is marked with the ``cf_consumed`` attribute, and; * A result of C retainable pointer type is assumed to not be returned retained; unless the function is either marked ``cf_returns_retained`` or it follows; the create/copy naming convention and is not marked; ``cf_returns_not_retained``. A function obeys the :arc-term:`create/copy` naming convention if its name; contains as a substring:. * either ""Create"" or ""Copy"" not followed by a lowercase letter, or; * either ""create"" or ""copy"" not follo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:102663,audit,audit,102663,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['audit'],['audit']
Security,"nt with new TWebCanvas - interactivity, attributes/position updates; 12. Provide initial WebVR support (#176), thanks to Diego Marcos (@dmarcos); 13. Upgrade three.js 86 -> 102, use SoftwareRenderer instead of CanvasRenderer; 14. Upgrade d3.js 4.4.4 -> 5.7.0; 15. Use d3.js and three.js from npm when running with node.js; 16. Fix - support clipping for tracks and points in geo painter; 17. Fix - drawing of TGeoNode with finder; 18. Fix - key press events processed only in active pad (ROOT-9128); 19. Fix - use X0/Y0 in xtru shape (#182), thanks to @altavir; 20. Move most of ui5-specific code into ROOT repository, where it will be maintained; 21. Provide special widget for object inspector. ## Changes in 5.6.4; 1. Fix - try workaround corrupted data in TTree; 2. Fix - support min0 draw option like ROOT does; 3. Fix - correctly handle TH2Poly draw options; 4. Fix - seldom error in JSROOT.cleanup; 5. Fix - repair TTree player UI; 6. Fix - error in TH3 filling; 7. Fix - correctly access top element in simple layout; 8. Fix - exclude duplicated points when drawing TH2 with SURF3 options. ## Changes in 5.6.3; 1. Fix - support clipping for tracks and points in geo painter; 2. Fix - geometry with TGeoNodeOffset was not correctly drawn; 3. Fix - use proper formatting for entries and integral (#179); 4. Fix - TTree::Draw for 3d histogram was not properly performed. ## Changes in 5.6.2; 1. Fix - correctly handle negative parameter values in TF1/TF2. ## Changes in 5.6.1; 1. Add TMath.BreitWigner function; 2. Support custom streamers for TMaterial and TMixture (very old examples); 3. Fix Y-scale drawing of THStack (https://root-forum.cern.ch/t/31266); 4. Fix - select palette from colz element; 5. Fix - LZ4 uncompression of large buffers. ## Changes in 5.6.0; 1. By drawing outline speed up (factor 10) canvas with many small sub-pads; 2. Let configure user click and double-click handlers, extend tooltip.htm example; 3. Implement workaround for standard THREE.SVGRenderer - no need fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:31430,access,access,31430,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['access'],['access']
Security,"nt' dataset from two input datasets without; the need to copy the input data and 'filtered' datasets that represent; a reduced view (in dimensions or by selecting events) of a dataset; without the need to copy content. Various workspace improvements. A number of smaller and larger improvements has been made to the RooWorkspace class. Direct interactive access to contents from CINT -; One can now directly access the contents of any RooWorkspace; on the ROOT commandline through CINT if the RooWorkspace::exportToCint() call is made.; In CINT, all workspace objects will appear as correctly typed references to workspace objects in; a C++ namespace with the same name as the RooWorkspace object. Given e.g. a workspace w, with a Gaussian p.d.f gauss in terms of variables; x,m,s one can now do. RooWorkspace w(""w"",true) ; // workspace with CINT interface activated; // ... fill workspace with RooGaussian gauss(x,m,s) ...; RooPlot* frame = w::x.frame() ;; w::gauss.plotOn(frame) ;. to access the workspace contents. Each reference has the correct type, e.g. w::gauss is; a RooGaussian&. If a workspace is deleted from memory, the corresponding CINT namespace; is removed as well. Note that this feature is strictly available in interpreted C++ only; A new tutorial macro has been added to illustrate this functionality in more detail: rf509_wsinteractive.C.; writeToFile -- A new utility method RooWorkspace::writeToFile() has been added; to simplify the process of saving a workspace to file; Named sets and parameter snapshots -- It is now possible to define and retrieve; named RooArgSets of objects that live in the workspace through methods; defineSet() and set(). While named sets merely group objects logically, methods loadSnapshot and; saveSnapshot allow to make copies of the values, errors and 'constant' status of; sets of variable objects that live in the workspace. A newly added tutorial macro rf510_namedsets.C illustrates the functionality of both; of these features.; Improved pri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html:16806,access,access,16806,roofit/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v524/index.html,2,['access'],['access']
Security,"nt`` (in configuration: ``NoIndent``); Does not indent extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. * ``IEBS_Indent`` (in configuration: ``Indent``); Indents extern blocks. .. code-block:: c++. extern ""C"" {; void foo();; }. .. _IndentGotoLabels:. **IndentGotoLabels** (``Boolean``) :versionbadge:`clang-format 10` :ref:`¶ <IndentGotoLabels>`; Indent goto labels. When ``false``, goto labels are flushed left. .. code-block:: c++. true: false:; int f() { vs. int f() {; if (foo()) { if (foo()) {; label1: label1:; bar(); bar();; } }; label2: label2:; return 1; return 1;; } }. .. _IndentPPDirectives:. **IndentPPDirectives** (``PPDirectiveIndentStyle``) :versionbadge:`clang-format 6` :ref:`¶ <IndentPPDirectives>`; The preprocessor directive indenting style to use. Possible values:. * ``PPDIS_None`` (in configuration: ``None``); Does not indent any directives. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. * ``PPDIS_AfterHash`` (in configuration: ``AfterHash``); Indents directives after the hash. .. code-block:: c++. #if FOO; # if BAR; # include <foo>; # endif; #endif. * ``PPDIS_BeforeHash`` (in configuration: ``BeforeHash``); Indents directives before the hash. .. code-block:: c++. #if FOO; #if BAR; #include <foo>; #endif; #endif. .. _IndentRequiresClause:. **IndentRequiresClause** (``Boolean``) :versionbadge:`clang-format 15` :ref:`¶ <IndentRequiresClause>`; Indent the requires clause in a template. This only applies when; ``RequiresClausePosition`` is ``OwnLine``, or ``WithFollowing``. In clang-format 12, 13 and 14 it was named ``IndentRequires``. .. code-block:: c++. true:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. false:; template <typename It>; requires Iterator<It>; void sort(It begin, It end) {; //....; }. .. _IndentWidth:. **IndentWidth** (``Unsigned``) :versionbadge:`clang-format 3.7` :ref:`¶ <IndentWidth>`; The number of columns to use for indentation. .. code-block:: c++. I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:73397,hash,hash,73397,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['hash'],['hash']
Security,"ntation doesn't currently support that strategy. ## Common API Functions. ```c++; BLAKE3::BLAKE3();. void BLAKE3::init();; ```; ```c; void llvm_blake3_hasher_init(; llvm_blake3_hasher *self);; ```. Initialize a `llvm_blake3_hasher` in the default hashing mode. ---. ```c++; void BLAKE3::update(ArrayRef<uint8_t> Data);. void BLAKE3::update(StringRef Str);; ```; ```c; void llvm_blake3_hasher_update(; llvm_blake3_hasher *self,; const void *input,; size_t input_len);; ```. Add input to the hasher. This can be called any number of times. ---. ```c++; template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; using BLAKE3Result = std::array<uint8_t, NumBytes>;. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; void BLAKE3::final(BLAKE3Result<NumBytes> &Result);. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; BLAKE3Result<NumBytes> BLAKE3::final();; ```; ```c; void llvm_blake3_hasher_finalize(; const llvm_blake3_hasher *self,; uint8_t *out,; size_t out_len);; ```. Finalize the hasher and return an output of any length, given in bytes.; This doesn't modify the hasher itself, and it's possible to finalize; again after adding more input. The constant `LLVM_BLAKE3_OUT_LEN` provides; the default output length, 32 bytes, which is recommended for most; callers. Outputs shorter than the default length of 32 bytes (256 bits) provide; less security. An N-bit BLAKE3 output is intended to provide N bits of; first and second preimage resistance and N/2 bits of collision; resistance, for any N up to 256. Longer outputs don't provide any; additional security. Shorter BLAKE3 outputs are prefixes of longer ones. Explicitly; requesting a short output is equivalent to truncating the default-length; output. (Note that this is different between BLAKE2 and BLAKE3.). ## Less Common API Functions. ```c; void llvm_blake3_hasher_init_keyed(; llvm_blake3_hasher *self,; const uint8_t key[LLVM_BLAKE3_KEY_LEN]);; ```. Initialize a `llvm_blake3_hasher` in the keyed hashing mode. The key must be; exactly 32 byt",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:3424,hash,hasher,3424,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['hash'],['hasher']
Security,"ntially massive leaks are about as likely to take down; the process as this corruption is if the program does try to recover from; exceptions. .. _arc.misc.interior:. Interior pointers; -----------------. An Objective-C method returning a non-retainable pointer may be annotated with; the ``objc_returns_inner_pointer`` attribute to indicate that it returns a; handle to the internal data of an object, and that this reference will be; invalidated if the object is destroyed. When such a message is sent to an; object, the object's lifetime will be extended until at least the earliest of:. * the last use of the returned pointer, or any pointer derived from it, in the; calling function or; * the autorelease pool is restored to a previous state. .. admonition:: Rationale. Rationale: not all memory and resources are managed with reference counts; it; is common for objects to manage private resources in their own, private way.; Typically these resources are completely encapsulated within the object, but; some classes offer their users direct access for efficiency. If ARC is not; aware of methods that return such ""interior"" pointers, its optimizations can; cause the owning object to be reclaimed too soon. This attribute informs ARC; that it must tread lightly. The extension rules are somewhat intentionally vague. The autorelease pool; limit is there to permit a simple implementation to simply retain and; autorelease the receiver. The other limit permits some amount of; optimization. The phrase ""derived from"" is intended to encompass the results; both of pointer transformations, such as casts and arithmetic, and of loading; from such derived pointers; furthermore, it applies whether or not such; derivations are applied directly in the calling code or by other utility code; (for example, the C library routine ``strchr``). However, the implementation; never need account for uses after a return from the code which calls the; method returning an interior pointer. As an exception, n",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:100440,access,access,100440,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['access']
Security,"ntiating constexpr variables for potential constant evaluation; Not resolved. 2801; DR; Reference binding with reference-related types; Unknown. 2802; open; Constrained auto and redeclaration with non-abbreviated syntax; Not resolved. 2803; tentatively ready; Overload resolution for reference binding of similar types; Unknown. 2804; open; Lookup for determining rewrite targets; Not resolved. 2805; open; Underspecified selection of deallocation function; Not resolved. 2806; DR; Make a type-requirement a type-only context; Unknown. 2807; DR; Destructors declared consteval; Unknown. 2808; review; Explicit specialization of defaulted special member function; Not resolved. 2809; tentatively ready; An implicit definition does not redeclare a function; Unknown. 2810; tentatively ready; Requiring the absence of diagnostics for templates; Unknown. 2811; tentatively ready; Clarify ""use"" of main; Unknown. 2812; open; Allocation with explicit alignment; Not resolved. 2813; review; Class member access with prvalues; Not resolved. 2814; review; Alignment requirement of incomplete class type; Not resolved. 2815; open; Overload resolution for references/pointers to noexcept functions; Not resolved. 2816; review; Unclear phrasing ""may assume ... eventually""; Not resolved. 2817; open; sizeof(abstract class) is underspecified; Not resolved. 2818; review; Use of predefined reserved identifiers; Not resolved. 2819; review; Cast from null pointer value in a constant expression; Not resolved. 2820; open; Value-initialization and default constructors; Not resolved. 2821; open; Lifetime, zero-initialization, and dynamic initialization; Not resolved. 2822; tentatively ready; Side-effect-free pointer zap; Unknown. 2823; DR; Implicit undefined behavior when dereferencing pointers; Unknown. 2824; tentatively ready; Copy-initialization of arrays; Unknown. 2825; tentatively ready; Range-based for statement using a braced-init-list; Unknown. 2826; tentatively ready; Missing definition of ""temporary",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:195199,access,access,195199,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"ntics:. The '`llvm.ptrauth.strip`' intrinsic implements the `strip`_ operation.; It returns a raw pointer value. It does **not** check that the; signature is valid. `key` should identify a key that is appropriate for `value`, as defined; by the target-specific [keys](#keys)). If `value` is a raw pointer value, it is returned as-is (provided the `key`; is appropriate for the pointer). If `value` is not a pointer value for which `key` is appropriate, the; behavior is target-specific. If `value` is a signed pointer value, but `key` does not identify the; same key that was used to generate `value`, the behavior is; target-specific. #### '`llvm.ptrauth.resign`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.resign(i64 <value>,; i32 <old key>, i64 <old discriminator>,; i32 <new key>, i64 <new discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.resign`' intrinsic re-signs a signed pointer using; a different key and diversity data. ##### Arguments:. The `value` argument is the signed pointer value to be authenticated.; The `old key` argument is the identifier of the key that was used to generate; the signed value.; The `old discriminator` argument is the additional diversity data to be used; as a discriminator in the auth operation.; The `new key` argument is the identifier of the key to use to generate the; resigned value.; The `new discriminator` argument is the additional diversity data to be used; as a discriminator in the sign operation. ##### Semantics:. The '`llvm.ptrauth.resign`' intrinsic performs a combined `auth`_ and `sign`_; operation, without exposing the intermediate raw pointer.; It returns a signed pointer value.; If `value` does not have a correct signature for `old key` and; `old discriminator`, the intrinsic traps in a target-specific way. #### '`llvm.ptrauth.sign_generic`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.sign_generic(i64 <value>, i64 <discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.sign_generic`' intrinsic computes",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:4128,authenticat,authenticated,4128,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,1,['authenticat'],['authenticated']
Security,"ntics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; metadata for the outer loop; !3 = distinct !{} ; access group for instructions in the inner loop (which are implicitly contained in outer loop as well); !4 = distinct !{} ; access group for instructions in the outer, but not the inner loop. .. _langref_llvm_loop_mustprogress:. '``llvm.loop.mustprogress``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.mustprogress`` metadata indicates that this loop is required to; terminate, unwind, or interact with the environment in an observable way e.g.; via a volatile memory access, I/O, or other synchronization. If such a loop is; not found to interact with the environment in an observable way, the loop may; be removed. This corresponds to th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313933,access,access,313933,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"nto the corresponding submodule (``std.io``, ``std.lib``, ``std.math``, etc.). Having a list of the headers that are part of the ``std`` module allows the compiler to build the ``std`` module as a standalone entity, and having the mapping from header names to (sub)modules allows the automatic translation of ``#include`` directives to module imports. Module maps are specified as separate files (each named ``module.modulemap``) alongside the headers they describe, which allows them to be added to existing software libraries without having to change the library headers themselves (in most cases [#]_). The actual `Module map language`_ is described in a later section. .. note::. To actually see any benefits from modules, one first has to introduce module maps for the underlying C standard library and the libraries and headers on which it depends. The section `Modularizing a Platform`_ describes the steps one must take to write these module maps. One can use module maps without modules to check the integrity of the use of header files. To do this, use the ``-fimplicit-module-maps`` option instead of the ``-fmodules`` option, or use ``-fmodule-map-file=`` option to explicitly specify the module map files to load. Compilation model; -----------------; The binary representation of modules is automatically generated by the compiler on an as-needed basis. When a module is imported (e.g., by an ``#include`` of one of the module's headers), the compiler will spawn a second instance of itself [#]_, with a fresh preprocessing context [#]_, to parse just the headers in that module. The resulting Abstract Syntax Tree (AST) is then persisted into the binary representation of the module that is then loaded into translation unit where the module import was encountered. The binary representation of modules is persisted in the *module cache*. Imports of a module will first query the module cache and, if a binary representation of the required module is already available, will load that r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:12885,integrity,integrity,12885,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['integrity'],['integrity']
Security,"ntries. .. option:: --dyn-symbols, --dyn-syms, --dt. Display the dynamic symbol table. .. option:: --dynamic-table, --dynamic, -d. Display the dynamic table. .. option:: --cg-profile. Display the callgraph profile section. .. option:: --histogram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output (the default) is an expanded and; structured format. ``GNU`` output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --section-groups, -g. Display section groups. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dynamic symbols. .. option:: --memtag. Display information about memory tagging present in the binary. This includes; various dynamic entries, decoded global descriptor sections, and decoded; Android-specific ELF notes. .. option:: --notes, -n. Display all notes. .. option:: --pretty-print. When used with :option:`--elf-output-style`, JSON output will be formatted in; a more readable format. .. option:: --program-headers, --segments, -l. Display the program headers. .. option:: --raw-relr. Do not decode relocations in RELR relocation sections when displaying them. .. option:: --section-mapping. Display the section to segment mapping. .. option:: --stack-sizes. Display the contents of the stack sizes section(s), i.e. pairs of function; names and the size of their stack frames. Currently only implemented for GNU; style output. .. option:: --version-info, -V. Display version sections. MACH-O SPECIFIC OPTIONS; -----------------------. The following options are implemented only for th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst:6023,hash,hash,6023,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,1,['hash'],['hash']
Security,"nts to be the DIE offset (eAtomTypeDIEOffset) that is; encoded as a 32 bit value (DW_FORM_data4). This allows a single name to have; multiple matching DIEs in a single file, which could come up with an inlined; function for instance. Future tables could include more information about the; DIE such as flags indicating if the DIE is a function, method, block,; or inlined. The KeyType for the DWARF table is a 32 bit string table offset into the; "".debug_str"" table. The "".debug_str"" is the string table for the DWARF which; may already contain copies of all of the strings. This helps make sure, with; help from the compiler, that we reuse the strings between all of the DWARF; sections and keeps the hash table size down. Another benefit to having the; compiler generate all strings as DW_FORM_strp in the debug info, is that; DWARF parsing can be made much faster. After a lookup is made, we get an offset into the hash data. The hash data; needs to be able to deal with 32 bit hash collisions, so the chunk of data; at the offset in the hash data consists of a triple:. .. code-block:: c. uint32_t str_offset; uint32_t hash_data_count; HashData[hash_data_count]. If ""str_offset"" is zero, then the bucket contents are done. 99.9% of the; hash data chunks contain a single item (no 32 bit hash collision):. .. code-block:: none. .------------.; | 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] => ""main""); | 0x00000004 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_t HashData[1] DIE offset; | 0x........ | uint32_t HashData[2] DIE offset; | 0x........ | uint32_t HashData[3] DIE offset; | 0x00000000 | uint32_t KeyType (end of hash chain); `------------'. If there are collisions, you will have multiple valid string offsets:. .. code-block:: none. .------------.; | 0x00001023 | uint32_t KeyType (.debug_str[0x0001023] => ""main""); | 0x00000004 | uint32_t HashData count; | 0x........ | uint32_t HashData[0] DIE offset; | 0x........ | uint32_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:75526,hash,hash,75526,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,3,['hash'],['hash']
Security,"nts used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter with a default argument that refers to itself; Superseded by 481. 23; NAD; Some questions regarding partial ordering of function templates; Yes. 24; TC1; Errors in examples in 14.7.3; N/A. 25; TC1; Exception specifications and pointers to members; Yes. 26; NAD; Copy constructors and default arguments; Yes. 27; NAD; Overload ambiguities for builtin ?: prototypes; Yes. 28; CD1; 'exit', 'signal' and static object destruction; N/A (Library DR). 29; CD1; Linkage of locally declared functions; Clang 3.4. 30; TC1; Valid uses of ""::template""; Superseded by 468 (C++11 onwards). 31; NAD; Looking up new/delete; Clang 2.8. 32; TC1; Clarification of explicit instantiation of non-exported templates; N/A. 33; TC1; Argument dependent lookup and overloaded functions; Clang 9. 34; NAD;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:2086,access,access,2086,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"num HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32_t offsets[Header.hashes_count]; // An offset that corresponds to each item in the ""hashes[]"" array above; };. ``buckets`` is an array of 32 bit indexes into the ``hashes`` array. The; ``hashes`` array contains all of the 32 bit hash values for all names in the; hash table. Each hash in the ``hashes`` table has an offset in the ``offsets``; array that points to the data for the hash value. This table setup makes it very easy to repurpose these tables to contain; different data, while keeping the lookup mechanism the same for all tables.; This layout also makes it possible to save the table to disk and map it in; later and do very efficient name lookups with little or no parsing. DWARF lookup tables can be implemented in a variety of ways and can store a lot; of information for each name. We want to make the DWARF tables extensible and; able to store the data efficiently so we have used some of the DWARF features; that enable efficient data storage to define exactly what kind of data we store; for each name. The ``HeaderData`` contains a definition of the contents of each HashData chunk.; We might want to store an offset to all ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:70981,hash,hashes,70981,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hashes']
Security,"number R. If the current call frame is the top call frame, it pushes a location; description L that specifies one register location description SL on the; stack. SL specifies the register location storage that corresponds to R with; a bit offset of 0 for the current thread. If the current call frame is not the top call frame, call frame information; (see :ref:`amdgpu-dwarf-call-frame-information`) is used to determine the; location description that holds the register for the current call frame and; current program location of the current thread. The resulting location; description L is pushed. *Note that if call frame information is used, the resulting location; description may be register, memory, or undefined.*. *An implementation may evaluate the call frame information immediately, or; may defer evaluation until L is accessed by an operation. If evaluation is; deferred, R and the current context can be recorded in L. When accessed, the; recorded context is used to evaluate the call frame information, not the; current context of the access operation.*. *These operations obtain a register location. To fetch the contents of a; register, it is necessary to use* ``DW_OP_regval_type``\ *, use one of the*; ``DW_OP_breg*`` *register-based addressing operations, or use* ``DW_OP_deref*``; *on a register location description.*. .. _amdgpu-dwarf-implicit-location-description-operations:. A.2.5.4.4.5 Implicit Location Description Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces DWARF Version 5 section 2.6.1.1.4. Implicit location storage represents a piece or all of an object which has no; actual location in the program but whose contents are nonetheless known, either; as a constant or can be computed from other locations and values in the program. An implicit location description specifies an implicit location storage. The bit; offset corresponds to a bit position within the implicit location storage. Bits; accessed using an i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:119743,access,accessed,119743,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['access'],"['access', 'accessed']"
Security,"nusual circumstances. .. _SymbolTable:. The ``ValueSymbolTable`` class; ------------------------------. The ``ValueSymbolTable`` (`doxygen; <https://llvm.org/doxygen/classllvm_1_1ValueSymbolTable.html>`__) class provides; a symbol table that the :ref:`Function <c_Function>` and Module_ classes use for; naming value definitions. The symbol table can provide a name for any Value_. Note that the ``SymbolTable`` class should not be directly accessed by most; clients. It should only be used when iteration over the symbol table names; themselves are required, which is very special purpose. Note that not all LLVM; Value_\ s have names, and those without names (i.e. they have an empty name) do; not exist in the symbol table. Symbol tables support iteration over the values in the symbol table with; ``begin/end/iterator`` and supports querying to see if a specific name is in the; symbol table (with ``lookup``). The ``ValueSymbolTable`` class exposes no; public mutator methods, instead, simply call ``setName`` on a value, which will; autoinsert it into the appropriate symbol table. .. _UserLayout:. The ``User`` and owned ``Use`` classes' memory layout; -----------------------------------------------------. The ``User`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1User.html>`__); class provides a basis for expressing the ownership of ``User`` towards other; `Value instance <https://llvm.org/doxygen/classllvm_1_1Value.html>`_\ s. The; ``Use`` (`doxygen <https://llvm.org/doxygen/classllvm_1_1Use.html>`__) helper; class is employed to do the bookkeeping and to facilitate *O(1)* addition and; removal. .. _Use2User:. Interaction and relationship between ``User`` and ``Use`` objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A subclass of ``User`` can choose between incorporating its ``Use`` objects or; refer to them out-of-line by means of a pointer. A mixed variant (some ``Use``; s inline others hung off) is impractical and breaks the invariant that the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:126433,expose,exposes,126433,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['expose'],['exposes']
Security,"ny; given private address will be different to the memory accessed by another lane; of the same or different wavefront for the same private address. If a kernel dispatch uses scratch, then the hardware allocates memory from a; pool of backing memory allocated by the runtime for each wavefront. The lanes; of the wavefront access this using dword (4 byte) interleaving. The mapping; used from private address to backing memory address is:. ``wavefront-scratch-base +; ((private-address / 4) * wavefront-size * 4) +; (wavefront-lane-id * 4) + (private-address % 4)``. If each lane of a wavefront accesses the same private address, the; interleaving results in adjacent dwords being accessed and hence requires; fewer cache lines to be fetched. There are different ways that the wavefront scratch base address is; determined by a wavefront (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). Scratch memory can be accessed in an interleaved manner using buffer; instructions with the scratch buffer descriptor and per wavefront scratch; offset, by the scratch instructions, or by flat instructions. Multi-dword; access is not supported except by flat and scratch instructions in; GFX9-GFX11. Code that manipulates the stack values in other lanes of a wavefront,; such as by ``addrspacecast``-ing stack pointers to generic ones and taking offsets; that reach other lanes or by explicitly constructing the scratch buffer descriptor,; triggers undefined behavior when it modifies the scratch values of other lanes.; The compiler may assume that such modifications do not occur.; When using code object V5 ``LIBOMPTARGET_STACK_SIZE`` may be used to provide the; private segment size in bytes, for cases where a dynamic stack is used. **Constant 32-bit**; *TODO*. **Buffer Fat Pointer**; The buffer fat pointer is an experimental address space that is currently; unsupported in the backend. It exposes a non-integral pointer that is in; the future intended to support the modelling of 128-bit buffer ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:27658,access,accessed,27658,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"o (and update) the list of files in the file browser (left panel) when opening a ROOT file from the ""Open File"" menu. TGListView. Keyboard navigation is now fully working in the list view. TGMainFrame. Allow to save a snapshot of the GUI in a picture file. The supported formats are gif, jpg, png, tiff, and xpm. TGFileDialog. Allow to change directory by typing its name in the text entry field of the dialog. TProofProgressDialog. Added a speedometer widget (TGSpeedo) to display the processing rate; Added a check button to enable/disable smooth update of the speedometer (enabled by default). This could be useful in the case of slow displays (e.g. when using it via ssh); Several layout improvements. TRecorder. Improvements and consolidation of the cross-platform interoperability, allowing to record and replay sessions between different platforms with less side effects. NB: Using different OS/WM (Window Managers) and using different ROOT GUI settings (via e.g. system.rootrc) between recording and replaying may still produce a wrong behavior of the recorder.; New tutorial guitest_playback.C replaying a recorded session showing and validating the GUI (using guitest.C). GUI Builder; New features, new user interface; Several important features have been added to the builder, and its user interface has been redesigned.; Editing modes are now clearly distinguished with enabled and disabled layout mode. Possibility to enable automatic layout fasten the interface development, as the positioning doesn't have to be done manually anymore; Major changes in the user interface:. Added a list tree displaying the complete structure of the GUI; The name of every element of the GUI is now editable; New, more intuitive interface for padding and layout hints; Color settings option was added to the widget editor; Extended commands in the top menu (open project, save project...); Added important warning dialogs, such as ""Save project"" dialog when closing the window; Added several tool tips. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html:1714,validat,validating,1714,gui/doc/v526/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/doc/v526/index.html,2,['validat'],['validating']
Security,"o ``%a`` is clearly not a clobber for the store to ``%b``. It would; be the walker's goal to figure this out, and return ``liveOnEntry`` when queried; for the clobber of ``MemoryAccess`` ``2``. By default, ``MemorySSA`` provides a walker that can optimize ``MemoryDef``\ s; and ``MemoryUse``\ s by consulting whatever alias analysis stack you happen to; be using. Walkers were built to be flexible, though, so it's entirely reasonable; (and expected) to create more specialized walkers (e.g. one that specifically; queries ``GlobalsAA``, one that always stops at ``MemoryPhi`` nodes, etc). Default walker APIs; ^^^^^^^^^^^^^^^^^^^. There are two main APIs used to retrieve the clobbering access using the walker:. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA);`` return the; clobbering memory access for ``MA``, caching all intermediate results; computed along the way as part of each access queried. - ``MemoryAccess *getClobberingMemoryAccess(MemoryAccess *MA, const MemoryLocation &Loc);``; returns the access clobbering memory location ``Loc``, starting at ``MA``.; Because this API does not request the clobbering access of a specific memory; access, there are no results that can be cached. Locating clobbers yourself; ^^^^^^^^^^^^^^^^^^^^^^^^^^. If you choose to make your own walker, you can find the clobber for a; ``MemoryAccess`` by walking every ``MemoryDef`` that dominates said; ``MemoryAccess``. The structure of ``MemoryDef``\ s makes this relatively simple;; they ultimately form a linked list of every clobber that dominates the; ``MemoryAccess`` that you're trying to optimize. In other words, the; ``definingAccess`` of a ``MemoryDef`` is always the nearest dominating; ``MemoryDef`` or ``MemoryPhi`` of said ``MemoryDef``. Use and Def optimization; ------------------------. ``MemoryUse``\ s keep a single operand, which is their defining or optimized; access.; Traditionally ``MemorySSA`` optimized ``MemoryUse``\ s at build-time, up to a; given threshold.; Spec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:10214,access,access,10214,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security,"o add. On the right are the leaves or; variables in the tree. You can double click on any leaf to a histogram; it. The toolbar in the upper part can be used for user commands, changing; the drawing option and the histogram name. The lower part contains three; picture buttons that draw a histogram, stop the current command, and; refresh the tree. The three check buttons toggle the following:. `Hist`- the histogram drawing mode;. `Scan`- enables redirecting of `TTree::Scan `command in an ASCII file;. `Rec` - enables recording of the last issued command. - ![](pictures/020000F1.jpg) To draw more than one dimension you can drag; and drop any leaf to the `X,Y,Z` boxes"". Then push the Draw button,; witch is marked with the purple icon on the bottom left. - ![](pictures/030000F2.png) All commands can be interrupted at any time; by pressing this button. - ![](pictures/030000F3.png) The method **`TTree::Refresh`** is called by; pressing the refresh button in `TTreeViewer`. It redraws the current; exposed expression. Calling `TTree::Refresh` is useful when a tree is; produced by a writer process and concurrently analyzed by one or more; readers. - ![](pictures/030000F4.png) To add a cut/weight to the histogram, enter an; expression in the ""cut box"". The cut box is the one with the scissor; icon. Below them there are two text widgets for specifying the input and; output event lists. A Tree Viewer session is made by the list of; user-defined expressions and cuts, applying to a specified tree. A; session can be saved using File / `SaveSource` menu or the `SaveSource`; method from the context menu of the right panel. This will create a; macro having as default name `treeviewer.C` that can be ran at any time; to reproduce the session. Besides the list of user-defined expressions, a session may contain a; list of RECORDS. A record can be produced in the following way: dragging; leaves/expression on X/Y/Z; changing drawing options; clicking the RED; button on the bottom when happy w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:8300,expose,exposed,8300,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['expose'],['exposed']
Security,"o be specified. Almost all uses of addresses in DWARF are limited to defining location; descriptions, or to be dereferenced to read memory. The exception is; ``DW_CFA_val_offset`` which uses the address to set the value of a register. In; order to support address spaces, the CFA DWARF expression is defined to be a; memory location description. This allows it to specify an address space which is; used to convert the offset address back to an address in that address space. See; :ref:`amdgpu-dwarf-call-frame-information`. This approach of extending memory location descriptions to support address; spaces, allows all existing DWARF Version 5 expressions to have the identical; semantics. It allows the compiler to explicitly specify the address space it is; using. For example, a compiler could choose to access private memory in a; swizzled manner when mapping a source language thread to the lane of a wavefront; in a SIMT manner. Or a compiler could choose to access it in an unswizzled; manner if mapping the same language with the wavefront being the thread. It also allows the compiler to mix the address space it uses to access private; memory. For example, for SIMT it can still spill entire vector registers in an; unswizzled manner, while using a swizzled private memory for SIMT variable; access. This approach also allows memory location descriptions for different address; spaces to be combined using the regular ``DW_OP_*piece`` operations. Location descriptions are an abstraction of storage. They give freedom to the; consumer on how to implement them. They allow the address space to encode lane; information so they can be used to read memory with only the memory location; description and no extra information. The same set of operations can operate on; locations independent of their kind of storage. The ``DW_OP_deref*`` therefore; can be used on any storage kind, including memory location descriptions of; different address spaces. Therefore, the ``DW_OP_xderef*`` operations",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:22282,access,access,22282,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security,"o call a; function defined in a different compilation unit. In this case, the front-end; can emit the following descriptor for the trampoline function:. .. code-block:: text. !DISubprogram(name: ""sub1_.t0p"", linkageName: ""sub1_.t0p"", scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: ""sub1_""). The targetFuncName field is the name of the function that the trampoline; calls. This descriptor results in the following DWARF tag:. .. code-block:: text. DW_TAG_subprogram; ...; DW_AT_linkage_name	(""sub1_.t0p""); DW_AT_name	(""sub1_.t0p""); DW_AT_trampoline	(""sub1_""). Debugging information format; ============================. Debugging Information Extension for Objective C Properties; ----------------------------------------------------------. Introduction; ^^^^^^^^^^^^. Objective C provides a simpler way to declare and define accessor methods using; declared properties. The language provides features to declare a property and; to let compiler synthesize accessor methods. The debugger lets developer inspect Objective C interfaces and their instance; variables and class variables. However, the debugger does not know anything; about the properties defined in Objective C interfaces. The debugger consumes; information generated by compiler in DWARF format. The format does not support; encoding of Objective C properties. This proposal describes DWARF extensions to; encode Objective C properties, which the debugger can use to let developers; inspect Objective C properties. Proposal; ^^^^^^^^. Objective C properties exist separately from class members. A property can be; defined only by ""setter"" and ""getter"" selectors, and be calculated anew on each; access. Or a property can just be a direct access to some declared ivar.; Finally it can have an ivar ""automatically synthesized"" for it by the compiler,; in which case the property can be referred to in user code directly using the; standard C dereference syntax",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:49440,access,accessor,49440,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['access'],['accessor']
Security,"o common and frequently used application; actions described in menu titles, implemented by **`TGMenuTitle`**; class. The menu bar is the highest-level of the menu system and it is a; starting point for all interactions. Also, it is always visible and; allows using the keyboard equivalents. The geometry of the menu bar is; automatically set to the parent widget, i.e. the menu bar automatically; resizes itself so that it has the same width as its parent (typically; **`TGMainFrame`**). The menu bar is as a container for its menus - objects of the type; **`TGPopupMenu.`** Popup menus can appear in a menu bar. They can be a; sub-menu of another popup menu (cascading menus) or can be standalone; (as a context menu). They are made of one or more menu items choices.; When displayed, the menu items are arranged in a vertical list. Usually; they correspond to actions (e.g. `Open`**)**. These items can be labeled; with text, graphics or a combination of both. Each of them should have a; character defined as its unique key for access. Grouped logically by; their functionality, they are separated visually by menu separators in; groups. For example, The `File` menu is a common menu title for tasks; that apply to a file, as **`Open`**,**`Save`**,**`Close`**,**`Print`**... ``` {.cpp}; // a popup menu; fMenuFile = new TGPopupMenu(gClient->GetRoot());. // adding menu entries; fMenuFile->AddEntry(""&Open..."",M_FILE_OPEN);; fMenuFile->AddEntry(""&Save"",M_FILE_SAVE);; fMenuFile->AddEntry(""S&ave as..."",M_FILE_SAVEAS);; fMenuFile->AddEntry(""&Close"", -1);. // adding separator; fMenuFile->AddSeparator();. // next group of menu entries; fMenuFile->AddEntry(""&Print"",M_FILE_PRINT);; fMenuFile->AddEntry(""P&rint setup..."",M_FILE_PRINTSETUP);; . . .; fMenuFile->AddSeparator();; fMenuFile->AddEntry(""E&xit"",M_FILE_EXIT);; ```. First we create the File menu by creating an object of; class**` TGPopupMenu`** and adding menu entries with `AddEntry` method.; Its first parameter is a hot string, the second",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:69820,access,access,69820,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security,"o get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be loaded at startup. However, when calling into ROOT; functions from python, that won't happen, since python is not sanitised. Therefore, the address sanitizer runtime has to be preloaded with; `LD_PRELOAD=<pathToRuntime>:libROOTSanitizerConfig.<so|dylib> pythonX ROOTScript.py`. Preloading the shared sanitizer config as above is optional, but recommended, because it adds leak sanitizer suppressions. On Mac, preloading is theoretically possible, but code signing and man",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:2284,sanitiz,sanitizer,2284,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['sanitiz'],['sanitizer']
Security,"o install the experiment; environment scripts system-wide. Configuration scripts for LHC experiments are shipped with the VAF; client and can be found in; `/dest/dir/client/config-samples/<experiment_name>`. To make them used; by default by the VAF client, place them in the `/dest/dir/etc`; directory like this:. ``` {.bash}; rsync -a /dest/dir/client/config-samples/<experiment_name>/ /dest/dir/etc/; ```. Remember that the trailing slash in the source directory name has a; meaning in `rsync` and must not be omitted. > Remember that system-wide configuration files will always have; > precedence over user's configuration files, so *don't place there; > files that are supposed to be provided by the user!*. Entering the Virtual Analysis Facility environment; --------------------------------------------------. The Virtual Analysis Facility client is a wrapper around commands sent; to the remote host by means of PROOF on Demand's `pod-remote`. The VAF; client takes care of setting up passwordless SSH from your client node; to the VAF master. ### Getting the credentials. > You can skip this paragraph if the remote server wasn't configured for; > HTTPS+SSH authentication. In our example we will assume that the remote server's name is; `cloud-gw-213.to.infn.it`: substitute it with your remote endpoint. First, check that you have your Grid certificate and private key; installed both in your browser and in the home directory of your; client. Point your browser to `https://cloud-gw-213.to.infn.it/auth/`: you'll; probably be asked for a certificate to choose for authentication. Pick; one and you'll be presented with the following web page:. ![Web authentication with sshcertauth](img/sshcertauth-web.png). The webpage clearly explains you what to do next. ### Customizing user's configuration. Before entering the VAF environment, you should customize the user's; configuration. How to do so depends on your experiment, but usually you; should essentially specify the version of the exp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md:8384,password,passwordless,8384,proof/doc/confman/UsingVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/UsingVirtualAnalysisFacility.md,1,['password'],['passwordless']
Security,"o=thin``; enabled and be statically linked into the program. This scheme is currently not compatible with cross-DSO CFI or the; Microsoft ABI. .. _cfi-ignorelist:. Ignorelist; ==========. A :doc:`SanitizerSpecialCaseList` can be used to relax CFI checks for certain; source files, functions and types using the ``src``, ``fun`` and ``type``; entity types. Specific CFI modes can be be specified using ``[section]``; headers. .. code-block:: bash. # Suppress all CFI checking for code in a file.; src:bad_file.cpp; src:bad_header.h; # Ignore all functions with names containing MyFooBar.; fun:*MyFooBar*; # Ignore all types in the standard library.; type:std::*; # Disable only unrelated cast checks for this function; [cfi-unrelated-cast]; fun:*UnrelatedCast*; # Disable CFI call checks for this function without affecting cast checks; [cfi-vcall|cfi-nvcall|cfi-icall]; fun:*BadCall*. .. _cfi-cross-dso:. Shared library support; ======================. Use **-f[no-]sanitize-cfi-cross-dso** to enable the cross-DSO control; flow integrity mode, which allows all CFI schemes listed above to; apply across DSO boundaries. As in the regular CFI, each DSO must be; built with ``-flto`` or ``-flto=thin``. Normally, CFI checks will only be performed for classes that have hidden LTO; visibility. With this flag enabled, the compiler will emit cross-DSO CFI; checks for all classes, except for those which appear in the CFI ignorelist; or which use a ``no_sanitize`` attribute. Design; ======. Please refer to the :doc:`design document<ControlFlowIntegrityDesign>`. Publications; ============. `Control-Flow Integrity: Principles, Implementations, and Applications <https://research.microsoft.com/pubs/64250/ccs05.pdf>`_.; Martin Abadi, Mihai Budiu, Úlfar Erlingsson, Jay Ligatti. `Enforcing Forward-Edge Control-Flow Integrity in GCC & LLVM <http://www.pcc.me.uk/~peter/acad/usenix14.pdf>`_.; Caroline Tice, Tom Roeder, Peter Collingbourne, Stephen Checkoway,; Úlfar Erlingsson, Luis Lozano, Geoff Pike.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:18194,sanitiz,sanitize-cfi-cross-dso,18194,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,2,"['integrity', 'sanitiz']","['integrity', 'sanitize-cfi-cross-dso']"
Security,"oading dictionaries is fine if this is hidden under the hood of; a Python package and thus transparently done on ``import``.; Otherwise, the automatic class loader is more convenient, as it allows direct; use without having to manually find and load dictionaries (assuming these are; locatable by the dynamic loader). The class loader utilizes so-called rootmap files, which by convention should; live alongside the dictionary shared library (and C++ module file).; These are simple text files, which map C++ entities (such as classes) to the; dictionaries and other libraries that need to be loaded for their use. With ``genreflex``, the mapping file can be automatically created with; ``--rootmap-lib=MyClassDict``, where ""MyClassDict"" is the name of the shared; library (without the extension) build from the dictionary file.; With ``rootcling``, create the same mapping file with; ``-rmf MyClassDict.rootmap -rml MyClassDict``.; It is necessary to provide the final library name explicitly, since it is; only in the separate linking step where these names are fixed and those names; may not match the default choice. With the mapping file in place, the above example can be rerun without; explicit loading of the dictionary:. .. code-block:: python. >>> import cppyy; >>> from cppyy.gbl import MyClass; >>> MyClass(42).get_int(); 42; >>>. .. _cppyy-generator:. Bindings collection; -------------------. ``cppyy-generator`` is a clang-based utility program which takes a set of C++; header files and generates a JSON output file describing the objects found in; them.; This output is intended to support more convenient access to a set of; cppyy-supported bindings::. $ cppyy-generator --help; usage: cppyy-generator [-h] [-v] [--flags FLAGS] [--libclang LIBCLANG]; output sources [sources ...]; ... This utility is mainly used as part of the; :doc:`CMake interface <cmake_interface>`. .. _`support for exporting all`: https://cmake.org/cmake/help/latest/prop_tgt/WINDOWS_EXPORT_ALL_SYMBOLS.html; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst:9816,access,access,9816,bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/utilities.rst,1,['access'],['access']
Security,"oads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is in",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45181,inject,inject,45181,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['inject'],['inject']
Security,"oal.; Especially for new contributors, that often means many rounds of reviews; and push-back on design decisions that do not fit well within the; overall architecture of the project. For your first patches, this means:. - be kind, and expect reviewers to be kind in return - LLVM has a `Code; of Conduct <https://llvm.org/docs/CodeOfConduct.html>`__;. - be patient - understanding how a new feature fits into the; architecture of the project is often a time consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if you can't agree, generally the best way is to do what the reviewer; asks; we optimize for readability of the code, which the reviewer is; in a better position to judge; if this feels like it's not the right; option, you can contact the cfe-dev mailing list to get more feedback; on the direction;. Commit access; =============. Once you've contributed a handful of patches to LLVM, start to think; about getting commit access yourself. It's probably a good idea if:. - you've landed 3-5 patches of larger scope than ""fix a typo"". - you'd be willing to review changes that are closely related to yours. - you'd like to keep contributing to LLVM. Getting commit access; ---------------------. LLVM uses Git for committing changes. The details are in the `developer; policy; document <https://llvm.org/docs/DeveloperPolicy.html#obtaining-commit-access>`__. With great power; ----------------. Actually, this would be a great time to read the rest of the `developer; policy <https://llvm.org/docs/DeveloperPolicy.html>`__, too. At minimum,; you need to be subscribed to the relevant commits list before landing; changes (e.g. llvm-commits@lists.llvm.org), as discussion often happens; there if a new patch causes problems. Post-commit errors; ------------------. Once your change is submitted it will be picked up by automated build; bots that will build and test your patch in a varie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:12768,access,access,12768,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['access'],['access']
Security,"objc. @interface A; + (instancetype)constructAnA;; @end. The related result type can also be inferred for some methods. To determine; whether a method has an inferred related result type, the first word in the; camel-case selector (e.g., ""``init``"" in ""``initWithObjects``"") is considered,; and the method will have a related result type if its return type is compatible; with the type of its class and if:. * the first word is ""``alloc``"" or ""``new``"", and the method is a class method,; or. * the first word is ""``autorelease``"", ""``init``"", ""``retain``"", or ""``self``"",; and the method is an instance method. If a method with a related result type is overridden by a subclass method, the; subclass method must also return a type that is compatible with the subclass; type. For example:. .. code-block:: objc. @interface NSString : NSObject; - (NSUnrelated *)init; // incorrect usage: NSUnrelated is not NSString or a superclass of NSString; @end. Related result types only affect the type of a message send or property access; via the given method. In all other respects, a method with a related result; type is treated the same way as method that returns ``id``. Use ``__has_feature(objc_instancetype)`` to determine whether the; ``instancetype`` contextual keyword is available. Automatic reference counting; ----------------------------. Clang provides support for :doc:`automated reference counting; <AutomaticReferenceCounting>` in Objective-C, which eliminates the need; for manual ``retain``/``release``/``autorelease`` message sends. There are three; feature macros associated with automatic reference counting:; ``__has_feature(objc_arc)`` indicates the availability of automated reference; counting in general, while ``__has_feature(objc_arc_weak)`` indicates that; automated reference counting also includes support for ``__weak`` pointers to; Objective-C objects. ``__has_feature(objc_arc_fields)`` indicates that C structs; are allowed to have fields that are pointers to Objective-C ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:70466,access,access,70466,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access']
Security,"object can be registered directly to the server with a [THttpServer::Register()](https://root.cern/doc/master/classTHttpServer.html#a73658daf379e87a4832fe9dc5c1483ed) call. Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the `gSystem->ProcessEvents()` call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session. If an application runs in compiled code and does not contain `gSystem->ProcessEvents()` calls, two method are available. ### Asynchronous timer. The first method is to configure an asynchronous timer for the server, like for example:. ```cpp; serv->SetTimer(100, kFALSE);; ```. Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of **`TH1::Fill()`** calls and an histogram object may be incomplete. Therefore such method is not recommended. ### Regular calls of THttpServer::ProcessRequests() method. The second method is preferable - one just inserts in the application regular calls of the THttpServer::ProcessRequests() method, like:. ```cpp; serv->ProcessRequests();; ```. In such case, one can fully disable the timer of the server:. ```cpp; serv->SetTimer(0, kTRUE);; ```. ## Data access from command shell. The big advantage of the http protocol is that it is not only supported in web browsers, but also in many other applications. One could use http requests to directly access ROOT objects and data members from any kind of scripts. If one starts a server and register an object like for example:. ```cpp; auto serv = new THttpServer(""http:8080"");; TNamed* n1 = new TNamed(""obj"", ""title"");; serv->Register(""subfolder"", n1);; ```. One could request a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:13836,access,access,13836,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['access']
Security,"ocs/GoldPlugin.html. .. _cfi-schemes:. Available schemes; =================. Available schemes are:. - ``-fsanitize=cfi-cast-strict``: Enables :ref:`strict cast checks; <cfi-strictness>`.; - ``-fsanitize=cfi-derived-cast``: Base-to-derived cast to the wrong; dynamic type.; - ``-fsanitize=cfi-unrelated-cast``: Cast from ``void*`` or another; unrelated type to the wrong dynamic type.; - ``-fsanitize=cfi-nvcall``: Non-virtual call via an object whose vptr is of; the wrong dynamic type.; - ``-fsanitize=cfi-vcall``: Virtual call via an object whose vptr is of the; wrong dynamic type.; - ``-fsanitize=cfi-icall``: Indirect call of a function with wrong dynamic; type.; - ``-fsanitize=cfi-mfcall``: Indirect call via a member function pointer with; wrong dynamic type. You can use ``-fsanitize=cfi`` to enable all the schemes and use; ``-fno-sanitize`` flag to narrow down the set of schemes as desired.; For example, you can build your program with; ``-fsanitize=cfi -fno-sanitize=cfi-nvcall,cfi-icall``; to use all schemes except for non-virtual member function call and indirect call; checking. Remember that you have to provide ``-flto`` or ``-flto=thin`` if at; least one CFI scheme is enabled. Trapping and Diagnostics; ========================. By default, CFI will abort the program immediately upon detecting a control; flow integrity violation. You can use the :ref:`-fno-sanitize-trap=; <controlling-code-generation>` flag to cause CFI to print a diagnostic; similar to the one below before the program aborts. .. code-block:: console. bad-cast.cpp:109:7: runtime error: control flow integrity check for type 'B' failed during base-to-derived cast (vtable address 0x000000425a50); 0x000000425a50: note: vtable is of type 'A'; 00 00 00 00 f0 f1 41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 20 5a 42 00; ^. If diagnostics are enabled, you can also configure CFI to continue program; execution instead of aborting by using the :ref:`-fsanitize-recover=; <controlling-code",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:3004,sanitiz,sanitize,3004,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['sanitiz'],['sanitize']
Security,"ode Insertion:. Prolog/Epilog Code Insertion; ----------------------------. .. note::. To Be Written. Compact Unwind; --------------. Throwing an exception requires *unwinding* out of a function. The information on; how to unwind a given function is traditionally expressed in DWARF unwind; (a.k.a. frame) info. But that format was originally developed for debuggers to; backtrace, and each Frame Description Entry (FDE) requires ~20-30 bytes per; function. There is also the cost of mapping from an address in a function to the; corresponding FDE at runtime. An alternative unwind encoding is called *compact; unwind* and requires just 4-bytes per function. The compact unwind encoding is a 32-bit value, which is encoded in an; architecture-specific way. It specifies which registers to restore and from; where, and how to unwind out of the function. When the linker creates a final; linked image, it will create a ``__TEXT,__unwind_info`` section. This section is; a small and fast way for the runtime to access unwind info for any given; function. If we emit compact unwind info for the function, that compact unwind; info will be encoded in the ``__TEXT,__unwind_info`` section. If we emit DWARF; unwind info, the ``__TEXT,__unwind_info`` section will contain the offset of the; FDE in the ``__TEXT,__eh_frame`` section in the final linked image. For X86, there are three modes for the compact unwind encoding:. *Function with a Frame Pointer (``EBP`` or ``RBP``)*; ``EBP/RBP``-based frame, where ``EBP/RBP`` is pushed onto the stack; immediately after the return address, then ``ESP/RSP`` is moved to; ``EBP/RBP``. Thus to unwind, ``ESP/RSP`` is restored with the current; ``EBP/RBP`` value, then ``EBP/RBP`` is restored by popping the stack, and the; return is done by popping the stack once more into the PC. All non-volatile; registers that need to be restored must have been saved in a small range on; the stack that starts ``EBP-4`` to ``EBP-1020`` (``RBP-8`` to; ``RBP-1020``). The offset ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:71855,access,access,71855,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['access']
Security,"ode snippet for such a walk looks like this:. .. code-block:: c++. MemoryDef *Def; // find who's optimized or defining for this MemoryDef; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *DefUser = cast_of_null<MemoryDef>MA); if (DefUser->isOptimized() && DefUser->getOptimized() == Def) {; // User who is optimized to Def; } else {; // User who's defining access is Def; optimized to something else or not optimized.; }; }. When ``MemoryUse``\ s are optimized, for a given store, you can find all loads; clobbered by that store by walking the immediate and transitive uses of; the store. .. code-block:: c++. checkUses(MemoryAccess *Def) { // Def can be a MemoryDef or a MemoryPhi.; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *MU = cast_of_null<MemoryUse>MA) {; // Process MemoryUse as needed.; }; else {; // Process MemoryDef or MemoryPhi as needed. // As a user can come up twice, as an optimized access and defining; // access, keep a visited list. // Check transitive uses as needed; checkUses (MA); // use a worklist for an iterative algorithm; }; }; }. An example of similar traversals can be found in the DeadStoreElimination pass. Invalidation and updating; -------------------------. Because ``MemorySSA`` keeps track of LLVM IR, it needs to be updated whenever; the IR is updated. ""Update"", in this case, includes the addition, deletion, and; motion of ``Instructions``. The update API is being made on an as-needed basis.; If you'd like examples, ``GVNHoist`` and ``LICM`` are users of ``MemorySSA``\ s; update API.; Note that adding new ``MemoryDef``\ s (by calling ``insertDef``) can be a; time-consuming update, if the new access triggers many ``MemoryPhi`` insertions and; renaming (optimization invalidation) of many ``MemoryAccesses``\ es. Phi placement; ^^^^^^^^^^^^^. ``MemorySSA`` only places ``MemoryPhi``\ s where they're actually; needed. That is, it is a pruned SSA form, like ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:13814,access,access,13814,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,2,['access'],['access']
Security,"of *trap base address* register. GFX7, GFX8; [tba_lo] Low 32 bits of *trap base address* register (an SP3 syntax). GFX7, GFX8; [tba_hi] High 32 bits of *trap base address* register (an SP3 syntax). GFX7, GFX8; ================== ======================================================================= =============. .. _amdgpu_synid_tma:. tma; ---. Trap memory address, 64-bits wide. ================= ======================================================================= ==================; Syntax Description Availability; ================= ======================================================================= ==================; tma 64-bit *trap memory address* register. GFX7, GFX8; [tma] 64-bit *trap memory address* register (an SP3 syntax). GFX7, GFX8; [tma_lo,tma_hi] 64-bit *trap memory address* register (an SP3 syntax). GFX7, GFX8; ================= ======================================================================= ==================. High and low 32 bits of *trap memory address* may be accessed as separate registers:. ================= ======================================================================= ==================; Syntax Description Availability; ================= ======================================================================= ==================; tma_lo Low 32 bits of *trap memory address* register. GFX7, GFX8; tma_hi High 32 bits of *trap memory address* register. GFX7, GFX8; [tma_lo] Low 32 bits of *trap memory address* register (an SP3 syntax). GFX7, GFX8; [tma_hi] High 32 bits of *trap memory address* register (an SP3 syntax). GFX7, GFX8; ================= ======================================================================= ==================. .. _amdgpu_synid_flat_scratch:. flat_scratch; ------------. Flat scratch address, 64-bits wide. Holds the base address of scratch memory. ================================== ================================================================; Syntax Description; ================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:13948,access,accessed,13948,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['access'],['accessed']
Security,"of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{dim's 0's, index}``. '``llvm.preserve.union.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <type>; @llvm.preserve.union.access.index.p0s_union.anons.p0s_union.anons(<type> base,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic carries the debuginfo field index; ``di_index`` and returns the ``base`` address.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide union debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``type`` is the same as the ``base`` type. Arguments:; """""""""""""""""""". The ``base`` is the union base address. The ``di_index`` is the field index in debuginfo. Semantics:; """""""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic returns the ``base`` address. '``llvm.preserve.struct.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.struct.access.index.p0i8.p0s_struct.anon.0s(<type> base,; i32 gep_index,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.struct.access.index``' intrinsic returns the getelementptr address; based on struct base ``base`` and IR struct member index ``gep_index``.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:974381,access,access,974381,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,of allocation; Unknown. 625; CD2; Use of auto as a template-argument; Yes. 626; CD2; Preprocessor string literals; Yes. 627; NAD; Values behaving as types; Yes. 628; CD2; The values of an enumeration with no enumerator; N/A. 629; CD1; auto parsing ambiguity; Clang 2.9. 630; CD2; Equality of narrow and wide character values in the basic character set; Yes. 631; CD3; Jumping into a “then” clause; N/A. 632; CD1; Brace-enclosed initializer for scalar member of aggregate; Yes. 633; CD2; Specifications for variables that should also apply to references; N/A. 634; CD1; Conditionally-supported behavior for non-POD objects passed to ellipsis redux; Yes. 635; NAD; Names of constructors and destructors of templates; Yes. 636; CD4; Dynamic type of objects and aliasing; Unknown. 637; CD1; Sequencing rules and example disagree; Yes. 638; CD2; Explicit specialization and friendship; No. 639; CD1; What makes side effects “different” from one another?; Clang 3.3. 640; NAD; Accessing destroyed local objects of static storage duration; Unknown. 641; CD2; Overload resolution and conversion-to-same-type operators; Yes. 642; CD2; Definition and use of “block scope” and “local scope”; Yes. 643; NAD; Use of decltype in a class member-specification; Clang 3.2. 644; CD1; Should a trivial class type be a literal type?; Partial. 645; CD2; Are bit-field and non-bit-field members layout compatible?; N/A. 646; NAD; Can a class with a constexpr copy constructor be a literal type?; Superseded by 981. 647; CD1; Non-constexpr instances of constexpr constructor templates; Clang 3.1. 648; CD1; Constant expressions in constexpr initializers; Yes. 649; CD1; Optionally ill-formed extended alignment requests; Clang 3.5. 650; CD2; Order of destruction for temporaries bound to the returned value of a function; Unknown. 651; CD1; Problems in decltype specification and examples; Yes. 652; CD2; Compile-time evaluation of floating-point expressions; Yes. 653; CD2; Copy assignment of unions; Unknown. 654; CD1; Con,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:43662,Access,Accessing,43662,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Accessing']
Security,"of the LLVM; ``GlobalVariable`` class.; - **typed variables** - Kaleidoscope currently only supports variables; of type double. This gives the language a very nice elegance, because; only supporting one type means that you never have to specify types.; Different languages have different ways of handling this. The easiest; way is to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage; Collection <../../GarbageCollection.html>`_ including algorithms that; move objects and need to scan/update the stack.; - **exception handling support** - LLVM supports generation of `zero; cost exceptions <../../ExceptionHandling.html>`_ which interoperate wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:2797,access,access,2797,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['access'],['access']
Security,"of the box; * Strict rules for the contents of tables. Table size is important and the accelerator table format should allow the reuse; of strings from common string tables so the strings for the names are not; duplicated. We also want to make sure the table is ready to be used as-is by; simply mapping the table into memory with minimal header parsing. The name lookups need to be fast and optimized for the kinds of lookups that; debuggers tend to do. Optimally we would like to touch as few parts of the; mapped table as possible when doing a name lookup and be able to quickly find; the name entry we are looking for, or discover there are no matches. In the; case of debuggers we optimized for lookups that fail most of the time. Each table that is defined should have strict rules on exactly what is in the; accelerator tables and documented so clients can rely on the content. Hash Tables; ^^^^^^^^^^^. Standard Hash Tables; """""""""""""""""""""""""""""""""""""""". Typical hash tables have a header, buckets, and each bucket points to the; bucket contents:. .. code-block:: none. .------------.; | HEADER |; |------------|; | BUCKETS |; |------------|; | DATA |; `------------'. The BUCKETS are an array of offsets to DATA for each hash:. .. code-block:: none. .------------.; | 0x00001000 | BUCKETS[0]; | 0x00002000 | BUCKETS[1]; | 0x00002200 | BUCKETS[2]; | 0x000034f0 | BUCKETS[3]; | | ...; | 0xXXXXXXXX | BUCKETS[n_buckets]; '------------'. So for ``bucket[3]`` in the example above, we have an offset into the table; 0x000034f0 which points to a chain of entries for the bucket. Each bucket must; contain a next pointer, full 32 bit hash value, the string itself, and the data; for the current string value. .. code-block:: none. .------------.; 0x000034f0: | 0x00003500 | next pointer; | 0x12345678 | 32 bit hash; | ""erase"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003500: | 0x00003550 | next pointer; | 0x29273623 | 32 bit hash; | ""dump"" | string value; | data[n] | HashD",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:60879,hash,hash,60879,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"of the boxes (`X,` `Y,` `Z,` `Cut`, or `Scan`). To scan one or more; variables, drop them into the Scan box, then double click on the box.; You can also redirect the result of the scan to a file by checking the; Scan box on top. ![](pictures/030000F5.png). When the ""`Rec`"" box is checked, the `Draw` and `Scan` commands are; recorded in the history file and echoed on the command line. The; ""Histogram"" text box contains the name of the resulting histogram. By; default it is `htemp`. You can type any name, if the histogram does not; exist it will create one. The Option text box contains the list of Draw; options. See ""Draw Options"". You can select the options with the Options; menu. The Command box lets you enter any command that you could also; enter on the command line. The vertical slider on the far left side can; be used to select the minimum and maximum of an event range. The actual; start and end index are shown in on the bottom in the status window. There is an extensive help utility accessible with the Help menu. The; `IList` and `OList` are to `specify` an input list of entry indices and; a name for the output list respectively. Both need to be of type; **`TList`** and contain integers of entry indices. These lists are; described below in the paragraph ""**Error! Reference source not; found.**"". ![A couple of graphs](pictures/030000F6.png). The first one is a plot of the age distribution, the second a scatter; plot of the cost vs. age. The second one was generated by dragging the; age leaf into the Y-box and the cost leaf into the X-box, and pressing; the Draw button. By default, this will generate a scatter plot. Select a; different option, for example `""lego""` to create a 2D histogram. ## Creating and Saving Trees. This picture shows the **`TTree`** class:. ![The TTree class](pictures/030000F8.png). To create a **`TTree`** we use its constructor. Then we design our data; layout and add the branches. A tree can be created by giving a name and; title:. ``` {.cp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:11048,access,accessible,11048,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['accessible']
Security,"of the caller of ``llvm.localescape``. Arguments:; """""""""""""""""""". All arguments to '``llvm.localescape``' must be pointers to static allocas or; casts of static allocas. Each function can only call '``llvm.localescape``'; once, and it can only do so from the entry block. The ``func`` argument to '``llvm.localrecover``' must be a constant; bitcasted pointer to a function defined in the current module. The code; generator cannot determine the frame allocation offset of functions defined in; other modules. The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a; call frame that is currently live. The return value of '``llvm.localaddress``'; is one way to produce such a value, but various runtimes also expose a suitable; pointer in platform-specific ways. The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to; '``llvm.localescape``' to recover. It is zero-indexed. Semantics:; """""""""""""""""""". These intrinsics allow a group of functions to share access to a set of local; stack allocations of a one parent function. The parent function may call the; '``llvm.localescape``' intrinsic once from the function entry block, and the; child functions can use '``llvm.localrecover``' to access the escaped allocas.; The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where; the escaped allocas are allocated, which would break attempts to use; '``llvm.localrecover``'. '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.try.begin(); declare void @llvm.seh.try.end(). Overview:; """""""""""""""""". The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark; the boundary of a _try region for Windows SEH Asynchrous Exception Handling. Semantics:; """""""""""""""""""". When a C-function is compiled with Windows SEH Asynchrous Exception option,; -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to mark _try; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:514718,access,access,514718,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"of the program. BPF_IND | BPF_W | BPF_LD is equivalent to:; R0 = ntohl(\*(u32 \*) (((struct sk_buff \*) R6)->data + src_reg + imm32)). eBPF maps; ^^^^^^^^^. eBPF maps are provided for sharing data between kernel and user-space.; Currently implemented types are hash and array, with potential extension to; support bloom filters, radix trees, etc. A map is defined by its type,; maximum number of elements, key size and value size in bytes. eBPF syscall; supports create, update, find and delete functions on maps. Function calls; ^^^^^^^^^^^^^^. Function call arguments are passed using up to five registers (R1 - R5).; The return value is passed in a dedicated register (R0). Four additional; registers (R6 - R9) are callee-saved, and the values in these registers; are preserved within kernel functions. R0 - R5 are scratch registers within; kernel functions, and eBPF programs must therefor store/restore values in; these registers if needed across function calls. The stack can be accessed; using the read-only frame pointer R10. eBPF registers map 1:1 to hardware; registers on x86_64 and other 64-bit architectures. For example, x86_64; in-kernel JIT maps them as. ::. R0 - rax; R1 - rdi; R2 - rsi; R3 - rdx; R4 - rcx; R5 - r8; R6 - rbx; R7 - r13; R8 - r14; R9 - r15; R10 - rbp. since x86_64 ABI mandates rdi, rsi, rdx, rcx, r8, r9 for argument passing; and rbx, r12 - r15 are callee saved. Program start; ^^^^^^^^^^^^^. An eBPF program receives a single argument and contains; a single eBPF main routine; the program does not contain eBPF functions.; Function calls are limited to a predefined set of kernel functions. The size; of a program is limited to 4K instructions: this ensures fast termination and; a limited number of kernel function calls. Prior to running an eBPF program,; a verifier performs static analysis to prevent loops in the code and; to ensure valid register usage and operand types. The AMDGPU backend; ------------------. The AMDGPU code generator lives in the ``lib/Ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:107325,access,accessed,107325,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accessed']
Security,"of times. ---. ```c++; template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; using BLAKE3Result = std::array<uint8_t, NumBytes>;. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; void BLAKE3::final(BLAKE3Result<NumBytes> &Result);. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; BLAKE3Result<NumBytes> BLAKE3::final();; ```; ```c; void llvm_blake3_hasher_finalize(; const llvm_blake3_hasher *self,; uint8_t *out,; size_t out_len);; ```. Finalize the hasher and return an output of any length, given in bytes.; This doesn't modify the hasher itself, and it's possible to finalize; again after adding more input. The constant `LLVM_BLAKE3_OUT_LEN` provides; the default output length, 32 bytes, which is recommended for most; callers. Outputs shorter than the default length of 32 bytes (256 bits) provide; less security. An N-bit BLAKE3 output is intended to provide N bits of; first and second preimage resistance and N/2 bits of collision; resistance, for any N up to 256. Longer outputs don't provide any; additional security. Shorter BLAKE3 outputs are prefixes of longer ones. Explicitly; requesting a short output is equivalent to truncating the default-length; output. (Note that this is different between BLAKE2 and BLAKE3.). ## Less Common API Functions. ```c; void llvm_blake3_hasher_init_keyed(; llvm_blake3_hasher *self,; const uint8_t key[LLVM_BLAKE3_KEY_LEN]);; ```. Initialize a `llvm_blake3_hasher` in the keyed hashing mode. The key must be; exactly 32 bytes. ---. ```c; void llvm_blake3_hasher_init_derive_key(; llvm_blake3_hasher *self,; const char *context);; ```. Initialize a `llvm_blake3_hasher` in the key derivation mode. The context; string is given as an initialization parameter, and afterwards input key; material should be given with `llvm_blake3_hasher_update`. The context string; is a null-terminated C string which should be **hardcoded, globally; unique, and application-specific**. The context string should not; include any dynamic input like salts, nonces, or iden",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:3993,secur,security,3993,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['secur'],['security']
Security,"of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:5826,hash,hashing,5826,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['hash'],['hashing']
Security,"of(Value) │; ... ├─ |Capacity| Bucket entries; .--------------------. │; | Key | │; .--------------------. │; | Value | │; .--------------------. ─╯. - **Size** - The number of values contained in the hash table. - **Capacity** - The number of buckets in the hash table. Producers should; maintain a load factor of no greater than ``2/3*Capacity+1``. - **Present Bit Vector** - A serialized bit vector which contains information; about which buckets have valid values. If the bucket has a value, the; corresponding bit will be set, and if the bucket doesn't have a value (either; because the bucket is empty or because the value is a tombstone value) the bit; will be unset. - **Deleted Bit Vector** - A serialized bit vector which contains information; about which buckets have tombstone values. If the entry in this bucket is; deleted, the bit will be set, otherwise it will be unset. - **Keys and Values** - A list of ``Capacity`` hash buckets, where the first; entry is the key (always a uint32), and the second entry is the value. The; state of each bucket (valid, empty, deleted) can be determined by examining; the present and deleted bit vectors. .. _hash_bit_vectors:. Present and Deleted Bit Vectors; ===============================. The bit vectors indicating the status of each bucket are serialized as follows:. .. code-block:: none. .--------------------.-- +0; | Word Count |; .--------------------.-- +4; | Word_0 | ─╮; .--------------------.-- +8 │; | Word_1 | │; .--------------------.-- +12 ├─ |Word Count| values; ... │; .--------------------. │; | Word_N | │; .--------------------. ─╯. The words, when viewed as a contiguous block of bytes, represent a bit vector; with the following layout:. .. code-block:: none. .------------. .------------.------------.; | Word_N | ... | Word_1 | Word_0 |; .------------. .------------.------------.; | | | | |; +N*32 +(N-1)*32 +64 +32 +0. where the k'th bit of this bit vector represents the status of the k'th bucket; in the hash table.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/HashTable.rst:3268,hash,hash,3268,interpreter/llvm-project/llvm/docs/PDB/HashTable.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/HashTable.rst,1,['hash'],['hash']
Security,"official release qualification criteria. It is up to the; the release manager to determine when a release is ready. The release manager; should pay attention to the results of community testing, the number of outstanding; bugs, and then number of regressions when determining whether or not to make a; release. The community values time based releases, so releases should not be delayed for; too long unless there are critical issues remaining. In most cases, the only; kind of bugs that are critical enough to block a release would be a major regression; from a previous release. Official Testing; ----------------. A few developers in the community have dedicated time to validate the release; candidates and volunteered to be the official release testers for each; architecture. These will be the ones testing, generating and uploading the official binaries; to the server, and will be the minimum tests *necessary* for the release to; proceed. This will obviously not cover all OSs and distributions, so additional community; validation is important. However, if community input is not reached before the; release is out, all bugs reported will have to go on the next stable release. The official release managers are:. * Even releases: Tom Stellard (tstellar@redhat.com); * Odd releases: Tobias Hieta (tobias@hieta.se). The official release testers are volunteered from the community and have; consistently validated and released binaries for their targets/OSs. To contact; them, you should post on the `Discourse forums (Project; Infrastructure - Release Testers). <https://discourse.llvm.org/c/infrastructure/release-testers/66>`_. The official testers list is in the file ``RELEASE_TESTERS.TXT``, in the ``LLVM``; repository. Community Testing; -----------------. Once all testing has been completed and appropriate bugs filed, the release; candidate tarballs are put on the website and the LLVM community is notified. We ask that all LLVM developers test the release in any the following ways",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:7227,validat,validation,7227,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['validat'],['validation']
Security,"ogical to expose C++ classes as Python ones, including the full; inheritance hierarchy. The C++ code used for the examples below can be found; :doc:`here <cppyy_features_header>`, and it is assumed that that code is; loaded at the start of any session.; Download it, save it under the name ``features.h``, and load it:. .. code-block:: python. >>> import cppyy; >>> cppyy.include('features.h'); >>>. `Basics`; --------. All bound C++ code starts off from the global C++ namespace, represented in; Python by ``gbl``.; This namespace, as any other namespace, is treated as a module after it has; been loaded.; Thus, we can import C++ classes that live underneath it:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> Concrete; <class cppyy.gbl.Concrete at 0x2058e30>; >>>. Placing classes in the same structure as imposed by C++ guarantees identity,; even if multiple Python modules bind the same class.; There is, however, no necessity to expose that structure to end-users: when; developing a Python package that exposes C++ classes through ``cppyy``,; consider ``cppyy.gbl`` an ""internal"" module, and expose the classes in any; structure you see fit.; The C++ names will continue to follow the C++ structure, however, as is needed; for e.g. pickling:. .. code-block:: python. >>> from cppyy.gbl import Namespace; >>> Concrete == Namespace.Concrete; False; >>> n = Namespace.Concrete.NestedClass(); >>> type(n); <class cppyy.gbl.Namespace.Concrete.NestedClass at 0x22114c0>; >>> type(n).__name__; NestedClass; >>> type(n).__module__; cppyy.gbl.Namespace.Concrete; >>> type(n).__cpp_name__; Namespace::Concrete::NestedClass; >>>. `Constructors`; --------------. Python and C++ both make a distinction between allocation (``__new__`` in; Python, ``operator new`` in C++) and initialization (``__init__`` in Python,; the constructor call in C++).; When binding, however, there comes a subtle semantic difference: the Python; ``__new__`` allocates memory for the proxy object only, and ``__",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:1067,expose,expose,1067,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,2,['expose'],"['expose', 'exposes']"
Security,"ols that allow the user control over where clang-cl will; locate these headers. The default behaviour for the Windows SDK and UCRT is as; follows:. 1. Consult the command line. Anything the user specifies is always given precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ To",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:194804,validat,validation,194804,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['validat'],['validation']
Security,"olution is off. The streamer and process id; information are send only once per socket (and is supported for all; types of; sockets, TSocket, TPSocket and TXSocket). If you communicate between; two; ROOT based applications, check the version numbers on both sides. If; they; are not the same enable the schema evolution support (in case ROOT; objects; are transferred). . XROOTD. New version 20080621-0000 containing several improvements and fixes; Server:. New daemon 'cmsd' supposed to replace 'olbd' with improved performances; Improved polling strategy; Fix problem with handling writev creating unjustified disconnections ; Fix problem with setrlimit on MacOsX Leopard. Client:; ; Fix a nasty memory leak in XrdClientCacheRead affecting; processing via TChain; Optimized file closing recipe; Fix; potential cache thrashing problem with big blocks requests. Fixes / improvements in the GSI plug-in:; ; support for large (> 32 bits) certificate serial; numbers in CRL handling; support for an external function for DN-to-username; mapping function; provide example for an LDAP based search; fixed a few problem with return code checking. netx. TXNetFile:; . Enable dynamic cache size synchronization; ; Enable per-instance control of the cache parameters; also for RAW files; by; default cache is OFF for these files, but there maybe cases in which the cache can; improve performances.; Remove call to XrdClient::Sync in SysStat. Correctly honor the create/recreate options coming from TFile::Open(); Allow the size of the (written) file to be retrieved after the Close (solves several reported file size mismatches).; . TXNetSystem:; ; Fix problem with GetDirEntry: the entry object was; going out-of-scope so; that the returned string was meaningless.; Reset; the list if dir entries in FreeDirectory.; Fix problem affecting repeated calls. The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html:1227,certificate,certificate,1227,net/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v520/index.html,2,['certificate'],['certificate']
Security,"om 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global handle:. ```javascript; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; ```. ### Use of JSON. It is strongly recommended to use JSON when communicating with ROOT application.; THttpServer provides a JSON representation for every registered object with an url address like:. http://your_root_server:8080/Canvases/c1/root.json. Such JSON representation generated using the [TBufferJSON](https://root.cern/doc/master/classTBufferJSON.html) class. One could create JSON file for any ROOT object directly, just writing in the code:. ```cpp; obj->SaveAs(""file.json"");; ```. To access data from a remote web server, it is recommended to use the `httpRequest` method.; For instance to receive object from a THttpServer server one could do:. ```javascript; import { httpRequest } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = await httpRequest(""http://your_root_server:8080/Canvases/c1/root.json"", ""object""); console.log('Read object of type', obj._typename);; ```. Function returns Promise, which provides parsed object (or Error in case of failure). If JSON string was obtained by different method, it could be parsed with `parse` function:. ```javascript; import { parse } from 'https://root.cern/js/latest/modules/main.mjs';; let obj = parse(json_string);; ```. ### Objects drawing. After an object has been created, one can directly draw it. If HTML page has `<div>` element:. ```html; <div id=""drawing""></div>; ```. One could use the `draw` function:. ```javascript; import { draw } from 'https://root.cern/js/latest/modules/main.mjs';; draw(""drawing"", obj, ""colz"");; ```. The first argument is the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:37070,access,access,37070,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['access'],['access']
Security,"om another, non-projected source field.; If a projected field has attached columns,; these columns are alias columns to physical columns attached to the source field.; The following restrictions apply on field projections:; - The source field and the target field must have the same structural role,; except for an `RNTupleCardinality` field, which must have a collection field as a source.; - For streamer fields and leaf fields, the type name of the source field and the projected field must be identical.; - Projections involving variants or fixed-size arrays are unsupported.; - Projected fields must be on the same schema path of collection fields as the source field.; For instance, one can project a vector of structs with floats to individual vectors of floats but cannot; project a vector of a vector of floats to a vector of floats. If `flag==0x04` (_type checksum_) is set, the field metadata contain the checksum of the ROOT streamer info.; This checksum is only used for I/O rules in order to find types that are identified by checksum. Depending on the flags, the following optional values follow:. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Array Size (if flag 0x01 is set) +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; + Source Field ID (if flag 0x02 is set) +; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; + ROOT Type Checksum (if flag 0x04 is set) +; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. The block of integers is followed by a list of strings:. - String: field name; - String: type name; - String: type alias; - String: field description. The order of fields matters: every field gets an implicit field ID; which is equal the zero-based index of the field in the serialized list;; subfields are ordered from smaller IDs to larger IDs.; Top-level fields have their own field ID set as pa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:17357,checksum,checksum,17357,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,2,['checksum'],['checksum']
Security,"omes with a; default ABI list which is intended to eventually cover the glibc library on; Linux but it may become necessary for users to extend the ABI list in cases; where a particular library or function cannot be instrumented (e.g. because; it is implemented in assembly or another language which DataFlowSanitizer does; not support) or a function is called from a library or function which cannot; be instrumented. DataFlowSanitizer's ABI list file is a :doc:`SanitizerSpecialCaseList`.; The pass treats every function in the ``uninstrumented`` category in the; ABI list file as conforming to the native ABI. Unless the ABI list contains; additional categories for those functions, a call to one of those functions; will produce a warning message, as the labelling behavior of the function; is unknown. The other supported categories are ``discard``, ``functional``; and ``custom``. * ``discard`` -- To the extent that this function writes to (user-accessible); memory, it also updates labels in shadow memory (this condition is trivially; satisfied for functions which do not write to user-accessible memory). Its; return value is unlabelled.; * ``functional`` -- Like ``discard``, except that the label of its return value; is the union of the label of its arguments.; * ``custom`` -- Instead of calling the function, a custom wrapper ``__dfsw_F``; is called, where ``F`` is the name of the function. This function may wrap; the original function or provide its own implementation. This category is; generally used for uninstrumentable functions which write to user-accessible; memory or which have more complex label propagation behavior. The signature; of ``__dfsw_F`` is based on that of ``F`` with each argument having a; label of type ``dfsan_label`` appended to the argument list. If ``F``; is of non-void return type a final argument of type ``dfsan_label *``; is appended to which the custom function can store the label for the; return value. For example:. .. code-block:: c++. void f(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst:3161,access,accessible,3161,interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DataFlowSanitizer.rst,2,['access'],['accessible']
Security,"oming from: if control flow comes; from the cond\_false block, X.2 gets the value of X.1. Alternatively, if; control flow comes from cond\_true, it gets the value of X.0. The intent; of this chapter is not to explain the details of SSA form. For more; information, see one of the many `online; references <http://en.wikipedia.org/wiki/Static_single_assignment_form>`_. The question for this article is ""who places the phi nodes when lowering; assignments to mutable variables?"". The issue here is that LLVM; *requires* that its IR be in SSA form: there is no ""non-ssa"" mode for; it. However, SSA construction requires non-trivial algorithms and data; structures, so it is inconvenient and wasteful for every front-end to; have to reproduce this logic. Memory in LLVM; ==============. The 'trick' here is that while LLVM does require all register values to; be in SSA form, it does not require (or permit) memory objects to be in; SSA form. In the example above, note that the loads from G and H are; direct accesses to G and H: they are not renamed or versioned. This; differs from some other compiler systems, which do try to version memory; objects. In LLVM, instead of encoding dataflow analysis of memory into; the LLVM IR, it is handled with `Analysis; Passes <../../WritingAnLLVMPass.html>`_ which are computed on demand. With this in mind, the high-level idea is that we want to make a stack; variable (which lives in memory, because it is on the stack) for each; mutable object in a function. To take advantage of this trick, we need; to talk about how LLVM represents stack variables. In LLVM, all memory accesses are explicit with load/store instructions,; and it is carefully designed not to have (or need) an ""address-of""; operator. Notice how the type of the @G/@H global variables is actually; ""i32\*"" even though the variable is defined as ""i32"". What this means is; that @G defines *space* for an i32 in the global data area, but its; *name* actually refers to the address for that spa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:3740,access,accesses,3740,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['access'],['accesses']
Security,"on 5.32/00 has been released on November 29, 2011.; In case you are upgrading from an old version, please read the releases notes; of version 5.26, 5,28 and version 5.30 in addition to these notes. The release of version 5.34 is scheduled for May 30, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Wim Lavrijsen, LBNL, PyRoot,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg Stelzer, DESY/Atlas, TMVA, ; Alja Tadel, UCSD/CMS, Eve, ; Matevz Tadel, UCSD/CMS, Eve, ; Eckhard von Toerne, University Bonn, ATLAS, TMVA, ; Wouter Verkerke, NIKHEF/Atlas, RooFit, ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v534/index.html:1285,authenticat,authentication,1285,doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v534/index.html,2,['authenticat'],['authentication']
Security,"on a dataset URI containign wild; cards will return a grand dataset sum of all the datasets matching the; URI.; Add options to get a list of all dataset registered names; from ScanDataSets (option kList; the result is a TMap of {TObjString,; TObjString} with the second TObjString empty).Improved version of the PQ2 scripts; the scripts now invoke a dedicated ROOT application (named pq2) available under $ROOTSYS/bin .Add; support for recursive reading of group config files via the 'include; sub-file' directive. This allows to have a common part and, for; example, customize differently the quotas.Fix an issue with TTreeFriends. New tutorial showing how to use friends in PROOF.Package; management: add support for arguments in the SETUP function: it is; possible now to pass a string or a list of objects. The; TProof::EnablePackage interface has been extended to support this.Optimize; the validation step in the case not all the entries are required. The; validation step is stopped as soon as the requested number of events is; reached. If the parameter ""PROOF_ValidateByFile"" is set to 1, the; number of files is exactly what needed; otherwise the number of files; may exceed the number of files needed by (Number_Of_Workers - 1) .; New directive 'xpd.datadir' to better control the user data directories and their permission settings. In TPacketizerUnit, add the possibility to exactly share the number of cycles between the workers.; See the parameter PROOF_PacketizerFixedNum.Implement; a timer to terminate idle sessions. The timeout value is controlled by; the variable ProofServ.IdleTimeout (value in seconds). This variable; can be set for all sessions in the xproofd config file via the 'xpd.putrc' directive.; Add the possibility to control the use of sub-mergers with; the ROOTrc variable Proof.SubMergers. It has the same meaning of the; parameter 'PROOF_UseMergers'. The capabilities of the latter have been; extended: now -1 means disable the use of submergers (before  negative ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:5951,validat,validation,5951,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['validat'],['validation']
Security,"on and removal processes. Discussion Medium; =================. *FUTURE*: this section needs more work! Where discussions occur is influenced by other factors that are still open in this document. We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a private mailing list. Process; =======. The following process occurs on the discussion medium for each reported issue:. * A security issue reporter (not necessarily an LLVM contributor) reports an issue.; * Within two business days, a member of the Security Group is put in charge of driving the issue to an acceptable resolution. This champion doesn’t need to be the same person for each issue. This person can self-nominate.; * Members of the Security Group discuss in which circumstances (if a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:11454,confidential,confidential,11454,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,2,"['confidential', 'secur']","['confidential', 'security']"
Security,"on but the declarations introduce different default-arguments?; No. 2; drafting; How can dependent names be used in member declarations that appear outside of the class template definition?; Not resolved. 3; NAD; The template compilation model rules render some explicit specialization declarations not visible during instantiation; Yes. 4; CD1; Does extern ""C"" affect the linkage of function names with internal linkage?; Clang 2.8. 5; CD1; CV-qualifiers and type conversions; Clang 3.1. 6; NAD; Should the optimization that allows a class object to alias another object also allow the case of a parameter in an inline function to alias its argument?; Unknown. 7; NAD; Can a class with a private virtual base class be derived from?; Clang 3.4. 8; CD1; Access to template arguments used in a function return type and in the nested name specifier; Duplicate of 45. 9; CD1; Clarification of access to base class members; Clang 2.8. 10; CD1; Can a nested class access its own class name as a qualified name if it is a private member of the enclosing class?; Duplicate of 45. 11; CD1; How do the keywords typename/template interact with using-declarations?; Yes. 12; dup; Default arguments on different declarations for the same function and the Koenig lookup; Superseded by 239. 13; NAD; extern ""C"" for Parameters of Function Templates; No. 14; NAD; extern ""C"" functions and declarations in different namespaces; Clang 3.4. 15; dup; Default arguments for parameters of function templates; Yes. 16; CD1; Access to members of indirect private base classes; Clang 2.8. 17; NAD; Footnote 99 should discuss the naming class when describing members that can be accessed from friends; Yes. 18; NAD; f(TYPE) where TYPE is void should be allowed; Superseded by 577. 19; NAD; Clarify protected member access; Clang 3.1. 20; TC1; Some clarifications needed for 12.8 para 15; Clang 2.8. 21; TC1; Can a default argument for a template parameter appear in a friend declaration?; Clang 3.4. 22; TC1; Template parameter",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:1256,access,access,1256,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"on call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisCo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67264,attack,attack,67264,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['attack'],['attack']
Security,"on is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23016,secur,security,23016,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"on of default-initialization; Duplicate of 178. 36; CD6; using-declarations in multiple-declaration contexts; Clang 2.8. 37; NAD; When is uncaught_exception() true?; Superseded by 475. 38; TC1; Explicit template arguments and operator functions; Yes. 39; CD1; Conflicting ambiguity rules; No. 40; TC1; Syntax of declarator-id; N/A. 41; TC1; Clarification of lookup of names after declarator-id; Yes. 42; NAD; Redefining names from base classes; Yes. 43; TC1; Copying base classes (PODs) using memcpy; N/A. 44; CD1; Member specializations; Superseded by 727. 45; CD1; Access to nested classes; Yes. 46; NAD; Explicit instantiation of member templates; Yes. 47; NAD; Template friend issues; Superseded by 329. 48; TC1; Definitions of unused static members; Yes. 49; TC1; Restriction on non-type, non-value template arguments; Clang 2.8. 50; NAD; Converting pointer to incomplete type to same type; Yes. 51; TC1; Overloading and user-defined conversions; Clang 2.8. 52; TC1; Non-static members, member selection and access checking; Clang 2.8. 53; TC1; Lvalue-to-rvalue conversion before certain static_casts; Yes. 54; CD1; Static_cast from private base to derived class; Clang 2.8. 55; NAD; Adding/subtracting pointer and enumeration value; Yes. 56; TC1; Redeclaring typedefs within classes; Yes. 57; open; Empty unions; Not resolved. 58; CD1; Signedness of bit fields of enum type; Clang 3.1. 59; TC1; Clarification of overloading and UDC to reference type; Yes. 60; CD1; Reference binding and valid conversion sequences; Yes. 61; NAD; Address of static member function ""&p->f""; Clang 3.4. 62; CD1; Unnamed members of classes used as type parameters; Clang 2.9. 63; CD1; Class instantiation from pointer conversion to void*, null and self; Yes. 64; TC1; Partial ordering to disambiguate explicit specialization; Yes. 65; TC1; Typo in default argument example; N/A. 66; NAD; Visibility of default args vs overloads added after using-declaration; No. 67; TC1; Evaluation of left side of object-expressio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:4168,access,access,4168,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"on to these notes. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. Binaries for all supported platforms are available at:. https://root.cern/releases/release-52800/. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Alberto Annovi, INFN, TH1, ; Kevin Belasco, Princeton University, RooStats,; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU, RooStats,; Jason Detwiler, LBL, TClonesArray, ; Valeri Fine, BNL/STAR,; Fabrizio Furano, CERN/IT, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Oleksandr Grebenyuk, GSI, TLatex, TPostScript, ; Christian Gumpert, CERN and University Dresden, TEfficiency ; Bill Heintzelman, UPENN, TTree, ; Andreas Hoecker, CERN/Atlas, TMVA, ; Pierre Juillot, IN2P3, PostScript, ; Folkert Koetsveld, Nijmegen, RooFit, ; Alex Koutsman, Nikhef, RooFit, ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v528/index.html:1243,authenticat,authentication,1243,doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v528/index.html,2,['authenticat'],['authentication']
Security,"on will be performed using default iterative strategy.; Intrinsic is currently only implemented for i32. llvm.amdgcn.udot2 Provides direct access to v_dot2_u32_u16 across targets which; support such instructions. This performs unsigned dot product; with two v2i16 operands, summed with the third i32 operand. The; i1 fourth operand is used to clamp the output. llvm.amdgcn.udot4 Provides direct access to v_dot4_u32_u8 across targets which; support such instructions. This performs unsigned dot product; with two i32 operands (holding a vector of 4 8bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output. llvm.amdgcn.udot8 Provides direct access to v_dot8_u32_u4 across targets which; support such instructions. This performs unsigned dot product; with two i32 operands (holding a vector of 8 4bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output. llvm.amdgcn.sdot2 Provides direct access to v_dot2_i32_i16 across targets which; support such instructions. This performs signed dot product; with two v2i16 operands, summed with the third i32 operand. The; i1 fourth operand is used to clamp the output.; When applicable (e.g. no clamping), this is lowered into; v_dot2c_i32_i16 for targets which support it. llvm.amdgcn.sdot4 Provides direct access to v_dot4_i32_i8 across targets which; support such instructions. This performs signed dot product; with two i32 operands (holding a vector of 4 8bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output.; When applicable (i.e. no clamping / operand modifiers), this is lowered; into v_dot4c_i32_i8 for targets which support it.; RDNA3 does not offer v_dot4_i32_i8, and rather offers; v_dot4_i32_iu8 which has operands to hold the signedness of the; vector operands. Thus, this intrinsic lowers to the signed version; of this instruction for gfx11 targets. llvm.amdgcn.sdot8 Provides direct access to v_dot8_u32_u4 acr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:40006,access,access,40006,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"on). Page sources and sinks do not operate entry-based but based on pages/indices of columns.; For instance, there is no API in the page sink to write an entry, but only to write pages of columns.; The higher-level APIs, e.g. `RField`, `REntry`, `RNTupleWriter`, take care of presenting the available data as entries where necessary. The page source also gives access to an `RNTupleDescriptor` through a read/write lock guard.; The `RNTupleDescriptor` owned by the page source changes only when new cluster meta-data are loaded.; The header and the cluster group summary information is stable throughout its lifetime (cf. format specification). ### R{NTuple,Field,Column,Cluster,...}Descriptor; The descriptor classes provide read-only access to the on-disk meta-data of an RNTuple.; The meta-data include the schema (fields and columns), information about clusters and the page locations.; The descriptor classes are closely related to the format specification. For normal read and write tasks, access to the descriptor is not necessary.; One notable exception is bulk reading, where the descriptor can be used to determine entry boundaries of clusters.; The descriptors are used internally, e.g. to build an RNTupleModel from the on-disk information.; The descriptors are also useful for inspection purposes. The descriptor classes contain a copy of the meta-data; they are not linked to an open page source.; A descriptor can be used after its originating page source has been deleted. ### RField<T>; The RField<T> classes are central in RNTuple:; they link the in-memory representation of data types to their on-disk representation.; All field classes inherit from `RFieldBase`. Every type with RNTuple I/O supported has a corresponding RField<T> template specialization.; Complex types are composed of fields and sub fields.; E.g., a `struct` is represented by a parent field for the `struct` itself and a subfield for every member of the `struct`.; Fields of complex types have type-erased vers",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:7184,access,access,7184,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"on-LLVM based products if their product suffers from the same issue. The non-LLVM vendor should be asked to respect the issue’s embargo date, and to not share the information beyond the need-to-know people within their organization.; * If the LLVM Security Group agrees, key experts can be brought in to help address particular issues. The key expert should be asked to respect the issue’s embargo date, and to not share the information. Disclosure; ----------. Following the process below, the LLVM Security Group decides on embargo date for public disclosure for each Security issue. An embargo may be lifted before the agreed-upon date if all vendors planning to ship a fix have already done so, and if the reporter does not object. Collaboration; -------------. Members of the LLVM Security Group are expected to:. * Promptly share any LLVM vulnerabilities they become aware of.; * Volunteer to drive issues forward.; * Help evaluate the severity of incoming issues.; * Help write and review patches to address security issues.; * Participate in the member nomination and removal processes. Discussion Medium; =================. *FUTURE*: this section needs more work! Where discussions occur is influenced by other factors that are still open in this document. We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:10448,secur,security,10448,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"on; Clang 4. 260; open; User-defined conversions and built-in operator=; Not resolved. 261; CD1; When is a deallocation function ""used?""; No. 262; CD1; Default arguments and ellipsis; Yes. 263; CD1; Can a constructor be declared a friend?; Clang 3.3. 264; open; Unusable template constructors and conversion functions; Not resolved. 265; dup; Destructors, exceptions, and deallocation; Duplicate of 353. 266; NAD; No grammar sentence symbol; N/A. 267; open; Alignment requirement for new-expressions; Not resolved. 268; open; Macro name suppression in rescanned replacement text; Not resolved. 269; NAD; Order of initialization of multiply-defined static data members; of class templates; N/A. 270; CD1; Order of initialization of static data members of class templates; N/A. 271; CD6; Explicit instantiation and template argument deduction; Unknown. 272; CD1; Explicit destructor invocation and qualified-ids; Yes. 273; CD1; POD classes and operator&(); Yes. 274; CD1; Cv-qualification and char-alias access to out-of-lifetime objects; N/A. 275; CD1; Explicit instantiation/specialization and using-directives; No. 276; CD1; Order of destruction of parameters and temporaries; N/A. 277; CD1; Zero-initialization of pointers; Clang 3.1. 278; NAD; External linkage and nameless entities; Unknown. 279; CD6; Correspondence of ""names for linkage purposes""; Unknown. 280; CD1; Access and surrogate call functions; Clang 2.9. 281; CD1; inline specifier in friend declarations; No. 282; open; Namespace for extended_type_info; Not resolved. 283; CD1; Template type-parameters are not syntactically type-names; Yes. 284; CD1; qualified-ids in class declarations; No. 285; NAD; Identifying a function template being specialized; Yes. 286; CD1; Incorrect example in partial specialization; Clang 2.8. 287; drafting; Order dependencies in template instantiation; Not resolved. 288; CD1; Misuse of ""static type"" in describing pointers; N/A. 289; CD1; Incomplete list of contexts requiring a complete type; Yes. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:18081,access,access,18081,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"on<Following Up With the Reportee>` and feedback is requested. This; feedback may or may not be used to re-evaluate the resolution. 5. Inform the reportee of the resolution. The reportee is provided options to; :ref:`appeal<Appeal Process>`. . 6. The :ref:`resolution<Resolutions>` is implemented. 7. All reports, data, notes, and resolutions are logged in a private location; (e.g., Google Drive or other database). The committee will never make public statements about a resolution and will; only publish :ref:`transparency reports<Transparency Reports>`. If a public; statement is necessary and requested by the committee, it will be given by the; LLVM Foundation Board of Directors. Report Acknowledgement; ======================. When a report is received, the committee will reply to the reporter to confirm; receipt within 24 hours of the incident being reported. . This acknowledgement will contain:. * Acknowledgement of the incident report; * Next steps of the committee for responding to the incident; * Reminder of confidentiality policy regarding the report and parties involved. All incident reports should be assessed if they require immediate response and; acted on accordingly. .. _Incident Response Assessment:. Incident Response Assessment; ============================. The committee will assess the incident and determine an appropriate response.; The assessment will be documented and retained in records. Here are some; guidelines for the process:. * Review report documentation to determine the content and context of the; incident. * Request additional information if needed from the reporter. * Determine if it occurred within the scope of the CoC.; * Determine if it violated the CoC and specifically which part.; * Consult documentation of past incidents for patterns of behavior (if; available and applicable).; * Follow up with the reportee to get their view or any other additional; information.; * Determine appropriate resolutions to the incident when all information",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:4624,confidential,confidentiality,4624,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['confidential'],['confidentiality']
Security,"on](https://lwn.net/Articles/744287/) so far focuses on mitigating; specific known attackable components in the Linux kernel (or other kernels) by; manually rewriting the code to contain an instruction sequence that is not; vulnerable. For x86 systems this is done by either injecting an `lfence`; instruction along the code path which would leak data if executed speculatively; or by rewriting memory accesses to have branch-less masking to a known safe; region. On Intel systems, `lfence` [will prevent the speculative load of secret; data](https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this at scale, in many cases it still relies on; human judgement to evaluate whether code might be vulnerable. Especially for; software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:44645,attack,attacked,44645,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacked']
Security,"oned/Signed-QWord:; bcdcfn. bcdcfz. bcdctn. bcdctz. bcdcfsq. bcdctsq.; . Use instrinstics:; (set v1i128:$vD, (int_ppc_altivec_bcdcfno v1i128:$vB, i1:$PS)); (set v1i128:$vD, (int_ppc_altivec_bcdcfzo v1i128:$vB, i1:$PS)); (set v1i128:$vD, (int_ppc_altivec_bcdctno v1i128:$vB)); (set v1i128:$vD, (int_ppc_altivec_bcdctzo v1i128:$vB, i1:$PS)); (set v1i128:$vD, (int_ppc_altivec_bcdcfsqo v1i128:$vB, i1:$PS)); (set v1i128:$vD, (int_ppc_altivec_bcdctsqo v1i128:$vB)). - Decimal Copy-Sign/Set-Sign: bcdcpsgn. bcdsetsgn.; . Use instrinstics:; (set v1i128:$vD, (int_ppc_altivec_bcdcpsgno v1i128:$vA, v1i128:$vB)); (set v1i128:$vD, (int_ppc_altivec_bcdsetsgno v1i128:$vB, i1:$PS)). - Decimal Shift/Unsigned-Shift/Shift-and-Round: bcds. bcdus. bcdsr.; . Use instrinstics:; (set v1i128:$vD, (int_ppc_altivec_bcdso v1i128:$vA, v1i128:$vB, i1:$PS)); (set v1i128:$vD, (int_ppc_altivec_bcduso v1i128:$vA, v1i128:$vB)); (set v1i128:$vD, (int_ppc_altivec_bcdsro v1i128:$vA, v1i128:$vB, i1:$PS)). . Note! Their VA is accessed only 1 byte, i.e. VA.byte[7]. - Decimal (Unsigned) Truncate: bcdtrunc. bcdutrunc.; . Use instrinstics:; (set v1i128:$vD, (int_ppc_altivec_bcdso v1i128:$vA, v1i128:$vB, i1:$PS)); (set v1i128:$vD, (int_ppc_altivec_bcduso v1i128:$vA, v1i128:$vB)). . Note! Their VA is accessed only 2 byte, i.e. VA.hword[3] (VA.bit[48:63]). VSX:; - QP Copy Sign: xscpsgnqp; . Similar to xscpsgndp; . (set f128:$vT, (fcopysign f128:$vB, f128:$vA). - QP Absolute/Negative-Absolute/Negate: xsabsqp xsnabsqp xsnegqp; . Similar to xsabsdp/xsnabsdp/xsnegdp; . (set f128:$vT, (fabs f128:$vB)) // xsabsqp; (set f128:$vT, (fneg (fabs f128:$vB))) // xsnabsqp; (set f128:$vT, (fneg f128:$vB)) // xsnegqp. - QP Add/Divide/Multiply/Subtract/Square-Root:; xsaddqp xsdivqp xsmulqp xssubqp xssqrtqp; . Similar to xsadddp; . isCommutable = 1; (set f128:$vT, (fadd f128:$vA, f128:$vB)) // xsaddqp; (set f128:$vT, (fmul f128:$vA, f128:$vB)) // xsmulqp. . isCommutable = 0; (set f128:$vT, (fdiv f128:$vA, f128:$vB)) // xsdivqp; (set f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_P9.txt:5743,access,accessed,5743,interpreter/llvm-project/llvm/lib/Target/PowerPC/README_P9.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README_P9.txt,2,['access'],['accessed']
Security,"onesArray`**. The **`TClonesArray`** (pointed to) is split if; the split level is greater than two. When the split level is one,; the **`TClonesArray`** is not split. - If a data member is a pointer to an object, a special branch is; created. The branch will be filled by calling the class `Streamer`; function to serialize the object into the branch buffer. - If a data member is an object, the data members of this object are; split into branches according to the split-level (i.e. split-level; \> 2). - Base classes are split when the object is split. - Abstract base classes are never split. - All STL containers are supported. ``` {.cpp}; // STL vector of vectors of TAxis*; vector<vector<TAxis *> > fVectAxis;; // STL map of string/vector; map<string,vector<int> > fMapString;; // STL deque of pair; deque<pair<float,float> > fDequePair;; ```. - C-structure data members are not supported in split mode. - An object that is not split may be slow to browse. - A STL container that is not split will not be accessible in the; browser. ### Exempt a Data Member from Splitting. If you are creating a branch with an object and in general you want the; data members to be split, but you want to exempt a data member from the; split. You can specify this in the comment field of the data member:. ``` {.cpp}; class Event : public TObject {; private:; EventHeader fEvtHdr; //|| Don't split the header; ```. ### Adding a Branch to Hold a TClonesArray. ROOT has two classes to manage arrays of objects. The **`TObjArray`**; can manage objects of different classes, and the **`TClonesArray`** that; specializes in managing objects of the same class (hence the name Clones; Array). **`TClonesArray`** takes advantage of the constant size of each; element when adding the elements to the array. Instead of allocating; memory for each new object as it is added, it reuses the memory. Here is; an example of the time a **`TClonesArray`** can save over a; **`TObjArray`**. We have 100,000 events, and each has ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:28455,access,accessible,28455,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['accessible']
Security,"ons and use the newest version it finds instead,; e.g. if you have ``lib/aarch64-none-linux-android21`` and; ``lib/aarch64-none-linux-android29``, ``-target aarch64-none-linux-android23``; will use the former and ``-target aarch64-none-linux-android30`` will use the; latter. Falling back to a versionless directory will now emit a warning, and; the fallback will be removed in Clang 19. Windows Support; ^^^^^^^^^^^^^^^; - Fixed an assertion failure that occurred due to a failure to propagate; ``MSInheritanceAttr`` attributes to class template instantiations created; for explicit template instantiation declarations. - The ``-fno-auto-import`` option was added for MinGW targets. The option both; affects code generation (inhibiting generating indirection via ``.refptr``; stubs for potentially auto imported symbols, generating smaller and more; efficient code) and linking (making the linker error out on such cases).; If the option only is used during code generation but not when linking,; linking may succeed but the resulting executables may expose issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:63239,expose,expose,63239,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['expose'],['expose']
Security,"ons for both CPU and GPU versions of `MethodDL`. . ### Other New TMVA Features. - Add a new option to the `DataLoader` to switch off computation of correlation matrix. The new option is called *CalcCorrelations* and it should be used when a large number of input variables are; provided, otherwise TMVA will spend a long time in setting up the data set before training. ; ; - Build configuration:; - Add new cmake flags, `tmva-cpu` and `tmva-gpu`, which can be used to swicth on/off the CPU and GPU (based on CUDA) implementations of the TMVA Deep Learning module. `tmva-cpu` is enabled by; default if a Blas or CBlas library is found in the system. `tmva-gpu` is enabled when the cmake flag `cuda` is enabled and a compatible Cuda library is found. ; enabled if the corre; - Add possibility to independently configure building of optional pymva part of tmva with flag `-Dpymva=ON|OFF`. - New Cross Validation features:; - Add stratified splitting for cross validation.; - New plotting option in cross validation, average ROC curve. - Bugfixes:; - Fix bug in BDT training with imt=on; - Improved handling of large event numbers in cross validation using deterministic splitting. - Documentation:; - Update TMVA Users' guide. ## 2D Graphics Libraries. - Highlight mode is implemented for `TH1` and for `TGraph` classes. When; highlight mode is on, mouse movement over the bin will be represented; graphically. Histograms bins or graph points will be highlighted. Moreover,; any highlight emits signal `TCanvas::Highlighted()` which allows the user to; react and call their own function. For a better understanding see also; the tutorials `$ROOTSYS/tutorials/hist/hlHisto*.C` and; `$ROOTSYS/tutorials/graphs/hlGraph*.C` .; - Implement fonts embedding for PDF output. The ""EmbedFonts"" option allows to; embed the fonts used in a PDF file inside that file. This option relies on; the ""gs"" command (https://ghostscript.com). Example:. ~~~ {.cpp}; canvas->Print(""example.pdf"",""EmbedFonts"");; ~~~; - In TAttA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md:16068,validat,validation,16068,README/ReleaseNotes/v616/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v616/index.md,1,['validat'],['validation']
Security,"ons performed before training, e.g., D_Background,P_Signal,G,N_AllClasses for: Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed). H No False − Print method-specific help message. CreateMVAPdfs No False − Create PDFs for classifier outputs (signal and background). IgnoreNegWeightsInTraining No False − Events with negative weights are ignored in the training (but are included for testing and performance evaluation). GDTau No -1 − Gradient-directed (GD) path: default fit cut-off. GDTauPrec No 0.01 − GD path: precision of tau. GDStep No 0.01 − GD path: step size. GDNSteps No 10000 − GD path: number of steps. GDErrScale No 1.1 − Stop scan when error > scale*errmin. LinQuantile No 0.025 − Quantile of linear terms (removes outliers). GDPathEveFrac No 0.5 − Fraction of events used for the path search. GDValidEveFrac No 0.5 − Fraction of events used for the validation. fEventsMin No 0.1 − Minimum fraction of events in a splittable node. fEventsMax No 0.9 − Maximum fraction of events in a splittable node. nTrees No 20 − Number of trees in forest. ForestType No AdaBoost AdaBoost, Random Method to use for forest generation (AdaBoost or RandomForest). RuleMinDist No 0.001 − Minimum distance between rules. MinImp No 0.01 − Minimum rule importance accepted. Model No ModRuleLinear ModRule, ModRuleLinear, ModLinear Model to be used. RuleFitModule No RFTMVA RFTMVA, RFFriedman Which RuleFit module to use. RFWorkDir No ./rulefit − Friedman's RuleFit module (RFF): working dir. RFNrules No 2000 − RFF: Mximum number of rules. RFNendnodes No 4 − RFF: Average number of end nodes. Configuration options for MVA method :. Configuration options reference for MVA method: Likelihood. Option Array Default value Predefined values Description. V No False − Verbose output (short form of VerbosityLevel below - overrides the latter one). VerbosityLevel N",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html:19009,validat,validation,19009,documentation/tmva/UsersGuide/optionRef.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/tmva/UsersGuide/optionRef.html,2,['validat'],['validation']
Security,"ons that rely on category states faster. The interface to define or manipulate category states was also updated. Since categories are mappings from state names; to state index, this is now reflected in the interface. Among others, this is now possible:; | ROOT 6.22 | Before (still supported) |; |------------------------------------------------|----------------------------------------------------------------|; | `RooCategory cat(""cat"", ""Lepton flavour"");` | `RooCategory cat(""cat"", ""Lepton flavour"");` |; | `cat[""electron""] = 1;` | `cat.defineType(""electron"", 1);` |; | `cat[""muon""] = 2;` | `cat.defineType(""muon"", 2);` |. See also [Category reference guide](https://root.cern.ch/doc/master/classRooCategory.html). ### Type-safe proxies for RooFit objects; RooFit's proxy classes have been modernised. The class `RooTemplateProxy` allows for access to other RooFit objects; similarly to a smart pointer. In older versions of RooFit, the objects held by *e.g.* `RooRealProxy` had to be; accessed like this:; RooAbsArg* absArg = realProxy.absArg();; RooAbsPdf* pdf = dynamic_cast<RooAbsPdf*>(absArg);; assert(pdf); // This *should* work, but the proxy doesn't have a way to check; pdf->fitTo(...);; That is, a `RooRealProxy` stores a pointer to a RooAbsArg, and this pointer has to be cast. There was no type; safety, *i.e.*, any object deriving from RooAbsArg could be stored in that proxy, and the user had to take care; of ensuring that types are correct.; Now, if one uses; RooTemplateProxy<RooAbsPdf> pdfProxy;; instead of; RooRealProxy realProxy;; in RooFit classes, the above code can be simplified to; pdfProxy->fitTo(...);. Check the [doxygen reference guide](https://root.cern.ch/doc/master/classRooTemplateProxy.html) for `RooTemplateProxy` for; more information on how to modernise old code. ### HistFactory. #### Switch default statistical MC errors to Poisson; When defining HistFactory samples with statistical errors from C++, e.g.; Sample background1( ""background1"", ""background1"", I",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:4340,access,accessed,4340,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['access'],['accessed']
Security,"ons,; and short meaningful tool tip text. The related buttons should be; grouped together by frequency or sequence of use, or importance.; Potentially destructive buttons must be separated from them to avoid; accidental activation and potentially catastrophic results. Temporarily; not available items should be displayed grayed out. ### List Boxes. The purpose of a list box is to display a collection of items from which; single or multiple selection can be made. It is always visible, having a; scroll bar when the displayed area is not enough to show all items. The; choices may be mutually exclusive (a list box with single selection) or; not mutually exclusive (a list box with multiple selection). ![](pictures/02000219.jpg). The proper usage of the list boxes is for selecting values, or objects,; or setting attributes. You have to create them to display 4 to 8 choices; at one time (3 is a required minimum in case of lack of screen space).; The list should contain not more than 40 items accessible by scrolling; view (vertical scroll bar). If more are required, you should provide a; method for using search criteria or scoping the options. The best list; boxes use is for textual data or choices. They should be wide enough to; display fully all items. When it is not possible, break the long items; with ellipsis and provide tool tip that displays the full item text. The list box widget is represented by **`TGListBox`**,; **`TGLBContainer`**, **`TGLBEntry`** and **`TGTextLBEntry`** classes.; Currently entries are simple text strings (**`TGTextLBEntry`**). A; **`TGListBox`** looks a lot like a **`TGCanvas`**. It has a; **`TGViewPort`** containing a **`TGLBContainer`** which contains the; entries and it also has a vertical scrollbar which becomes visible if; there are more items than fit in the visible part of the container. The; **`TGListBox`** is user callable. The other classes are service classes; of the list box. Here is a sample code showing how to create a list box; wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:79092,access,accessible,79092,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['accessible']
Security,"onsistency of the heap operations;. - being able to detect potential corruption. For this purpose, the header is; checksummed and corruption of the header will be detected when said header is; accessed (note that if the corrupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3738,checksum,checksum,3738,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['checksum'],['checksum']
Security,"ontact info (so we can get in touch with you). Include email and; optionally a phone number.; * Names or descriptions of anyone who was involved or who witnessed the; incident.; * When and where the incident occurred. Please be as specific as possible.; * Your account of what occurred. If there is a written record (e.g. emails,; forum links, tweets, Slack, or Discord messages) please include screenshots,; as well as any available link.; * Any extra context you believe existed for the incident.; * If you believe this incident is ongoing.; * If you have concerns about retaliation or your personal safety, please note; those concerns in your report.; * Any other information you believe we should have. If you are unable to provide all of this information, please still make the; report and include as much information as you have. When handling a report, we follow our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Report",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:3627,confidential,confidential,3627,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,1,['confidential'],['confidential']
Security,"ontains the raw object image.; Before the code can be executed, the code and data sections from this; image must be loaded into suitable memory, relocations must be applied and; memory permission and code cache invalidation (if required) must be completed. Object Loading; ==============. Once an object image has been obtained, either through code generation or; having been retrieved from an ObjectCache, it is passed to RuntimeDyld to; be loaded. The RuntimeDyld wrapper class examines the object to determine; its file format and creates an instance of either RuntimeDyldELF or; RuntimeDyldMachO (both of which derive from the RuntimeDyldImpl base; class) and calls the RuntimeDyldImpl::loadObject method to perform that; actual loading. .. image:: MCJIT-dyld-load.png. RuntimeDyldImpl::loadObject begins by creating an ObjectImage instance; from the ObjectBuffer it received. ObjectImage, which wraps the; ObjectFile class, is a helper class which parses the binary object image; and provides access to the information contained in the format-specific; headers, including section, symbol and relocation information. RuntimeDyldImpl::loadObject then iterates through the symbols in the; image. Information about common symbols is collected for later use. For; each function or data symbol, the associated section is loaded into memory; and the symbol is stored in a symbol table map data structure. When the; iteration is complete, a section is emitted for the common symbols. Next, RuntimeDyldImpl::loadObject iterates through the sections in the; object image and for each section iterates through the relocations for; that sections. For each relocation, it calls the format-specific; processRelocationRef method, which will examine the relocation and store; it in one of two data structures, a section-based relocation list map and; an external symbol relocation map. .. image:: MCJIT-load-object.png. When RuntimeDyldImpl::loadObject returns, all of the code and data; sections for the object",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst:4228,access,access,4228,interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MCJITDesignAndImplementation.rst,1,['access'],['access']
Security,"ontrol-flow of any class that; subclasses ``Stmt``, which includes simple expressions. Control-flow graphs; are especially useful for performing `flow- or path-sensitive; <https://en.wikipedia.org/wiki/Data_flow_analysis#Sensitivities>`_ program; analyses on a given function. Basic Blocks; ^^^^^^^^^^^^. Concretely, an instance of ``CFG`` is a collection of basic blocks. Each basic; block is an instance of ``CFGBlock``, which simply contains an ordered sequence; of ``Stmt*`` (each referring to statements in the AST). The ordering of; statements within a block indicates unconditional flow of control from one; statement to the next. :ref:`Conditional control-flow; <ConditionalControlFlow>` is represented using edges between basic blocks. The; statements within a given ``CFGBlock`` can be traversed using the; ``CFGBlock::*iterator`` interface. A ``CFG`` object owns the instances of ``CFGBlock`` within the control-flow; graph it represents. Each ``CFGBlock`` within a CFG is also uniquely numbered; (accessible via ``CFGBlock::getBlockID()``). Currently the number is based on; the ordering the blocks were created, but no assumptions should be made on how; ``CFGBlocks`` are numbered other than their numbers are unique and that they; are numbered from 0..N-1 (where N is the number of basic blocks in the CFG). Entry and Exit Blocks; ^^^^^^^^^^^^^^^^^^^^^. Each instance of ``CFG`` contains two special blocks: an *entry* block; (accessible via ``CFG::getEntry()``), which has no incoming edges, and an; *exit* block (accessible via ``CFG::getExit()``), which has no outgoing edges.; Neither block contains any statements, and they serve the role of providing a; clear entrance and exit for a body of code such as a function body. The; presence of these empty blocks greatly simplifies the implementation of many; analyses built on top of CFGs. .. _ConditionalControlFlow:. Conditional Control-Flow; ^^^^^^^^^^^^^^^^^^^^^^^^. Conditional control-flow (such as those induced by if-statements",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:113157,access,accessible,113157,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['access'],['accessible']
Security,"ookup within a; given declaration (e.g., find the member named ``x`` in a structure) and; iterate over the declarations stored within a context (e.g., iterate over all; of the fields of a structure for structure layout). In Clang's AST file format, deserializing a declaration that is a; ``DeclContext`` is a separate operation from deserializing all of the; declarations stored within that declaration context. Therefore, Clang will; deserialize the translation unit declaration without deserializing the; declarations within that translation unit. When required, the declarations; stored within a declaration context will be deserialized. There are two; representations of the declarations within a declaration context, which; correspond to the name-lookup and iteration behavior described above:. * When the front end performs name lookup to find a name ``x`` within a given; declaration context (for example, during semantic analysis of the expression; ``p->x``, where ``p``'s type is defined in the precompiled header), Clang; refers to an on-disk hash table that maps from the names within that; declaration context to the declaration IDs that represent each visible; declaration with that name. The actual declarations will then be; deserialized to provide the results of name lookup.; * When the front end performs iteration over all of the declarations within a; declaration context, all of those declarations are immediately; de-serialized. For large declaration contexts (e.g., the translation unit),; this operation is expensive; however, large declaration contexts are not; traversed in normal compilation, since such a traversal is unnecessary.; However, it is common for the code generator and semantic analysis to; traverse declaration contexts for structs, classes, unions, and; enumerations, although those contexts contain relatively few declarations in; the common case. Statements and Expressions; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Statements and expressions are stored in the AST file",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:15420,hash,hash,15420,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['hash'],['hash']
Security,"oon as possible, i.e. after all sources have been read. One significant consequence is that now when an object is stored in a split branch; the rule is associtated with the branch of the last of the rule's sources rather; than the last of the object's data member. - Properly support TStreamerInfo written by ROOT v4.00. - Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile being written since v5.34/11. ## Networking Libraries. ### HTTP Server. ##### Command Interface; One can now register an arbitrary command to the server, which become visible in the web browser. Then, when the item is clicked by the user, the command ends-up in a gROOT->ProcessLineSync() call. ##### Custom Properties ; Custom properties can be configured for any item in the server. For example, one could configure an icon for each item visible in the browser. Or one could 'hide' any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details. ##### Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality. ##### Misc; Correctly set 'Cache-Control' headers when replying to http requests.; Better support of STL containers when converting objects into json with TBufferJSON class. ## JavaScript ROOT. - Several files can now be loaded simultaneously; - Use d3.time.scale to display time scales; - Implemented drag and drop to superimpose histograms or graphs; - Allow selection of drawing option via context menu; - Better support of touch devices; - Provide simple layout, making it default; - Allow to open ROOT files in online session (via url parameter); - One could monitor simultaneously objects from server and root f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:9811,access,access,9811,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['access'],['access']
Security,"oop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:310037,access,access,310037,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"oop(this);; ctx.addToCodeBody(weightSumName + "" += "" + ctx.getResult(*_weightVar) + "";\n"");; }. if (_simCount > 1) {; std::string simCountStr = std::to_string(static_cast<double>(_simCount));; ctx.addToCodeBody(resName + "" += "" + weightSumName + "" * std::log("" + simCountStr + "");\n"");; }; ... }; ```. > Source: - [RooNLLVarNew](https://github.com/root-project/root/blob/master/roofit/roofitcore/src/RooNLLVarNew.cxx). The complexity of the `RooNLLVarNew::translate()` function in this example can; be attributed to the more complex scenarios/operations specific to the; computation of negative log-likelihood (NLL) values for probability density; functions (PDFs) in RooFit, especially for simultaneous fits (multiple; simultaneous PDFs being considered) and binned likelihoods (adding further; complexity). In this example, the `RooNLLVarNew::translate()` function generates code to; compute the Negative Log likelihood (NLL). We can see that the intermediate; result variable `resName` is added to the context so that it can be accessed; and used in the generated code. This variable is made available globally; (using `addToGlobalScope()`). If a weight sum is needed, then it creates a loop, and `weightSumName` is; accumulated with the weight variable. Otherwise, if there are multiple; simultaneous PDFs, then it adds a term to the result that scales with the; logarithm of the count of simultaneous PDFs. The rest of the function body; (including the loop scope with NLL computation) has omitted from this example; to keep it brief. Helper functions:. - `makeValidVarName()` helps get a valid name from the name of the respective; RooFit class. It then helps save it to the variable that represents the result; of this class (the squashed code/ C++ function that will be created). - `addToGlobalScope()` helps declare and initialize the results variable, so; that it can be available globally (throughout the function body). For local; variables, the `addToCodeBody()` function can be used to ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:16603,access,accessed,16603,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['access'],['accessed']
Security,"oot --web tutorials/geom/rootgeom.C`; Not all features of TGeoPainter are supported - only plain drawing of selected TGeoVolume. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. By default, ROOT now falls back to the built-in version of xrootd if it can't find it in the system.; This means that passing `-Dbuiltin_xrootd=ON` is not necessary anymore to build ROOT with xrootd support.; Note that built-in xrootd requires a working network connection. ### Experimental address sanitizer build configuration; Added a build flag `asan` that switches on address sanitizer. It's experimental, so expect problems. For example, when building with gcc,; manipulations in global variables in llvm will abort the build. Such checks can be disabled using environment variables. Check the address; sanitizer documentation or the link below for details. In clang, which allows to blacklist functions, the build will continue. See [core/sanitizer](https://github.com/root-project/root/tree/master/core/sanitizer) for information. ### Optimization of ROOT header files. Many (but intentionally not all) unused includes were removed from ROOT header files. For instance, `#include ""TObjString.h""` and; `#include ""ThreadLocalStorage.h""` were removed from `TClass.h`. Or `#include ""TDatime.h""` was removed from; `TDirectory.h` header file . Or `#include ""TDatime.h""` was removed from `TFile.h`.; This change may cause errors during compilation of ROOT-based code. To fix it, provide missing the includes; where they are really required.; This improves compile times and reduces code inter-dependency; see https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/WhyIWYU.md for a good overview of the motivation. Even more includes will be ""hidden"" when ROOT configured with `-Ddev=ON` build option.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md:7951,sanitiz,sanitizer,7951,README/ReleaseNotes/v622/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v622/index.md,1,['sanitiz'],['sanitizer']
Security,"ootIO avoid objects cloning when object referenced several times; - Treat special cases (collection, arrays) in one place.; This is major advantage, while any new classes should be implemented once.; - Object representation, produced by JSRootIO is similar to; objects, produced by TBufferJSON class. By this one can exchange; I/O engine and use same JavaSctript graphic for display.; - More clear functions to display different elements of the file.; In the future functions should be fully separated from I/O part; and organized in similar way as online part.; - Eliminate usage of gFile pointer in the I/O part.; - Provide TBufferJSON::JsonWriteMember method. It allows to stream any; selected data member of the class. Supported are: basic data types,; arrays of basic data types, TString, TArray classes. Also any object; as data member can be streamed.; - TRootSniffer do not creates sublevels for base classes; - When streaming data member, TBufferJSON produces array with all dimensions; only when fCompact==0. By default, THttpServer uses compact=1 for member; - Support both get.json and root.json requests, they have similar meaning. January 2014; - Make THttpServer::CreateEngine as factory method. One could; create http, fastcgi and dabc engines to access data from server.; Syntax allows to provide arbitrary arguments. Examples:; THttpServer* serv = new THttpServer();; serv->CreateEngine(""http:8080"");; serv->CreateEngine(""fastcgi:9000/none?top=MyApp"");; serv->CreateEngine(""dabc:1237?top=MyApp"");; serv->CreateEngine(""dabc:http:8090?top=MyApp"");; serv->CreateEngine(""dabc:fastcgi:9010?top=MyApp"");; - Many engines can be created at once.; - Provide TDabcEngine (in DABC framework).; - Support additional options for mongoose and fastcgi servers; - Port to ROOT 6 (adjust makefiles), keep Module.mk.ver5. December 2013; - Start of project; - Move ROOT-relevant functionality from DABC plugin; - Introduce THttpServer, THttpEngine and TRootSniffer classes; - Integrate JSRootIO code. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:4253,access,access,4253,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,2,['access'],['access']
Security,"open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-classes; Unknown. 2548; NAD; Array prvalues and additive operators; Unknown. 2549; review; Implicitly moving the operand of a throw-expression in unevaluated contexts; Not resolved. 2550; DRWP; Type ""reference to cv void"" outside of a declarator; Unknown. 2551; review; ""Refers to allocated storage"" has no meaning; Not resolved. 2552; DRWP; Constant evaluation of non-defining variable declarations; Unknown. 2553; review; Restrictions on explicit object member functions; Clang 18. 2554; review; Overriding virtual functions, also with explicit object parameters; Clang 18. 2555; drafting; Ineffective redeclaration prevention for using-declarators; Not resolved. 2556; DR; Unusable promise::return_void; Unknown. 2557; drafting; Class member access referring to an unrelated class; Not resolved. 2558; C++23; Uninitialized subobjects as a result of an immediate invocation; Unknown. 2559; open; Defaulted consteval functions; Not resolved. 2560; tentatively ready; Parameter type determination in a requirement-parameter-list; Unknown. 2561; review; Conversion to function pointer for lambda with explicit object parameter; Clang 18. 2562; open; Exceptions thrown during coroutine startup; Not resolved. 2563; drafting; Initialization of coroutine result object; Not resolved. 2564; drafting; Conversion to function pointer with an explicit object parameter; Not resolved. 2565; open; Invalid types in the parameter-declaration-clause of a requires-expression; Clang 16. 2566; review; Matching deallocation for uncaught exception; Not resolved. 2567; NAD; Operator lookup ambiguity; Unknown. 2568; tentatively ready; Access checking during synthesis of defaulted comparison operator; Unknown. 2569; CD6; Use of decltype(capture) in a lambda's parameter-d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:175695,access,access,175695,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"operating system; to preclude mapping memory in the low two gigabytes of address space. ###### 64-bit load checking instructions. We can use the following instruction sequences to check loads. We set up `%r8`; in these examples to hold the special value of `-1` which will be `cmov`ed over; `%rax` in misspeculated paths. Single register addressing mode:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; orq %rax, %rsi # Mask the pointer if misspeculating.; movl (%rsi), %edi; ```. Two register addressing mode:; ```; ... .LBB0_4: # %danger; cmovneq %r8, %rax # Conditionally update predicate state.; orq %rax, %rsi # Mask the pointer if misspeculating.; orq %rax, %rcx # Mask the index if misspeculating.; movl (%rsi,%rcx), %edi; ```. This will result in a negative address near zero or in `offset` wrapping the; address space back to a small positive address. Small, negative addresses will; fault in user-mode for most operating systems, but targets which need the high; address space to be user accessible may need to adjust the exact sequence used; above. Additionally, the low addresses will need to be marked unreadable by the; OS to fully harden the load. ###### RIP-relative addressing is even easier to break. There is a common addressing mode idiom that is substantially harder to check:; addressing relative to the instruction pointer. We cannot change the value of; the instruction pointer register and so we have the harder problem of forcing; `%base + scale * %index + offset` to be an invalid address, by *only* changing; `%index`. The only advantage we have is that the attacker also cannot modify; `%base`. If we use the fast instruction sequence above, but only apply it to; the index, we will always access `%rip + (scale * -1) + offset`. If the; attacker can find a load which with this address happens to point to secret; data, then they can reach it. However, the loader and base libraries can also; simply refuse to map the heap, data se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:30086,access,accessible,30086,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['access'],['accessible']
Security,"opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, the ``Differential Revision``, etc from the review; and place it in the commit message. You may also commit an accepted change; directly using ``git push``, per the section in the :ref:`getting st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13519,access,access,13519,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['access'],['access']
Security,"opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76296,integrity,integrity,76296,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['integrity'],['integrity']
Security,"option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more detail",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78898,sanitiz,sanitize-address-outline-instrumentation,78898,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize-address-outline-instrumentation']
Security,"optional ``Params`` is used by ``StackSafety`` and looks like:. .. code-block:: text. Params: ((Param)[, (Param)]*). where each ``Param`` describes pointer parameter access inside of the; function and looks like:. .. code-block:: text. param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?. where the first ``param`` is the number of the parameter it describes,; ``offset`` is the inclusive range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:345180,access,accesses,345180,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security,"or (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol21->Fill(px,5*py);; hcol22->Fill(px,5*py);; }; hcol21->SetBit(TH1::kNoStats);; hcol22->SetBit(TH1::kNoStats);; gStyle->SetPalette(1);; c1->cd(1); hcol21->Draw(""COLZ"");; c1->cd(2); hcol22->Draw(""COLZ0"");; hcol22->SetMaximum(100);; hcol22->SetMinimum(40);; return c1;; }; ```; ![COLZ0 plot example](colz0.png ""COLZ0 plot example""); - The parameter `gStyle->SetHistTopMargin()` was ignored when plotting a 2D histogram; using the option `E`. This can be seen plotting the histogram with `""LEGO E""`.; - `GetObjectInfo` did not display the right value form `""Sum""` for histograms plotted; with option `SAME` on top of an histogram displayed with a subrange. This was; reported in ROOT-7124.; - Use `GeyStdDev` instead of `GetRMS`. The stat box now shows `Std Dev` instead; of `RMS`.; - The Stats Format was ignored when painting the pave stats for 2D histograms. ### TGraph2D. - Change `GetHistogram()` in order to be able to access the returned histogram; before the 2D graph has been filled with points. That was not possible previously.; This problem was reported; <a href=""https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=19186"">here</a>.; - When a `TGraph2D` was entirely in the plane `Z=0` the 3D could not be defined.; This problem was reported; <a href=""https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=19517"">here</a>. ### TMultiGraph; - When a `TMultiGraph` contained only one `TGraph` the number of bins for the; internal histogram was not set correctly. This problem was reported; <a href=""https://root.cern.ch/phpBB3/viewtopic.php?f=3&t=19603&p=83973#p83973"">here</a>. ### THStack. - Implement `GetNhists()` to return the number of histograms in the stack.; - New drawing option `NOSTACKB`. histograms are drawn next to each other as; bar charts. Example:. ``` {.cpp}; TCanvas* nostackb() {; TCanvas *cst0 = new TCanvas(""cst0"",""cst0"",600,400);; THStack *hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md:18426,access,access,18426,README/ReleaseNotes/v604/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v604/index.md,1,['access'],['access']
Security,"or code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.se",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62830,secur,security-MmapWriteExec,62830,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security-MmapWriteExec']
Security,"or everyone involved. If a report is received concerning a committee member, that member must not be; involved in the response process. The rest of the committee will meet and; decide on the report without the reported committee member being present, and; will not share more information than they would have with a non-member. If a; member of the committee is found to have violated the CoC, they may no longer; be able to keep serving on the committee. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. However, the Code of Conduct Committee will always; comply with law enforcement when directed. In the case that a CoC committee; member is involved in a report, the member will be asked to recuse themselves; from ongoing conversations, and they will not have access to reports after the; enforcement decision has been made. . In the event of a temporary suspension or ban, the appropriate people must be; notified of the ban in order to restrict access to infrastructure or events.; These individuals will only be notified of the person's name and the; restrictions imposed. They will be under a confidentiality clause and not; allowed to respond to questions regarding the ban and should direct all; questions to the CoC committee. . .. _Transparency Reports:. Transparency Reports; ====================. Lack of transparency in the outcomes of our Code of Conduct incidents leaves; our community without an understanding of how or if the organizers worked to; resolve incidents. The CoC committee should aim to publish transparency; reports, if reports are received, after major events (such as the LLVM; Developers' meetings) and on the following dates: Jan 15, April 15, July 15,; Oct 15. . A transparency report consists of 2 parts:. * An overview of the reports received, and resolutions.; * A more detailed summary of each reported incident and the resolution while; maintaining confidentiality. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:11668,access,access,11668,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['access'],['access']
Security,"or files being formatted; that are allowed to be considered ""main"" in the; file-to-main-include mapping. By default, clang-format considers files as ""main"" only when they end; with: ``.c``, ``.cc``, ``.cpp``, ``.c++``, ``.cxx``, ``.m`` or ``.mm``; extensions.; For these files a guessing of ""main"" include takes place; (to assign category 0, see above). This config option allows for; additional suffixes and extensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C(); C();; }; };; void foo() { void foo() {; return 1; return 1;; } }. .. _IndentCaseBlocks:. **IndentCaseBlocks** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <IndentCaseBlocks>`; Indent case label blocks one level from the case label. When ``false``, the block following the case label uses the same",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:69831,access,access,69831,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"or memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is allocated in host memory accessed as; MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also; causes it to be treated as non-volatile and so is not invalidated by; ``*_vol``.; * On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent); and so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX6-GFX9 are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table`. .. table:: AMDHSA Memory Model Code Sequences GFX6-GFX9; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX6-GFX9; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; ------------------------------------------------------------------------------------; load",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:211031,access,accessed,211031,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"or to run during the execution of; unmanaged code. Furthermore, it is common that coordinating the transition from; managed to unmanaged code requires extra code generation at the call site to; inform the collector of the transition. In order to support these needs, a; statepoint may be marked as a GC transition, and data that is necessary to; perform the transition (if any) may be provided as additional arguments to the; statepoint. Note that although in many cases statepoints may be inferred to be GC; transitions based on the function symbols involved (e.g. a call from a; function with GC strategy ""foo"" to a function with GC strategy ""bar""),; indirect calls that are also GC transitions must also be supported. This; requirement is the driving force behind the decision to require that GC; transitions are explicitly marked. Let's revisit the sample given above, this time treating the call to ``@foo``; as a GC transition. Depending on our target, the transition code may need to; access some extra state in order to inform the collector of the transition.; Let's assume a hypothetical GC--somewhat unimaginatively named ""hypothetical-gc""; --that requires that a TLS variable must be written to before and after a call; to unmanaged code. The resulting relocation sequence is:. .. code-block:: llvm. @flag = thread_local global i32 0, align 4. define i8 addrspace(1)* @test1(i8 addrspace(1) *%obj); gc ""hypothetical-gc"" {. %0 = call token (i64, i32, void ()*, i32, i32, ...)* @llvm.experimental.gc.statepoint.p0f_isVoidf(i64 0, i32 0, void ()* @foo, i32 0, i32 1, i32* @Flag, i32 0, i8 addrspace(1)* %obj); %obj.relocated = call coldcc i8 addrspace(1)* @llvm.experimental.gc.relocate.p1i8(token %0, i32 7, i32 7); ret i8 addrspace(1)* %obj.relocated; }. During lowering, this will result in an instruction selection DAG that looks; something like:. ::. CALLSEQ_START; ...; GC_TRANSITION_START (lowered i32 *@Flag), SRCVALUE i32* Flag; STATEPOINT; GC_TRANSITION_END (lowered i32 *@Flag), SR",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst:17546,access,access,17546,interpreter/llvm-project/llvm/docs/Statepoints.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Statepoints.rst,1,['access'],['access']
Security,"order to be more; useful on C++ codebases.; While full library modeling is not an easy task,; large gains can be achieved by supporting only a few cases:; e.g. calling .length() on an empty; std::string always yields zero.; (Difficulty: Medium). Enhance CFG to model exception-handling.; Currently exceptions are treated as ""black holes"", and exception-handling; control structures are poorly modeled in order to be conservative.; This could be improved for both C++ and Objective-C exceptions.; (Difficulty: Hard). Core Analyzer Infrastructure; ; Handle unions.; Currently in the analyzer the value of a union is always regarded as; an unknown.; This problem was; previously discussed; on the mailing list, but no solution was implemented.; (Difficulty: Medium) . Floating-point support.; Currently, the analyzer treats all floating-point values as unknown.; This project would involve adding a new SVal kind; for constant floats, generalizing the constraint manager to handle floats,; and auditing existing code to make sure it doesn't; make incorrect assumptions (most notably, that X == X; is always true, since it does not hold for NaN).; (Difficulty: Medium). Improved loop execution modeling.; The analyzer simply unrolls each loop N times before; dropping the path, for a fixed constant N.; However, that results in lost coverage in cases where the loop always; executes more than N times.; A Google Summer Of Code; project; was completed to make the loop bound parameterizable,; but the widening; problem still remains open. (Difficulty: Hard). Basic function summarization support; The analyzer performs inter-procedural analysis using; either inlining or ""conservative evaluation"" (invalidating all data; passed to the function).; Often, a very simple summary; (e.g. ""this function is pure"") would be; enough to be a large improvement over conservative evaluation.; Such summaries could be obtained either syntactically,; or using a dataflow framework.; (Difficulty: Hard). Implement a dat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html:6741,audit,auditing,6741,interpreter/llvm-project/clang/www/analyzer/open_projects.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/open_projects.html,2,['audit'],['auditing']
Security,"ore sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. T",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848324,access,accessed,848324,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"ore, which; eliminates a constant pool load. For example, consider:. define i64 @ccosf(float %z.0, float %z.1) nounwind readonly {; entry:; %tmp6 = fsub float -0.000000e+00, %z.1		; <float> [#uses=1]; %tmp20 = tail call i64 @ccoshf( float %tmp6, float %z.0 ) nounwind readonly; ret i64 %tmp20; }; declare i64 @ccoshf(float %z.0, float %z.1) nounwind readonly. This currently compiles to:. LCPI1_0:					# <4 x float>; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; 	.long	2147483648	# float -0; _ccosf:; 	subl	$12, %esp; 	movss	16(%esp), %xmm0; 	movss	%xmm0, 4(%esp); 	movss	20(%esp), %xmm0; 	xorps	LCPI1_0, %xmm0; 	movss	%xmm0, (%esp); 	call	L_ccoshf$stub; 	addl	$12, %esp; 	ret. Note the load into xmm0, then xor (to negate), then store. In PIC mode,; this code computes the pic base and does two loads to do the constant pool ; load, so the improvement is much bigger. The tricky part about this xform is that the argument load/store isn't exposed; until post-legalize, and at that point, the fneg has been custom expanded into ; an X86 fxor. This means that we need to handle this case in the x86 backend; instead of in target independent code. //===---------------------------------------------------------------------===//. Non-SSE4 insert into 16 x i8 is atrociously bad. //===---------------------------------------------------------------------===//. <2 x i64> extract is substantially worse than <2 x f64>, even if the destination; is memory. //===---------------------------------------------------------------------===//. INSERTPS can match any insert (extract, imm1), imm2 for 4 x float, and insert; any number of 0.0 simultaneously. Currently we only use it for simple; insertions. See comments in LowerINSERT_VECTOR_ELT_SSE4. //===---------------------------------------------------------------------===//. On a random note, SSE2 should declare insert/extract of 2 x f64 as legal, not; Custom. All combinations of insert/extract reg-reg, reg-m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt:13462,expose,exposed,13462,interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/README-SSE.txt,2,['expose'],['exposed']
Security,"ore; each kernel dispatch execution to allow constant memory to change values between; kernel dispatches. The local memory space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates work-groups of wavefronts, and; freed when all the wavefronts of a work-group have terminated. The data store; (DS) instructions can be used to access it. The private memory space uses the hardware scratch memory support. If the kernel; uses scratch, then the hardware allocates memory that is accessed using; wavefront lane dword (4 byte) interleaving. The mapping used from private; address to physical address is:. ``wavefront-scratch-base +; (private-address * wavefront-size * 4) +; (wavefront-lane-id * 4)``. There are different ways that the wavefront scratch base address is determined; by a wavefront (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). This; memory can be accessed in an interleaved manner using buffer instruction with; the scratch buffer descriptor and per wavefront scratch offset, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS req",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:154903,access,accessed,154903,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"orm:. .. code-block:: c. struct _block_byref_foo {; void *isa;; struct _block_byref_foo *forwarding;; int flags; //refcount;; int size;; // helper functions called via Block_copy() and Block_release(); void (*byref_keep)(void *dst, void *src);; void (*byref_dispose)(void *);; typeof(marked_variable) marked_variable;; };. The structure is initialized such that:. a. The ``forwarding`` pointer is set to the beginning of its enclosing; structure. b. The ``size`` field is initialized to the total size of the enclosing; structure. c. The ``flags`` field is set to either 0 if no helper functions are needed; or (1<<25) if they are. d. The helper functions are initialized (if present). e. The variable itself is set to its initial value. f. The ``isa`` field is set to ``NULL``. Access to ``__block`` variables from within its lexical scope; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In order to ""move"" the variable to the heap upon a ``copy_helper`` operation the; compiler must rewrite access to such a variable to be indirect through the; structures ``forwarding`` pointer. For example:. .. code-block:: c. int __block i = 10;; i = 11;. would be rewritten to be:. .. code-block:: c. struct _block_byref_i {; void *isa;; struct _block_byref_i *forwarding;; int flags; //refcount;; int size;; int captured_i;; } i = { NULL, &i, 0, sizeof(struct _block_byref_i), 10 };. i.forwarding->captured_i = 11;. In the case of a ``Block`` reference variable being marked ``__block`` the; helper code generated must use the ``_Block_object_assign`` and; ``_Block_object_dispose`` routines supplied by the runtime to make the; copies. For example:. .. code-block:: c. __block void (voidBlock)(void) = blockA;; voidBlock = blockB;. would translate into:. .. code-block:: c. struct _block_byref_voidBlock {; void *isa;; struct _block_byref_voidBlock *forwarding;; int flags; //refcount;; int size;; void (*byref_keep)(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src);; vo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst:13226,access,access,13226,interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Block-ABI-Apple.rst,1,['access'],['access']
Security,"ory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196647,validat,validate,196647,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['validat'],['validate']
Security,"ory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; - ``memory(readwrite, argmem: none)``: May access any memory apart from; argument memory. The supported memory location kinds are:. - ``argmem``: This refers to accesses that are based on pointer arguments; to the function.; - ``inaccessiblemem``: This refers to accesses to memory which is not; accessible by the current module (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, the; call-site annotation takes precedence over the potential effects described; by either the function annotation or the operand bundles.; ``minsize``; This attribute suggests that optimization passes and code generator; passes make choices that keep the code size of this function as small; as possible and perform optimizations that may sacrifice runtime; performance in order to minimize the size of the generated code.; This attribute is incompatible with the ``optdebug`` and ``optnone``; attributes.; ``naked``; This attribute disables prologue / epilogue emission for the; function. This can have very sy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:86086,access,access,86086,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"oryManager`` can use to identify executor memory for deallocation); and pass it to the ``OnFinalized`` callback. Finalized allocations (represented by ``FinalizedAlloc`` objects) can be; deallocated by calling the ``JITLinkMemoryManager::dealloc`` method. This method; takes a vector of ``FinalizedAlloc`` objects, since it is common to deallocate; multiple objects at the same time and this allows us to batch these requests for; transmission to the executing process. JITLink provides a simple in-process implementation of this interface:; ``InProcessMemoryManager``. It allocates pages once and re-uses them as both; working and target memory. ORC provides a cross-process-capable ``MapperJITLinkMemoryManager`` that can use; shared memory or ORC-RPC-based communication to transfer content to the executing; process. JITLinkMemoryManager and Security; ---------------------------------. JITLink's ability to link JIT'd code for a separate executor process can be; used to improve the security of a JIT system: The executor process can be; sandboxed, run within a VM, or even run on a fully separate machine. JITLink's memory manager interface is flexible enough to allow for a range of; trade-offs between performance and security. For example, on a system where code; pages must be signed (preventing code from being updated), the memory manager; can deallocate working memory pages after linking to free memory in the process; running JITLink. Alternatively, on a system that allows RWX pages, the memory; manager may use the same pages for both working and target memory by marking; them as RWX, allowing code to be modified in place without further overhead.; Finally, if RWX pages are not permitted but dual-virtual-mappings of; physical memory pages are, then the memory manager can dual map physical pages; as RW- in the JITLink process and R-X in the executor process, allowing; modification from the JITLink process but not from the executor (at the cost of; extra administrative overhead",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:30829,secur,security,30829,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['secur'],['security']
Security,"oryUse``. This can be seen in the above example; the; second ``MemoryUse`` in ``if.end`` has an operand of ``1``, which is a; ``MemoryDef`` from the entry block. This is done to make walking,; value numbering, etc, faster and easier.; As of `this revision <https://reviews.llvm.org/D121381>`_, the default was; changed to not optimize uses at build time, in order to provide the option to; reduce compile-time if the walking is not necessary in a pass. Most users call; the new API ``ensureOptimizedUses()`` to keep the previous behavior and do a; one-time optimization of ``MemoryUse``\ s, if this was not done before.; New pass users are recommended to call ``ensureOptimizedUses()``. Initially it was not possible to optimize ``MemoryDef``\ s in the same way, as we; restricted ``MemorySSA`` to one operand per access.; This was changed and ``MemoryDef``\ s now keep two operands.; The first one, the defining access, is; always the previous ``MemoryDef`` or ``MemoryPhi`` in the same basic block, or; the last one in a dominating predecessor if the current block doesn't have any; other accesses writing to memory. This is needed for walking Def chains.; The second operand is the optimized access, if there was a previous call on the; walker's ``getClobberingMemoryAccess(MA)``. This API will cache information; as part of ``MA``.; Optimizing all ``MemoryDef``\ s has quadratic time complexity and is not done; by default. A walk of the uses for any MemoryDef can find the accesses that were optimized; to it.; A code snippet for such a walk looks like this:. .. code-block:: c++. MemoryDef *Def; // find who's optimized or defining for this MemoryDef; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *DefUser = cast_of_null<MemoryDef>MA); if (DefUser->isOptimized() && DefUser->getOptimized() == Def) {; // User who is optimized to Def; } else {; // User who's defining access is Def; optimized to something else or not optimized.; }; }. When ``Mem",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:12209,access,access,12209,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,2,['access'],"['access', 'accesses']"
Security,"ot method in; the following way:. ``` {.cpp}; Connect(myButton, ""Pressed()"", ""TH1"", hist, ""SetMaximum(=123) "");; Connect(myButton, ""Pressed()"", ""TH1"", hist, ""Draw(=\""LEGO\"")"");; ```. As you see the parameter's value is preceded by the equation symbol (=).; Please note that this method of passing arguments by value works only; if the signal has less arguments than the slot.; If the signal method has the same number of arguments, then the slot; argument will be overwritten with the signal argument. In the; example below, the Draw option would be overwritten in the first line; by the emitted signal argument. The second line would be ok, the; argument passed by value would not be overwritten. ``` {.cpp}; Connect(myComboBox, ""Selected(const char*)"", ""TTree"", myTree, ""Draw(=\""x\"")"");; Connect(myComboBox, ""Selected(const char*)"", ""TTree"", myTree, ""Draw(const char*, =\"" y==1 \"")"");; ```. In addition, if the signal and slot arguments differ in argument type,; passing arguments by value leads to undefined behaviour and illegal; memory access, as the signal argument will be casted to another data; type. In the example below, if Selected emits Int_t = 1, then ChangeText; will try to read a TString at address 0x1. ``` {.cpp}; Connect(myComboBox, ""Selected(Int_t)"", ""TGTextButton"", myButton, ""ChangeText(=\""Hello\"")"");; ```. You have the possibility to destroy a signal/slot connection by using; `Disconnect()` methods. There are three ways to do this:. 1/ to destroy all connections to an object's signals;. 2/ to destroy all connections to a particular object's signal; 3/ to; detach an object from a specific receiver:. ``` {.cpp}; Disconnect(myObgect); // case 1; Disconnect(myObgect, ""mySignal""); // case 2; Disconnect(myObgect,0,myReceiver,0); // case 3; ```. Three parameters of these methods could be replaced by 0. The meaning in; these cases would be ""any signal"", ""any receiving object"", ""any slot of; the receiving object"", i.e. 0 is used as a wildcard. The sender; parameter cannot ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:50190,access,access,50190,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security,"ot naturally encode a needed element type. This is also; used for inline assembly. Note that some of the methods mentioned above only exist to support both typed; and opaque pointers at the same time, and will be dropped once the migration; has completed. For example, ``isOpaqueOrPointeeTypeEquals()`` becomes; meaningless once all pointers are opaque. While direct usage of pointer element types is immediately apparent in code,; there is a more subtle issue that opaque pointers need to contend with: A lot; of code assumes that pointer equality also implies that the used load/store; type or GEP source element type is the same. Consider the following examples; with typed and opaque pointers:. .. code-block:: llvm. define i32 @test(i32* %p) {; store i32 0, i32* %p; %bc = bitcast i32* %p to i64*; %v = load i64, i64* %bc; ret i64 %v; }. define i32 @test(ptr %p) {; store i32 0, ptr %p; %v = load i64, ptr %p; ret i64 %v; }. Without opaque pointers, a check that the pointer operand of the load and; store are the same also ensures that the accessed type is the same. Using a; different type requires a bitcast, which will result in distinct pointer; operands. With opaque pointers, the bitcast is not present, and this check is no longer; sufficient. In the above example, it could result in store to load forwarding; of an incorrect type. Code making such assumptions needs to be adjusted to; check the accessed type explicitly:; ``LI->getType() == SI->getValueOperand()->getType()``. Frontends; ---------. Frontends need to be adjusted to track pointee types independently of LLVM,; insofar as they are necessary for lowering. For example, clang now tracks the; pointee type in the ``Address`` structure. Frontends using the C API through an FFI interface should be aware that a; number of C API functions are deprecated and will be removed as part of the; opaque pointer transition::. LLVMBuildLoad -> LLVMBuildLoad2; LLVMBuildCall -> LLVMBuildCall2; LLVMBuildInvoke -> LLVMBuildInvoke2; LLVM",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:9246,access,accessed,9246,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['access'],['accessed']
Security,"ot resolved. 420; CD1; postfixexpression->scalar_type_dtor() inconsistent; Clang 9. 421; CD1; Is rvalue.field an rvalue?; Yes. 422; NAD; Is a typedef redeclaration allowed with a template type that might be the same?; Yes. 423; NAD; Can a conversion be done on the left operand of a compound assignment?; Yes. 424; CD1; Wording problem with issue 56 resolution on redeclaring typedefs in class scope; Yes. 425; CD1; Set of candidates for overloaded built-in operator with float operand; Yes. 426; C++17; Identically-named variables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29274,inject,injected,29274,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injected']
Security,"ot,; consider a :ref:`SmallVector <dss_smallvector>`). The cost of a heap allocated; array is the cost of the new/delete (aka malloc/free). Also note that if you; are allocating an array of a type with a constructor, the constructor and; destructors will be run for every element in the array (re-sizable vectors only; construct those elements actually used). .. _dss_tinyptrvector:. llvm/ADT/TinyPtrVector.h; ^^^^^^^^^^^^^^^^^^^^^^^^. ``TinyPtrVector<Type>`` is a highly specialized collection class that is; optimized to avoid allocation in the case when a vector has zero or one; elements. It has two major restrictions: 1) it can only hold values of pointer; type, and 2) it cannot hold a null pointer. Since this container is highly specialized, it is rarely used. .. _dss_smallvector:. llvm/ADT/SmallVector.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallVector<Type, N>`` is a simple class that looks and smells just like; ``vector<Type>``: it supports efficient iteration, lays out elements in memory; order (so you can do pointer arithmetic between elements), supports efficient; push_back/pop_back operations, supports efficient random access to its elements,; etc. The main advantage of SmallVector is that it allocates space for some number of; elements (N) **in the object itself**. Because of this, if the SmallVector is; dynamically smaller than N, no malloc is performed. This can be a big win in; cases where the malloc/free call is far more expensive than the code that; fiddles around with the elements. This is good for vectors that are ""usually small"" (e.g. the number of; predecessors/successors of a block is usually less than 8). On the other hand,; this makes the size of the SmallVector itself large, so you don't want to; allocate lots of them (doing so will waste a lot of space). As such,; SmallVectors are most useful when on the stack. In the absence of a well-motivated choice for the number of; inlined elements ``N``, it is recommended to use ``SmallVector<T>`` (that is,; omittin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:59712,access,access,59712,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"ot[] THtml h; root[] h.Convert(""MyCode.C"", ""Look At My Code"", ""htmlout/"");; ```. This will create the file `htmlout/MyCode.C.html`. The HTML page will; have the title ""Look At My Code"". ## Special Documentation Elements: Directives. A common documentation problem is the inclusion of images. They are; usually generated externally, which poses problems with where to keep; the images, and how to keep them up to date. **`THtml`** solves this by; offering a few special documentation elements: macro and latex; directives. ### Latex Directive. Documentation surrounded by the keywords `BEGIN_LATEX / END_LATEX` will; be passed to ROOT Latex engine **`TLatex`**. The keywords can be written; with small or capital letters (case insensitive). The output will be; stored to an image file, which gets automatically included in the; documentation. ``` {.cpp}; // This function calculates BEGIN_LATEX; // F(x_{#frac{1}{2}}) = #prod(x < x_{#frac{1}{2}}) = #frac{1}{2}; // END_LATEX; ```. THtml will inject the following picture:. ![](pictures/0300022D.png). The image file name is generated from the formula and will be unique for; all the documentation. It is stored along-side the documentation, and it; will be automatically regenerated when the documentation is updated. The; handling of the Latex directive is done by the class; **`TDocLatexDirective`**. The `BEGIN_LATEX` keyword can take the following parameters:. - `fontsize`: sets the **`TLatex`** font size. The default value is 16. - `separator`: sets a list of characters for which a new column will; be started. This allows aligned, multi-line, multi-column layout,; which can be useful for e.g. mathematical derivations. It is unset; by default, meaning the Latex directive will only generate one; column. - `rseparator`: like separator, but a regular expression. Columns; start with a match of this regular expression. Only one of separator; or rseparator can be given. - `align`: defines the alignment of the columns. Note that the column; d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md:5981,inject,inject,5981,documentation/users-guide/HTMLDoc.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/HTMLDoc.md,1,['inject'],['inject']
Security,"otected or; private members if you hide them in the display options. Inheritance; You can often access members of a class's base classes, just as if they are defined; in the derived class. A histogram,; for example, has a name, and you can access it using GetName() as defined in its base; class TNamed. If you want to see; all available members, and not just the ones defined in the current class, in the; display options. They will be prefixed with the name of; the class they are defined in. Class Charts; The class charts are shown in a tabbed box; click on the names ontop to select a tab. Inheritance; This chart shows the inheritance hierarchy for the current class. Arrows point to; base classes. You can click the classes to get to their reference page. Inherited Members; The second chart shows a list of all members of all base classes. You can see at what; level they are defined or at what level they are defined. Members that are accessible; (public) have a green background, protected ones have a yellow background, and private; members have a red background. Members with a dark gray background are re-implemented; or hidden by a derived class. Includes; The Includes chart shows which files are indirectly included by including the class's; header. Most headers will #include some files, so by #including that header you also; #include the #included files, and so on. A illegible chart often means you should; read a bit on the C++ trick known as ""forward declaration"". Including too many headers; has some nasty consequences, like compile time, additional dependencies, etc. Libraries; Each class is assumed to be in a library. That library might depend on other libraries.; The fourth chart shows the dependencies of these libraries. You will need to link against; all of these if you write your own program. Member Function Documentation; Each function should be documented by the developer of the class. The documentation can; contain HTML, pictures, and example code. It should ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html:7296,access,accessible,7296,etc/html/HELP.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/etc/html/HELP.html,2,['access'],['accessible']
Security,"other option. #### The dictionaries. The most convenient place to specify the conversion rules is a dictionary. One can; do that either in a LinkDef file or in the selection xml file being fed to genreflex.; The syntax of the rules is the following:. - For dictionaries created from a LinkDef file:. ``` {.cpp}; #pragma read \; sourceClass=""ClassA"" \; source=""double m_a; double m_b; double m_c"" \; version=""[4-5,7,9,12-]"" \; checksum=""[12345,123456]"" \; targetClass=""ClassB"" \; target=""m_x"" \; embed=""true"" \; include=""iostream,cstdlib"" \; code=""{m_x = onfile.m_a * onfile.m_b * onfile.m_c; }"" \. #pragma readraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:78982,checksum,checksum,78982,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['checksum'],['checksum']
Security,"other; operations within the same address space. ``workgroup-one-as`` Same as ``workgroup`` but only synchronizes with; other operations within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, v_sqrt_f32 and v_sqrt_f16; (on targets with half support). Performs sqrt function. llvm.amdgcn.log Provides direct access to v_log_f32 and v_log_f16; (on targets with half support). Performs log2 function. llvm.amdgcn.exp2 Provides direct access to v_exp_f32 and v_exp_f16; (on targets with half support). Performs exp2 function. :ref:`llvm.frexp <int_frexp>` Implemented for half, float and double. :ref:`llvm.log2 <int_log2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.sqrt <int_sqrt>` Implemented for double, float and half (and vectors). :ref:`llvm.log <int_log>` Implemented for float and half (and vectors). :ref:`llvm.exp <int_exp>` Implemented for float and half (and vectors). :ref:`llvm.log10 <int_log10>` Implemented for float and half (and vectors). :ref:`llvm.exp2 <int_exp2>` Implemented for float and hal",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:35837,access,access,35837,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"ould be concise. Because all commits are emailed to the list with; the first line as the subject, long titles are frowned upon. Short titles; also look better in `git log`. * When the changes are restricted to a specific part of the code (e.g. a; back-end or optimization pass), it is customary to add a tag to the; beginning of the line in square brackets. For example, ""[SCEV] ...""; or ""[OpenMP] ..."". This helps email filters and searches for post-commit; reviews. * The body, if it exists, should be separated from the title by an empty line. * The body should be concise, but explanatory, including a complete; reasoning. Unless it is required to understand the change, examples,; code snippets and gory details should be left to bug comments, web; review or the mailing list. * Text formatting and spelling should follow the same rules as documentation; and in-code comments, ex. capitalization, full stop, etc. * If the commit is a bug fix on top of another recently committed patch, or a; revert or reapply of a patch, include the git commit hash of the prior; related commit. This could be as simple as ""Revert commit NNNN because it; caused PR#"". * If the patch has been reviewed, add a link to its review page, as shown; `here <https://www.llvm.org/docs/Phabricator.html#committing-a-change>`__.; If the patch fixes a bug in GitHub Issues, we encourage adding a reference to; the issue being closed, as described; `here <https://llvm.org/docs/BugLifeCycle.html#resolving-closing-bugs>`__. * It is also acceptable to add other metadata to the commit message to automate; processes, including for downstream consumers. This metadata can include; links to resources that are not available to the entire community. However,; such links and/or metadata should not be used in place of making the commit; message self-explanatory. Note that such non-public links should not be; included in the submitted code. For minor violations of these recommendations, the community normally favors; reminding",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:17352,hash,hash,17352,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,1,['hash'],['hash']
Security,"ould take those consequences into account. Remember; that we're a world-wide community, so you might not be communicating in; someone else's primary language. .. _be respectful:. * **Be respectful.** Not all of us will agree all the time, but disagreement is; no excuse for poor behavior and poor manners. We might all experience some; frustration now and then, but we cannot allow that frustration to turn into; a personal attack. It's important to remember that a community where people; feel uncomfortable or threatened is not a productive one. Members of the LLVM; community should be respectful when dealing with other members as well as; with people outside the LLVM community. .. _be careful in the words that you choose and be kind to others:. * **Be careful in the words that you choose and be kind to others.** Do not; insult or put down other participants. Harassment and other exclusionary; behavior aren't acceptable. This includes, but is not limited to:. * Violent threats or language directed against another person.; * Discriminatory jokes and language.; * Posting sexually explicit or violent material.; * Posting (or threatening to post) other people's personally identifying; information (""doxing"").; * Personal insults, especially those using racist or sexist terms.; * Unwelcome sexual attention.; * Advocating for, or encouraging, any of the above behavior. In general, if someone asks you to stop, then stop. Persisting in such; behavior after being asked to stop is considered harassment. .. _when we disagree, try to understand why:. * **When we disagree, try to understand why.** Disagreements, both social and; technical, happen all the time and LLVM is no exception. It is important that; we resolve disagreements and differing views constructively. Remember that; we're different. The strength of LLVM comes from its varied community, people; from a wide range of backgrounds. Different people have different; perspectives on issues. Being unable to understand why someon",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:4192,threat,threats,4192,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['threat'],['threats']
Security,"ounwind. ; Definition of main function; define i32 @main() {; ; Call puts function to write out the string to stdout.; call i32 @puts(ptr @.str); ret i32 0; }. ; Named metadata; !0 = !{i32 42, null, !""string""}; !foo = !{!0}. This example is made up of a :ref:`global variable <globalvars>` named; ""``.str``"", an external declaration of the ""``puts``"" function, a; :ref:`function definition <functionstructure>` for ""``main``"" and; :ref:`named metadata <namedmetadatastructure>` ""``foo``"". In general, a module is made up of a list of global values (where both; functions and global variables are global values). Global values are; represented by a pointer to a memory location (in this case, a pointer; to an array of char, and a pointer to a function), and have one of the; following :ref:`linkage types <linkage>`. .. _linkage:. Linkage Types; -------------. All Global Variables and Functions have one of the following types of; linkage:. ``private``; Global values with ""``private``"" linkage are only directly; accessible by objects in the current module. In particular, linking; code into a module with a private global value may cause the; private to be renamed as necessary to avoid collisions. Because the; symbol is private to the module, all references can be updated. This; doesn't show up in any symbol table in the object file.; ``internal``; Similar to private, but the value shows as a local symbol; (``STB_LOCAL`` in the case of ELF) in the object file. This; corresponds to the notion of the '``static``' keyword in C.; ``available_externally``; Globals with ""``available_externally``"" linkage are never emitted into; the object file corresponding to the LLVM module. From the linker's; perspective, an ``available_externally`` global is equivalent to; an external declaration. They exist to allow inlining and other; optimizations to take place given knowledge of the definition of the; global, which is known to be somewhere outside the module. Globals; with ``available_externally",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:7439,access,accessible,7439,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessible']
Security,"oup``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; .",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:312539,access,access,312539,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['access']
Security,"our :doc:`Response Guide <ResponseGuide>`. Confidentiality; ===============. All reports will be kept confidential with details shared only with the Code of; Conduct committee members. In the case that a CoC committee member is involved; in a report, the member will be asked to recuse themselves from ongoing; conversations, and they will not have access to any reports at any time.; Resolution action may also include removal of that member from the CoC; committee. Some incidents happen in one-on-one interactions, and though details are; anonymized, the reported person may be able to guess who made the report. If; you have concerns about retaliation or your personal safety, please note those; concerns in your report. You are still encouraged to report the incident so; that we can support you while keeping our community members safe. In some; cases, we can compile several anonymized reports into a pattern of behavior,; and take action on that pattern. . Transparency reports will be published but will retain confidentiality. See the; :doc:`Response Guide <ResponseGuide>`. for details on this. Following Up With Reporter(s); =============================. Once a report is filed, the Code of Conduct committee will handle the review; and follow up according to the procedures in the :doc:`Response Guide; <ResponseGuide>`. . Thanks!; =======. This guide was created and inspired by the following: the `Django Project`_,; `Carpentries Response Guide`_, and the `Write The Docs Response Guide`_. License; =======. All content on this page is licensed under a `Creative Commons Attribution 3.0; Unported License`_. .. _Django Project: https://www.djangoproject.com/conduct/; .. _Carpentries Response Guide: https://docs.carpentries.org/topic_folders/policies/enforcement-guidelines.html; .. _Write The Docs Response Guide: https://www.writethedocs.org/code-of-conduct/#guidelines-for-reporting-incidents; .. _Creative Commons Attribution 3.0 Unported License: http://creativecommons.org/lice",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst:4545,confidential,confidentiality,4545,interpreter/llvm-project/llvm/docs/ReportingGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReportingGuide.rst,1,['confidential'],['confidentiality']
Security,"ously needed for location list expressions.*. .. note::. The rest of this section is the same as DWARF Version 5 section 2.6.2. .. _amdgpu-dwarf-address-spaces:. A.2.13 Address Spaces; ~~~~~~~~~~~~~~~~~~~~~. .. note::. This is a new section after DWARF Version 5 section 2.12 Segmented Addresses. DWARF address spaces correspond to target architecture specific linear; addressable memory areas. They are used in DWARF expression location; descriptions to describe in which target architecture specific memory area data; resides. *Target architecture specific DWARF address spaces may correspond to hardware; supported facilities such as memory utilizing base address registers, scratchpad; memory, and memory with special interleaving. The size of addresses in these; address spaces may vary. Their access and allocation may be hardware managed; with each thread or group of threads having access to independent storage. For; these reasons they may have properties that do not allow them to be viewed as; part of the unified global virtual address space accessible by all threads.*. *It is target architecture specific whether multiple DWARF address spaces are; supported and how source language memory spaces map to target architecture; specific DWARF address spaces. A target architecture may map multiple source; language memory spaces to the same target architecture specific DWARF address; class. Optimization may determine that variable lifetime and access pattern; allows them to be allocated in faster scratchpad memory represented by a; different DWARF address space than the default for the source language memory; space.*. Although DWARF address space identifiers are target architecture specific,; ``DW_ASPACE_LLVM_none`` is a common address space supported by all target; architectures, and defined as the target architecture default address space. DWARF address space identifiers are used by:. * The ``DW_AT_LLVM_address_space`` attribute. * The DWARF expression operations: ``DW_OP_asp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:148632,access,accessible,148632,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessible']
Security,"p (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23837,secur,security,23837,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"p if `Thread0`; is not static. On the other hand, if `Thread0` is static, no compiler; warnings are generated at all. Because the `'this'` pointer is passed in; `'arg'` in the call to `Thread0(void *arg),` you have access to the; instance of the class even if `Thread0` is static. Using the `'this'`; pointer, non static members can still be read and written from; `Thread0`, as long as you have provided Getter and Setter methods for; these members. For example:. ``` {.cpp}; Bool_t state = arg->GetRunStatus();; arg->SetRunStatus(state);; ```. Second, the pointer to the current instance of `Myclass`, i.e. (void\*); this, has to be passed as first argument of the threaded function; Thread0 (C++ member functions internally expect this pointer as first; argument to have access to class members of the same instance).; `pthreads` are made for simple C functions and do not know about Thread0; being a member function of a class. Thus, you have to pass this; information by hand, if you want to access all members of the `Myclass`; instance from the Thread0 function. Note: Method Thread0 cannot be a virtual member function, since the cast; of `Thread0` to `void(*)` in the **`TThread`** constructor may raise; problems with C++ virtual function table. However, Thread0 may call; another virtual member function virtual void `Myclass::Func0()` which; then can be overridden in a derived class of `Myclass`. (See example; `TMhs3`). Class `Myclass` may also provide a method to stop the running thread:. ``` {.cpp}; Int_t Myclass::Threadstop() {; if (mTh) {; TThread::Delete(mTh);; delete mTh;; mTh=0;; return 0;; }; return 1;; }; ```. Example `TMhs3:` Class **`TThreadframe`**; (`TThreadframe.h, TThreadframe.cxx`) is a simple example of a framework; class managing up to four threaded methods. Class `TMhs3`; (`TMhs3.h, TMhs3.cxx)` inherits from this base class, showing the `mhs3`; example 8.1 `(mhs3.h, mhs3.cxx) `within a class. The `Makefile` of this; example builds the shared libraries `libT",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:15773,access,access,15773,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['access'],['access']
Security,"p level parallelism. The intrinsic; implements predefined intruction scheduling orderings. The intrinsic applies to the; surrounding scheduling region. The intrinsic takes a value that specifies the; strategy. The compiler implements two strategies. 0. Interleave DS and MFMA instructions for small GEMM kernels.; 1. Interleave DS and MFMA instructions for single wave small GEMM kernels. Only one iglp_opt intrinsic may be used in a scheduling region. The iglp_opt intrinsic; cannot be combined with sched_barrier or sched_group_barrier. The iglp_opt strategy implementations are subject to change. llvm.amdgcn.atomic.cond.sub.u32 Provides direct access to flat_atomic_cond_sub_u32, global_atomic_cond_sub_u32; and ds_cond_sub_u32 based on address space on gfx12 targets. This; performs subtraction only if the memory value is greater than or; equal to the data value. llvm.amdgcn.s.getpc Provides access to the s_getpc_b64 instruction, but with the return value; sign-extended from the width of the underlying PC hardware register even on; processors where the s_getpc_b64 instruction returns a zero-extended value. ============================================== ==========================================================. .. TODO::. List AMDGPU intrinsics. LLVM IR Attributes; ------------------. The AMDGPU backend supports the following LLVM IR attributes. .. table:: AMDGPU LLVM IR Attributes; :name: amdgpu-llvm-ir-attributes-table. ======================================= ==========================================================; LLVM Attribute Description; ======================================= ==========================================================; ""amdgpu-flat-work-group-size""=""min,max"" Specify the minimum and maximum flat work group sizes that; will be specified when the kernel is dispatched. Generated; by the ``amdgpu_flat_work_group_size`` CLANG attribute [CLANG-ATTR]_.; The IR implied default value is 1,1024. Clang may emit this attribute; with more restrictive bounds de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:45529,access,access,45529,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"p onto these; instructions as such:; * [`llvm.ptrauth.sign`](#llvm-ptrauth-sign): `PAC{I,D}{A,B}{Z,SP,}`; * [`llvm.ptrauth.auth`](#llvm-ptrauth-auth): `AUT{I,D}{A,B}{Z,SP,}`; * [`llvm.ptrauth.strip`](#llvm-ptrauth-strip): `XPAC{I,D}`; * [`llvm.ptrauth.blend`](#llvm-ptrauth-blend): The semantics of the blend; operation are specified by the ABI. In both the ELF PAuth ABI Extension and; arm64e, it's a `MOVK` into the high 16 bits. Consequently, this limits; the width of the integer discriminator used in blends to 16 bits.; * [`llvm.ptrauth.sign_generic`](#llvm-ptrauth-sign-generic): `PACGA`; * [`llvm.ptrauth.resign`](#llvm-ptrauth-resign): `AUT*+PAC*`. These are; represented as a single pseudo-instruction in the backend to guarantee that; the intermediate raw pointer value is not spilled and attackable. #### Assembly Representation. At the assembly level, authenticated relocations are represented; using the `@AUTH` modifier:. ```asm; .quad _target@AUTH(<key>,<discriminator>[,addr]); ```. where:; * `key` is the Armv8.3-A key identifier (`ia`, `ib`, `da`, `db`); * `discriminator` is the 16-bit unsigned discriminator value; * `addr` signifies that the authenticated pointer is address-discriminated; (that is, that the relocation's target address is to be blended into the; `discriminator` before it is used in the sign operation. For example:; ```asm; _authenticated_reference_to_sym:; .quad _sym@AUTH(db,0); _authenticated_reference_to_sym_addr_disc:; .quad _sym@AUTH(ia,12,addr); ```. #### ELF Object File Representation. At the object file level, authenticated relocations are represented; using the `R_AARCH64_AUTH_ABS64` relocation kind (with value `0xE100`). The signing schema is encoded in the place of relocation to be applied; as follows:. ```; | 63 | 62 | 61:60 | 59:48 | 47:32 | 31:0 |; | ----------------- | -------- | -------- | -------- | ------------- | ------------------- |; | address diversity | reserved | key | reserved | discriminator | reserved for addend |; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:9737,authenticat,authenticated,9737,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,2,['authenticat'],['authenticated']
Security,"p semantics with attributes like; ``ns_returns_retained``, this attribute allows the user to communicate; semantic intent, which is of use both to ARC (which, e.g., treats calls to; ``init`` specially) and the static analyzer. .. _arc.family.semantics:. Semantics of method families; ----------------------------. A method's membership in a method family may imply non-standard semantics for; its parameters and return type. Methods in the ``alloc``, ``copy``, ``mutableCopy``, and ``new`` families ---; that is, methods in all the currently-defined families except ``init`` ---; implicitly :ref:`return a retained object; <arc.object.operands.retained-return-values>` as if they were annotated with; the ``ns_returns_retained`` attribute. This can be overridden by annotating; the method with either of the ``ns_returns_autoreleased`` or; ``ns_returns_not_retained`` attributes. Properties also follow same naming rules as methods. This means that those in; the ``alloc``, ``copy``, ``mutableCopy``, and ``new`` families provide access; to :ref:`retained objects <arc.object.operands.retained-return-values>`. This; can be overridden by annotating the property with ``ns_returns_not_retained``; attribute. .. _arc.family.semantics.init:. Semantics of ``init``; ^^^^^^^^^^^^^^^^^^^^^. Methods in the ``init`` family implicitly :ref:`consume; <arc.objects.operands.consumed>` their ``self`` parameter and :ref:`return a; retained object <arc.object.operands.retained-return-values>`. Neither of; these properties can be altered through attributes. A call to an ``init`` method with a receiver that is either ``self`` (possibly; parenthesized or casted) or ``super`` is called a :arc-term:`delegate init; call`. It is an error for a delegate init call to be made except from an; ``init`` method, and excluding blocks within such methods. As an exception to the :ref:`usual rule <arc.misc.self>`, the variable ``self``; is mutable in an ``init`` method and has the usual semantics for a ``__strong``; var",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:72579,access,access,72579,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['access']
Security,"p table entry,; jump table range check, and `JMP` to the jump table entry. This protection is also *near-precise*. Returns from functions called indirectly; ----------------------------------------. If a function is called indirectly, the return jump table is constructed for the; equivalence class of functions instead of a single function. Cross-DSO calls; ---------------; Consider two instrumented DSOs, `A` and `B`. `A` defines `f()` and `B` calls it. This case will be handled similarly to the cross-DSO scheme using the slow path callback. Non-goals; ---------. RCFI does not protect `RET` instructions:; * in non-instrumented DSOs,; * in instrumented DSOs for functions that are called from non-instrumented DSOs,; * embedded into other instructions (e.g. `0f4fc3 cmovg %ebx,%eax`). .. _SafeStack: https://clang.llvm.org/docs/SafeStack.html; .. _RFG: https://xlab.tencent.com/en/2016/11/02/return-flow-guard; .. _Intel CET: https://software.intel.com/en-us/blogs/2016/06/09/intel-release-new-technology-specifications-protect-rop-attacks. Hardware support; ================. We believe that the above design can be efficiently implemented in hardware.; A single new instruction added to an ISA would allow to perform the forward-edge CFI check; with fewer bytes per check (smaller code size overhead) and potentially more; efficiently. The current software-only instrumentation requires at least; 32-bytes per check (on x86_64).; A hardware instruction may probably be less than ~ 12 bytes.; Such instruction would check that the argument pointer is in-bounds,; and is properly aligned, and if the checks fail it will either trap (in monolithic scheme); or call the slow path function (cross-DSO scheme).; The bit vector lookup is probably too complex for a hardware implementation. .. code-block:: none. // This instruction checks that 'Ptr'; // * is aligned by (1 << kAlignment) and; // * is inside [kRangeBeg, kRangeBeg+(kRangeSize<<kAlignment)); // and if the check fails it jumps to the g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:27793,attack,attacks,27793,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['attack'],['attacks']
Security,"p`** and **`TGVButtonGroup`** are convenience classes; that offer you a thin layer on top of **`TGButtonGroup`**.; **`TGHButtonGroup`** organize button widgets in a group of one; horizontal row, **`TGVButtonGroup`** in a group of one column. You can; also organize buttons in rows and columns using the provided constructor; and **`TGMatrixLayout`**. Do not use a radio button to indicate the presence or absence of a state; - use a check box instead. ![](pictures/03000212.png). To have the check button ""Event Status"" and to set it as selected we; need to write:. ``` {.cpp}; TGCheckButton *estat = new TGCheckButton(p, ""Event Status"",1);; estat->SetState(kButtonDown);; ```. Check boxes show the selected choices and any number of them can be; selected, including none. Their proper usage is for setting attributes,; properties or values; also for data or choices that are discrete, small; and fixed in number, not easily remembered. With check boxes all; alternatives are visible: it is easy to access and compare choices; because they can all be seen together. Each option acts as a switch and; can be either ""on"" or ""off"". It is never changed in contents. Checkboxes; differ from radio buttons in that they permit selection of more than one; alternative. Each box can be switched on or off independently. These; buttons can be used alone or grouped in sets. It is good practice to; provide default settings for check boxes whenever it is possible. ![](pictures/03000213.png). This can be done by:. ``` {.cpp}; SetState(EButtonState state); ```. The parameter state can be one of `kButtonUp`, `kButtonDown`,; `kButtonEngaged`, `kButtonDisabled`. Check boxes can be used to affect other controls. The contents of a list; can, for example, be filtered by setting a check box. In any case, use a; check box only when both states of a choice are clearly opposite and; unambiguous. If opposite states are not clear, it is better to use two; radio buttons. Choice description, i.e. check box label, mus",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:62290,access,access,62290,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security,"pairs; that are currently inserted in the map. DenseMap is a great way to map; pointers to pointers, or map other small types to each other. There are several aspects of DenseMap that you should be aware of, however.; The iterators in a DenseMap are invalidated whenever an insertion occurs,; unlike map. Also, because DenseMap allocates space for a large number of; key/value pairs (it starts with 64 by default), it will waste a lot of space if; your keys or values are large. Finally, you must implement a partial; specialization of DenseMapInfo for the key that you want, if it isn't already; supported. This is required to tell DenseMap about two special marker values; (which can never be inserted into the map) that it needs internally. DenseMap's find_as() method supports lookup operations using an alternate key; type. This is useful in cases where the normal key type is expensive to; construct, but cheap to compare against. The DenseMapInfo is responsible for; defining the appropriate comparison and hashing methods for each alternate key; type used. DenseMap.h also contains a SmallDenseMap variant, that similar to; :ref:`SmallVector <dss_smallvector>` performs no heap allocation until the; number of elements in the template parameter N are exceeded. .. _dss_valuemap:. llvm/IR/ValueMap.h; ^^^^^^^^^^^^^^^^^^^. ValueMap is a wrapper around a :ref:`DenseMap <dss_densemap>` mapping; ``Value*``\ s (or subclasses) to another type. When a Value is deleted or; RAUW'ed, ValueMap will update itself so the new version of the key is mapped to; the same value, just as if the key were a WeakVH. You can configure exactly how; this happens, and what else happens on these two events, by passing a ``Config``; parameter to the ValueMap template. .. _dss_intervalmap:. llvm/ADT/IntervalMap.h; ^^^^^^^^^^^^^^^^^^^^^^. IntervalMap is a compact map for small keys and values. It maps key intervals; instead of single keys, and it will automatically coalesce adjacent intervals.; When the map onl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:91830,hash,hashing,91830,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['hash'],['hashing']
Security,"params=0);; ```. - `name:` name assigned to the medium; - `mat:` pointer to a material; - `params:` array of additional parameters. Another constructor allows effectively defining tracking parameters in; GEANT3 style:. ``` {.cpp}; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; ```. This constructor is reserved for creating tracking media from the VMC; interface [...]:. - `numed:` user-defined medium index; - `imat:` unique ID of the material; - `others:` see G3 documentation. Looking at our simple world example, one can see that for creating; volumes one needs to create tracking media before. The way to proceed; for those not interested in performing tracking with external MC's is to; define and use only one `dummy tracking medium` as in the example (or a; `NULL` pointer). ### User Interface for Handling Materials and Media. The **`TGeoManager`** class contains the API for accessing and handling; defined materials:. ``` {.cpp}; TGeoManager::GetMaterial(name);; ```. ## Shapes. Shapes are geometrical objects that provide the basic modeling; functionality. They provide the definition of the `local` coordinate; system of the volume. Any volume must have a shape. Any shape recognized; by the modeller has to derive from the base **`TGeoShape`** class,; providing methods for:. - Finding out if a point defined in their local frame is contained or; not by the shape;; - Computing the distance to enter/exit the shape from a local point,; given a known direction;; - Computing the maximum distance in any direction from a local point; that does NOT result in a boundary crossing of the shape (safe; distance);; - Computing the cosines of the normal vector to the crossed shape; surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to; provide navigation functionality. In addition to those, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:23037,access,accessing,23037,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessing']
Security,"paths. Modules can have a number of different kinds of members, each of which is described below:. .. parsed-literal::. *module-member*:; *requires-declaration*; *header-declaration*; *umbrella-dir-declaration*; *submodule-declaration*; *export-declaration*; *export-as-declaration*; *use-declaration*; *link-declaration*; *config-macros-declaration*; *conflict-declaration*. An extern module references a module defined by the *module-id* in a file given by the *string-literal*. The file can be referenced either by an absolute path or by a path relative to the current map file. Requires declaration; ~~~~~~~~~~~~~~~~~~~~; A *requires-declaration* specifies the requirements that an importing translation unit must satisfy to use the module. .. parsed-literal::. *requires-declaration*:; ``requires`` *feature-list*. *feature-list*:; *feature* (',' *feature*)*. *feature*:; ``!``:sub:`opt` *identifier*. The requirements clause allows specific modules or submodules to specify that they are only accessible with certain language dialects, platforms, environments and target specific features. The feature list is a set of identifiers, defined below. If any of the features is not available in a given translation unit, that translation unit shall not import the module. When building a module for use by a compilation, submodules requiring unavailable features are ignored. The optional ``!`` indicates that a feature is incompatible with the module. The following features are defined:. altivec; The target supports AltiVec. blocks; The ""blocks"" language feature is available. coroutines; Support for the coroutines TS is available. cplusplus; C++ support is available. cplusplus11; C++11 support is available. cplusplus14; C++14 support is available. cplusplus17; C++17 support is available. cplusplus20; C++20 support is available. cplusplus23; C++23 support is available. c99; C99 support is available. c11; C11 support is available. c17; C17 support is available. c23; C23 support is available",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:33524,access,accessible,33524,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['access'],['accessible']
Security,"pdated in web browser, using THttpServer monitoring capability like histogram objects. ## Tutorials; - Add the ""Legacy"" category collecting the old tutorials which do not represent any more best practices. ## Class Reference Guide; - Images in tutorials can now be displayed à JavaScript thanks to the (js) option; added next to the directive `\macro_image`; - As the tutorial `palettes.C` is often hit when searching the keyword `palette`; in the reference guide, a direct link from this example to the full list of; predefined palettes given in `TColor` has been added.; - Revisited the TSpectrum2 documentation. All the static images have been replaced; by macros generating images at reference guide build time. These macros have; been added in the tutorial section of the reference guide.; - The Reference Guide can now be accessed directly from the ROOT prompt thanks to; a great extension (implemented by Desislava Kalaydjieva) of the `.help` command.; For example to access the Reference Guide for `TTree` it is enough to type:; ~~~ {.cpp}; root[0] .help TTree; ~~~; To open the reference guide for a function/member:; ~~~ {.cpp}; root[0] .help TTree::Draw; ~~~. ## Build, Configuration and Testing Infrastructure. - Make MLP optional via the `-Dmlp={OFF,ON}` switch for CMake; - Make Spectrum optional via the `-Dspectrum={OFF,ON}` switch for CMake; - ROOT now fails to configure when any package is missing; when `-Dfail-on-missing=ON` is passed to CMake; - The `-Dall=ON` now switches the default value of all optional packages to `ON`; - The options `astiff`, `cling`, `pch`, `thread`, and `explicitlink` have been; removed and are now ignored. They either had no effect (their value was not; being used in the build system), or could not be disabled (like `cling` and; `explicitlink`).; - ROOT library targets now export which C++ standard they were built with via; the target compile features `cxx_std_11`, `cxx_std_14`, and `cxx_std_17`.; - The file `RootNewMacros.cmake` has been renam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md:7610,access,access,7610,README/ReleaseNotes/v620/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v620/index.md,1,['access'],['access']
Security,"pe_traits""; }; }. Header declaration; ~~~~~~~~~~~~~~~~~~; A header declaration specifies that a particular header is associated with the enclosing module. .. parsed-literal::. *header-declaration*:; ``private``:sub:`opt` ``textual``:sub:`opt` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``umbrella`` ``header`` *string-literal* *header-attrs*:sub:`opt`; ``exclude`` ``header`` *string-literal* *header-attrs*:sub:`opt`. *header-attrs*:; '{' *header-attr** '}'. *header-attr*:; ``size`` *integer-literal*; ``mtime`` *integer-literal*. A header declaration that does not contain ``exclude`` nor ``textual`` specifies a header that contributes to the enclosing module. Specifically, when the module is built, the named header will be parsed and its declarations will be (logically) placed into the enclosing submodule. A header with the ``umbrella`` specifier is called an umbrella header. An umbrella header includes all of the headers within its directory (and any subdirectories), and is typically used (in the ``#include`` world) to easily access the full API provided by a particular library. With modules, an umbrella header is a convenient shortcut that eliminates the need to write out ``header`` declarations for every library header. A given directory can only contain a single umbrella header. .. note::; Any headers not included by the umbrella header should have; explicit ``header`` declarations. Use the; ``-Wincomplete-umbrella`` warning option to ask Clang to complain; about headers not covered by the umbrella header or the module map. A header with the ``private`` specifier may not be included from outside the module itself. A header with the ``textual`` specifier will not be compiled when the module is; built, and will be textually included if it is named by a ``#include``; directive. However, it is considered to be part of the module for the purpose; of checking *use-declaration*\s, and must still be a lexically-valid header; file. In the future, we intend to pre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:36486,access,access,36486,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,1,['access'],['access']
Security,"pecified, then the mapping is treated as another; prebuilt module search mechanism (in addition to ``-fprebuilt-module-path``); and the module is only loaded if required. Note that in this case the; specified file also overrides this module's paths that might be embedded; in other precompiled module files. ``-fprebuilt-module-path=<directory>``; Specify the path to the prebuilt modules. If specified, we will look for modules in this directory for a given top-level module name. We don't need a module map for loading prebuilt modules in this directory and the compiler will not try to rebuild these modules. This can be specified multiple times. ``-fprebuilt-implicit-modules``; Enable prebuilt implicit modules. If a prebuilt module is not found in the; prebuilt modules paths (specified via ``-fprebuilt-module-path``), we will; look for a matching implicit module in the prebuilt modules paths. -cc1 Options; ~~~~~~~~~~~~. ``-fmodules-strict-context-hash``; Enables hashing of all compiler options that could impact the semantics of a; module in an implicit build. This includes things such as header search paths; and diagnostics. Using this option may lead to an excessive number of modules; being built if the command line arguments are not homogeneous across your; build. Using Prebuilt Modules; ----------------------. Below are a few examples illustrating uses of prebuilt modules via the different options. First, let's set up files for our examples. .. code-block:: c. /* A.h */; #ifdef ENABLE_A; void a() {}; #endif. .. code-block:: c. /* B.h */; #include ""A.h"". .. code-block:: c. /* use.c */; #include ""B.h""; void use() {; #ifdef ENABLE_A; a();; #endif; }. .. code-block:: c. /* module.modulemap */; module A {; header ""A.h""; }; module B {; header ""B.h""; export *; }. In the examples below, the compilation of ``use.c`` can be done without ``-cc1``, but the commands used to prebuild the modules would need to be updated to take into account the default options passed to ``clang -c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst:18272,hash,hash,18272,interpreter/llvm-project/clang/docs/Modules.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Modules.rst,2,['hash'],"['hash', 'hashing']"
Security,"pectful:. * **Be respectful.** Not all of us will agree all the time, but disagreement is; no excuse for poor behavior and poor manners. We might all experience some; frustration now and then, but we cannot allow that frustration to turn into; a personal attack. It's important to remember that a community where people; feel uncomfortable or threatened is not a productive one. Members of the LLVM; community should be respectful when dealing with other members as well as; with people outside the LLVM community. .. _be careful in the words that you choose and be kind to others:. * **Be careful in the words that you choose and be kind to others.** Do not; insult or put down other participants. Harassment and other exclusionary; behavior aren't acceptable. This includes, but is not limited to:. * Violent threats or language directed against another person.; * Discriminatory jokes and language.; * Posting sexually explicit or violent material.; * Posting (or threatening to post) other people's personally identifying; information (""doxing"").; * Personal insults, especially those using racist or sexist terms.; * Unwelcome sexual attention.; * Advocating for, or encouraging, any of the above behavior. In general, if someone asks you to stop, then stop. Persisting in such; behavior after being asked to stop is considered harassment. .. _when we disagree, try to understand why:. * **When we disagree, try to understand why.** Disagreements, both social and; technical, happen all the time and LLVM is no exception. It is important that; we resolve disagreements and differing views constructively. Remember that; we're different. The strength of LLVM comes from its varied community, people; from a wide range of backgrounds. Different people have different; perspectives on issues. Being unable to understand why someone holds; a viewpoint doesn't mean that they're wrong. Don't forget that it is human to; err and blaming each other doesn't get us anywhere. Instead, focus on helping; to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:4348,threat,threatening,4348,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['threat'],['threatening']
Security,"perands:; """""""""""""""""". The only argument is a pointer which is based on some object with; an unknown offset from the base of said object. Semantics:; """""""""""""""""""". This intrinsic is used in the abstract machine model for GC to represent; the offset of an arbitrary derived pointer from its base pointer. This intrinsic is inlined by the :ref:`RewriteStatepointsForGC` pass by; replacing all uses of this callsite with the offset of a derived pointer from; its base pointer value. The replacement is done as part of the lowering to the; explicit statepoint model. Basically this call calculates difference between the derived pointer and its; base pointer (see :ref:`gc.get.pointer.base`) both ptrtoint casted. But; this cast done outside the :ref:`RewriteStatepointsForGC` pass could result; in the pointers lost for further lowering from the abstract model to the; explicit physical one. Code Generator Intrinsics; -------------------------. These intrinsics are provided by LLVM to expose special features that; may only be implemented with code generator support. '``llvm.returnaddress``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare ptr @llvm.returnaddress(i32 <level>). Overview:; """""""""""""""""". The '``llvm.returnaddress``' intrinsic attempts to compute a; target-specific value indicating the return address of the current; function or one of its callers. Arguments:; """""""""""""""""""". The argument to this intrinsic indicates which function to return the; address for. Zero indicates the calling function, one indicates its; caller, etc. The argument is **required** to be a constant integer; value. Semantics:; """""""""""""""""""". The '``llvm.returnaddress``' intrinsic either returns a pointer; indicating the return address of the specified call frame, or zero if it; cannot be identified. The value returned by this intrinsic is likely to; be incorrect or 0 for arguments other than zero, so it should only be; used for debugging purposes. Note that calling this intrinsic does ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:509452,expose,expose,509452,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['expose'],['expose']
Security,"perations. #### '`llvm.ptrauth.sign`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.sign(i64 <value>, i32 <key>, i64 <discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.sign`' intrinsic signs a raw pointer. ##### Arguments:. The `value` argument is the raw pointer value to be signed.; The `key` argument is the identifier of the key to be used to generate the; signed value.; The `discriminator` argument is the additional diversity data to be used as a; discriminator (an integer, an address, or a blend of the two). ##### Semantics:. The '`llvm.ptrauth.sign`' intrinsic implements the `sign`_ operation.; It returns a signed value. If `value` is already a signed value, the behavior is undefined. If `value` is not a pointer value for which `key` is appropriate, the; behavior is undefined. #### '`llvm.ptrauth.auth`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.auth(i64 <value>, i32 <key>, i64 <discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.auth`' intrinsic authenticates a signed pointer. ##### Arguments:. The `value` argument is the signed pointer value to be authenticated.; The `key` argument is the identifier of the key that was used to generate; the signed value.; The `discriminator` argument is the additional diversity data to be used as a; discriminator. ##### Semantics:. The '`llvm.ptrauth.auth`' intrinsic implements the `auth`_ operation.; It returns a raw pointer value.; If `value` does not have a correct signature for `key` and `discriminator`,; the intrinsic traps in a target-specific way. #### '`llvm.ptrauth.strip`'. ##### Syntax:. ```llvm; declare i64 @llvm.ptrauth.strip(i64 <value>, i32 <key>); ```. ##### Overview:. The '`llvm.ptrauth.strip`' intrinsic strips the embedded signature out of a; possibly-signed pointer. ##### Arguments:. The `value` argument is the signed pointer value to be stripped.; The `key` argument is the identifier of the key that was used to generate; the signed value. ##### Semantics:. The '`llvm.ptrauth.strip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:2132,authenticat,authenticates,2132,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,1,['authenticat'],['authenticates']
Security,"perform loads and stores to; different address spaces via the x86 segment registers. A segment override; prefix byte on an instruction causes the instruction's memory access to go to; the specified segment. LLVM address space 0 is the default address space, which; includes the stack, and any unqualified memory accesses in a program. Address; spaces 1-255 are currently reserved for user-defined code. The GS-segment is; represented by address space 256, the FS-segment is represented by address space; 257, and the SS-segment is represented by address space 258. Other x86 segments; have yet to be allocated address space numbers. While these address spaces may seem similar to TLS via the ``thread_local``; keyword, and often use the same underlying hardware, there are some fundamental; differences. The ``thread_local`` keyword applies to global variables and specifies that they; are to be allocated in thread-local memory. There are no type qualifiers; involved, and these variables can be pointed to with normal pointers and; accessed with normal loads and stores. The ``thread_local`` keyword is; target-independent at the LLVM IR level (though LLVM doesn't yet have; implementations of it for some configurations). Special address spaces, in contrast, apply to static types. Every load and store; has a particular address space in its address operand type, and this is what; determines which address space is accessed. LLVM ignores these special address; space qualifiers on global variables, and does not provide a way to directly; allocate storage in them. At the LLVM IR level, the behavior of these special; address spaces depends in part on the underlying OS or runtime environment, and; they are specific to x86 (and LLVM doesn't yet handle them correctly in some; cases). Some operating systems and runtime environments use (or may in the future use); the FS/GS-segment registers for various low-level purposes, so care should be; taken when considering them. Instruction naming; ^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:92811,access,accessed,92811,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accessed']
Security,"performance penalty (in addition to the monolithic CFI; overhead).; - Calls from an instrumented DSO to an uninstrumented one are; unchecked and just work, with performance penalty.; - Calls from an instrumented DSO outside of any known DSO are; detected as CFI violations. In the monolithic scheme a call site is instrumented as. .. code-block:: none. if (!InlinedFastCheck(f)); abort();; call *f. In the cross-DSO scheme it becomes. .. code-block:: none. if (!InlinedFastCheck(f)); __cfi_slowpath(CallSiteTypeId, f);; call *f. CallSiteTypeId; --------------. ``CallSiteTypeId`` is a stable process-wide identifier of the; call-site type. For a virtual call site, the type in question is the class; type; for an indirect function call it is the function signature. The; mapping from a type to an identifier is an ABI detail. In the current,; experimental, implementation the identifier of type T is calculated as; follows:. - Obtain the mangled name for ""typeinfo name for T"".; - Calculate MD5 hash of the name as a string.; - Reinterpret the first 8 bytes of the hash as a little-endian; 64-bit integer. It is possible, but unlikely, that collisions in the; ``CallSiteTypeId`` hashing will result in weaker CFI checks that would; still be conservatively correct. CFI_Check; ---------. In the general case, only the target DSO knows whether the call to; function ``f`` with type ``CallSiteTypeId`` is valid or not. To; export this information, every DSO implements. .. code-block:: none. void __cfi_check(uint64 CallSiteTypeId, void *TargetAddr, void *DiagData). This function provides external modules with access to CFI checks for; the targets inside this DSO. For each known ``CallSiteTypeId``, this; function performs an ``llvm.type.test`` with the corresponding type; identifier. It reports an error if the type is unknown, or if the; check fails. Depending on the values of compiler flags; ``-fsanitize-trap`` and ``-fsanitize-recover``, this function may; print an error, abort and/or return t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst:20415,hash,hash,20415,interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrityDesign.rst,1,['hash'],['hash']
Security,"permission to use the GNU C Library in; non-free programs enables many more people to use the whole GNU; operating system, as well as its variant, the GNU/Linux operating; system. Although the Lesser General Public License is Less protective of the; users' freedom, it does ensure that the user of a program that is; linked with the Library has the freedom and the wherewithal to run; that program using a modified version of the Library. The precise terms and conditions for copying, distribution and; modification follow. Pay close attention to the difference between a; ""work based on the library"" and a ""work that uses the library"". The; former contains code derived from the library, whereas the latter must; be combined with the library in order to run.; ; GNU LESSER GENERAL PUBLIC LICENSE; TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION. 0. This License Agreement applies to any software library or other; program which contains a notice placed by the copyright holder or; other authorized party saying it may be distributed under the terms of; this Lesser General Public License (also called ""this License"").; Each licensee is addressed as ""you"". A ""library"" means a collection of software functions and/or data; prepared so as to be conveniently linked with application programs; (which use some of those functions and data) to form executables. The ""Library"", below, refers to any such software library or work; which has been distributed under these terms. A ""work based on the; Library"" means either the Library or any derivative work under; copyright law: that is to say, a work containing the Library or a; portion of it, either verbatim or with modifications and/or translated; straightforwardly into another language. (Hereinafter, translation is; included without limitation in the term ""modification"".). ""Source code"" for a work means the preferred form of the work for; making modifications to it. For a library, complete source code means; all the source code fo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:6187,authoriz,authorized,6187,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['authoriz'],['authorized']
Security,"ph`**, **`TGraphErrors`**, etc.; `gui`: Scripts to create Graphical User Interface `hist`: Histogramming; `image`: Image Processing `io`: Input/Output `math`: Maths and; Statistics functions `matrix`: Matrices (**`TMatrix`**) examples; `mlp`: Neural networks with **`TMultiLayerPerceptron`** `net`: Network; classes (client/server examples) `physics`: LorentzVectors, phase; space `pyroot`: Python tutorials `pythia`: Example with `pythia8`; `quadp`: Quadratic Programming `smatrix`:; Matrices with a templated package `spectrum`: Peak finder, background,; deconvolutions `splot`: Example of the **`TSplot`** class; (signal/background estimator) `sql`: Interfaces to SQL (mysql, oracle,; etc) `thread`: Using Threads `tmva`: Examples of the MultiVariate; Analysis classes `tree`: Creating Trees, Playing with Trees `unuran`:; Interface with the unuram random generator library `xml`:; Writing/Reading xml files. You can execute the scripts in `$ROOTSYS/tutorials`; (or sub-directories) by setting your current directory in the script; directory or from any user directory with write access. Several; tutorials create new files. If you have write access to the tutorials; directory, the new files will be created in the tutorials directory,; otherwise they will be created in the user directory. ### \$ROOTSYS/test. The test directory contains a set of examples example that represent; all areas of the framework. When a new release is cut, the examples in; this directory are compiled and run to test the new release's backward; compatibility. The list of source files is described in chapter ""The; Tutorials and Tests"". The `$ROOTSYS/test` directory is a gold mine of ROOT-wisdom nuggets,; and we encourage you to explore and exploit it. We recommend the new; users to read the chapter ""Getting Started"". The chapter ""The; Tutorials and Tests"" has instructions on how to build all the programs; and it goes over the examples `Event` and `stress`. ### \$ROOTSYS/include. The `include` directory contai",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:22403,access,access,22403,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['access'],['access']
Security,"piled or interpreted function `GetWebHistogram()` would have been; called instead of the Cling script `GetWebHistogram.C.`. ### Array of TRef. When storing multiple **`TRef`**s, it is more efficient to use a; **`TRefArray`**. The efficiency is due to having a single pointer `fPID`; for all `TRefs` in the array. It has a dynamic compact table of; `fUniqueIDs`. We recommend that you use a **`TRefArray`** rather then a; collection of `TRefs`. Example:. - Suppose a `TObjArray *mytracks` containing a list of `Track`; objects. - Suppose a `TRefArray *pions` containing pointers to the pion tracks; in `mytracks`. This list is created with statements like:; `pions->Add(track);`. - Suppose a `TRefArray *muons` containing pointers to the muon tracks; in `mytracks`. The 3 arrays `mytracks`,` pions` and `muons` may be written separately. ## Schema Evolution. Schema evolution is a problem faced by long-lived data. When a schema; changes, existing persistent data can become inaccessible unless the; system provides a mechanism to access data created with previous; versions of the schema. In the lifetime of collaboration, the class; definitions (i.e. the schema) are likely to change frequently. Not only; can the class itself change, but any of its parent classes or data; member classes can change also. This makes the support for schema; evolution necessary. ROOT fully supports schema evolution. The next figure below illustrates; some of the scenarios. ![The ROOT schema evolution](pictures/020000ED.jpg). The top half represents different versions of the shared library with; the class definitions. These are the in-memory class versions. The; bottom half represents data files that contain different versions of the; classes. - An old version of a shared library and a file with new class; definitions - this can be the case when someone has not updated the; library and is reading a new file. - Reading a file with a shared library that is missing a class; definition (i.e. missing class D). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:67647,access,access,67647,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['access'],['access']
Security,"piler instruments all CMP instructions with a callback that receives both CMP arguments.; * The callback computes `(caller_pc&4095) | (popcnt(Arg1 ^ Arg2) << 12)` and uses this value to set a bit in a bitset.; * Every new observed bit in the bitset is treated as new coverage. This feature has a potential to discover many interesting inputs,; but there are two downsides.; First, the extra instrumentation may bring up to 2x additional slowdown.; Second, the corpus may grow by several times. Fuzzer-friendly build mode; ---------------------------; Sometimes the code under test is not fuzzing-friendly. Examples:. - The target code uses a PRNG seeded e.g. by system time and; thus two consequent invocations may potentially execute different code paths; even if the end result will be the same. This will cause a fuzzer to treat; two similar inputs as significantly different and it will blow up the test corpus.; E.g. libxml uses ``rand()`` inside its hash table.; - The target code uses checksums to protect from invalid inputs.; E.g. png checks CRC for every chunk. In many cases it makes sense to build a special fuzzing-friendly build; with certain fuzzing-unfriendly features disabled. We propose to use a common build macro; for all such cases for consistency: ``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION``. .. code-block:: c++. void MyInitPRNG() {; #ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION; // In fuzzing mode the behavior of the code should be deterministic.; srand(0);; #else; srand(time(0));; #endif; }. AFL compatibility; -----------------; LibFuzzer can be used together with AFL_ on the same test corpus.; Both fuzzers expect the test corpus to reside in a directory, one file per input.; You can run both fuzzers on the same corpus, one after another:. .. code-block:: console. ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@; ./llvm-fuzz testcase_dir findings_dir # Will write new tests to testcase_dir. Periodically restart both fuzzers so that they can use e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst:21703,checksum,checksums,21703,interpreter/llvm-project/llvm/docs/LibFuzzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LibFuzzer.rst,1,['checksum'],['checksums']
Security,"placed by a symbol outside the; module at link time or runtime, any optimization cannot replace the alias with; the aliasee, since the behavior may be different. The alias may be used as a; name guaranteed to point to the content in the current module. .. _langref_ifunc:. IFuncs; -------. IFuncs, like as aliases, don't create any new data or func. They are just a new; symbol that is resolved at runtime by calling a resolver function. On ELF platforms, IFuncs are resolved by the dynamic linker at load time. On; Mach-O platforms, they are lowered in terms of ``.symbol_resolver`` functions,; which lazily resolve the callee the first time they are called. IFunc may have an optional :ref:`linkage type <linkage>` and an optional; :ref:`visibility style <visibility>`. Syntax::. @<Name> = [Linkage] [PreemptionSpecifier] [Visibility] ifunc <IFuncTy>, <ResolverTy>* @<Resolver>; [, partition ""name""]. .. _langref_comdats:. Comdats; -------. Comdat IR provides access to object file COMDAT/section group functionality; which represents interrelated sections. Comdats have a name which represents the COMDAT key and a selection kind to; provide input on how the linker deduplicates comdats with the same key in two; different object files. A comdat must be included or omitted as a unit.; Discarding the whole comdat is allowed but discarding a subset is not. A global object may be a member of at most one comdat. Aliases are placed in the; same COMDAT that their aliasee computes to, if any. Syntax::. $<Name> = comdat SelectionKind. For selection kinds other than ``nodeduplicate``, only one of the duplicate; comdats may be retained by the linker and the members of the remaining comdats; must be discarded. The following selection kinds are supported:. ``any``; The linker may choose any COMDAT key, the choice is arbitrary.; ``exactmatch``; The linker may choose any COMDAT key but the sections must contain the; same data.; ``largest``; The linker will choose the section containing the largest",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:45363,access,access,45363,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ple anchor: the initial link to the location of the header and footer (cf. format specification); 3) A locator format: how are byte ranges addressed (e.g., through an offset in a file or an object ID). That means that new backends are likely to have implications on the RNTuple format specification. The page sources and sinks are ROOT internal classes.; They are not meant to be extended by users. Multi-Threading; ---------------. The following options exist in RNTuple for multithreaded data processing. ### Implicit Multi-Threading; When `ROOT::EnableImplicitMT()` is used, RNTuple uses ROOT's task arena to compress and decompress pages.; That requires writes to be buffered and reads uses the cluster pool resp.; The RNTuple data source for RDataFrame lets RDataFrame full control of the thread pool.; That means that RDataFrame uses a separate data source for every thread, each of the data sources runs in sequential mode. ### Concurrent Readers; Multiple readers can read the same RNTuple concurrently as long as access to every individual reader is sequential. ### Parallel REntry Preparation; Multiple `REntry` object can be concurrently prepared by multiple threads.; I.e., construction and binding of the objects can happen in parallel.; The actual reading and writing of entries (`RNTupleReader::LoadEntry()`, `RNTupleWriter::Fill()`) needs to be protected by a mutex.; This is considered ""mild scalability parallelization"" in RNTuple. ### RNTupleParallelWriter; The parallel writer offers the most scalable parallel writing interface.; Multiple _fill contexts_ can concurrently serialize and compress data.; Every fill context prepares a set of entire clusters in the final on-disk layout.; When a fill context flushes data,; a brief serialization point handles the RNTuple meta-data updates and the reservation of disk space to write into. Low precision float types; --------------------------; RNTuple supports encoding floating point types with a lower precision when writing them t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:24993,access,access,24993,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"ple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; ```. After script loading one can configure different parameters in `gStyle` object.; It is instance of the `TStyle` object and behaves like `gStyle` variable in ROOT. For instance,; to change stat format using to display value in stats box:. ```javascript; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; ```. There is also `settings` object which contains all other JSROOT settings. For instance,; one can configure custom format for different axes:. ```javascript; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; ```. One also can use `build/jsroot.js` bundle to load all functionality at one and access it via `JSROOT` global handle:. ```javascript; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; ```. ### Use of JSON. It is strongly recommended to use JSON when communicating with ROOT application.; THttpServer provides a JSON representation for every registered object with an url address like:. http://your_root_server:8080/Canvases/c1/root.json. Such JSON representation generated using the [TBufferJSON](https://root.cern/doc/master/classTBufferJSON.html) class. One could create JSON file for any ROOT object directly, just writing in the code:. ```cpp; obj->SaveAs(""file.json"");; ```. To access data from a remote web server, it is recommended to use the `httpRequest` method.; For instance to receive object from a THttpServer server one could do:. ```javascript; import { httpRequest } from 'https://root.cern/js/latest/modules",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:36316,access,access,36316,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['access'],['access']
Security,"ple, reading an object from a file and displaying it will look like:. ```javascript; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; ```. Here is [running example](https://root.cern/js/latest/api.htm#custom_html_read_root_file) and [source code](https://github.com/root-project/jsroot/blob/master/demo/read_file.htm). ### TTree API. Simple TTree::Draw operation can be performed with following code:. ```javascript; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; ```. To get access to selected branches, one should use `TSelector` class:. ```javascript; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for every entry; sumpx += this.tgtobj.px;; sumpy += this.tgtobj.py;; cnt++;; }. selector.Terminate = function(res) {; if (!res || (cnt === 0)) return;; let meanpx = sumpx/cnt, meanpy = sumpy/cnt;; console.log(`Results meanpx = ${meanpx} meanpy = ${meanpy}`);; }. await treeProcess(tree, selector);; ```. Here is [running example](https://roo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:40945,access,access,40945,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['access'],['access']
Security,"ple. security.FloatLoopCounter; (C); Warn on using a floating point value as a loop counter (CERT: FLP30-C,; FLP30-CPP). void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. security.insecureAPI.UncheckedReturn; (C); Warn on uses of functions whose return values must be always checked:; setuid; setgid; seteuid; setegid; setreuid; setregid. void test() {; setuid(1); // warn; }. security.insecureAPI.bcmp; (C); Warn on uses of the bcmp function. void test() {; bcmp(ptr0, ptr1, n); // warn; }. security.insecureAPI.bcopy; (C); Warn on uses of the bcopy function. void test() {; bcopy(src, dst, n); // warn; }. security.insecureAPI.bzero; (C); Warn on uses of the bzero function. void test() {; bzero(ptr, n); // warn; }. security.insecureAPI.getpw; (C); Warn on uses of the getpw function. void test() {; char buff[1024];; getpw(2, buff); // warn; }. security.insecureAPI.gets; (C); Warn on uses of the gets function. void test() {; char buff[1024];; gets(buff); // warn; }. security.insecureAPI.mkstemp; (C); Warn when mktemp, mkstemp, mkstemps or; mkdtemp is passed fewer than 6; X's in the format string. void test() {; mkstemp(""XX""); // warn; }. security.insecureAPI.mktemp; (C); Warn on uses of the mktemp function. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. security.insecureAPI.rand; (C); Warn on uses of inferior random number generating functions (only if arc4random; function is available):; drand48; erand48; jrand48; lcong48; lrand48; mrand48; nrand48; random; rand_r. void test() {; random(); // warn; }. security.insecureAPI.strcpy; (C); Warn on uses of the strcpy and strcat functions. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. security.insecureAPI.vfork; (C); Warn on uses of the vfork function. void test() {; vfork(); // warn; }. security.insecureAPI.decodeValueOfObjCType; (ObjC); Warn on uses of the -[NSCoder decodeValueOfObjCType:at:] method.; The safe alternative is -[NSCoder decodeValue",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:22030,secur,security,22030,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,2,['secur'],['security']
Security,"plementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24216,access,access,24216,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['access'],['access']
Security,"pointer identity can break. So, any function annotated with; ``jumptable`` must also be ``unnamed_addr``.; ``memory(...)``; This attribute specifies the possible memory effects of the call-site or; function. It allows specifying the possible access kinds (``none``,; ``read``, ``write``, or ``readwrite``) for the possible memory location; kinds (``argmem``, ``inaccessiblemem``, as well as a default). It is best; understood by example:. - ``memory(none)``: Does not access any memory.; - ``memory(read)``: May read (but not write) any memory.; - ``memory(write)``: May write (but not read) any memory.; - ``memory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; - ``memory(readwrite, argmem: none)``: May access any memory apart from; argument memory. The supported memory location kinds are:. - ``argmem``: This refers to accesses that are based on pointer arguments; to the function.; - ``inaccessiblemem``: This refers to accesses to memory which is not; accessible by the current module (before return from the function -- an; allocator function may return newly accessible memory while only; accessing inaccessible memory itself). Inaccessible memory is often used; to model control dependencies of intrinsics.; - The default access kind (specified without a location prefix) applies to; all locations that haven't been specified explicitly, including those that; don't currently have a dedicated location kind (e.g. accesses to globals; or captured pointers). If the ``memory`` attribute is not specified, then ``memory(readwrite)``; is implied (all memory effects are possible). The memory effects of a call can be computed as; ``CallSiteEffects & (FunctionEffects | OperandBundleEffects)``. Thus, t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:85560,access,access,85560,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"port for folding control flow into faulting machine instructions. :doc:`Atomics`; Information about LLVM's concurrency model. :doc:`ExceptionHandling`; This document describes the design and implementation of exception handling; in LLVM. :doc:`Extensions`; LLVM-specific extensions to tools and formats LLVM seeks compatibility with. :doc:`HowToSetUpLLVMStyleRTTI`; How to make ``isa<>``, ``dyn_cast<>``, etc. available for clients of your; class hierarchy. :doc:`BlockFrequencyTerminology`; Provides information about terminology used in the ``BlockFrequencyInfo``; analysis pass. :doc:`BranchWeightMetadata`; Provides information about Branch Prediction Information. :doc:`GetElementPtr`; Answers to some very frequent questions about LLVM's most frequently; misunderstood instruction. :doc:`ScudoHardenedAllocator`; A library that implements a security-hardened `malloc()`. :doc:`MemTagSanitizer`; Security hardening for production code aiming to mitigate memory; related vulnerabilities. Based on the Armv8.5-A Memory Tagging Extension. :doc:`Dependence Graphs <DependenceGraphs/index>`; A description of the design of the various dependence graphs such as; the DDG (Data Dependence Graph). :doc:`SpeculativeLoadHardening`; A description of the Speculative Load Hardening mitigation for Spectre v1. :doc:`SegmentedStacks`; This document describes segmented stacks and how they are used in LLVM. :doc:`MarkedUpDisassembly`; This document describes the optional rich disassembly output syntax. :doc:`StackMaps`; LLVM support for mapping instruction addresses to the location of; values and allowing code to be patched. :doc:`Coroutines`; LLVM support for coroutines. :doc:`PointerAuth`; A description of pointer authentication, its LLVM IR representation, and its; support in the backend. :doc:`YamlIO`; A reference guide for using LLVM's YAML I/O library. :doc:`ConvergenceAndUniformity`; A description of uniformity analysis in the presence of irreducible; control flow, and its implementation.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst:5212,authenticat,authentication,5212,interpreter/llvm-project/llvm/docs/Reference.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Reference.rst,1,['authenticat'],['authentication']
Security,"port of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/Ope",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:143200,access,accessible,143200,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['access'],['accessible']
Security,"port security issues, see `this commit on; 20th of May 2021 <https://github.com/llvm/llvm-project/commit/c9dbaa4c86d2>`_; * We refined the nomination process for new group members, see `this; commit on 30th of July 2021 <https://github.com/llvm/llvm-project/commit/4c98e9455aad>`_; * We started writing an annual transparency report (you're reading the 2021; report here). Over the course of 2021, we had 2 people leave the LLVM Security group and 4; people join. In 2021, the security group received 13 issue reports that were made publicly; visible before 31st of December 2021. The security group judged 2 of these; reports to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=5; * https://bugs.chromium.org/p/llvm/issues/detail?id=11. Both issues were addressed with source changes: #5 in clangd/vscode-clangd, and; #11 in llvm-project. No dedicated LLVM release was made for either. We believe that with the publishing of this first annual transparency report,; the security group now has implemented all necessary processes for the group to; operate as promised. The group's processes can be improved further, and we do; expect further improvements to get implemented in 2022. Many of the potential; improvements end up being discussed on the `monthly public call on LLVM's; security group <https://llvm.org/docs/GettingInvolved.html#online-sync-ups>`_. 2022; ----. In this section we report on the issues the group received in 2022, or on issues; that were received earlier, but were disclosed in 2022. In 2022, the llvm security group received 15 issues that have been disclosed at; the time of writing this transparency report. 5 of these were judged to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=17 reports a miscompile in; LLVM that can result in the frame pointer and return address being; overwritten. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=19 reports a vulnerability; in `std::filesystem::remove_all` in l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst:1697,secur,security,1697,interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,1,['secur'],['security']
Security,"port this tutorial to any language that has a JSON parser. This is the process in LLVM, using a C++ backend:; ```; TableGen source -> llvm-tblgen -> backend (within llvm-tblgen) -> results; ```; This is what we will be doing:; ```; TableGen source -> llvm-tblgen -> JSON -> Python -> results; ```. The backend here is ported from one of several in ""SQLGen"" which was written by Min-Yih Hsu.; * SQLGen C++ sources - https://github.com/mshockwave/SQLGen; * LLVM dev presentation - https://www.youtube.com/watch?v=UP-LBRbvI_U. I encourage you to use those resources to supplement this notebook. ## Compiling TableGen. Unlike the other tutorial notebooks we are not using the TableGen kernel. This is an iPython notebook and we're going to run `llvm-tblgen` as a subprocess. First let's find it, in the same way the TableGen kernel does. ```python; import os; import shutil. def find_tblgen():; path = os.environ.get(""LLVM_TBLGEN_EXECUTABLE""); if path is not None and os.path.isfile(path) and os.access(path, os.X_OK):; return path; else:; path = shutil.which(""llvm-tblgen""); if path is None:; raise OSError(""llvm-tblgen not found""); return path; ; _ = find_tblgen(); ```. If the above cell raises an exception, either put `llvm-tblgen` on your `PATH` or point to it using the `LLVM_TBLGEN_EXECUTABLE` environment variable. Alternatively, edit the code to use whatever path you want. Then we need to compile some TableGen by passing it to `llvm-tblgen`'s stdin. We will be using the option `--dump-json` and returning the JSON as a Python dictionary if the compilation succeeds. If it fails, we raise an exception. ```python; import subprocess; import tempfile; import json. def run_tblgen(src):; # Passing to stdin requires a file like object.; with tempfile.TemporaryFile(""w+"") as f:; f.write(src); f.seek(0); got = subprocess.run(; [find_tblgen(), ""--dump-json""],; stdin=f,; stderr=subprocess.PIPE,; stdout=subprocess.PIPE,; universal_newlines=True,; ); ; if got.stderr:; raise RuntimeError(""llvm-tblg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md:1266,access,access,1266,interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/jupyter/sql_query_backend.md,1,['access'],['access']
Security,pp; compiler-rt/lib/sanitizer_common/tests/sanitizer_addrhashmap_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_chained_origin_depot_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_dense_map_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_flat_map_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_hash_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_leb128_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_lzw_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_stackdepot_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_stack_store_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_stoptheworld_test.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_test_main.cpp; compiler-rt/lib/sanitizer_common/tests/sanitizer_type_traits_test.cpp; compiler-rt/lib/scudo/standalone/allocator_config.h; compiler-rt/lib/scudo/standalone/atomic_helpers.h; compiler-rt/lib/scudo/standalone/bytemap.h; compiler-rt/lib/scudo/standalone/checksum.cpp; compiler-rt/lib/scudo/standalone/checksum.h; compiler-rt/lib/scudo/standalone/chunk.h; compiler-rt/lib/scudo/standalone/combined.h; compiler-rt/lib/scudo/standalone/common.cpp; compiler-rt/lib/scudo/standalone/common.h; compiler-rt/lib/scudo/standalone/crc32_hw.cpp; compiler-rt/lib/scudo/standalone/flags.cpp; compiler-rt/lib/scudo/standalone/flags.h; compiler-rt/lib/scudo/standalone/flags_parser.cpp; compiler-rt/lib/scudo/standalone/flags_parser.h; compiler-rt/lib/scudo/standalone/fuchsia.cpp; compiler-rt/lib/scudo/standalone/fuchsia.h; compiler-rt/lib/scudo/standalone/internal_defs.h; compiler-rt/lib/scudo/standalone/linux.cpp; compiler-rt/lib/scudo/standalone/linux.h; compiler-rt/lib/scudo/standalone/list.h; compiler-rt/lib/scudo/standalone/local_cache.h; compiler-rt/lib/scudo/standalone/memtag.h; compiler-rt/lib/scudo/standalone/mutex.h; compiler-rt/lib/scudo/standalone/options.h; compiler-rt/lib/scudo/standalone/platform.h; compiler-rt/lib/scudo/standalon,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:100082,checksum,checksum,100082,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['checksum'],['checksum']
Security,"pproach is to use an std::vector (or other sequential container) with; std::sort+std::unique to remove duplicates. This approach works really well if; your usage pattern has these two distinct phases (insert then query), and can be; coupled with a good choice of :ref:`sequential container <ds_sequential>`. This combination provides the several nice properties: the result data is; contiguous in memory (good for cache locality), has few allocations, is easy to; address (iterators in the final vector are just indices or pointers), and can be; efficiently queried with a standard binary search (e.g.; ``std::lower_bound``; if you want the whole range of elements comparing; equal, use ``std::equal_range``). .. _dss_smallset:. llvm/ADT/SmallSet.h; ^^^^^^^^^^^^^^^^^^^. If you have a set-like data structure that is usually small and whose elements; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78209,access,accesses,78209,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accesses']
Security,"pproved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:14984,secur,securable,14984,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,2,['secur'],"['securable', 'security']"
Security,"presence of SrcArgs key indicates conditional taint propagation,; # which is conceptually what a propagator does. # Propagation function; # char *dirname(char *path); #; # Result example:; # char* path = read_path();; # char* dir = dirname(path);; # // dir is tainted if path was tainted; - Name: dirname; SrcArgs: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:3930,sanitiz,sanitization,3930,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,1,['sanitiz'],['sanitization']
Security,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:179955,sanitiz,sanitize-address-poison-custom-array-cookie,179955,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,7,"['integrity', 'sanitiz']","['integrity', 'sanitize-address-poison-custom-array-cookie', 'sanitize-address-use-after-scope', 'sanitize-address-use-odr-indicator', 'sanitize-cfi-cross-dso', 'sanitize-ignorelist', 'sanitizers']"
Security,"presents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 4. ``DW_OP_push_object_address``. ``DW_OP_push_object_address`` pushes the location description L of the; current object. *This object may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a structure.*. .. note::. This operation could be removed and the object location description; specified as the initial stack as for ``DW_AT_data_member_location``. Or this operation could be used instead of needing to specify an initial; stack. The latter approach is more composable as access to the object may; be needed at any point of the expression, and passing it as the initial; stack requires the entire expression to be aware where on the stack it is.; If this were done, ``DW_AT_use_location`` would require a; ``DW_OP_push_object2_address`` operation for the second object. Or a more general way to pass an arbitrary number of arguments in and an; operation to get the Nth one such as ``DW_OP_arg N``. A vector of; arguments would then be passed in the expression context rather than an; initial stack. This could also resolve the issues with ``DW_OP_call*`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:100602,access,access,100602,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security,"program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22239,access,accessing,22239,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['access'],['accessing']
Security,"project/pull/66782>`_,; `#65889 <https://github.com/llvm/llvm-project/pull/65889>`_,; `#65888 <https://github.com/llvm/llvm-project/pull/65888>`_,; `#65887 <https://github.com/llvm/llvm-project/pull/65887>`_). - Fixed note links of the HTML output.; (`#64054 <https://github.com/llvm/llvm-project/issues/64054>`_). - Allow widening rage-based for loops.; (`#70190 <https://github.com/llvm/llvm-project/pull/70190>`_). - Fixed uninitialized base class with initializer list when ctor is not; declared in the base class.; (`#70464 <https://github.com/llvm/llvm-project/issues/70464>`_,; `#59493 <https://github.com/llvm/llvm-project/issues/59493>`_,; `#54533 <https://github.com/llvm/llvm-project/issues/54533>`_). - Fixed an ``alpha.unix.cstring`` crash on variadic functions.; (`#74269 <https://github.com/llvm/llvm-project/issues/74269>`_). - Fix false positive in mutation check when using pointer to member function.; (`#66204 <https://github.com/llvm/llvm-project/issues/66204>`_). - Fixed a crash in ``security.cert.env.InvalidPtr`` checker when accidentally; matched user-defined ``strerror`` and similar library functions.; (`#88181 <https://github.com/llvm/llvm-project/issues/88181>`_). Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:72353,secur,security,72353,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['secur'],['security']
Security,"ps; executing on it.; * All LDS operations of a CU are performed as wavefront wide operations in a; global order and involve no caching. Completion is reported to a wavefront in; execution order.; * The LDS memory has multiple request queues shared by the SIMDs of a; CU. Therefore, the LDS operations performed by different wavefronts of a; work-group can be reordered relative to each other, which can result in; reordering the visibility of vector memory operations with respect to LDS; operations of other wavefronts in the same work-group. A ``s_waitcnt; lgkmcnt(0)`` is required to ensure synchronization between LDS operations and; vector memory operations between wavefronts of a work-group, but not between; operations performed by the same wavefront.; * The vector memory operations are performed as wavefront wide operations and; completion is reported to a wavefront in execution order. The exception is; that for GFX7-GFX9 ``flat_load/store/atomic`` instructions can report out of; vector memory order if they access LDS memory, and out of LDS operation order; if they access global memory.; * The vector memory operations access a single vector L1 cache shared by all; SIMDs a CU. Therefore, no special action is required for coherence between the; lanes of a single wavefront, or for coherence between wavefronts in the same; work-group. A ``buffer_wbinvl1_vol`` is required for coherence between; wavefronts executing in different work-groups as they may be executing on; different CUs.; * The scalar memory operations access a scalar L1 cache shared by all wavefronts; on a group of CUs. The scalar and vector L1 caches are not coherent. However,; scalar operations are used in a restricted way so do not impact the memory; model. See :ref:`amdgpu-amdhsa-memory-spaces`.; * The vector and scalar memory operations use an L2 cache shared by all CUs on; the same agent.; * The L2 cache has independent channels to service disjoint ranges of virtual; addresses.; * Each CU has a separate",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:207606,access,access,207606,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],['access']
Security,"ption is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal`` which generates compact branches; when a delay slot cannot be filled. ``never`` disables the usage of; compact branches and ``always`` generates compact branches whenever; possible. .. option:: -f[no-]max-type-align=[number]. Instruct the code generator to not enforce a higher alignment than the given; number (of bytes) when accessing memory via an opaque pointer or reference.; This cap is ignored when directly accessing a variable or when the pointee; type has an explicit “aligned” attribute. The value should usually be determined by the properties of the system allocator.; Some builtin types, especially vector types, have very high natural alignments;; when working with values of those types, Clang usually wants to use instructions; that take advantage of that alignment. However, many system allocators do; not promise to return memory that is more than 8-byte or 16-byte-aligned. Use; this option to limit the alignment that the compiler can assume for an arbitrary; pointer, which may point onto the heap. This option does not affect the ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typedef. For example:. .. code-block:: console. #include <immintrin.h>; // Make an aligned typedef of the AVX-512 16-int vector type.; typedef ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:85385,access,accessing,85385,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['access'],['accessing']
Security,"qual zero. ### Accessing Properties. The following table shows the methods to access the information about; the relevant matrix property:. +-----------------------------+----------------------------------------------+; | Method | Descriptions |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowLwb` `()` | row lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetRowUpb` `()` | row upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNrows` `()` | number of rows |; +-----------------------------+----------------------------------------------+; | `Int_t GetColLwb` `()` | column lower-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetColUpb` `()` | column upper-bound index |; +-----------------------------+----------------------------------------------+; | `Int_t GetNcols` `()` | number of columns |; +-----------------------------+----------------------------------------------+; | `Int_t GetNoElements` `()` | number of elements, for a dense matrix this |; | | equals: `fNrows x fNcols` |; +-----------------------------+----------------------------------------------+; | `Double_t GetTol` `()` | tolerance number which is used in |; | | decomposition operations |; +-----------------------------+----------------------------------------------+; | `Int_t *GetRowIndexArray` | for sparse matrices, access to the row index |; | `()` | of `fNrows+1` entries |; +-----------------------------+----------------------------------------------+; | `Int_t *GetColIndexArray` | for sparse matrices, access to the column |; | `()` | index of `fNelems` entries |; +-----------------------------+----------------------------------------------+. The last two methods in this table are specific to the sparse matrix,; which is implemented according to the Harwell-Boeing format. Here,",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:4983,access,access,4983,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,2,['access'],['access']
Security,"quality more aggressively than the default behavior,; especially in cross-DSO mode which normally preserves function address; equality entirely. Furthermore, it is occasionally necessary for code not compiled with; ``-fsanitize=cfi-icall`` to take a function address that is valid; for CFI. For example, this is necessary when a function's address; is taken by assembly code and then called by CFI-checking C code. The; ``__attribute__((cfi_canonical_jump_table))`` attribute may be used to make; the jump table entry of a specific function canonical so that the external; code will end up taking an address for the function that will pass CFI checks. ``-fsanitize=cfi-icall`` and ``-fsanitize=function``; ----------------------------------------------------. This tool is similar to ``-fsanitize=function`` in that both tools check; the types of function calls. However, the two tools occupy different points; on the design space; ``-fsanitize=function`` is a developer tool designed; to find bugs in local development builds, whereas ``-fsanitize=cfi-icall``; is a security hardening mechanism designed to be deployed in release builds. ``-fsanitize=function`` has a higher space and time overhead due to a more; complex type check at indirect call sites, which may make it unsuitable for; deployment. On the other hand, ``-fsanitize=function`` conforms more closely with the C++; standard and user expectations around interaction with shared libraries;; the identity of function pointers is maintained, and calls across shared; library boundaries are no different from calls within a single program or; shared library. .. _kcfi:. ``-fsanitize=kcfi``; -------------------. This is an alternative indirect call control-flow integrity scheme designed; for low-level system software, such as operating system kernels. Unlike; ``-fsanitize=cfi-icall``, it doesn't require ``-flto``, won't result in; function pointers being replaced with jump table references, and never breaks; cross-DSO function addr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:14757,secur,security,14757,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,1,['secur'],['security']
Security,"r (int i = 0; i < ev->Ntracks; i++) {; TTrack *track = (TTrack*)a.ConstructedAt(i);; track->Set(x,y,z,....);; ...; ...; }; ...; a.Clear();. even in case where the TTrack class allocates memory. TClonesArray: update ExpandCreateFast to also reset the non-used slots; so that calling Clear (which does too much) is no longer necessary; when using ExpandCreateFast. New Thread Pool class. A first version of TThreadPool class has been introduced.; This class implements a Thread Pool pattern.; So far it supports only one type of queue - FIFO. Thread library. Reduces risk of internal dead lock by using a private internal lock to protect the internals of TThread, rather than using TThread::Lock. New header TThreadSlots.h to centralize and formalize the use of the TThread local memory slots amongst the ROOT packages. Global Variables. The global values gPad, gVirtualX, gInterpreter, gDirectory and gFile; are now all accessed via a static function of their respective class. The; access is made transparent via a CPP macro.; The access is now also made transparent from the CINT and python prompt.; gPad, gVirtualX and gInterpreter are now accessible even when their value; is zero and they now properly support tab completion.; See the important note in the I/O section on gDirectory and gFile which; are now thread local. Meta. The new interface TDictionary::GetDictionary(const char*) offers a; single entry point to query the type based on its name, conveniently combining; TDataType and TClass queries. It does name normalization (removing std etc). Add the ability to explicitly forbid (or allow) the splitting of a class; (TClass::SetSplit) so that user can inforce the use of a custom streamer in all possible split cases. Resolve several issues with the creation of StreamerInfo for abstract classes. When looking for the value corresponding to an enum type, skip global that are not enums. (This improves the speed of TFile::Open by 60%). TStyle. The Modern style has now a transparent bac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html:3052,access,access,3052,core/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v532/index.html,2,['access'],['access']
Security,"r **`TNtuples`** and want to read the contents for use; in your analysis code. This is commonly the case when you work with the; result of the reconstruction software of your experiment (e.g. the; combined ntuple in ATLAS). The following example code outlines the main; steps (you can run it on the result of the `tree1.C` macro):. ``` {.cpp}; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; break. # copy next entry into memory and verify; nb = mychain.GetEntry(jentry); if nb<=0:; continue. # use the values directly from the tree; nEvent = int(mychain.ev); if nEvent<0:; continue. print(mychain.pz, '=', mychain.px*mychain.px, '+', mychain.py*mychain.py); ```. Access to arrays works the same way as access to single value tree; elements, where the size of the array is determined by the number of; values actually read from the file. For example:. ``` {.cpp}; # loop over array tree element; for d in mychain.mydoubles:; print(d). # direct access into an array tree element; i5 = mychain.myints[5]; ```. #### Writing a Tree. Writing a ROOT **`TTree`** in a Python session is a little convoluted,; if only because you will need a C++ class to make sure that data members; can be mapped, unless you are working with built-in types. Here is an; example for working with the latter only:. ``` {.cpp}; from ROOT import TFile, TTree; from array import array. h = TH1F('h1','test',100,-10.,10.); f = TFile('test.root','recreate'); t = TTree('t1','tree with histos'); maxn = 10; n = array('i',[0]); d = array('f',maxn*[0.]); t.Branch('mynum',n,'mynum/I'); t.Branch('myval',d,'myval[mynum]/F'). for i in range(25):; n[0] = min(i,maxn); for j in range(n[0]):; d[j] = i*0.1+j; t.Fill(). f.Write(); f.Close(); ```. The use of arrays is needed, because the po",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:29737,access,access,29737,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['access'],['access']
Security,"r = new TColor(ci, 0.1, 0.2, 0.3, 0.5); // alpha = 0.5; ; An example of tranparency usage with parallel coordinates can be found; in $ROOTSYS/tutorials/tree/parallelcoordtrans.C. TSVG. Implement the transparency in SVG files (cf TPDF).; . TLegend. The option E, to draw the error bar on a legend entry, does not need; anymore the option L to be active. It is now possible to draw the error; bar only using the option E alone. The combination of the options E and L; still works as before.; . The text attributes were not properly initialized by the default; constructor.; . TLatex. Implement #mp.; . TPad. New method DivideSquare a canvas in to n sub-pads. The number of sub-pads; along the X and Y axis are computed according to the square root of n.; Example:; ; void divsquare(int w, int h, int n); {; TCanvas *c = new TCanvas (""c"",""c"",0,0,w,h);; c->DivideSquare(n);; for (int i=1; i<=n; i++) {; c->cd(i);; gPad->DrawFrame(0,0,1,1);; }; }; . TPad::Print always use TImageDump to print gif, png and jpeg files, in; interactive and batch mode (previously it was used in the batch case only).; This allows to generate output transparent colors in these formats even in; interactive mode. The generation of gif, png and jpeg files from the; graphics window in interactive mode is kept for OpenGL canvases.; . New graphical back-end for MacOSX. TGCocoa/TGQuartz classes are the implementation of TVirtualX based on Cocoa and Quartz 2D.; They let to use ROOT's GUI and graphics on MacOS X without installing X11.app and also give an access to Apple's native; graphics and GUI frameworks. Window management, event loop, event dispatching, etc. are implemented on top of Cocoa.; Graphics (GUI rendering and non-GUI) is done by Quartz 2D (Core Graphics).; An example of a TCanvas with a THStack object, transparency, anti-aliasing, gradient fill, shadows:. ROOT must be configured with --enable-cocoa parameter to use Cocoa back-end instead of X11 version.; Please note, this is still a work in progress.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v534/index.html:2379,access,access,2379,graf2d/doc/v534/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v534/index.html,2,['access'],['access']
Security,"r Input object's error() method will; return true. For instance the following document:. .. code-block:: yaml. - name: Tom; shoe-size: 12; - name: Dan; hat-size: 7. Has a key (shoe-size) that is not defined in the schema. YAML I/O will; automatically generate this error:. .. code-block:: yaml. YAML:2:2: error: unknown key 'shoe-size'; shoe-size: 12; ^~~~~~~~~. Similar errors are produced for other input not conforming to the schema. Scalars; =======. YAML scalars are just strings (i.e. not a sequence or mapping). The YAML I/O; library provides support for translating between YAML scalars and specific; C++ types. Built-in types; --------------; The following types have built-in support in YAML I/O:. * bool; * float; * double; * StringRef; * std::string; * int64_t; * int32_t; * int16_t; * int8_t; * uint64_t; * uint32_t; * uint16_t; * uint8_t. That is, you can use those types in fields of MappingTraits or as element type; in sequence. When reading, YAML I/O will validate that the string found; is convertible to that type and error out if not. Unique types; ------------; Given that YAML I/O is trait based, the selection of how to convert your data; to YAML is based on the type of your data. But in C++ type matching, typedefs; do not generate unique type names. That means if you have two typedefs of; unsigned int, to YAML I/O both types look exactly like unsigned int. To; facilitate make unique type names, YAML I/O provides a macro which is used; like a typedef on built-in types, but expands to create a class with conversion; operators to and from the base type. For example:. .. code-block:: c++. LLVM_YAML_STRONG_TYPEDEF(uint32_t, MyFooFlags); LLVM_YAML_STRONG_TYPEDEF(uint32_t, MyBarFlags). This generates two classes MyFooFlags and MyBarFlags which you can use in your; native data structures instead of uint32_t. They are implicitly; converted to and from uint32_t. The point of creating these unique types; is that you can now specify traits on them to get different YAML c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:6525,validat,validate,6525,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['validat'],['validate']
Security,"r ``std::initializer_list`` this reachable region would the region for the backing; array and the transfer functions for begin() and end() yield the beginning and; end element regions for it. In my view this differs from ghost variables in that (1) this storage does; actually exist (it is just a library implementation detail where that storage; lives) and (2) it is perfectly valid for a pointer into that storage to be; returned and for another part of the program to read or write from that storage.; (Well, in this case just read since it is allowed to be read-only memory). What I'm not OK with is modeling abstract analysis state (for example, the count; of a NSMutableArray or the typestate of a file handle) as a value stored in some; ginned up region in the store. This takes an easy problem that the analyzer does; well at (modeling typestate) and turns it into a hard one that the analyzer is; bad at (reasoning about the contents of the heap). I think the key criterion here is: ""is the region accessible from outside the; library"". That is, does the library expose the region as a pointer that can be; read to or written from in the client program? If so, then it makes sense for; this to be in the store: we are modeling reachable storage as storage. But if; we're just modeling arbitrary analysis facts that need to be invalidated when a; pointer escapes then we shouldn't try to gin up storage for them just to get; invalidation for free. **Artem:**. > In this case, I would be fine with some sort of ``AbstractStorageMemoryRegion``; > that meant ""here is a memory region and somewhere reachable from here exists; > another region of type T"". Or even multiple regions with different; > identifiers. This wouldn't specify how the memory is reachable, but it would; > allow for transfer functions to get at those regions and it would allow for; > invalidation. Yeah, this is what we can easily implement now as a; symbolic-region-based-on-a-metadata-symbol (though we can make a new reg",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:9754,access,accessible,9754,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,1,['access'],['accessible']
Security,"r a null pointer or is; pointing to memory of the specified size. To support this idiom,; ``-fbounds-safety`` provides ``*_or_null`` variants,; ``__counted_by_or_null(N)``, ``__sized_by_or_null(N)``, and; ``__ended_by_or_null(P)``. Accessing a pointer with any of these bounds; annotations will require an extra null check to avoid a null pointer; dereference. Internal bounds annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. A wide pointer (sometimes known as a ""fat"" pointer) is a pointer that carries; additional bounds information internally (as part of its data). The bounds; require additional storage space making wide pointers larger than normal; pointers, hence the name ""wide pointer"". The memory layout of a wide pointer is; equivalent to a struct with the pointer, upper bound, and (optionally) lower; bound as its fields as shown below. .. code-block:: c. struct wide_pointer_datalayout {; void* pointer; // Address used for dereferences and pointer arithmetic; void* upper_bound; // Points one past the highest address that can be; // accessed; void* lower_bound; // (Optional) Points to lowest address that can be; // accessed; };. Even with this representational change, wide pointers act syntactically as; normal pointers to allow standard pointer operations, such as pointer; dereference (``*p``), array subscript (``p[i]``), member access (``p->``), and; pointer arithmetic, with some restrictions on bounds-unsafe uses. ``-fbounds-safety`` has a set of ""internal"" bounds annotations to turn pointers; into wide pointers. These are ``__bidi_indexable`` and ``__indexable``. When a; pointer has either of these annotations, the compiler changes the pointer to the; corresponding wide pointer. This means these annotations will break the ABI and; will not be compatible with plain C, and thus they should generally not be used; in ABI surfaces. * ``__bidi_indexable`` : A pointer with this annotation becomes a wide pointer; to carry the upper bound and the lower bound, the layout of which",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:13419,access,accessed,13419,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,2,['access'],['accessed']
Security,"r all functions in those files; fun:*. And an example blocklist:. .. code-block:: none. # Disable instrumentation for a specific source file that the allowlist allowed; src:bar/b.cpp; # Disable instrumentation for a specific function that the allowlist allowed; fun:*myFunc*. The use of ``*`` wildcards above is required because function names are matched after mangling.; Without the wildcards, one would have to write the whole mangled name. Be careful that the paths of source files are matched exactly as they are provided on the clang; command line.; For example, the allowlist above would include file ``bar/b.cpp`` if the path was provided; exactly like this, but would it would fail to include it with other ways to refer to the same; file such as ``./bar/b.cpp``, or ``bar\b.cpp`` on Windows.; So, please make sure to always double check that your lists are correctly applied. Default implementation; ======================. The sanitizer run-time (AddressSanitizer, MemorySanitizer, etc) provide a; default implementations of some of the coverage callbacks.; You may use this implementation to dump the coverage on disk at the process; exit. Example:. .. code-block:: console. % cat -n cov.cc; 1 #include <stdio.h>; 2 __attribute__((noinline)); 3 void foo() { printf(""foo\n""); }; 4; 5 int main(int argc, char **argv) {; 6 if (argc == 2); 7 foo();; 8 printf(""main\n"");; 9 }; % clang++ -g cov.cc -fsanitize=address -fsanitize-coverage=trace-pc-guard; % ASAN_OPTIONS=coverage=1 ./a.out; wc -c *.sancov; main; SanitizerCoverage: ./a.out.7312.sancov 2 PCs written; 24 a.out.7312.sancov; % ASAN_OPTIONS=coverage=1 ./a.out foo ; wc -c *.sancov; foo; main; SanitizerCoverage: ./a.out.7316.sancov 3 PCs written; 24 a.out.7312.sancov; 32 a.out.7316.sancov. Every time you run an executable instrumented with SanitizerCoverage; one ``*.sancov`` file is created during the process shutdown.; If the executable is dynamically linked against instrumented DSOs,; one ``*.sancov`` file will be also created",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:15867,sanitiz,sanitizer,15867,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['sanitiz'],['sanitizer']
Security,"r and easier.; As of `this revision <https://reviews.llvm.org/D121381>`_, the default was; changed to not optimize uses at build time, in order to provide the option to; reduce compile-time if the walking is not necessary in a pass. Most users call; the new API ``ensureOptimizedUses()`` to keep the previous behavior and do a; one-time optimization of ``MemoryUse``\ s, if this was not done before.; New pass users are recommended to call ``ensureOptimizedUses()``. Initially it was not possible to optimize ``MemoryDef``\ s in the same way, as we; restricted ``MemorySSA`` to one operand per access.; This was changed and ``MemoryDef``\ s now keep two operands.; The first one, the defining access, is; always the previous ``MemoryDef`` or ``MemoryPhi`` in the same basic block, or; the last one in a dominating predecessor if the current block doesn't have any; other accesses writing to memory. This is needed for walking Def chains.; The second operand is the optimized access, if there was a previous call on the; walker's ``getClobberingMemoryAccess(MA)``. This API will cache information; as part of ``MA``.; Optimizing all ``MemoryDef``\ s has quadratic time complexity and is not done; by default. A walk of the uses for any MemoryDef can find the accesses that were optimized; to it.; A code snippet for such a walk looks like this:. .. code-block:: c++. MemoryDef *Def; // find who's optimized or defining for this MemoryDef; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *DefUser = cast_of_null<MemoryDef>MA); if (DefUser->isOptimized() && DefUser->getOptimized() == Def) {; // User who is optimized to Def; } else {; // User who's defining access is Def; optimized to something else or not optimized.; }; }. When ``MemoryUse``\ s are optimized, for a given store, you can find all loads; clobbered by that store by walking the immediate and transitive uses of; the store. .. code-block:: c++. checkUses(MemoryAccess *Def) { // Def can be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:12491,access,access,12491,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security,"r every architecture, a default set of CPU/FPU/ABI; will be chosen, so you'll almost always have to change it via flags. Typical flags include:; * ``-mcpu=<cpu-name>``, like x86-64, swift, cortex-a15; * ``-mfpu=<fpu-name>``, like SSE3, NEON, controlling the FP unit available; * ``-mfloat-abi=<fabi>``, like soft, hard, controlling which registers; to use for floating-point. The default is normally the common denominator, so that Clang doesn't; generate code that breaks. But that also means you won't get the best; code for your specific hardware, which may mean orders of magnitude; slower than you expect. For example, if your target is ``arm-none-eabi``, the default CPU will; be ``arm7tdmi`` using soft float, which is extremely slow on modern cores,; whereas if your triple is ``armv7a-none-eabi``, it'll be Cortex-A8 with; NEON, but still using soft-float, which is much better, but still not; great. Toolchain Options; -----------------. There are three main options to control access to your cross-compiler:; ``--sysroot``, ``-I``, and ``-L``. The two last ones are well known,; but they're particularly important for additional libraries; and headers that are specific to your target. There are two main ways to have a cross-compiler:. #. When you have extracted your cross-compiler from a zip file into; a directory, you have to use ``--sysroot=<path>``. The path is the; root directory where you have unpacked your file, and Clang will; look for the directories ``bin``, ``lib``, ``include`` in there. In this case, your setup should be pretty much done (if no; additional headers or libraries are needed), as Clang will find; all binaries it needs (assembler, linker, etc) in there. #. When you have installed via a package manager (modern Linux; distributions have cross-compiler packages available), make; sure the target triple you set is *also* the prefix of your; cross-compiler toolchain. In this case, Clang will find the other binaries (assembler,; linker), but not always where",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst:6233,access,access,6233,interpreter/llvm-project/clang/docs/CrossCompilation.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CrossCompilation.rst,1,['access'],['access']
Security,"r functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:5802,hash,hashes,5802,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['hash'],['hashes']
Security,"r of elements as the; result vector type. The fourth operand is the explicit vector length of the; operation. Semantics:; """""""""""""""""""". The '``llvm.vp.is.fpclass``' intrinsic performs llvm.is.fpclass (:ref:`llvm.is.fpclass <llvm.is.fpclass>`). Examples:; """""""""""""""""". .. code-block:: llvm. %r = call <2 x i1> @llvm.vp.is.fpclass.v2f16(<2 x half> %x, i32 3, <2 x i1> %m, i32 %evl); %t = call <vscale x 2 x i1> @llvm.vp.is.fpclass.nxv2f16(<vscale x 2 x half> %x, i32 3, <vscale x 2 x i1> %m, i32 %evl). .. _int_mload_mstore:. Masked Vector Load and Store Intrinsics; ---------------------------------------. LLVM provides intrinsics for predicated vector load and store operations. The predicate is specified by a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits of the mask are on, the intrinsic is identical to a regular vector load or store. When all bits are off, no memory is accessed. .. _int_mload:. '``llvm.masked.load.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data is a vector of any integer, floating-point or pointer data type. ::. declare <16 x float> @llvm.masked.load.v16f32.p0(ptr <ptr>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.load.v2f64.p0(ptr <ptr>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); ;; The data is a vector of pointers; declare <8 x ptr> @llvm.masked.load.v8p0.p0(ptr <ptr>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads a vector from memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:843104,access,accessed,843104,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"r or the _begin_ and the size. Note that; for the Vector the iterator is not generic and must be of type _T*,_ where T is the type; of the contained elements. Here are some examples on how to create a vector. In the following we assume that we are; using the namespace ROOT::Math. ~~~ {.cpp}; SVector<double,N> v; // create a vector of size N, v[i]=0; SVector<double,3> v(1,2,3); // create a vector of size 3, v[0]=1,v[1]=2,v[2]=3; double a[9] = {1,2,3,4,5,6,7,8,9}; // input data; SVector<double,9> v(a,9); // create a vector using the a[] data; ~~~. ### Accessing and Setting Methods. The single vector elements can be set or retrieved using the _operator[i]_ , _operator(i)_; or the iterator interface. Notice that the index starts from zero and not from one as in; FORTRAN. Also no check is performed on the passed index. Furthermore, all the matrix; elements can be set also by using the ROOT::SVector::SetElements function passing a generic; iterator. The elements can be accessed also by using the ROOT::Math::SVector::apply(i) function. ~~~ {.cpp}; v[0] = 1; // set the first element; v(1) = 2; // set the second element; *(v.begin()+3) = 3; // set the third element; // set vector elements from a std::vector<double>::iterator</double>; std::vector <double> w(3);; v.SetElements(w.begin(),w.end());. double x = m(i); // return the i-th element; x = m.apply(i); // return the i-th element; x = *(m.begin()+i); // return the i-th element; ~~~. In addition there are methods to place a sub-vector in a vector. If the size of the the; sub-vector is larger than the vector size a static assert ( a compilation error) is produced. ~~~ {.cpp}; SVector<double,N> v;; SVector<double,M> w; // M <= N otherwise a compilation error is obtained later; // place a vector of size M starting from element ioff, v[ioff + i] = w[i]; v.Place_at(w,ioff);; // return a sub-vector of size M starting from v[ioff]: w[i] = v[ioff + i]; w = v.Sub < SVector>double,M> > (ioff);; ~~~. For additional Vector functionalit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SVector.md:1798,access,accessed,1798,math/smatrix/doc/SVector.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SVector.md,1,['access'],['accessed']
Security,"r runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-norma",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78961,sanitiz,sanitizer,78961,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitizer']
Security,"r the arguments have been; translated. A long term goal is to remove this tool chain specific translation, and; instead force each tool to change its own logic to do the right thing on; the untranslated original arguments. Unused Argument Warnings; ^^^^^^^^^^^^^^^^^^^^^^^^. The driver operates by parsing all arguments but giving Tools the; opportunity to choose which arguments to pass on. One downside of this; infrastructure is that if the user misspells some option, or is confused; about which options to use, some command line arguments the user really; cared about may go unused. This problem is particularly important when; using clang as a compiler, since the clang compiler does not support; anywhere near all the options that gcc does, and we want to make sure; users know which ones are being used. To support this, the driver maintains a bit associated with each; argument of whether it has been used (at all) during the compilation.; This bit usually doesn't need to be set by hand, as the key ArgList; accessors will set it automatically. When a compilation is successful (there are no errors), the driver; checks the bit and emits an ""unused argument"" warning for any arguments; which were never accessed. This is conservative (the argument may not; have been used to do what the user wanted) but still catches the most; obvious cases. Relation to GCC Driver Concepts; -------------------------------. For those familiar with the gcc driver, this section provides a brief; overview of how things from the gcc driver map to the clang driver. - **Driver Driver**. The driver driver is fully integrated into the clang driver. The; driver simply constructs additional Actions to bind the architecture; during the *Pipeline* phase. The tool chain specific argument; translation is responsible for handling ``-Xarch_``. The one caveat is that this approach requires ``-Xarch_`` not be used; to alter the compilation itself (for example, one cannot provide; ``-S`` as an ``-Xarch_`` argument",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst:14705,access,accessors,14705,interpreter/llvm-project/clang/docs/DriverInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/DriverInternals.rst,1,['access'],['accessors']
Security,"r the entire array?; // There is not, but it is a stack variable, so we use; // ""uninitialized"" as the default value (and emit a; // diagnostic!). NOTE: The fact that bindings are stored as a base region plus an offset limits; the Default Binding strategy, because in C aggregates can contain other; aggregates. In the current implementation of RegionStore, there is no way to; distinguish a Default binding for an entire aggregate from a Default binding; for the sub-aggregate at offset 0. Lazy Bindings (LazyCompoundVal); -------------------------------. RegionStore implements an optimization for copying aggregates (structs and; arrays) called ""lazy bindings"", implemented using a special SVal called; LazyCompoundVal. When the store is asked for the ""binding"" for an entire; aggregate (i.e. for an lvalue-to-rvalue conversion), it returns a; LazyCompoundVal instead. When this value is then stored into a variable, it is; bound as a Default value. This makes copying arrays and structs much cheaper; than if they had required memberwise access. Under the hood, a LazyCompoundVal is implemented as a uniqued pair of (region,; store), representing ""the value of the region during this 'snapshot' of the; store"". This has important implications for any sort of liveness or; reachability analysis, which must take the bindings in the old store into; account. Retrieving a value from a lazy binding happens in the same way as any other; Default binding: since there is no direct binding, the store manager falls back; to super-regions to look for an appropriate default binding. LazyCompoundVal; differs from a normal default binding, however, in that it contains several; different values, instead of one value that will appear several times. Because; of this, the store manager has to reconstruct the subregion chain on top of the; LazyCompoundVal region, and look up *that* region in the previous store. Here's a concrete example:. .. code-block:: cpp. CGPoint p;; p.x = 42; // A Direct binding is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:7088,access,access,7088,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,1,['access'],['access']
Security,"r the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""Undo"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. \anchor GP08d; ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. \anchor GP08e; ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""Position"" allows editing the; positioning matrix of a given node. \image html geometry022.jpg width=600px; \image html geometry023.jpg ""Setting volume properties and modifying volume hierarchy"" width=600px. - *Visualization*. Thi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:131796,access,accessible,131796,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['accessible']
Security,"r unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators have different behaviors with regard to; reclaiming. While Secondary mapped allocations can be unmapped on deallocation,; it isn't the case for the Primary, which could lead to a steady growth of the; RSS of a process. To counteract this, if the underlying OS allows it, pages; that are covered by contiguous free memory blocks in the Primary can be; released: this generally means they won't count towards the RSS of a process and; be zero filled on subsequent accesses). This is done",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:4464,secur,security,4464,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['secur'],['security']
Security,"r"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. alpha.osx.cocoa.localizability.PluralMisuseChecker; (ObjC); Warns against using one vs. many plural pattern in code; when generating localized strings. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is taint",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:9850,secur,security,9850,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['secur'],['security']
Security,"r(int a, ...); // error - variadic prototype is not allowed. ``__cl_clang_non_portable_kernel_param_types``; ----------------------------------------------. With this extension it is possible to enable the use of some restricted types; in kernel parameters specified in `C++ for OpenCL v1.0 s2.4; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html#kernel_function>`_.; The restrictions can be relaxed using regular OpenCL extension pragma mechanism; detailed in `the OpenCL Extension Specification, section 1.2; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Ext.html#extensions-overview>`_. This is not a conformant behavior and it can only be used when the; kernel arguments are not accessed on the host side or the data layout/size; between the host and device is known to be compatible. **Example of Use**:. .. code-block:: c++. // Plain Old Data type.; struct Pod {; int a;; int b;; };. // Not POD type because of the constructor.; // Standard layout type because there is only one access control.; struct OnlySL {; int a;; int b;; OnlySL() : a(0), b(0) {}; };. // Not standard layout type because of two different access controls.; struct NotSL {; int a;; private:; int b;; };. #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : enable; kernel void kernel_main(; Pod a,. OnlySL b,; global NotSL *c,; global OnlySL *d; );; #pragma OPENCL EXTENSION __cl_clang_non_portable_kernel_param_types : disable. Remove address space builtin function; -------------------------------------. ``__remove_address_space`` allows to derive types in C++ for OpenCL; that have address space qualifiers removed. This utility only affects; address space qualifiers, therefore, other type qualifiers such as; ``const`` or ``volatile`` remain unchanged. **Example of Use**:. .. code-block:: c++. template<typename T>; void foo(T *par){; T var1; // error - local function variable with global address space; __private T var2; // error - conflicting address space quali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:90061,access,access,90061,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access']
Security,"r) curves; 12. Let change physical node visibility in TGeo drawings; 13. Use TGaxis attributes from gStyle - fAxisMaxDigits, fStripDecimals and exponent offset; 14. Implement ""projxy"" draw option for TH2 - like projxy3 or projx1_y5; 15. Support custom function in TGaxis - when drawn in TWebCanvas; 16. Introduce settings.WithCredentials, set xhr.withCredentials = true when submitting HTTP requests; 17. Let superimpose TH3 and geo drawings; 18. Apply pad draw options like 'gridx' or 'logy' to all subpads; 19. Support new TScatter and TAnnotation classes; 20. Implement moving and resizing of subpads; 21. Implement zooming in the TASImage; 22. Let configure position and direction of camera for TGeo, let create URL for that; 23. Support labels rotation for simple axis in geometry; 24. Support many orthographic cameras with overlayed grid/labels; 25. Support InstancedMesh for TGeo drawing, let show really large geometries; 26. Implement 'inject=path/script_name.js' url option to inject scripts without emulating of v6; 27. Exclude 'HEAD' http request when reading ROOT file, all necessary info can be get from first real HTTP request; 28. Provide makeImage function for generation of svg, png and jpeg images in batch and interactively (#257); 29. Implement interactive zoom shifting when middle-mouse button down or single-touch moving; 30. Several improvements for touch devices or devices with small displays; 31. Remove settings.FrameNDC, use Style.fPadLeft/Right/Top/BottomMargin values instead; 32. Fix - rescan sumw2 when update TH1; 33. Fix - correct placing for TLegend header; 34. Fix - correctly align sub/super scripts in complex TLatex; 35. Fix - correctly set visibility level for geo drawing (#258); 36. Fix - use more factor for number of nodes in geo drawing (#258). ## Changes in 7.3.4; 1. Fix - failure in normal_cdf calculation; 2. Fix - check in TTree::Draw for null buffer; 3. Fix - do not rise exception in treeProcess; 4. Fix - RH1 zero line drawing only when required",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:13682,inject,inject,13682,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['inject'],['inject']
Security,"r,; which is either another scalar type descriptor or the TBAA root. Scalar; type descriptors can have an optional third argument, but that must be the; constant integer zero. Struct type descriptors are represented as ``MDNode`` s with an odd number; of operands greater than 1. The first operand is an ``MDString`` denoting; the name of the struct type. Like in scalar type descriptors the actual; value of this name operand is irrelevant to LLVM. After the name operand,; the struct type descriptors have a sequence of alternating ``MDNode`` and; ``ConstantInt`` operands. With N starting from 1, the 2N - 1 th operand,; an ``MDNode``, denotes a contained field, and the 2N th operand, a; ``ConstantInt``, is the offset of the said contained field. The offsets; must be in non-decreasing order. Access tags are represented as ``MDNode`` s with either 3 or 4 operands.; The first operand is an ``MDNode`` pointing to the node representing the; base type. The second operand is an ``MDNode`` pointing to the node; representing the access type. The third operand is a ``ConstantInt`` that; states the offset of the access. If a fourth field is present, it must be; a ``ConstantInt`` valued at 0 or 1. If it is 1 then the access tag states; that the location being accessed is ""constant"" (meaning; ``pointsToConstantMemory`` should return true; see `other useful; AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_). The TBAA root of; the access type and the base type of an access tag must be the same, and; that is the TBAA root of the access tag. '``tbaa.struct``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The :ref:`llvm.memcpy <int_memcpy>` is often used to implement; aggregate assignment operations in C and similar languages, however it; is defined to copy a contiguous region of memory, which is more than; strictly necessary for aggregate types which contain holes due to; padding. Also, it doesn't contain any TBAA information about the fields; of the aggregate. ``!tbaa.struct`` metadata c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:279064,access,access,279064,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"r. In; order to support address spaces, the CFA DWARF expression is defined to be a; memory location description. This allows it to specify an address space which is; used to convert the offset address back to an address in that address space. See; :ref:`amdgpu-dwarf-call-frame-information`. This approach of extending memory location descriptions to support address; spaces, allows all existing DWARF Version 5 expressions to have the identical; semantics. It allows the compiler to explicitly specify the address space it is; using. For example, a compiler could choose to access private memory in a; swizzled manner when mapping a source language thread to the lane of a wavefront; in a SIMT manner. Or a compiler could choose to access it in an unswizzled; manner if mapping the same language with the wavefront being the thread. It also allows the compiler to mix the address space it uses to access private; memory. For example, for SIMT it can still spill entire vector registers in an; unswizzled manner, while using a swizzled private memory for SIMT variable; access. This approach also allows memory location descriptions for different address; spaces to be combined using the regular ``DW_OP_*piece`` operations. Location descriptions are an abstraction of storage. They give freedom to the; consumer on how to implement them. They allow the address space to encode lane; information so they can be used to read memory with only the memory location; description and no extra information. The same set of operations can operate on; locations independent of their kind of storage. The ``DW_OP_deref*`` therefore; can be used on any storage kind, including memory location descriptions of; different address spaces. Therefore, the ``DW_OP_xderef*`` operations are; unnecessary, except to become a more compact way to encode a non-default address; space address followed by dereferencing it. See; :ref:`amdgpu-dwarf-general-operations`. 2.9 Support for Vector Base Types; -------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:22619,access,access,22619,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security,"r; ---------------. DWARF lane identifies specify a target architecture lane position for hardware; that executes in a SIMD or SIMT manner, and on which a source language maps its; threads of execution onto those lanes. The DWARF lane identifier is pushed by; the ``DW_OP_LLVM_push_lane`` DWARF expression operation. See DWARF Version 5; section 2.5 which is updated by *DWARF Extensions For Heterogeneous Debugging*; section :ref:`amdgpu-dwarf-operation-expressions`. For AMDGPU, the lane identifier corresponds to the hardware lane ID of a; wavefront. It is numbered from 0 to the wavefront size minus 1. Operation Expressions; ---------------------. DWARF expressions are used to compute program values and the locations of; program objects. See DWARF Version 5 section 2.5 and; :ref:`amdgpu-dwarf-operation-expressions`. DWARF location descriptions describe how to access storage which includes memory; and registers. When accessing storage on AMDGPU, bytes are ordered with least; significant bytes first, and bits are ordered within bytes with least; significant bits first. For AMDGPU CFI expressions, ``DW_OP_LLVM_select_bit_piece`` is used to describe; unwinding vector registers that are spilled under the execution mask to memory:; the zero-single location description is the vector register, and the one-single; location description is the spilled memory location description. The; ``DW_OP_LLVM_form_aspace_address`` is used to specify the address space of the; memory location description. In AMDGPU expressions, ``DW_OP_LLVM_select_bit_piece`` is used by the; ``DW_AT_LLVM_lane_pc`` attribute expression where divergent control flow is; controlled by the execution mask. An undefined location description together; with ``DW_OP_LLVM_extend`` is used to indicate the lane was not active on entry; to the subprogram. See :ref:`amdgpu-dwarf-dw-at-llvm-lane-pc` for an example. Debugger Information Entry Attributes; -------------------------------------. This section describes how certain ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:98668,access,accessing,98668,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessing']
Security,"r; <https://github.com/NVIDIA/nvidia-docker>`_ to run your docker containers. Note; that you don't need nvidia-docker to build the images, but you need it in order; to have an access to GPU from a docker container that is running the built; image. If you have a different use-case, you could create your own image based on; ``example/`` folder. Any docker image can be built and run using only the docker binary, i.e. you can; run debian10 build on Fedora or any other Linux distribution. You don't need to; install CMake, compilers or any other clang dependencies. It is all handled; during the build process inside Docker's isolated environment. Stable build; ============; If you want a somewhat recent and somewhat stable build, use the; ``branches/google/stable`` branch, i.e. the following command will produce a; Debian10-based image using the latest ``google/stable`` sources for you:. .. code-block:: bash. ./llvm/utils/docker/build_docker_image.sh \; 	-s debian10 --d clang-debian10 -t ""staging"" \; 	--branch branches/google/stable \; 	-p clang -i install-clang -i install-clang-resource-headers \; 	-- \; 	-DCMAKE_BUILD_TYPE=Release. Minimizing docker image size; ============================; Due to how Docker's filesystem works, all intermediate writes are persisted in; the resulting image, even if they are removed in the following commands.; To minimize the resulting image size we use `multi-stage Docker builds; <https://docs.docker.com/develop/develop-images/multistage-build/>`_.; Internally Docker builds two images. The first image does all the work: installs; build dependencies, checks out LLVM source code, compiles LLVM, etc.; The first image is only used during build and does not have a descriptive name,; i.e. it is only accessible via the hash value after the build is finished.; The second image is our resulting image. It contains only the built binaries; and not any build dependencies. It is also accessible via a descriptive name; (specified by -d and -t flags).; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst:7967,access,accessible,7967,interpreter/llvm-project/llvm/docs/Docker.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Docker.rst,3,"['access', 'hash']","['accessible', 'hash']"
Security,"r; indirect control flow operations are protected by CFI, and should output these; results in a human-readable form. This tool should also be added as part of Clang's continuous integration testing; framework, where modifications to the compiler ensure that CFI protection; schemes are still present in the final binary. Location; ========. This tool will be present as a part of the LLVM toolchain, and will reside in; the ""/llvm/tools/llvm-cfi-verify"" directory, relative to the LLVM trunk. It will; be tested in two methods:. - Unit tests to validate code sections, present in; ""/llvm/unittests/tools/llvm-cfi-verify"".; - Integration tests, present in ""/llvm/tools/clang/test/LLVMCFIVerify"". These; integration tests are part of clang as part of a continuous integration; framework, ensuring updates to the compiler that reduce CFI coverage on; indirect control flow instructions are identified. Background; ==========. This tool will continuously validate that CFI directives are properly; implemented around all indirect control flows by analysing the output machine; code. The analysis of machine code is important as it ensures that any bugs; present in linker or compiler do not subvert CFI protections in the final; shipped binary. Unprotected indirect control flow instructions will be flagged for manual; review. These unexpected control flows may simply have not been accounted for in; the compiler implementation of CFI (e.g. indirect jumps to facilitate switch; statements may not be fully protected). It may be possible in the future to extend this tool to flag unnecessary CFI; directives (e.g. CFI directives around a static call to a non-polymorphic base; type). This type of directive has no security implications, but may present; performance impacts. Design Ideas; ============. This tool will disassemble binaries and DSO's from their machine code format and; analyse the disassembled machine code. The tool will inspect virtual calls and; indirect function calls. This tool wil",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst:1374,validat,validate,1374,interpreter/llvm-project/llvm/docs/CFIVerify.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CFIVerify.rst,1,['validat'],['validate']
Security,"r=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ign",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77722,sanitiz,sanitize-trap,77722,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize-trap']
Security,"r>`` elements, and the second argument ``%B`` to a matrix with; ``<Inner> * <OuterColumns>`` elements. Arguments ``<OuterRows>``,; ``<Inner>`` and ``<OuterColumns>`` must be positive, constant integers. The; returned vector must have ``<OuterRows> * <OuterColumns>`` elements.; Vectors ``%A``, ``%B``, and the returned vector all have the same float or; integer element type. '``llvm.matrix.column.major.load.*``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. ::. declare vectorty @llvm.matrix.column.major.load.*(; ptrty %Ptr, i64 %Stride, i1 <IsVolatile>, i32 <Rows>, i32 <Cols>). Overview:; """""""""""""""""". The '``llvm.matrix.column.major.load.*``' intrinsics load a ``<Rows> x <Cols>``; matrix using a stride of ``%Stride`` to compute the start address of the; different columns. The offset is computed using ``%Stride``'s bitwidth. This; allows for convenient loading of sub matrixes. If ``<IsVolatile>`` is true, the; intrinsic is considered a :ref:`volatile memory access <volatile>`. The result; matrix is returned in the result vector. If the ``%Ptr`` argument is known to; be aligned to some boundary, this can be specified as an attribute on the; argument. Arguments:; """""""""""""""""""". The first argument ``%Ptr`` is a pointer type to the returned vector type, and; corresponds to the start address to load from. The second argument ``%Stride``; is a positive, constant integer with ``%Stride >= <Rows>``. ``%Stride`` is used; to compute the column memory addresses. I.e., for a column ``C``, its start; memory addresses is calculated with ``%Ptr + C * %Stride``. The third Argument; ``<IsVolatile>`` is a boolean value. The fourth and fifth arguments,; ``<Rows>`` and ``<Cols>``, correspond to the number of rows and columns,; respectively, and must be positive, constant integers. The returned vector must; have ``<Rows> * <Cols>`` elements. The :ref:`align <attr_align>` parameter attribute can be provided for the; ``%Ptr`` argume",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:678233,access,access,678233,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"rLiteral(5)`` |; +-----------------------+; | ``IntegerLiteral(4)`` |; +-----------------------+; | ``IntegerLiteral(3)`` |; +-----------------------+; | ``IntegerLiteral(-)`` |; +-----------------------+; | ``IntegerLiteral(+)`` |; +-----------------------+; | ``STOP`` |; +-----------------------+. When reading this representation, Clang evaluates each expression record it; encounters, builds the appropriate abstract syntax tree node, and then pushes; that expression on to a stack. When a record contains *N* subexpressions ---; ``BinaryOperator`` has two of them --- those expressions are popped from the; top of the stack. The special STOP code indicates that we have reached the end; of a serialized expression or statement; other expression or statement records; may follow, but they are part of a different expression. .. _pchinternals-ident-table:. Identifier Table Block; ^^^^^^^^^^^^^^^^^^^^^^. The identifier table block contains an on-disk hash table that maps each; identifier mentioned within the AST file to the serialized representation of; the identifier's information (e.g, the ``IdentifierInfo`` structure). The; serialized representation contains:. * The actual identifier string.; * Flags that describe whether this identifier is the name of a built-in, a; poisoned identifier, an extension token, or a macro.; * If the identifier names a macro, the offset of the macro definition within; the :ref:`pchinternals-preprocessor`.; * If the identifier names one or more declarations visible from translation; unit scope, the :ref:`declaration IDs <pchinternals-decls>` of these; declarations. When an AST file is loaded, the AST file reader mechanism introduces itself; into the identifier table as an external lookup source. Thus, when the user; program refers to an identifier that has not yet been seen, Clang will perform; a lookup into the identifier table. If an identifier is found, its contents; (macro definitions, flags, top-level declarations, etc.) will be deserialize",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst:18546,hash,hash,18546,interpreter/llvm-project/clang/docs/PCHInternals.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/PCHInternals.rst,1,['hash'],['hash']
Security,"raced-init-list as a default argument; Unknown. 995; CD2; Incorrect example for using-declaration and explicit instantiation; Unknown. 996; C++11; Ambiguous partial specializations of member class templates; Unknown. 997; C++11; Argument-dependent lookup and dependent function template parameter types; Unknown. 998; dup; Function parameter transformations and template functions; Unknown. 999; CD2; “Implicit” or “implied” object argument/parameter?; Unknown. 1000; CD2; Mistaking member typedefs for constructors; Unknown. 1001; drafting; Parameter type adjustment in dependent parameter types; Not resolved. 1002; NAD; Pack expansion for function arguments; Unknown. 1003; CD3; Acceptable definitions of main; Unknown. 1004; C++11; Injected-class-names as arguments for template template parameters; Clang 5. 1005; NAD; Qualified name resolution in member functions of class templates; Unknown. 1006; C++11; std::nullptr_t as a non-type template parameter; Unknown. 1007; NAD; Protected access and pointers to members; Unknown. 1008; NAD; Querying the alignment of an object; Unknown. 1009; C++11; Missing cases in the declarator-id of a function template declaration; Unknown. 1010; CD2; Address of object with dynamic storage duration in constant expression; Unknown. 1011; C++11; Standard conversions that cannot be inverted; Unknown. 1012; C++11; Undeprecating static; Unknown. 1013; CD3; Uninitialized std::nullptr_t objects; Unknown. 1014; NAD; Overload resolution between const T& and T&&; Unknown. 1015; C++11; Template arguments and argument-dependent lookup; Unknown. 1016; C++11; Overloadable declarations, function templates, and references; Unknown. 1017; C++11; Member access transformation in unevaluated operands; Unknown. 1018; C++11; Ambiguity between simple-declaration and attribute-declaration; Unknown. 1019; dup; Dependent simple-template-ids in base-specifiers and mem-initializers; Unknown. 1020; C++11; Implicitly-defined copy constructors and explicit base class constr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:66351,access,access,66351,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"ral(0,3); (Double_t)1.84865252799946810e+00; root[] f1.Draw(); ```. By default the method `TF1::Paint()`, that draws the function,; computes 100 equidistant points to draw it. The number of points can; be set to a higher value with:. ``` {.cpp}; root[] f1.SetNpx(2000);; ```. Note that while the ROOT framework is an object-oriented framework,; this does not prevent the user from calling plain functions. ### User Interaction. Now we will look at some interactive capabilities. Try to draw the; function `sin(x)/x` again. Every object in a window (which is called a; canvas) is, in fact, a graphical object in the sense that you can grab; it, resize it, and change its characteristics with a mouse click. For; example, bring the cursor over the x-axis. The cursor changes to a; hand with a pointing finger when it is over the axis. Now, left click; and drag the mouse along the axis to the right. You have a very simple; zoom. When you move the mouse over any object, you can get access to; selected methods by pressing the right mouse button and obtaining a; context menu. If you try this on the function **`TF1`**, you will get; a menu showing available methods. The other objects on this canvas are; the title, a **`TPaveText`** object`;` the x and y-axis, **`TAxis`**; objects, the frame, a **`TFrame`** object, and the canvas a; **`TCanvas `** object. Try clicking on these and observe the context; menu with their methods. ![A context menu](pictures/0300002A.png). For example try selecting the `SetRange()` method and putting `-10`,; `10` in the dialog box fields. This is equivalent to executing; `f1.SetRange(-10,10)` from the command line, followed by `f1.Draw()`.; Here are some other options you can try. Once the picture suits your wishes, you may want to see the code you; should put in a script to obtain the same result. To do that, choose; Save / `canvas.C` entry of the File menu. This will generate a script; showing the options set in the current canvas. Notice that you can; also",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:21039,access,access,21039,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['access']
Security,"ram. The constructor must specify the type of the function to create and; what type of linkage the function should have. The FunctionType_ argument; specifies the formal arguments and return value for the function. The same; FunctionType_ value can be used to create multiple functions. The ``Parent``; argument specifies the Module in which the function is defined. If this; argument is provided, the function will automatically be inserted into that; module's list of functions. * ``bool isDeclaration()``. Return whether or not the ``Function`` has a body defined. If the function is; ""external"", it does not have a body, and thus must be resolved by linking with; a function defined in a different translation unit. * | ``Function::iterator`` - Typedef for basic block list iterator; | ``Function::const_iterator`` - Typedef for const_iterator.; | ``begin()``, ``end()``, ``size()``, ``empty()``, ``insert()``,; ``splice()``, ``erase()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's BasicBlock_ list. * | ``Function::arg_iterator`` - Typedef for the argument list iterator; | ``Function::const_arg_iterator`` - Typedef for const_iterator.; | ``arg_begin()``, ``arg_end()``, ``arg_size()``, ``arg_empty()``. These are forwarding methods that make it easy to access the contents of a; ``Function`` object's Argument_ list. * ``Function::ArgumentListType &getArgumentList()``. Returns the list of Argument_. This is necessary to use when you need to; update the list or perform a complex action that doesn't have a forwarding; method. * ``BasicBlock &getEntryBlock()``. Returns the entry ``BasicBlock`` for the function. Because the entry block; for the function is always the first block, this returns the first block of; the ``Function``. * | ``Type *getReturnType()``; | ``FunctionType *getFunctionType()``. This traverses the Type_ of the ``Function`` and returns the return type of; the function, or the FunctionType_ of the actual function",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:157185,access,access,157185,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"ram`` describes pointer parameter access inside of the; function and looks like:. .. code-block:: text. param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?. where the first ``param`` is the number of the parameter it describes,; ``offset`` is the inclusive range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load i8, ptr %5; %7 = getelementptr inbounds i8, ptr %2, i8 %3; tail call void @bar(i8 %3, ptr %7); %8 = load i64, ptr %0; ret i64 %8; }. We can expect the record like this:. .. code-block:: text. params: ((param: 0, offset: [0, 7]),(param: 2, offset: [5, 5], calls: ((callee: ^3, param: 1, offset: [-128, 127])))). The function may access just 8 bytes of the parameter %0 . ``calls`` is empty,; so the parameter is either not used for function calls or ``offset`` already; covers all accesses from nested function calls.; Parameter %1 escapes, so access is unknown.; The function itself can access just a single byte of the parameter %2. Additional; access is possible inside of the ``@bar`` or ``^3``. The function adds signed; offset to the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:345303,access,access,345303,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"rating atomic instructions generally need to be aware of the; target to some degree; atomic instructions are guaranteed to be lock-free, and; therefore an instruction which is wider than the target natively supports can be; impossible to generate. .. _Atomic orderings:. Atomic orderings; ================. In order to achieve a balance between performance and necessary guarantees,; there are six levels of atomicity. They are listed in order of strength; each; level includes all the guarantees of the previous level except for; Acquire/Release. (See also `LangRef Ordering <LangRef.html#ordering>`_.). .. _NotAtomic:. NotAtomic; ---------. NotAtomic is the obvious, a load or store which is not atomic. (This isn't; really a level of atomicity, but is listed here for comparison.) This is; essentially a regular load or store. If there is a race on a given memory; location, loads from that location return undef. Relevant standard; This is intended to match shared variables in C/C++, and to be used in any; other context where memory access is necessary, and a race is impossible. (The; precise definition is in `LangRef Memory Model <LangRef.html#memmodel>`_.). Notes for frontends; The rule is essentially that all memory accessed with basic loads and stores; by multiple threads should be protected by a lock or other synchronization;; otherwise, you are likely to run into undefined behavior. If your frontend is; for a ""safe"" language like Java, use Unordered to load and store any shared; variable. Note that NotAtomic volatile loads and stores are not properly; atomic; do not try to use them as a substitute. (Per the C/C++ standards,; volatile does provide some limited guarantees around asynchronous signals, but; atomics are generally a better solution.). Notes for optimizers; Introducing loads to shared variables along a codepath where they would not; otherwise exist is allowed; introducing stores to shared variables is not. See; `Optimization outside atomic`_. Notes for code gen",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:6374,access,access,6374,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['access'],['access']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ArraySubscriptExpr>hasBaseMatcher<Expr> InnerMatcher; Matches the base expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasBase(implicitCastExpr(; hasSourceExpression(declRefExpr())))); matches i[1] with the declRefExpr() matching i. Matcher<ArraySubscriptExpr>hasIndexMatcher<Expr> InnerMatcher; Matches the index expression of an array subscript expression. Given; int i[5];; void f() { i[1] = 42; }; arraySubscriptExpression(hasIndex(integerLiteral())); matches i[1] with the integerLiteral() matching 1. Matcher<ArraySubscriptExpr>hasLHSMatcher<Expr> InnerMatcher; Matches the left hand side of binary operator expressions. Example matches a (matcher = binaryOperator(hasLHS())); a || b. Matcher<ArraySubscriptExpr>hasRHSMa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:138659,Inject,InjectedClassNameType,138659,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXConstructorDecl>forEachConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches each constructor initializer in a constructor definition. Given; class A { A() : i(42), j(42) {} int i; int j; };; cxxConstructorDecl(forEachConstructorInitializer(; forField(decl().bind(""x"")); )); will trigger two matches, binding for 'i' and 'j' respectively. Matcher<CXXConstructorDecl>hasAnyConstructorInitializerMatcher<CXXCtorInitializer> InnerMatcher; Matches a constructor initializer. Given; struct Foo {; Foo() : foo_(1) { }; int foo_;; };; cxxRecordDecl(has(cxxConstructorDecl(; hasAnyConstructorInitializer(anything()); ))); record matches Foo, hasAnyConstructorInitializer matches foo_(1). Matcher<CXXCtorInitializer>forFieldMatcher<FieldDecl> InnerMatcher; Matches the field decl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:150206,Inject,InjectedClassNameType,150206,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CXXNewExpr>hasPlacementArgunsigned Index, Matcher<Expr> InnerMatcher; Matches placement new expression arguments. Given:; MyClass *p1 = new (Storage, 16) MyClass();; cxxNewExpr(hasPlacementArg(1, integerLiteral(equals(16)))); matches the expression 'new (Storage, 16) MyClass()'. Matcher<CXXNewExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitia",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:163310,Inject,InjectedClassNameType,163310,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<CaseStmt>hasCaseConstantMatcher<Expr> InnerMatcher; If the given case statement does not use the GNU case range; extension, matches the constant given in the statement. Given; switch (1) { case 1: case 1+1: case 3 ... 4: ; }; caseStmt(hasCaseConstant(integerLiteral())); matches ""case 1:"". Matcher<CastExpr>hasSourceExpressionMatcher<Expr> InnerMatcher; Matches if the cast's source expression; or opaque value's source expression matches the given matcher. Example 1: matches ""a string""; (matcher = castExpr(hasSourceExpression(cxxConstructExpr()))); class URL { URL(string); };; URL url = ""a string"";. Example 2: matches 'b' (matcher =; opaqueValueExpr(hasSourceExpression(implicitCastExpr(declRefExpr()))); int a = b ?: 1;. Matcher<ClassTemplateSpecializationDecl>forEachTemplateArgumentc",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:176505,Inject,InjectedClassNameType,176505,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<DeclRefExpr>hasTemplateArgumentLocunsigned Index, Matcher<TemplateArgumentLoc> InnerMatcher; Matches template specialization `TypeLoc`s where the n'th; `TemplateArgumentLoc` matches the given `InnerMatcher`. Given; template<typename T, typename U> class A {};; A<double, int> b;; A<int, double> c;; varDecl(hasTypeLoc(templateSpecializationTypeLoc(hasTemplateArgumentLoc(0,; hasTypeLoc(loc(asString(""double""))))))); matches `A<double, int> b`, but not `A<int, double> c`. Matcher<DeclRefExpr>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:; namespace a { int f(); }; using a::f;; int x = f();; declRefExpr(throughUsingDecl(anything())); matches f. namespace a { class X{}; }; using a::X;; X x;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:184219,Inject,InjectedClassNameType,184219,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ExplicitCastExpr>hasDestinationTypeMatcher<QualType> InnerMatcher; Matches casts whose destination type matches a given matcher. (Note: Clang's AST refers to other conversions as ""casts"" too, and calls; actual casts ""explicit"" casts.). Matcher<ExplicitCastExpr>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:191717,Inject,InjectedClassNameType,191717,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LabelStmt>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The associated declaration is:; - for type nodes, the declaration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be ach",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:210160,Inject,InjectedClassNameType,210160,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<LambdaCapture>capturesVarMatcher<ValueDecl> InnerMatcher; Matches a `LambdaCapture` that refers to the specified `VarDecl`. The; `VarDecl` can be a separate variable that is captured by value or; reference, or a synthesized variable if the capture has an initializer. Given; void foo() {; int x;; auto f = [x](){};; auto g = [x = 1](){};; }; In the matcher; lambdaExpr(hasAnyCapture(lambdaCapture(capturesVar(hasName(""x"")))),; capturesVar(hasName(""x"")) matches `x` and `x = 1`. Matcher<LambdaExpr>forEachLambdaCaptureMatcher<LambdaCapture> InnerMatcher; Matches each lambda capture in a lambda expression. Given; int main() {; int x, y;; float z;; auto f = [=]() { return x + y + z; };; }; lambdaExpr(forEachLambdaCapture(; lambdaCapture(capturesVar(varDecl(hasType(isInteger())))))); will t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:211568,Inject,InjectedClassNameType,211568,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<MemberExpr>hasObjectExpressionMatcher<Expr> InnerMatcher; Matches a member expression where the object expression is matched by a; given matcher. Implicit object expressions are included; that is, it matches; use of implicit `this`. Given; struct X {; int m;; int f(X x) { x.m; return m; }; };; memberExpr(hasObjectExpression(hasType(cxxRecordDecl(hasName(""X""))))); matches `x.m`, but not `m`; however,; memberExpr(hasObjectExpression(hasType(pointsTo(; cxxRecordDecl(hasName(""X"")))))); matches `m` (aka. `this->m`), but not `x.m`. Matcher<MemberExpr>memberMatcher<ValueDecl> InnerMatcher; Matches a member expression where the member is matched by a; given matcher. Given; struct { int first, second; } first, second;; int i(second.first);; int j(first.second);; memberExpr(member(hasName(""",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:214167,Inject,InjectedClassNameType,214167,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<QualType>ignoringParensMatcher<QualType> InnerMatcher; Matches types that match InnerMatcher after any parens are stripped. Given; void (*fp)(void);; The matcher; varDecl(hasType(pointerType(pointee(ignoringParens(functionType()))))); would match the declaration for fp. Matcher<QualType>pointsToMatcher<Decl> InnerMatcher; Overloaded to match the pointee type's declaration. Matcher<QualType>pointsToMatcher<QualType> InnerMatcher; Matches if the matched type is a pointer type and the pointee type; matches the specified matcher. Example matches y->x(); (matcher = cxxMemberCallExpr(on(hasType(pointsTo; cxxRecordDecl(hasName(""Y""))))))); class Y { public: void x(); };; void z() { Y *y; y->x(); }. Matcher<QualType>referencesMatcher<Decl> InnerMatcher; Overloaded to match the referenced t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:227551,Inject,InjectedClassNameType,227551,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<ReferenceTypeLoc>hasReferentLocMatcher<TypeLoc> ReferentMatcher; Matches reference `TypeLoc`s that have a referent `TypeLoc` matching; `ReferentMatcher`. Given; int x = 3;; int& xx = x;; referenceTypeLoc(hasReferentLoc(loc(asString(""int"")))); matches `int&`. Matcher<ReferenceType>pointeeMatcher<Type>; Narrows PointerType (and similar) matchers to those where the; pointee matches a given matcher. Given; int *a;; int const *b;; float const *f;; pointerType(pointee(isConstQualified(), isInteger())); matches ""int const *b"". Usable as: Matcher<BlockPointerType>, Matcher<MemberPointerType>,; Matcher<PointerType>, Matcher<ReferenceType>. Matcher<ReturnStmt>hasReturnValueMatcher<Expr> InnerMatcher; Matches the return value expression of a return statement. Given; return a + b;; hasReturnV",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:230434,Inject,InjectedClassNameType,230434,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateArgumentLoc>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecializationDecl>, Matcher<CompoundLiteralExpr>,; Matcher<DeclaratorDecl>, Matcher<ExplicitCastExpr>,; Matcher<ObjCPropert",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:236306,Inject,InjectedClassNameType,236306,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TemplateSpecializationType>hasTemplateArgumentunsigned N, Matcher<TemplateArgument> InnerMatcher; Matches classTemplateSpecializations, templateSpecializationType and; functionDecl where the n'th TemplateArgument matches the given InnerMatcher. Given; template<typename T, typename U> class A {};; A<bool, int> b;; A<int, bool> c;. template<typename T> void f() {}; void func() { f<int>(); };; classTemplateSpecializationDecl(hasTemplateArgument(; 1, refersToType(asString(""int"")))); matches the specialization A<bool, int>. functionDecl(hasTemplateArgument(0, refersToType(asString(""int"")))); matches the specialization f<int>. Matcher<TemplateTypeParmType>hasDeclarationMatcher<Decl> InnerMatcher; Matches a node if the declaration associated with that node; matches the given matcher. The",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:242851,Inject,InjectedClassNameType,242851,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<Type>hasUnqualifiedDesugaredTypeMatcher<Type> InnerMatcher; Matches if the matched type matches the unqualified desugared; type of the matched node. For example, in:; class A {};; using B = A;; The matcher type(hasUnqualifiedDesugaredType(recordType())) matches; both B and A. Matcher<UnaryExprOrTypeTraitExpr>hasArgumentOfTypeMatcher<QualType> InnerMatcher; Matches unary expressions that have a specific type of argument. Given; int a, c; float b; int s = sizeof(a) + sizeof(b) + alignof(c);; unaryExprOrTypeTraitExpr(hasArgumentOfType(asString(""int"")); matches sizeof(a) and alignof(c). Matcher<UnaryOperator>hasUnaryOperandMatcher<Expr> InnerMatcher; Matches if the operand of a unary operator matches. Example matches true (matcher = hasUnaryOperand(; cxxBoolLiteral(equals(true)))); !t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:247886,Inject,InjectedClassNameType,247886,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<TypeLoc>locMatcher<QualType> InnerMatcher; Matches TypeLocs for which the given inner; QualType-matcher matches. Matcher<TypedefNameDecl>hasTypeLocMatcher<TypeLoc> Inner; Matches if the type location of a node matches the inner matcher. Examples:; int x;; declaratorDecl(hasTypeLoc(loc(asString(""int"")))); matches int x. auto x = int(3);; cxxTemporaryObjectExpr(hasTypeLoc(loc(asString(""int"")))); matches int(3). struct Foo { Foo(int, int); };; auto x = Foo(1, 2);; cxxFunctionalCastExpr(hasTypeLoc(loc(asString(""struct Foo"")))); matches Foo(1, 2). Usable as: Matcher<BlockDecl>, Matcher<CXXBaseSpecifier>,; Matcher<CXXCtorInitializer>, Matcher<CXXFunctionalCastExpr>,; Matcher<CXXNewExpr>, Matcher<CXXTemporaryObjectExpr>,; Matcher<CXXUnresolvedConstructExpr>,; Matcher<ClassTemplateSpecial",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:244907,Inject,InjectedClassNameType,244907,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"ration of the underlying type; - for CallExpr, the declaration of the callee; - for MemberExpr, the declaration of the referenced member; - for CXXConstructExpr, the declaration of the constructor; - for CXXNewExpr, the declaration of the operator new; - for ObjCIvarExpr, the declaration of the ivar. For type nodes, hasDeclaration will generally match the declaration of the; sugared type. Given; class X {};; typedef X Y;; Y y;; in varDecl(hasType(hasDeclaration(decl()))) the decl will match the; typedefDecl. A common use case is to match the underlying, desugared type.; This can be achieved by using the hasUnqualifiedDesugaredType matcher:; varDecl(hasType(hasUnqualifiedDesugaredType(; recordType(hasDeclaration(decl()))))); In this matcher, the decl will match the CXXRecordDecl of class X. Usable as: Matcher<AddrLabelExpr>, Matcher<CallExpr>,; Matcher<CXXConstructExpr>, Matcher<CXXNewExpr>, Matcher<DeclRefExpr>,; Matcher<EnumType>, Matcher<InjectedClassNameType>, Matcher<LabelStmt>,; Matcher<MemberExpr>, Matcher<QualType>, Matcher<RecordType>,; Matcher<TagType>, Matcher<TemplateSpecializationType>,; Matcher<TemplateTypeParmType>, Matcher<TypedefType>,; Matcher<UnresolvedUsingType>. Matcher<UsingShadowDecl>hasTargetDeclMatcher<NamedDecl> InnerMatcher; Matches a using shadow declaration where the target declaration is; matched by the given matcher. Given; namespace X { int a; void b(); }; using X::a;; using X::b;; usingDecl(hasAnyUsingShadowDecl(hasTargetDecl(functionDecl()))); matches using X::b but not using X::a ; Matcher<UsingType>hasUnderlyingTypeMatcher<Type>; Matches DecltypeType or UsingType nodes to find the underlying type. Given; decltype(1) a = 1;; decltype(2.0) b = 2.0;; decltypeType(hasUnderlyingType(isInteger())); matches the type of ""a"". Usable as: Matcher<DecltypeType>, Matcher<UsingType>. Matcher<UsingType>throughUsingDeclMatcher<UsingShadowDecl> Inner; Matches if a node refers to a declaration through a specific; using shadow declaration. Examples:;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:250658,Inject,InjectedClassNameType,250658,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,1,['Inject'],['InjectedClassNameType']
Security,"rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; hardened, and compiling untrusted code usually also includes running utilities; such as `make` which can more readily perform malicious things. .. _CVE process: https://cve.mitre.org; .. _open a new issue: https://bugs.chromium.org/p/llvm/issues/entry; .. _chromium issue tracker: https://crbug.com; .. _GitHub security: https://help.github.com/en/articles/about-maintainer-security-advisories; .. _Discourse forums: https://discourse.llvm.org; .. _MITRE: https://cve.mitre.org; .. _example nomination is available here: https://reviews.llvm.org/D99232; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:15795,secur,security,15795,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,3,['secur'],"['security', 'security-advisories']"
Security,"rators; Not resolved. 2556; DR; Unusable promise::return_void; Unknown. 2557; drafting; Class member access referring to an unrelated class; Not resolved. 2558; C++23; Uninitialized subobjects as a result of an immediate invocation; Unknown. 2559; open; Defaulted consteval functions; Not resolved. 2560; tentatively ready; Parameter type determination in a requirement-parameter-list; Unknown. 2561; review; Conversion to function pointer for lambda with explicit object parameter; Clang 18. 2562; open; Exceptions thrown during coroutine startup; Not resolved. 2563; drafting; Initialization of coroutine result object; Not resolved. 2564; drafting; Conversion to function pointer with an explicit object parameter; Not resolved. 2565; open; Invalid types in the parameter-declaration-clause of a requires-expression; Clang 16. 2566; review; Matching deallocation for uncaught exception; Not resolved. 2567; NAD; Operator lookup ambiguity; Unknown. 2568; tentatively ready; Access checking during synthesis of defaulted comparison operator; Unknown. 2569; CD6; Use of decltype(capture) in a lambda's parameter-declaration-clause; Unknown. 2570; DR; Clarify constexpr for defaulted functions; Unknown. 2571; CD6; Evaluation order for subscripting; Unknown. 2572; review; Address of overloaded function with no target; Not resolved. 2573; DRWP; Undefined behavior when splicing results in a universal-character-name; Unknown. 2574; DRWP; Undefined behavior when lexing unmatched quotes; Unknown. 2575; open; Undefined behavior when macro-replacing ""defined"" operator; Not resolved. 2576; open; Undefined behavior with macro-expanded #include directives; Not resolved. 2577; open; Undefined behavior for preprocessing directives in macro arguments; Not resolved. 2578; open; Undefined behavior when creating an invalid string literal via stringizing; Not resolved. 2579; open; Undefined behavior when token pasting does not create a preprocessing token; Not resolved. 2580; open; Undefined behavior wit",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:176570,Access,Access,176570,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"raw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""Only"" will allow drawing only the edited; volume. The check button ""Raytrace"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. \image html geometry024.jpg width=600px; \image html geometry025.jpg ""Volume visualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. \anchor GP08f; ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""Materials"" shutter item; category. Generally, for creating objects, the interface is always in; the TGeoManagerEditor in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""Shapes"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""Medium"" category. You will notice that some categories as ""Volume""; and ""Medium"" are inactive at the beginning because at that time there; is no material yet (for making a medium) and no shape (for making a; volume). These categories are dynamically ac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:134012,validat,validation,134012,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['validat'],['validation']
Security,"ray base ``base``, array dimension ``dim`` and the last access index ``index``; into the array. The return type ``ret_type`` is a pointer type to the array element.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr element type. Semantics:; """""""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic produces the same result; as a getelementptr with base ``base`` and access operands ``{dim's 0's, index}``. '``llvm.preserve.union.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <type>; @llvm.preserve.union.access.index.p0s_union.anons.p0s_union.anons(<type> base,; i32 di_index). Overview:; """""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic carries the debuginfo field index; ``di_index`` and returns the ``base`` address.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide union debuginfo type.; The metadata is a ``DICompositeType`` representing the debuginfo version of ``type``.; The return type ``type`` is the same as the ``base`` type. Arguments:; """""""""""""""""""". The ``base`` is the union base address. The ``di_index`` is the field index in debuginfo. Semantics:; """""""""""""""""""". The '``llvm.preserve.union.access.index``' intrinsic returns the ``base",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:973836,access,access,973836,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ray}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & ... & & & \\ |; | `TMatrixDDiag const(X)` | & & ... & & \\ |; | `TMatrixDDiag(X)` | & & & ... & \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+; | | $$ \left(\begin{array}{ccccc} |; | | x_{00} & & & & x_{0n} \\ |; | | & & & & \\ |; | `TMatrixDSub const(X,i,l,j,k)` | & & x_{ij} & ... & x_{ik} \\ |; | `TMatrixDSub(X,i,l,j,k)` | & & x_{lj} & ... & x_{lk} \\ |; | | x_{n0} & & & & x_{nn} |; | | \end{array}\right)$$ |; +--------------------------------+-----------------------------------------+. ### View Operators. For the matrix views **`TMatrixDRow`**, **`TMatrixDColumn`** and; **`TMatrixDDiag`**, the necessary assignment operators are available to; interact with the vector class **`TVectorD`**. The sub matrix view; **`TMatrixDSub`** has links to the matrix classes **`TMatrixD`** and; **`TMatrixDSym`**. The next table summarizes how the access individual; matrix elements in the matrix views:. +----------------------------------------+-----------------------------------+; | Format | Comment |; +----------------------------------------+-----------------------------------+; | `TMatrixDRow(A,i)(j)` | element $A_{ij}$ |; | `TMatrixDRow(A,i)[j]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDColumn(A,j)(i)` | element $A_{ij}$ |; | `TMatrixDColumn(A,j)[i]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDDiag(A(i)` | element $A_{ij}$ |; | `TMatrixDDiag(A[i]` | |; +----------------------------------------+-----------------------------------+; | `TMatrixDSub(A(i)` | element $A_{ij}$ |; | `TMatrixDSub(A,rl,rh,cl,ch)(i,j)` | |; | | element $A_{rl+i,cl+j}$ |; +----------------------------------------+-----------------------------------+. The next two tables show the possible operations with real numbers, and; the operations between the matrix vie",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md:27124,access,access,27124,documentation/users-guide/LinearAlgebra.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/LinearAlgebra.md,1,['access'],['access']
Security,"rchive-unbundling:. Additional Options while Archive Unbundling; -------------------------------------------. **-allow-missing-bundles**; Create an empty archive file if no compatible device binary is found. **-check-input-archive**; Check if input heterogeneous device archive follows rules for composition; as defined in :ref:`code-object-composition` before creating device-specific; archive(s). **-debug-only=CodeObjectCompatibility**; Verbose printing of matched/unmatched comparisons between bundle entry id of; a device binary from HDA and bundle entry ID of a given target processor; (see :ref:`compatibility-bundle-entry-id`). Compression and Decompression; =============================. ``clang-offload-bundler`` provides features to compress and decompress the full; bundle, leveraging inherent redundancies within the bundle entries. Use the; `-compress` command-line option to enable this compression capability. The compressed offload bundle begins with a header followed by the compressed binary data:. - **Magic Number (4 bytes)**:; This is a unique identifier to distinguish compressed offload bundles. The value is the string 'CCOB' (Compressed Clang Offload Bundle). - **Version Number (16-bit unsigned int)**:; This denotes the version of the compressed offload bundle format. The current version is `1`. - **Compression Method (16-bit unsigned int)**:; This field indicates the compression method used. The value corresponds to either `zlib` or `zstd`, represented as a 16-bit unsigned integer cast from the LLVM compression enumeration. - **Uncompressed Binary Size (32-bit unsigned int)**:; This is the size (in bytes) of the binary data before it was compressed. - **Hash (64-bit unsigned int)**:; This is a 64-bit truncated MD5 hash of the uncompressed binary data. It serves for verification and caching purposes. - **Compressed Data**:; The actual compressed binary data follows the header. Its size can be inferred from the total size of the file minus the header size.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst:19888,hash,hash,19888,interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangOffloadBundler.rst,1,['hash'],['hash']
Security,"rcing bounds safety for C; ==================================================. .. contents::; :local:. Overview; ========. ``-fbounds-safety`` is a C extension to enforce bounds safety to prevent; out-of-bounds (OOB) memory accesses, which remain a major source of security; vulnerabilities in C. ``-fbounds-safety`` aims to eliminate this class of bugs; by turning OOB accesses into deterministic traps. The ``-fbounds-safety`` extension offers bounds annotations that programmers can; use to attach bounds to pointers. For example, programmers can add the; ``__counted_by(N)`` annotation to parameter ``ptr``, indicating that the pointer; has ``N`` valid elements:. .. code-block:: c. void foo(int *__counted_by(N) ptr, size_t N);. Using this bounds information, the compiler inserts bounds checks on every; pointer dereference, ensuring that the program does not access memory outside; the specified bounds. The compiler requires programmers to provide enough bounds; information so that the accesses can be checked at either run time or compile; time — and it rejects code if it cannot. The most important contribution of ``-fbounds-safety`` is how it reduces the; programmer's annotation burden by reconciling bounds annotations at ABI; boundaries with the use of implicit wide pointers (a.k.a. ""fat"" pointers) that; carry bounds information on local variables without the need for annotations. We; designed this model so that it preserves ABI compatibility with C while; minimizing adoption effort. The ``-fbounds-safety`` extension has been adopted on millions of lines of; production C code and proven to work in a consumer operating system setting. The; extension was designed to enable incremental adoption — a key requirement in; real-world settings where modifying an entire project and its dependencies all; at once is often not possible. It also addresses multiple of other practical; challenges that have made existing approaches to safer C dialects difficult to; adopt, offering these",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:1072,access,accesses,1072,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['accesses']
Security,"rd input and prints the; result:. Using the C++ API:. ```c++; #include ""llvm/Support/BLAKE3.h""; #include <errno.h>; #include <stdio.h>; #include <stdlib.h>; #include <string.h>; #include <unistd.h>. int main() {; // Initialize the hasher.; llvm::BLAKE3 hasher;. // Read input bytes from stdin.; char buf[65536];; while (1) {; ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));; if (n > 0) {; hasher.update(llvm::StringRef(buf, n));; } else if (n == 0) {; break; // end of file; } else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. Default output length is 32 bytes.; auto output = hasher.final();. // Print the hash as hexadecimal.; for (uint8_t byte : output) {; printf(""%02x"", byte);; }; printf(""\n"");; return 0;; }; ```. Using the C API:. ```c; #include ""llvm-c/blake3.h""; #include <errno.h>; #include <stdio.h>; #include <stdlib.h>; #include <string.h>; #include <unistd.h>. int main() {; // Initialize the hasher.; llvm_blake3_hasher hasher;; llvm_blake3_hasher_init(&hasher);. // Read input bytes from stdin.; unsigned char buf[65536];; while (1) {; ssize_t n = read(STDIN_FILENO, buf, sizeof(buf));; if (n > 0) {; llvm_blake3_hasher_update(&hasher, buf, n);; } else if (n == 0) {; break; // end of file; } else {; fprintf(stderr, ""read failed: %s\n"", strerror(errno));; exit(1);; }; }. // Finalize the hash. LLVM_BLAKE3_OUT_LEN is the default output length, 32 bytes.; uint8_t output[LLVM_BLAKE3_OUT_LEN];; llvm_blake3_hasher_finalize(&hasher, output, LLVM_BLAKE3_OUT_LEN);. // Print the hash as hexadecimal.; for (size_t i = 0; i < LLVM_BLAKE3_OUT_LEN; i++) {; printf(""%02x"", output[i]);; }; printf(""\n"");; return 0;; }; ```. # API. ## The Class/Struct. ```c++; class BLAKE3 {; // API; private:; llvm_blake3_hasher Hasher;; };; ```; ```c; typedef struct {; // private fields; } llvm_blake3_hasher;; ```. An incremental BLAKE3 hashing state, which can accept any number of; updates. This implementation doesn't allocate any heap memory, but; `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:1143,hash,hasher,1143,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,2,['hash'],['hasher']
Security,"rder of creation of the TStreamerInfo during the opening of a ROOT file to insure that the CollectionProxy are properly setup.; Fix problem: ""recover warning when opening an empty file; created with TXNetFile"" which was due to a bad check in TFile::Recover; (line TFile.cxx:1561) where the inheritance from TFile should be checked; instead of requiring the name to be TFile.; In TBranch::File, in the case of importing the data directly from; an external TBuffer, remove 80 char limit on reading the class name; Re-enable support for the; rootrc configuration Root.ZipMode. Data Model Evolution. First step in the implemantation of the infrastructure for the new Data Model Evolution Scheme.; This Data Model Evolution is brought to your courtesy of BNL/STAR/ATLAS/Fermi/Cern; Current Capabilities. Assign values to transient data members; Rename classes; Rename data members; Change the shape of the data structures or convert one class; structure to another; Change the meaning of data members; Ability to access the TBuffer directly when needed; Ensure that the objects in collections are handled in the same; way as the ones stored separately; Supported in object-wise, member-wise and split modes. Coming soon. Make things operational also in bare ROOT mode; Ability to transform data before writing; Support for changing the class type of nested object in a split; branch; Support for access to onfile version of nested objects from; within the parent rule. LinkDef rule syntax; Setting a transient member:; #pragma read sourceClass=""ACache"" targetClass=""ACache"" source=""""; version=""[1-]"" target=""zcalc"" \; code=""{ zcalc = false; }"". Setting a new member from 2 removed members:. #pragma read sourceClass=""ACache"" targetClass=""ACache""; source=""int x; int y; char c"" version=""[8]"" target=""z"" \; code=""{ z = onfile.x*1000 + onfile.y*10; }"". Renaming a class:. #pragma read sourceClass=""ACache"" version=""[8]""; targetClass=""Axis"" \; source=""int x; int y;"" target=""z"" \; code=""{ z = onfile.x*1000 + ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v522/index.html:1024,access,access,1024,io/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v522/index.html,2,['access'],['access']
Security,"rds; published in AAPCS64 and the RISC-V psABI. Special unwind information is required on functions that are compiled; with ShadowCallStack and that may be unwound, i.e. functions compiled with; ``-fexceptions`` (which is the default in C++). Some unwinders (such as the; libgcc 4.9 unwinder) do not understand this unwind info and will segfault; when encountering it. LLVM libunwind processes this unwind info correctly,; however. This means that if exceptions are used together with ShadowCallStack,; the program must use a compatible unwinder. Security; ========. ShadowCallStack is intended to be a stronger alternative to; ``-fstack-protector``. It protects from non-linear overflows and arbitrary; memory writes to the return address slot. The instrumentation makes use of the ``SCSReg`` register to reference the shadow; call stack, meaning that references to the shadow call stack do not have; to be stored in memory. This makes it possible to implement a runtime that; avoids exposing the address of the shadow call stack to attackers that can; read arbitrary memory. However, attackers could still try to exploit side; channels exposed by the operating system `[1]`_ `[2]`_ or processor `[3]`_; to discover the address of the shadow call stack. .. _`[1]`: https://eyalitkin.wordpress.com/2017/09/01/cartography-lighting-up-the-shadows/; .. _`[2]`: https://www.blackhat.com/docs/eu-16/materials/eu-16-Goktas-Bypassing-Clangs-SafeStack.pdf; .. _`[3]`: https://www.vusec.net/projects/anc/. Unless care is taken when allocating the shadow call stack, it may be; possible for an attacker to guess its address using the addresses of; other allocations. Therefore, the address should be chosen to make this; difficult. One way to do this is to allocate a large guard region without; read/write permissions, randomly select a small region within it to be; used as the address of the shadow call stack and mark only that region as; read/write. This also mitigates somewhat against processor side chan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst:5170,attack,attackers,5170,interpreter/llvm-project/clang/docs/ShadowCallStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ShadowCallStack.rst,1,['attack'],['attackers']
Security,"re chosen to be sampled. These stubs are generally implemented in the; implementation of ``malloc()``, ``free()`` and ``realloc()``. The stubs are; extremely small, which makes using GWP-ASan in most allocators fairly trivial.; The stubs follow the same general pattern (example ``malloc()`` pseudocode; below):. .. code:: cpp. #ifdef INSTALL_GWP_ASAN_STUBS; gwp_asan::GuardedPoolAllocator GWPASanAllocator;; #endif. void* YourAllocator::malloc(..) {; #ifdef INSTALL_GWP_ASAN_STUBS; if (GWPASanAllocator.shouldSample(..)); return GWPASanAllocator.allocate(..);; #endif. // ... the rest of your allocator code here.; }. Then, all the supporting allocator needs to do is compile with; ``-DINSTALL_GWP_ASAN_STUBS`` and link against the GWP-ASan library! For; performance reasons, we strongly recommend static linkage of the GWP-ASan; library. Guarded Allocation Pool; -----------------------. The core of GWP-ASan is the guarded allocation pool. Each sampled allocation is; backed using its own *guarded* slot, which may consist of one or more accessible; pages. Each guarded slot is surrounded by two *guard* pages, which are mapped as; inaccessible. The collection of all guarded slots makes up the *guarded; allocation pool*. Buffer Underflow/Overflow Detection; -----------------------------------. We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:3338,access,accessible,3338,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['access'],['accessible']
Security,"re details are available at [#7143](https://github.com/root-project/root/issues/7143).; - The start-up time of event loops with large computation graphs with many just-in-time-compiled expressions (e.g. thousands of string `Filter`s and `Define`s) has been greatly reduced. See [the corresponding pull request](https://github.com/root-project/root/pull/7651) for more details. The full list of bug fixes for this release is available below. ### Distributed computing with RDataFrame; ROOT 6.24 introduces `ROOT.RDF.Experimental.Distributed`, an experimental python package that enhances RDataFrame with distributed computing capabilities. The new package allows distributing RDataFrame applications through one of the supported distributed backends. The package was designed so that different backends can be easily plugged in. Currently the [Apache Spark](http://spark.apache.org/) backend is supported and support for [Dask](https://dask.org/) is coming soon. The backend submodules of this package expose their own `RDataFrame` objects. The only needed change in user code is to substitute `ROOT.RDataFrame` calls with such backend-specific `RDataFrame`s. For example:. ```python; import ROOT. # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame. # It still accepts the same constructor arguments as traditional RDataFrame; df = RDataFrame(""mytree"",""myfile.root""). # Continue the application with the traditional RDataFrame API; ```. The main goal of this package is to support running any RDataFrame application distributedly. Nonetheless, not all RDataFrame operations currently work with this package. The subset that is currently available is:. - AsNumpy; - Count; - Define; - Fill; - Filter; - Graph; - Histo[1,2,3]D; - Max; - Mean; - Min; - Profile[1,2,3]D; - Snapshot; - Sum. with support for more operations coming in the future. Any distributed RDataFrame backend inherits the dependencies of the underlying software ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:10584,expose,expose,10584,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['expose'],['expose']
Security,"re division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal`` which generates compact branches; when a delay slot cannot be filled. ``never`` disables the usage of; compact branches and ``always`` generates compact branches whenever; possible. .. option:: -f[no-]max-type-align=[number]. Instruct the code generator to not enforce a higher alignment than the given; number (of bytes) when accessing memory via an opaque pointer or reference.; This cap is ignored when directly accessing a variable or when the pointee; type has an explicit “aligned” attribute. The value should usually be determined by the properties of the system allocator.; Some builtin types, especially vector types, have very high natural alignments;; when working with values of those types, Clang usually wants to use instructions; that take advantage of that alignment. However, many system allocators do; not promise to return memory that is more than 8-byte or 16-byte-aligned. Use; this option to limit the alignment that the compiler can assume for an arbitrary; pointer, which may point onto the heap. This option does not affect the ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typede",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:85297,access,accessing,85297,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['access'],['accessing']
Security,"re functionality should be imported from `main.mjs` module like:. ```javascript; import { create, parse, createHistogram, redraw } from 'https://root.cern/js/7.0.0/modules/main.mjs';; ```. * It is still possible to use `JSRoot.core.js` script, which provides very similar (but not identical!) functionality as with `v6` via global `JSROOT` object. * `JSROOT.define()` and `JSROOT.require()` functions only available after `JSRoot.core.js` loading. * Support of `require.js` and `openui5` loaders was removed. * Global hierarchy painter `JSROOT.hpainter` no longer existing, one can use `getHPainter` function:. ```javascript; import { getHPainter } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let hpainter = getHPainter();; ```. * All math functions previously available via `JSROOT.Math` should be imported from `base/math.mjs` module:. ```javascript; import * as math from 'https://root.cern/js/7.0.0/modules/base/math.mjs';; ```. * Indication of batch mode `JSROOT.batch_mode` should be accessed via functions:. ```javascript; import { isBatchMode, setBatchMode } from 'https://root.cern/js/7.0.0/modules/main.mjs';; let was_batch = isBatchMode();; if (!was_batch) setBatchMode(true);; ```. * `JSROOT.extend()` function was removed, use `Object.assign()` instead. ### Migration v5 -> v6. * Main script was renamed to `JSRoot.core.js`. Old `JSRootCore.js` was deprecated and removed in v6.2. All URL parameters for main script ignored now, to load JSROOT functionality one should use `JSROOT.require` function. To create standard GUI, `JSROOT.buildGUI` function has to be used. * Instead of `JSROOT.JSONR_unref()` one can use `JSROOT.parse()`. If object is provided to `JSROOT.parse()` it just replaces all references which were introduced by `TBufferJSON::ToJSON()` method. * Instead of `JSROOT.console()` one should use `console.log()`. Instead of `JSROOT.alert()` one should use `console.error()`. * Many settings were moved from `JSROOT.gStyle` to `JSROOT.settings` object. It was done",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:48296,access,accessed,48296,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['access'],['accessed']
Security,"re program has been run through the passes. This improves the cache behavior of the compiler, because it is only; touching the LLVM program representation for a single function at a time,; instead of traversing the entire program. It reduces the memory consumption; of compiler, because, for example, only one `DominatorSet; <https://llvm.org/doxygen/classllvm_1_1DominatorSet.html>`_ needs to be; calculated at a time. The effectiveness of the ``PassManager`` is influenced directly by how much; information it has about the behaviors of the passes it is scheduling. For; example, the ""preserved"" set is intentionally conservative in the face of an; unimplemented :ref:`getAnalysisUsage <writing-an-llvm-pass-getAnalysisUsage>`; method. Not implementing when it should be implemented will have the effect of; not allowing any analysis results to live across the execution of your pass. The ``PassManager`` class exposes a ``--debug-pass`` command line options that; is useful for debugging pass execution, seeing how things work, and diagnosing; when you should be preserving more analyses than you currently are. (To get; information about all of the variants of the ``--debug-pass`` option, just type; ""``opt -help-hidden``""). By using the --debug-pass=Structure option, for example, we can see how our; :ref:`Hello World <writing-an-llvm-pass-basiccode>` pass interacts with other; passes. Lets try it out with the gvn and licm passes:. .. code-block:: console. $ opt -load lib/LLVMHello.so -gvn -licm --debug-pass=Structure < hello.bc > /dev/null; ModulePass Manager; FunctionPass Manager; Dominator Tree Construction; Basic Alias Analysis (stateless AA impl); Function Alias Analysis Results; Memory Dependence Analysis; Global Value Numbering; Natural Loop Information; Canonicalize natural loops; Loop-Closed SSA Form Pass; Basic Alias Analysis (stateless AA impl); Function Alias Analysis Results; Scalar Evolution Analysis; Loop Pass Manager; Loop Invariant Code Motion; Module Verifier; Bi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:43164,expose,exposes,43164,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['expose'],['exposes']
Security,"re than one single location; description can read the object's value from any of the single location; descriptions (since they all refer to location storage that has the same value),; but must write any changed value to all the single location descriptions.*. The evaluation of an expression may require context elements to create a; location description. If such a location description is accessed, the storage it; denotes is that associated with the context element values specified when the; location description was created, which may differ from the context at the time; it is accessed. *For example, creating a register location description requires the thread; context: the location storage is for the specified register of that thread.; Creating a memory location description for an address space may required a; thread and a lane context: the location storage is the memory associated with; that thread and lane.*. If any of the context elements required to create a location description change,; the location description becomes invalid and accessing it is undefined. *Examples of context that can invalidate a location description are:*. * *The thread context is required and execution causes the thread to terminate.*; * *The call frame context is required and further execution causes the call; frame to return to the calling frame.*; * *The program location is required and further execution of the thread occurs.; That could change the location list entry or call frame information entry that; applies.*; * *An operation uses call frame information:*. * *Any of the frames used in the virtual call frame unwinding return.*; * *The top call frame is used, the program location is used to select the call; frame information entry, and further execution of the thread occurs.*. *A DWARF expression can be used to compute a location description for an object.; A subsequent DWARF expression evaluation can be given the object location; description as the object context or initial stack co",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:62291,access,accessing,62291,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessing']
Security,"reachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77956,sanitiz,sanitizer,77956,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,2,['sanitiz'],['sanitizer']
Security,"ream-blocks. In conjunction with :option:`-streams`, add information to the output about; what blocks the specified stream occupies. .. option:: -summary. Dump MSF and PDB header information. Module & File Options; +++++++++++++++++++++. .. option:: -modi=<uint>. For all options that dump information from each module/compiland, limit to; the specified module. .. option:: -files. Dump the source files that contribute to each displayed module. .. option:: -il. Dump inlinee line information (DEBUG_S_INLINEELINES CodeView subsection). .. option:: -l. Dump line information (DEBUG_S_LINES CodeView subsection). .. option:: -modules. Dump compiland information. .. option:: -xme. Dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS CodeView subsection). .. option:: -xmi. Dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS CodeView subsection). Symbol Options; ++++++++++++++. .. option:: -globals. dump global symbol records. .. option:: -global-extras. dump additional information about the globals, such as hash buckets and hash; values. .. option:: -publics. dump public symbol records. .. option:: -public-extras. dump additional information about the publics, such as hash buckets and hash; values. .. option:: -symbols. dump symbols (functions, variables, etc) for each module dumped. .. option:: -sym-data. For each symbol record dumped as a result of the :option:`-symbols` option,; display the full bytes of the record in binary as well. Type Record Options; +++++++++++++++++++. .. option:: -types. Dump CodeView type records from TPI stream. .. option:: -type-extras. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI st",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:8716,hash,hash,8716,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,2,['hash'],['hash']
Security,"ream; ModiStream; PublicStream; GlobalStream; HashTable; CodeViewSymbols; CodeViewTypes. .. _msf:. The MSF Container; -----------------; A PDB file is an MSF (Multi-Stream Format) file. An MSF file is a ""file system; within a file"". It contains multiple streams (aka files) which can represent; arbitrary data, and these streams are divided into blocks which may not; necessarily be contiguously laid out within the MSF container file.; Additionally, the MSF contains a stream directory (aka MFT) which describes how; the streams (files) are laid out within the MSF. For more information about the MSF container format, stream directory, and; block layout, see :doc:`MsfFile`. .. _streams:. Streams; -------; The PDB format contains a number of streams which describe various information; such as the types, symbols, source files, and compilands (e.g. object files); of a program, as well as some additional streams containing hash tables that are; used by debuggers and other tools to provide fast lookup of records and types; by name, and various other information about how the program was compiled such; as the specific toolchain used, and more. A summary of streams contained in a; PDB file is as follows:. +--------------------+------------------------------+-------------------------------------------+; | Name | Stream Index | Contents |; +====================+==============================+===========================================+; | Old Directory | - Fixed Stream Index 0 | - Previous MSF Stream Directory |; +--------------------+------------------------------+-------------------------------------------+; | PDB Stream | - Fixed Stream Index 1 | - Basic File Information |; | | | - Fields to match EXE to this PDB |; | | | - Map of named streams to stream indices |; +--------------------+------------------------------+-------------------------------------------+; | TPI Stream | - Fixed Stream Index 2 | - CodeView Type Records |; | | | - Index of TPI Hash Stream |; +-------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/index.rst:2700,hash,hash,2700,interpreter/llvm-project/llvm/docs/PDB/index.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/index.rst,1,['hash'],['hash']
Security,"reating a fat binary. This section is emitted during compilation; of offloading languages such as OpenMP or CUDA. If the data is intended to be; used by the device linker only, it should use the ``SHF_EXCLUDE`` flag so it is; automatically stripped from the final executable or shared library. The binary data stored in this section conforms to a custom binary format used; for storing offloading metadata. This format is effectively a string table; containing metadata accompanied by a device image. ``SHT_LLVM_LTO`` Section (LLVM bitcode for fat LTO); ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; This section stores LLVM bitcode used to perform regular LTO or ThinLTO at link; time. This section is generated when the compiler enables fat LTO. This section; has the ``SHF_EXCLUDE`` flag so that it is stripped from the final executable; or shared library. CodeView-Dependent; ------------------. ``.cv_file`` Directive; ^^^^^^^^^^^^^^^^^^^^^^; Syntax:; ``.cv_file`` *FileNumber FileName* [ *checksum* ] [ *checksumkind* ]. ``.cv_func_id`` Directive; ^^^^^^^^^^^^^^^^^^^^^^^^^; Introduces a function ID that can be used with ``.cv_loc``. Syntax:; ``.cv_func_id`` *FunctionId*. ``.cv_inline_site_id`` Directive; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Introduces a function ID that can be used with ``.cv_loc``. Includes; ``inlined at`` source location information for use in the line table of the; caller, whether the caller is a real function or another inlined call site. Syntax:; ``.cv_inline_site_id`` *FunctionId* ``within`` *Function* ``inlined_at`` *FileNumber Line* [ *Column* ]. ``.cv_loc`` Directive; ^^^^^^^^^^^^^^^^^^^^^; The first number is a file number, must have been previously assigned with a; ``.file`` directive, the second number is the line number and optionally the; third number is a column position (zero if not specified). The remaining; optional items are ``.loc`` sub-directives. Syntax:; ``.cv_loc`` *FunctionId FileNumber* [ *Line* ] [ *Column* ] [ *prologue_end* ] ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst:18952,checksum,checksum,18952,interpreter/llvm-project/llvm/docs/Extensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Extensions.rst,2,['checksum'],"['checksum', 'checksumkind']"
Security,"ref); ...; DW_AT_artificial (true). A Fortran front-end may need to generate a *trampoline* function to call a; function defined in a different compilation unit. In this case, the front-end; can emit the following descriptor for the trampoline function:. .. code-block:: text. !DISubprogram(name: ""sub1_.t0p"", linkageName: ""sub1_.t0p"", scope: !4, file: !4, type: !5, spFlags: DISPFlagLocalToUnit | DISPFlagDefinition, unit: !7, retainedNodes: !24, targetFuncName: ""sub1_""). The targetFuncName field is the name of the function that the trampoline; calls. This descriptor results in the following DWARF tag:. .. code-block:: text. DW_TAG_subprogram; ...; DW_AT_linkage_name	(""sub1_.t0p""); DW_AT_name	(""sub1_.t0p""); DW_AT_trampoline	(""sub1_""). Debugging information format; ============================. Debugging Information Extension for Objective C Properties; ----------------------------------------------------------. Introduction; ^^^^^^^^^^^^. Objective C provides a simpler way to declare and define accessor methods using; declared properties. The language provides features to declare a property and; to let compiler synthesize accessor methods. The debugger lets developer inspect Objective C interfaces and their instance; variables and class variables. However, the debugger does not know anything; about the properties defined in Objective C interfaces. The debugger consumes; information generated by compiler in DWARF format. The format does not support; encoding of Objective C properties. This proposal describes DWARF extensions to; encode Objective C properties, which the debugger can use to let developers; inspect Objective C properties. Proposal; ^^^^^^^^. Objective C properties exist separately from class members. A property can be; defined only by ""setter"" and ""getter"" selectors, and be calculated anew on each; access. Or a property can just be a direct access to some declared ivar.; Finally it can have an ivar ""automatically synthesized"" for it by the compiler,; in wh",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:49310,access,accessor,49310,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['access'],['accessor']
Security,"ref:`amdgpu-processor-table`; specifies *Architected flat scratch*:. If ENABLE_PRIVATE_SEGMENT is enabled in; :ref:`amdgpu-amdhsa-compute_pgm_rsrc2-gfx6-gfx12-table` then the FLAT_SCRATCH; register pair will be initialized to the 64-bit address of the base of scratch; backing memory being managed by SPI for the queue executing the kernel; dispatch plus the value of the wave's Scratch Wavefront Offset for use as the; flat scratch base in flat memory instructions. .. _amdgpu-amdhsa-kernel-prolog-private-segment-buffer:. Private Segment Buffer; ++++++++++++++++++++++. If the *Target Properties* column of :ref:`amdgpu-processor-table` specifies; *Architected flat scratch* then a Private Segment Buffer is not supported.; Instead the flat SCRATCH instructions are used. Otherwise, Private Segment Buffer SGPR register is used to initialize 4 SGPRs; that are used as a V# to access scratch. CP uses the value provided by the; runtime. It is used, together with Scratch Wavefront Offset as an offset, to; access the private memory space using a segment address. See; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`. The scratch V# is a four-aligned SGPR and always selected for the kernel as; follows:. - If it is known during instruction selection that there is stack usage,; SGPR0-3 is reserved for use as the scratch V#. Stack usage is assumed if; optimizations are disabled (``-O0``), if stack objects already exist (for; locals, etc.), or if there are any function calls. - Otherwise, four high numbered SGPRs beginning at a four-aligned SGPR index; are reserved for the tentative scratch V#. These will be used if it is; determined that spilling is needed. - If no use is made of the tentative scratch V#, then it is unreserved,; and the register count is determined ignoring it.; - If use is made of the tentative scratch V#, then its register numbers; are shifted to the first four-aligned SGPR index after the highest one; allocated by the register allocator, and all uses are updated.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:198556,access,access,198556,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"registers.; Each register may be specified using the syntax; defined :ref:`above<amdgpu_synid_v>`. In contrast with the standard syntax, registers; in *NSA* sequence are not required to have; consecutive indices. Moreover, the same register; may appear in the sequence more than once. GFX11+ has an additional limitation: if address; size occupies more than 5 dwords, registers; starting from the 5th element must be contiguous.; ===================================== =================================================. Examples:. .. parsed-literal::. [v32,v1,v[2]]; [v[32],v[1:1],[v2]]; [v4,v4,v4,v4]. .. _amdgpu_synid_v16:. v (16-bit); ----------. 16-bit vector registers. Each :ref:`32-bit vector register<amdgpu_synid_v>` is divided into two 16-bit low and high registers, so there are 512 16-bit vector registers. Only VOP3, VOP3P and VINTERP instructions may access all 512 registers (using :ref:`op_sel<amdgpu_synid_op_sel>` modifier).; VOP1, VOP2 and VOPC instructions may currently access only 128 low 16-bit registers using the syntax described below. .. WARNING:: This section is incomplete. The support of 16-bit registers in the assembler is still WIP. \; =================================================== ====================================================================; Syntax Description; =================================================== ====================================================================; **v**\<N> A single 16-bit *vector* register (low half).; =================================================== ====================================================================. Note: *N* must satisfy the following conditions:. * 0 <= *N* <= 127. Examples:. .. parsed-literal::. v127. .. _amdgpu_synid_a:. a; -. Accumulator registers. There are 256 32-bit accumulator registers. A sequence of *accumulator* registers may be used to operate with more than 32 bits of data. Assembler currently supports tuples with 1 to 12, 16 and 32 *accumulator* registers. ===========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:3980,access,access,3980,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['access'],['access']
Security,"relist>` types or types with public :doc:`LTO; visibility <LTOVisibility>`, must be compiled with ``-flto`` or ``-flto=thin``; enabled and be statically linked into the program. Performance; -----------. A performance overhead of less than 1% has been measured by running the; Dromaeo benchmark suite against an instrumented version of the Chromium; web browser. Another good performance benchmark for this mechanism is the; virtual-call-heavy SPEC 2006 xalancbmk. Note that this scheme has not yet been optimized for binary size; an increase; of up to 15% has been observed for Chromium. Bad Cast Checking; =================. This scheme checks that pointer casts are made to an object of the correct; dynamic type; that is, the dynamic type of the object must be a derived class; of the pointee type of the cast. The checks are currently only introduced; where the class being casted to is a polymorphic class. Bad casts are not in themselves control flow integrity violations, but they; can also create security vulnerabilities, and the implementation uses many; of the same mechanisms. There are two types of bad cast that may be forbidden: bad casts; from a base class to a derived class (which can be checked with; ``-fsanitize=cfi-derived-cast``), and bad casts from a pointer of; type ``void*`` or another unrelated type (which can be checked with; ``-fsanitize=cfi-unrelated-cast``). The difference between these two types of casts is that the first is defined; by the C++ standard to produce an undefined value, while the second is not; in itself undefined behavior (it is well defined to cast the pointer back; to its original type) unless the object is uninitialized and the cast is a; ``static_cast`` (see C++14 [basic.life]p5). If a program as a matter of policy forbids the second type of cast, that; restriction can normally be enforced. However it may in some cases be necessary; for a function to perform a forbidden cast to conform with an external API; (e.g. the ``allocate`` membe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst:5550,integrity,integrity,5550,interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ControlFlowIntegrity.rst,2,"['integrity', 'secur']","['integrity', 'security']"
Security,"remaining bytes in TStreamerInfo object (uncompressed); | OR'd with kByteCountMask (0x40000000); 4->5 Version = Version of TStreamerInfo Class; -Begin TNamed object (Base class of TStreamerInfo); 6->9 ByteCount = Number of remaining bytes in TNamed object; | OR'd with kByteCountMask (0x40000000); 10->11 Version = Version of TNamed Class; 12->21 = TObject object (Base class of TNamed) (see \ref tobject).; | Objects in StreamerInfo record are not referenced.; | Would be two bytes longer (12->23) if object were referenced.; 22->.. fName = Number of bytes in name of class that this TStreamerInfo object; | describes, followed by the class name itself. (TNamed::fName).; 0->.. fTitle = Number of bytes in title of class that this TStreamerInfo object; | describes, followed by the class title itself. (TNamed::fTitle).; | (Class title may be zero length); -End TNamed object; 0->3 fCheckSum = Check sum for class that this TStreamerInfo object describes.; | This checksum is over all base classes and all persistent; | non-static data members. It is computed by TClass::GetCheckSum().; | (TStreamerInfo::fCheckSum); 4->7 fClassVersion = Version of class that this TStreamerInfo object describes.; | (TStreamerInfo::fClassVersion); -Begin TObjArray object (Data member of TStreamerInfo); 0->3 ByteCount = Number of remaining bytes in TObjArray object (uncompressed); | OR'd with kByteCountMask (0x40000000); 4->.. ClassInfo = Information about TObjArray class; | If this is the first occurrence of a TObjArray object in the record; | 4->7 -1 = New class tag (constant kNewClassTag = 0xffffffff); | 8->17 Classname = Object Class Name ""TObjArray"" (null terminated); | Otherwise; | 4->7 clIdx = Byte offset of new class tag in record, plus 2.; | OR'd with kClassMask (0x80000000); 0->3 ByteCount = Number of remaining bytes in TObjArray object (uncompressed); | OR'd with kByteCountMask (0x40000000); 4->5 Version = Version of TObjArray Class; 6->15 = TObject object (a base class of TObjArray) (see \r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/streamerinfo.md:4673,checksum,checksum,4673,io/doc/TFile/streamerinfo.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/TFile/streamerinfo.md,1,['checksum'],['checksum']
Security,"required and # entries does not correspond to an complete subset of; files (e.g. # entries = 1001000 with files of 100000 entries each). The; effect was uncomplete processing (skipped events, magenta bar) or a; session freeze.; Fix problem with packet re-assignment in case of a worker death (some packets were processed twice or more times).; Fix problem with the transmission of non-default file; attributes (e.g. the number of entries) from TChainElement to; TDSetElement during TChain processing in PROOF; Fix problem in the default packetizer with validating the; exact number of needed files when the information about the entries is; already available.; Fix problem with 'xpd.putenv' and 'xpd.putrc' occuring when the variables themselves contain commas.; Avoid resolving the workers FQDN when running in PROOF-Lite,; creating unnecessary delays when running PROOF-Lite within virtual; machines.; Fix problem with the permissions of the user data directory.; Add files to the list of files to process only when finally validated.; Fix; problem with canvases when the feedback canvas and the final canvas are; the same (do not delete the feedback canvas at the end of processing); Make sure that TProof::Load, TProofPlayer::SendSelector and; TSelector::GetSelector treat consistently the extensions of the; implementation files.; Unlock the cache after failure to load a selector; prevents session freezing; Correctly update the number of submergers when workers die; Add missing protection causing a crash in submergers when the output list contained TProofOutputFile objects.; Move the creation and start of the idle timeout from the end; of SetupCommon to the end of CreateServer, so that the timeout is not; active during worker setup.; Make sure that the TProof instance on the client is invalidated after an idle timeout.; Fix an old issue with DeactivateWorker(""*"") (the session is; was terminated because no worker was active; this call coudl not be; used as intermediate step to select",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:12170,validat,validated,12170,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['validat'],['validated']
Security,"respectively. The index expressions shall have integral or unscoped; enumeration type and shall not be uses of the comma operator unless; parenthesized. The first index expression shall evaluate to a; non-negative value less than ``R``, and the second index expression shall; evaluate to a non-negative value less than ``C``, or else the expression has; undefined behavior. If ``E1`` is a prvalue, the result is a prvalue with type; ``T`` and is the value of the element at the given row and column in the matrix.; Otherwise, the result is a glvalue with type ``cv T`` and with the same value; category as ``E1`` which refers to the element at the given row and column in; the matrix. Programs containing a single subscript expression into a matrix are ill-formed. **Note**: We considered providing an expression of the form; ``postfix-expression [expression]`` to access columns of a matrix. We think; that such an expression would be problematic once both column and row major; matrixes are supported: depending on the memory layout, either accessing columns; or rows can be done efficiently, but not both. Instead, we propose to provide; builtins to extract rows and columns from a matrix. This makes the operations; more explicit. Matrix Type Binary Operators; ----------------------------. Given two matrixes, the ``+`` and ``-`` operators perform element-wise addition; and subtraction, while the ``*`` operator performs matrix multiplication.; ``+``, ``-``, ``*``, and ``/`` can also be used with a matrix and a scalar; value, applying the operation to each element of the matrix. Earlier versions of this extension did not support division by a scalar.; You can test for the availability of this feature with; ``__has_extension(matrix_types_scalar_division)``. For the expression ``M1 BIN_OP M2`` where. * ``BIN_OP`` is one of ``+`` or ``-``, one of ``M1`` and ``M2`` is of matrix; type, and the other is of matrix type or real type; or; * ``BIN_OP`` is ``*``, one of ``M1`` and ``M2`` is of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst:4782,access,accessing,4782,interpreter/llvm-project/clang/docs/MatrixTypes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/MatrixTypes.rst,1,['access'],['accessing']
Security,"resses. For example, consider this:. .. code-block:: text. @MyVar = external global { i32, ptr }; ...; %idx = getelementptr { i32, ptr }, ptr @MyVar, i64 0, i32 1; %arr = load ptr, ptr %idx; %idx = getelementptr [40 x i32], ptr %arr, i64 0, i64 17. In this example, we have a global variable, ``@MyVar``, which is a pointer to; a structure containing a pointer. Let's assume that this inner pointer points; to an array of type ``[40 x i32]``. The above IR will first compute the address; of the inner pointer, then load the pointer, and then compute the address of; the 18th array element. This cannot be expressed in a single GEP instruction, because it requires; a memory dereference in between. However, the following example would work; fine:. .. code-block:: text. @MyVar = external global { i32, [40 x i32 ] }; ...; %idx = getelementptr { i32, [40 x i32] }, ptr @MyVar, i64 0, i32 1, i64 17. In this case, the structure does not contain a pointer and the GEP instruction; can index through the global variable, into the second field of the structure; and access the 18th ``i32`` in the array there. Why don't GEP x,0,0,1 and GEP x,1 alias?; ----------------------------------------. Quick Answer: They compute different address locations. If you look at the first indices in these GEP instructions you find that they; are different (0 and 1), therefore the address computation diverges with that; index. Consider this example:. .. code-block:: llvm. @MyVar = external global { [10 x i32] }; %idx1 = getelementptr { [10 x i32] }, ptr @MyVar, i64 0, i32 0, i64 1; %idx2 = getelementptr { [10 x i32] }, ptr @MyVar, i64 1. In this example, ``idx1`` computes the address of the second integer in the; array that is in the structure in ``@MyVar``, that is ``MyVar+4``. However,; ``idx2`` computes the address of *the next* structure after ``@MyVar``, that is; ``MyVar+40``, because it indexes past the ten 4-byte integers in ``MyVar``.; Obviously, in such a situation, the pointers don't alias. Why do",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:7593,access,access,7593,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['access']
Security,"resses.; * Each CU has a separate request queue per channel for its associated L2.; Therefore, the vector and scalar memory operations performed by wavefronts; executing with different L1 caches and the same L2 cache can be reordered; relative to each other.; * A ``s_waitcnt vmcnt(0)`` is required to ensure synchronization between; vector memory operations of different CUs. It ensures a previous vector; memory operation has completed before executing a subsequent vector memory; or LDS operation and so can be used to meet the requirements of acquire and; release.; * An L2 cache can be kept coherent with other L2 caches by using the MTYPE RW; (read-write) for memory local to the L2, and MTYPE NC (non-coherent) with; the PTE C-bit set for memory not local to the L2. * Any local memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by the PTE C-bit.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter.; * To ensure coherence of local memory writes of CUs with different L1 caches; in the same agent a ``buffer_wbl2`` is required. It does nothing if the; agent is configured to have a single L2, or will writeback dirty L2 cache; lines if configured to have multiple L2 caches.; * To ensure coherence of local memory writes of CUs in different agents a; ``buffer_wbl2 sc1`` is required. It will writeback dirty L2 cache lines.; * To ensure coherence of local memory reads of CUs with different L1 caches; in the same agent a ``buffer_inv sc1`` is required. It does nothing if the; agent is configured to have a single L2, or will invalidate non-local L2; cache lines if configured to have multiple L2 caches.; * To ensure coherence of local memory reads of CUs in different agents a; ``buffer_inv sc0 sc1`` is required. It will invalidate non-local",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:288590,access,accesses,288590,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"ressing):. ::. SegmentReg: Base + [1,2,4,8] * IndexReg + Disp32. In order to represent this, LLVM tracks no less than 5 operands for each memory; operand of this form. This means that the ""load"" form of '``mov``' has the; following ``MachineOperand``\s in this order:. ::. Index: 0 | 1 2 3 4 5; Meaning: DestReg, | BaseReg, Scale, IndexReg, Displacement Segment; OperandTy: VirtReg, | VirtReg, UnsImm, VirtReg, SignExtImm PhysReg. Stores, and all other instructions, treat the four memory operands in the same; way and in the same order. If the segment register is unspecified (regno = 0),; then no segment override is generated. ""Lea"" operations do not have a segment; register specified, so they only have 4 operands for their memory reference. X86 address spaces supported; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. x86 has a feature which provides the ability to perform loads and stores to; different address spaces via the x86 segment registers. A segment override; prefix byte on an instruction causes the instruction's memory access to go to; the specified segment. LLVM address space 0 is the default address space, which; includes the stack, and any unqualified memory accesses in a program. Address; spaces 1-255 are currently reserved for user-defined code. The GS-segment is; represented by address space 256, the FS-segment is represented by address space; 257, and the SS-segment is represented by address space 258. Other x86 segments; have yet to be allocated address space numbers. While these address spaces may seem similar to TLS via the ``thread_local``; keyword, and often use the same underlying hardware, there are some fundamental; differences. The ``thread_local`` keyword applies to global variables and specifies that they; are to be allocated in thread-local memory. There are no type qualifiers; involved, and these variables can be pointed to with normal pointers and; accessed with normal loads and stores. The ``thread_local`` keyword is; target-independent at the LLVM IR level",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:91944,access,access,91944,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['access']
Security,"ression and possibly more memory. The ZLIB algorithm takes less; CPU time during compression than the LZMA algorithm, but the LZMA; algorithm usually delivers higher compression factors. The header file core/zip/inc/Compression.h declares the function; ""CompressionSettings"" and the enumeration for the algorithms.; Currently the following selections can be made for the algorithm:; kZLIB (1), kLZMA (2), kOldCompressionAlgo (3), and kUseGlobalSetting; (0). The last option refers to an older interface used to control the; algorithm that is maintained for backward compatibility. The following; function is defined in core/zip/inc/Bits.h and it set the global; variable. R__SetZipMode(int algorithm);. If the algorithm is set to kUseGlobalSetting (0), the global variable; controls the algorithm for compression operations. This is the; default and the default value for the global variable is kZLIB. gDirectory; gDirectory is now a thread local!. The value of gDirectory and gFile are now all accessed via a static function of their respective class. The access is made transparent via a CPP macro. Note: Whenever a thread has an associated TThread object, the value of gDirectory is now thread local, i.e. all modifications direct or indirect of gDirectory will not be seen by the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support sharing TFile amongst threads (i.e. a TFile must be accessed from exactly one thread). This means that whenever a TFile's control is passed from a thread to another, the code must explicitly reset gDirectory to another value or there is a risk for this gDirectory to point to a stale pointer if the other thread deletes the TFile object. A TFile deletion will only affect the value of the local gDirectory and gFile. TMemFile; Introduce TMemFile and update TFileMerger to support increm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:3005,access,accessed,3005,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,2,['access'],['accessed']
Security,"rger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the fla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:6079,hash,hashing,6079,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['hash'],['hashing']
Security,"rho,z,phi`; coordinates (cylindrical) in double precision. - `ROOT::Math::`**`RhoZPhiVectorF`** vector based on `rho,z,phi`; coordinates (cylindrical) in float precision. - `ROOT::Math::`**`RhoEtaPhiVector`** vector based on `rho,eta,phi`; coordinates (cylindrical using `eta` instead of `z`) in double; precision. - `ROOT::Math::`**`RhoEtaPhiVectorF`** vector based on `rho,eta,phi`; coordinates (cylindrical using `eta` instead of `z`) in float; precision. #### Constructors and Assignment. The following declarations are available:. ``` {.cpp}; XYZVector v1; //an empty vector (x=0, y=0, z=0); XYZVector v2(1,2,3); //vector with x=1, y=2, z=3;; Polar3DVector v3(1,PI/2,PI); //vector with r=1, theta=PI/2, phi=PI; RhoEtaPHiVector v4(1,2, PI); //vector with rho=1, eta=2, phi=PI; ```. Note that each vector type is constructed by passing its coordinate; representation, so a `XYZVector(1,2,3)` is different from a; `Polar3DVector(1,2,3)`. In addition, the vector classes can be; constructed by any vector, which implements the accessors `x()`, `y()`; and `z()`. This can be another 3D vector based on a different coordinate; system type. It can be even any vector of a different package, like the; CLHEP **`HepThreeVector`** that implements the required signature. ``` {.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; ```. #### Coordinate Accessors. All coordinate accessors are available through the class; `ROOT::Math::`**`DisplacementVector3D`**:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); ```. In addition, all the 3 coordinates of the vector can be retrieved with; the `GetCoordinates` method:. ``` {.cpp}; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:79378,access,accessors,79378,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['access'],['accessors']
Security,"riables, one internally and one externally linked, allowed?; Unknown. 427; CD1; static_cast ambiguity: conversion versus cast to derived; Yes. 428; CD1; Mention of expression with reference type; Yes. 429; CD1; Matching deallocation function chosen based on syntax or signature?; Clang 2.8 (C++11 onwards). 430; CD1; Ordering of expression evaluation in initializer list; Yes (C++11 onwards). 431; C++11; Defect in wording in 14.2; Yes. 432; CD1; Is injected class name visible in base class specifier list?; Clang 3.0. 433; CD1; Do elaborated type specifiers in templates inject into enclosing namespace scope?; Yes. 434; NAD; Unclear suppression of standard conversions while binding reference to lvalue; Superseded by 2352. 435; NAD; Change ""declararation or definition"" to ""declaration""; N/A. 436; CD1; Problem in example in 9.6 paragraph 4; Yes. 437; CD1; Is type of class allowed in member function exception specification?; Superseded by 1308. 438; CD2; Possible flaw in wording for multiple accesses to object between sequence points; Unknown. 439; CD1; Guarantees on casting pointer back to cv-qualified version of original type; Unknown. 440; NAD; Allow implicit pointer-to-member conversion on nontype template argument; Unknown. 441; CD1; Ordering of static reference initialization; Unknown. 442; CD1; Incorrect use of null pointer constant in description of delete operator; Superseded by 348. 443; CD1; Wording nit in description of lifetime of temporaries; N/A. 444; NAD; Overriding and the generated copy assignment operator; Yes. 445; NAD; Wording issue on friend declarations; Clang 3.2. 446; CD1; Does an lvalue-to-rvalue conversion on the ""?"" operator produce a temporary?; Clang 2.8. 447; CD1; Is offsetof type-dependent?; Yes. 448; C++11; Set of template functions in call with dependent explicit argument; Clang 2.8. 449; NAD; Consistency in use of hyphen with names of ""non"" entities; N/A. 450; CD1; Binding a reference to const to a cv-qualified array rvalue; Yes. 451; CD1; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:29823,access,accesses,29823,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['accesses']
Security,"riant #1 style; attack. Limitations of this approach:; * It requires re-compiling source code to insert hardening instruction; sequences. Only software compiled in this mode is protected.; * The performance is heavily dependent on a particular architecture's; implementation strategy. We outline a potential x86 implementation below and; characterize its performance.; * It does not defend against secret data already loaded from memory and; residing in registers or leaked through other side-channels in; non-speculative execution. Code dealing with this, e.g cryptographic; routines, already uses constant-time algorithms and code to prevent; side-channels. Such code should also scrub registers of secret data following; [these; guidelines](https://github.com/HACS-workshop/spectre-mitigations/blob/master/crypto_guidelines.md).; * To achieve reasonable performance, many loads may not be checked, such as; those with compile-time fixed addresses. This primarily consists of accesses; at compile-time constant offsets of global and local variables. Code which; needs this protection and intentionally stores secret data must ensure the; memory regions used for secret data are necessarily dynamic mappings or heap; allocations. This is an area which can be tuned to provide more comprehensive; protection at the cost of performance.; * [Hardened loads](#hardening-the-address-of-the-load) may still load data from; _valid_ addresses if not _attacker-controlled_ addresses. To prevent these; from reading secret data, the low 2gb of the address space and 2gb above and; below any executable pages should be protected. Credit:; * The core idea of tracing misspeculation through data and marking pointers to; block misspeculated loads was developed as part of a HACS 2018 discussion; between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other; individuals.; * Core idea of masking out loaded bits was part of the original mitigation; suggested by Jann Horn when these attacks were reporte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:7320,access,accesses,7320,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['access'],['accesses']
Security,"ribution. Let's see how operatively you; can fill and draw a histogram with the following example macro. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro5.C; ```. Which gives you the following plot (Figure [5.1](#f51)):. [f51]: figures/poisson.png ""f51""; <a name=""f51""></a>. ![The result of a counting (pseudo) experiment. Only bins corresponding; to integer values are filled given the discrete nature of the poissonian; distribution. \label{f51}][f51]. Using histograms is rather simple. The main differences with respect to; graphs that emerge from the example are:. - line *5*: The histograms have a name and a title right from the; start, no predefined number of entries but a number of bins and a; lower-upper range. - line *15*: An entry is stored in the histogram through the; `TH1F::Fill` method. - line *18* and *21*: The histogram can be drawn also normalised, ROOT; automatically takes cares of the necessary rescaling. - line *24* to *30*: This small snippet shows how easy it is to access; the moments and associated errors of a histogram. ## Add and Divide Histograms ##. Quite a large number of operations can be carried out with histograms.; The most useful are addition and division. In the following macro we; will learn how to manage these procedures within ROOT. ``` {.cpp .numberLines}; @ROOT_INCLUDE_FILE macros/macro6.C; ```. The plots that you will obtain are shown in Figures [5.2](#f52) and [5.3](#f53). [f52]: figures/histo_sum.png ""f52""; <a name=""f52""></a>. ![The sum of two histograms.\label{f52}][f52]. [f53]: figures/histo_ratio.png ""f53""; <a name=""f53""></a>. ![The ratio of two histograms.\label{f53}][f53]. Some lines now need a bit of clarification:. - line *3*: Cling, as we know, is also able to interpret more than one; function per file. In this case the function simply sets up some; parameters to conveniently set the line of histograms. - line *19* to *21*: Some `C++` syntax for conditional; statements is used to fill the histograms with different ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md:1730,access,access,1730,documentation/primer/histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/histograms.md,1,['access'],['access']
Security,"rical types, (; see issue in ROOT forum). When reading more than one TStreamerInfo for the same versioned; class, we now use the highest possible class version as the current; version of the class. Practically, we update the class version; when reading new (higher versioned) StreamerInfo until the Class; is actually used (i.e. TClass::GetClassVersion is call directly; or indirectly). In particular, if a file has several StreamerInfos for the same; versioned class, we will use the highest version number as the; 'current' class version (as opposed to the lowest until now). For backward compatibility TStreamerInfo::BuildCheck compares the checksum of; the on-file StreamerInfo not only to the current value of the class checksum; but also to the checksum calculated using the older algorithms. This patch extends this test to also be done when comparing 2 on-file StreamerInfos. This removes spurrious warning message when loading 2 older files which; were written with 2 different version of the TClass CheckSum algorithm; (and the in-memory class's version is greater than both TStreamerInfos'; class version). Extend support of TStreamerInfo::ReadValueAux to 'converted' numerical types, hence solving TTree::Draw's schema evolution problem (see http://root.cern/phpBB2/viewtopic.php?t=6225). DirectoryAutoAdd; Use the new DirectoryAutoAdd facility for the classes:; TTree, TH1, TEventList, TEntryList, TGraph2D; (and hence their derived classes). The instances of those classes are now added automatically; to the current directory only when Constructe'd with arguments or Clone'd; and to the directory they are read from when their are stored; directly in a TKey. [Note: the default constructor never adds; the object to the current directory]. The directory auto add can still be disabled for instance; of TH1 and TGraph2D by setting TH1::AddDirectory. Additionally one can disable the directory auto add for; a specific class by doing:. TClass::GetClass(""myclass"")->SetDirectoryAutoAdd(0)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html:2117,CheckSum,CheckSum,2117,io/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v520/index.html,1,['CheckSum'],['CheckSum']
Security,"ries during session startup, as they may significantly slowdown; the startup process is the medium is busy. In such a case, admins; are responsible to create the directories in advance; the session; releated part fo the path is created by the session once up.; In XrdProofd, move the check for the username after authentication.; This is because authentication may run some credentials-to-user mapping; which can modify the requested username. This way we really check the; final username and not the one requested by the client, which may even; not exist on the machines. Side modification: when the mapping function; returns more usernames, the username specified by the client is used to; help choosing the effective username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more flexibility to the definition of the library path seen by; proofserv. So far to avoid ambiguites in some cases, $ROOTSYS/lib was; removed and the one of the ROOT version chosen was added later on in; front, which proved to be to aggressive in some cases.; All changes (and fixes) needed to build against the version of Xrootd,; now always installed as external.; Fixes. Fix GetSessionLogs in PROOF-Lite; Restore correct parsing of ""workers=N"" in PROOF-Lite; In Proof-Bench, make sure that it can be run from any directory; and no matter how ROOT was installed; Fix issue in TProofPlayer::HandleHistogram preventing proper; histogram cleaning right after merging when using TH1::Add; histogram; were still des",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:2988,authoriz,authorization,2988,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,2,['authoriz'],['authorization']
Security,"ries section. .. option:: --dyn-relocations. Display the dynamic relocation entries. .. option:: --dyn-symbols, --dyn-syms, --dt. Display the dynamic symbol table. .. option:: --dynamic-table, --dynamic, -d. Display the dynamic table. .. option:: --cg-profile. Display the callgraph profile section. .. option:: --histogram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output (the default) is an expanded and; structured format. ``GNU`` output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --section-groups, -g. Display section groups. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dynamic symbols. .. option:: --memtag. Display information about memory tagging present in the binary. This includes; various dynamic entries, decoded global descriptor sections, and decoded; Android-specific ELF notes. .. option:: --notes, -n. Display all notes. .. option:: --pretty-print. When used with :option:`--elf-output-style`, JSON output will be formatted in; a more readable format. .. option:: --program-headers, --segments, -l. Display the program headers. .. option:: --raw-relr. Do not decode relocations in RELR relocation sections when displaying them. .. option:: --section-mapping. Display the section to segment mapping. .. option:: --stack-sizes. Display the contents of the stack sizes section(s), i.e. pairs of function; names and the size of their stack frames. Currently only implemented for GNU; style output. .. option:: --version-info, -V. Display version sections. MACH-O SPECIFIC OPTION",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst:5948,hash,hash,5948,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readobj.rst,1,['hash'],['hash']
Security,"ring compression than the LZMA algorithm, but the LZMA; algorithm usually delivers higher compression factors. The header file core/zip/inc/Compression.h declares the function; ""CompressionSettings"" and the enumeration for the algorithms.; Currently the following selections can be made for the algorithm:; kZLIB (1), kLZMA (2), kOldCompressionAlgo (3), and kUseGlobalSetting; (0). The last option refers to an older interface used to control the; algorithm that is maintained for backward compatibility. The following; function is defined in core/zip/inc/Bits.h and it set the global; variable. R__SetZipMode(int algorithm);. If the algorithm is set to kUseGlobalSetting (0), the global variable; controls the algorithm for compression operations. This is the; default and the default value for the global variable is kZLIB. gDirectory; gDirectory is now a thread local!. The value of gDirectory and gFile are now all accessed via a static function of their respective class. The access is made transparent via a CPP macro. Note: Whenever a thread has an associated TThread object, the value of gDirectory is now thread local, i.e. all modifications direct or indirect of gDirectory will not be seen by the other thread. In particular this means that several I/O operations (including TDirectory::Write) are thread safe (as long as all the required TClass and TStreamerInfo has been previously setup).; Note: This model does not support sharing TFile amongst threads (i.e. a TFile must be accessed from exactly one thread). This means that whenever a TFile's control is passed from a thread to another, the code must explicitly reset gDirectory to another value or there is a risk for this gDirectory to point to a stale pointer if the other thread deletes the TFile object. A TFile deletion will only affect the value of the local gDirectory and gFile. TMemFile; Introduce TMemFile and update TFileMerger to support incremental merges. Add new tutorials (net/treeClient.C + net/fastMergeServer.C); ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html:3067,access,access,3067,io/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v532/index.html,2,['access'],['access']
Security,"ring more and more data over time. They are; ready to use the true and tested technologies physics has invented. In; this way, other fields and industries have found ROOT useful and they; have started to use it also. In the bazaar view, software is released early and frequently to; expose it to thousands of eager co-developers to pound on, report; bugs, and contribute possible fixes. More users find more bugs,; because they stress the program in different ways. By now, after ten; years, the age of ROOT is quite mature. Most likely, you will find the; features you are looking for, and if you have found a hole, you are; encouraged to participate in the dialog and post your suggestion or; even implementation on the ROOT forum. ## The ROOT forum. If you have a question, it is likely that it has been asked, answered,; and stored in the ROOT Forum. Please use; the search engine to see if your question has already been answered; before posting a topic in the; Forum. You can access the ROOT forum at: <https://root-forum.cern.ch>. ## Contact Information. Several authors wrote this book and you may see a ""change of voice""; from one chapter to the next. We felt we could accept this in order to; have the expert explain what they know best. If you would like to; contribute a chapter or add to a section, please contact; <rootdoc@cern.ch>. We count on you to send us suggestions on; additional topics or on the topics that need more documentation.; Please send your comments, corrections, questions, and suggestions to; the `rootdoc` list: <rootdoc@cern.ch>. We attempt to give the user insight into the many capabilities of; ROOT. The book begins with the elementary functionality and progresses; in complexity reaching the specialized topics at the end. The; experienced user looking for special topics may find these chapters; useful: see ""Networking"", ""Writing a Graphical User Interface"",; ""Threads"", and ""PROOF: Parallel Processing"". ## Conventions Used in This Book. We tried to follow a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md:2624,access,access,2624,documentation/users-guide/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Introduction.md,1,['access'],['access']
Security,"rings. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. OS X Checkers. Name, DescriptionExample. osx.API; (C); Check for proper uses of various Apple APIs:; dispatch_once. void test() {; dispatch_once_t pred = 0;; dispatch_once(&pred, ^(){}); // warn: dispatch_once uses local; }. osx.NumberObjectConversion; (C, C++, ObjC); Check for erroneous conversions of objects representing numbers; into numbers. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. osx.SecKeychainAPI; (C); Check for improper uses of the Security framework's Keychain APIs:; SecKeychainItemCopyContent; SecKeychainFindGenericPassword; SecKeychainFindInternetPassword; SecKeychainItemFreeContent; SecKeychainItemCopyAttributesAndData; SecKeychainItemFreeAttributesAndData. void test() {; unsigned int *ptr = 0;; UInt32 length;. SecKeychainItemFreeContent(ptr, &length);; // warn: trying to free data which has not been allocated; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, outData);; // warn: data is not released; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. SecKeychainItemFreeContent(ptr, outData);; // warn: only call free if a non-NULL buffer was returned; }. void test() {; unsigned int *ptr = 0;; UInt32 *length = 0;; void *outData;. OSStatus st =; SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);. st = SecKeychainItemCopyContent(2, ptr, ptr, length, &outData);; // warn: release data before another call",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html:13026,Secur,Security,13026,interpreter/llvm-project/clang/www/analyzer/available_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/available_checks.html,1,['Secur'],['Security']
Security,"rinsic returns the; address of the given thread local global in the calling thread. .. _int_vscale:. '``llvm.vscale``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare i32 llvm.vscale.i32(); declare i64 llvm.vscale.i64(). Overview:; """""""""""""""""". The ``llvm.vscale`` intrinsic returns the value for ``vscale`` in scalable; vectors such as ``<vscale x 16 x i8>``. Semantics:; """""""""""""""""""". ``vscale`` is a positive value that is constant throughout program; execution, but is unknown at compile time.; If the result value does not fit in the result type, then the result is; a :ref:`poison value <poisonvalues>`. Stack Map Intrinsics; --------------------. LLVM provides experimental intrinsics to support runtime patching; mechanisms commonly desired in dynamic language JITs. These intrinsics; are described in :doc:`StackMaps`. Element Wise Atomic Memory Intrinsics; -------------------------------------. These intrinsics are similar to the standard library memory intrinsics except; that they perform memory transfer as a sequence of atomic memory accesses. .. _int_memcpy_element_unordered_atomic:. '``llvm.memcpy.element.unordered.atomic``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". This is an overloaded intrinsic. You can use ``llvm.memcpy.element.unordered.atomic`` on; any integer bit width and for different address spaces. Not all targets; support all bit widths however. ::. declare void @llvm.memcpy.element.unordered.atomic.p0.p0.i32(ptr <dest>,; ptr <src>,; i32 <len>,; i32 <element_size>); declare void @llvm.memcpy.element.unordered.atomic.p0.p0.i64(ptr <dest>,; ptr <src>,; i64 <len>,; i32 <element_size>). Overview:; """""""""""""""""". The '``llvm.memcpy.element.unordered.atomic.*``' intrinsic is a specialization of the; '``llvm.memcpy.*``' intrinsic. It differs in that the ``dest`` and ``src`` are treated; as arrays with elements that are exactly ``element_size`` bytes, and the copy between; buffers uses a sequence of :ref:`",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:956986,access,accesses,956986,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security,"rip Symbols"")));. This defines a variable that is conceptually of the type; ""``std::vector<enum Opts>``"". Thus, you can access it with standard vector; methods:. .. code-block:: c++. for (unsigned i = 0; i != OptimizationList.size(); ++i); switch (OptimizationList[i]); ... ... to iterate through the list of options specified. Note that the ""``cl::list``"" template is completely general and may be used with; any data types or other arguments that you can use with the ""``cl::opt``""; template. One especially useful way to use a list is to capture all of the; positional arguments together if there may be more than one specified. In the; case of a linker, for example, the linker takes several '``.o``' files, and; needs to capture them into a list. This is naturally specified as:. .. code-block:: c++. ...; cl::list<std::string> InputFilenames(cl::Positional, cl::desc(""<Input files>""), cl::OneOrMore);; ... This variable works just like a ""``vector<string>``"" object. As such, accessing; the list is simple, just like above. In this example, we used the; `cl::OneOrMore`_ modifier to inform the CommandLine library that it is an error; if the user does not specify any ``.o`` files on our command line. Again, this; just reduces the amount of checking we have to do. Collecting options as a set of flags; ------------------------------------. Instead of collecting sets of options in a list, it is also possible to gather; information for enum values in a **bit vector**. The representation used by the; `cl::bits`_ class is an ``unsigned`` integer. An enum value is represented by a; 0/1 in the enum's ordinal value bit position. 1 indicating that the enum was; specified, 0 otherwise. As each specified value is parsed, the resulting enum's; bit is set in the option's bit vector:. .. code-block:: c++. bits |= 1 << (unsigned)enum;. Options that are specified multiple times are redundant. Any instances after; the first are discarded. Reworking the above list example, we could replace `cl::li",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:21097,access,accessing,21097,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['access'],['accessing']
Security,"ript that comes with ROOT; it; prints all flags and libraries needed to compile code and link it with; the ROOT libraries. In order to make the code executable stand-alone, an; entry point for the operating system is needed, in C++ this is the; procedure `int main();`. The easiest way to turn a ROOT macro code into; a stand-alone application is to add the following ""dressing code"" at the; end of the macro file. This defines the procedure main, the only purpose; of which is to call your macro:. ``` {.cpp}; int main() {; ExampleMacro();; return 0;; }; ```. To create a stand-alone program from a macro called `ExampleMacro.C`, simply type. ``` {.cpp}; > g++ -o ExampleMacro ExampleMacro.C `root-config --cflags --libs`; ```. and execute it by typing. ``` {.cpp}; > ./ExampleMacro; ```. This procedure will, however, not give access to the ROOT graphics, as; neither control of mouse or keyboard events nor access to the graphics; windows of ROOT is available. If you want your stand-alone application; have display graphics output and respond to mouse and keyboard, a; slightly more complex piece of code can be used. In the example below, a; macro `ExampleMacro_GUI` is executed by the ROOT class `TApplication`. As; a additional feature, this code example offers access to parameters; eventually passed to the program when started from the command line.; Here is the code fragment:. ``` {.cpp}; void StandaloneApplication(int argc, char** argv) {; // eventually, evaluate the application parameters argc, argv; // ==>> here the ROOT macro is called; ExampleMacro_GUI();; }; // This is the standard ""main"" of C++ starting; // a ROOT application; int main(int argc, char** argv) {; TApplication app(""ROOT Application"", &argc, argv);; StandaloneApplication(app.Argc(), app.Argv());; app.Run();; return 0;; }; ```. Compile the code with. ``` {.cpp}; > g++ -o ExampleMacro_GUI ExampleMacro_GUI `root-config --cflags --libs`; ```. and execute the program with. ``` {.cpp}; > ./ExampleMacro_GUI; ```; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md:11522,access,access,11522,documentation/primer/your_first_ROOT_macro.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/your_first_ROOT_macro.md,1,['access'],['access']
Security,"riptors when; recovering sessions .; Fix an issue with a fake error message (""Error in; <TROOT::cd>: No such file root:/"") in PROOF-Lite when; issuing TProof::SetParallel().; Fix a problem with negative values for 'workers still; sending' in PROOF-Lite .; Fix locking issue while building packages locally.; Fix issue setting permission and ownership of the dataset; user directories.Fix; a subtle bug affecting the (possibly rare) case when not all entries; are required and # entries does not correspond to an complete subset of; files (e.g. # entries = 1001000 with files of 100000 entries each). The; effect was uncomplete processing (skipped events, magenta bar) or a; session freeze.; Fix problem with packet re-assignment in case of a worker death (some packets were processed twice or more times).; Fix problem with the transmission of non-default file; attributes (e.g. the number of entries) from TChainElement to; TDSetElement during TChain processing in PROOF; Fix problem in the default packetizer with validating the; exact number of needed files when the information about the entries is; already available.; Fix problem with 'xpd.putenv' and 'xpd.putrc' occuring when the variables themselves contain commas.; Avoid resolving the workers FQDN when running in PROOF-Lite,; creating unnecessary delays when running PROOF-Lite within virtual; machines.; Fix problem with the permissions of the user data directory.; Add files to the list of files to process only when finally validated.; Fix; problem with canvases when the feedback canvas and the final canvas are; the same (do not delete the feedback canvas at the end of processing); Make sure that TProof::Load, TProofPlayer::SendSelector and; TSelector::GetSelector treat consistently the extensions of the; implementation files.; Unlock the cache after failure to load a selector; prevents session freezing; Correctly update the number of submergers when workers die; Add missing protection causing a crash in submergers when the o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:11697,validat,validating,11697,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['validat'],['validating']
Security,"rity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Inte",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184728,access,access,184728,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,3,"['access', 'sanitiz']","['access', 'sanitizers']"
Security,"rizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations.; The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes. ::. call void @llvm.masked.store.v16f32.p0(<16 x float> %value, ptr %ptr, i32 4, <16 x i1> %mask). ;; The result of the following instructions is identical aside from potential data races and memory access exceptions; %oldval = load <16 x float>, ptr %ptr, align 4; %res = select <16 x i1> %mask, <16 x float> %value, <16 x float> %oldval; store <16 x float> %res, ptr %ptr, align 4. Masked Vector Gather and Scatter Intrinsics; -------------------------------------------. LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits are off, no memory is accessed. .. _int_mgather:. '``llvm.masked.gather.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating-point or pointer data type gathered together into one vector. ::. declare <16 x float> @llvm.masked.gather.v16f32.v16p0(<16 x ptr> <ptrs>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.gather.v2f64.v2p1(<2 x ptr addrspace(1)> <ptrs>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); declare <8 x ptr> @llvm.masked.gather.v8p0.v8p0(<8 x ptr> <ptrs>, i32 <alignment>, <8 x i1> <mask>, <8",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:848077,access,accesses,848077,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['accesses']
Security,"rl>"", ""masteronly""); Add full support for placeholders; <uid>,; <gid>, <group> and <homedir>; for the directives specified via 'xpd.putenv'; Add the configuration directive 'proofservparents' to; allow specifying a different list of parent names for the 'proofserv'; tasks. This is needed to avoid untimely killing of 'proofserv'; instances in test setups when multiple instances of the daemons are; running on the same machines under different names.; Add the possibility to switch to asynchronous mode while; running synchronously. A new button ""Run; in background"" has been added; to the dialog box. The behaviour of Ctrl-C has also been modified: the; user is prompted for a choice among continuing asynchronously, stopping; (terminating) or aborting the query.; Add the possibility to define the dataset information; sources via the directive 'xpd.datasetsrc'.; In this way the permissions; should be set correctly and the related problems disappear.; Record the logs from the ROOT version validation tests; (proofserv forked in test mode). In case of failure - or if the debug; flag is on - the log files are kept under; <xproof_adminpath>/rootsysvalidation/root.<tag>.log; (the <tag> has all the '/' replaced by '-'). This should; facilitate understanding the problems when in case of validation; failures.; Add support for automatic; running of PROOF sessions in valgrind. The second; argument of TProof::Open is used to trigger the relevant; settings. To valgrind the master session start PROOF; with TProof::Open(""<master>"",""valgrind=master"");; to valgrind two workers sessions use; TProof::Open(""<master>"",""valgrind=workers""); to valgrind; master and 2 workers, use; TProof::Open(""<master>"",""valgrind=master+workers""). Other; combinations are available. ; The valgrind logs are available with the tag; '<ordinal>-valgrind' in the log dialog or form; TProofMgr::GetSessionLogs() .; To add options to valgrind execute; TProof::AddEnvVar(""PROOF_WRAPPERCMD"",; ""valgrind_opts:<options>"") before",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:3334,validat,validation,3334,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['validat'],['validation']
Security,"rmatStyle &Style, Lexer &Lex,; SourceManager &SourceMgr,; std::vector<CharSourceRange> Ranges);. This reads a token stream out of the lexer ``Lex`` and reformats all the code; ranges in ``Ranges``. The ``FormatStyle`` controls basic decisions made during; formatting. A list of options can be found under :ref:`style-options`. The style options are described in :doc:`ClangFormatStyleOptions`. .. _style-options:. Style Options; -------------. The style options describe specific formatting options that can be used in; order to make `ClangFormat` comply with different style guides. Currently,; several style guides are hard-coded:. .. code-block:: c++. /// Returns a format style complying with the LLVM coding standards:; /// https://llvm.org/docs/CodingStandards.html.; FormatStyle getLLVMStyle();. /// Returns a format style complying with Google's C++ style guide:; /// http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml.; FormatStyle getGoogleStyle();. /// Returns a format style complying with Chromium's style guide:; /// https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md; FormatStyle getChromiumStyle();. /// Returns a format style complying with the GNU coding standards:; /// https://www.gnu.org/prep/standards/standards.html; FormatStyle getGNUStyle();. /// Returns a format style complying with Mozilla's style guide; /// https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html; FormatStyle getMozillaStyle();. /// Returns a format style complying with Webkit's style guide:; /// https://webkit.org/code-style-guidelines/; FormatStyle getWebkitStyle();. /// Returns a format style complying with Microsoft's style guide:; /// https://docs.microsoft.com/en-us/visualstudio/ide/editorconfig-code-style-settings-reference; FormatStyle getMicrosoftStyle();. These options are also exposed in the :doc:`standalone tools <ClangFormat>`; through the `-style` option. In the future, we plan on making this configurable.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst:2369,expose,exposed,2369,interpreter/llvm-project/clang/docs/LibFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibFormat.rst,1,['expose'],['exposed']
Security,"rmission, you risk loosing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is may also be corrupted. In addition, adding a branch to; a tree enlarges the tree and increases the amount of memory needed to; read an entry, and therefore decreases the performance. For these; reasons, ROOT offers the concept of friends for trees (and chains). We; encourage you to use `TTree::AddFriend` rather than adding a branch; manually. ### TTree::AddFriend. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way it; is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the; `TTree::AddFriend` method. The **`TTree`** (`tree`) below has two; friends (`ft1` and `ft2`) and now has access to the variables; `a,b,c,i,j,k,l` and `m`. ![](pictures/02000101.jpg). The `AddFriend` method has two parameters, the first is the tree name; and the second is the name of the ROOT file where the friend tree is; saved. `AddFriend` automatically opens the friend file. If no file name; is given, the tree called `ft1` is assumed to be in the same file as the; original tree. ``` {.cpp}; tree.AddFriend(""ft1"",""friendfile1.root"");; ```. If the friend tree has the same name as the original tree, you can give; it an alias in the context of the friendship:. ``` {.cpp}; tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; ```. Once the tree has friends, we can use `TTree::Draw` as if the friend's; variables were in the original tree. To specify which tree to use in the; `Draw` method, use the syntax:. ``` {.cpp}; <treeName>.<branchname>.<varname>; ```. If the `variablename` is enough to identify uniquely the variable, you; can leave out the tree and/or branch name. For exampl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:53140,access,access,53140,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['access']
Security,"rn CPUs. These; exploits are currently broken down into three variants:; * GPZ Variant #1 (a.k.a. Spectre Variant #1): Bounds check (or predicate) bypass; * GPZ Variant #2 (a.k.a. Spectre Variant #2): Branch target injection; * GPZ Variant #3 (a.k.a. Meltdown): Rogue data cache load. For more details, see the Google Project Zero blog post and the Spectre research; paper:; * https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html; * https://spectreattack.com/spectre.pdf. The core problem of GPZ Variant #1 is that speculative execution uses branch; prediction to select the path of instructions speculatively executed. This path; is speculatively executed with the available data, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `val",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:1376,attack,attackers,1376,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attackers']
Security,"rnal information could be needed. Such data would help to identify; debug information processed or incorrect logical element management.; Typically these kind of options are available only in *debug* builds. :program:`llvm-debuginfo-analyzer` supports these advanced options in; both *release* and *debug* builds, with the exception of the unique ID; that is generated only in *debug* builds. .. option:: --internal=<value[,value,...]>. With **value** being one of the options in the following list. .. code-block:: text. =all: Include all the below options. The following options allow to check the integrity of the logical view;; collect the debug tags that are processed or not implemented; ignore the; logical element line number, to facilitate the logical view comparison; when using external comparison tools; print the command line options; used to invoke :program:`llvm-debuginfo-analyzer`. .. code-block:: text. =id: Print unique element ID.; =cmdline: Print command line.; =integrity: Check elements integrity.; =none: Ignore element line number.; =tag: Debug information tags. **Note:** For ELF format, the collected tags represent the debug tags; that are not processed. For PE/COFF format, they represent the tags; that are processed. EXAMPLES; --------; This section includes some real binary files to show how to use; :program:`llvm-debuginfo-analyzer` to print a logical view and to; diagnose possible debug information issues. TEST CASE 1 - GENERAL OPTIONS; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; The below example is used to show different output generated by; :program:`llvm-debuginfo-analyzer`. We compiled the example for an X86; ELF target with Clang (-O0 -g):. .. code-block:: c++. 1 using INTPTR = const int *;; 2 int foo(INTPTR ParamPtr, unsigned ParamUnsigned, bool ParamBool) {; 3 if (ParamBool) {; 4 typedef int INTEGER;; 5 const INTEGER CONSTANT = 7;; 6 return CONSTANT;; 7 }; 8 return ParamUnsigned;; 9 }. PRINTING MODE; ^^^^^^^^^^^^^; In this mode :program:`llvm-debuginfo-analy",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst:23367,integrity,integrity,23367,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-debuginfo-analyzer.rst,2,['integrity'],['integrity']
Security,"rns which happen to resemble very closely the initial; proofs of concept. As such, while its performance is acceptable, it does not; appear to be an adequate systematic mitigation. ## Performance Overhead. The performance overhead of this style of comprehensive mitigation is very; high. However, it compares very favorably with previously recommended; approaches such as the `lfence` instruction. Just as users can restrict the; scope of `lfence` to control its performance impact, this mitigation technique; could be restricted in scope as well. However, it is important to understand what it would cost to get a fully; mitigated baseline. Here we assume targeting a Haswell (or newer) processor and; using all of the tricks to improve performance (so leaves the low 2gb; unprotected and +/- 2gb surrounding any PC in the program). We ran both; Google's microbenchmark suite and a large highly-tuned server built using; ThinLTO and PGO. All were built with `-march=haswell` to give access to BMI2; instructions, and benchmarks were run on large Haswell servers. We collected; data both with an `lfence`-based mitigation and load hardening as presented; here. The summary is that mitigating with load hardening is 1.77x faster than; mitigating with `lfence`, and the overhead of load hardening compared to a; normal program is likely between a 10% overhead and a 50% overhead with most; large applications seeing a 30% overhead or less. | Benchmark | `lfence` | Load Hardening | Mitigated Speedup |; | -------------------------------------- | -------: | -------------: | ----------------: |; | Google microbenchmark suite | -74.8% | -36.4% | **2.5x** |; | Large server QPS (using ThinLTO & PGO) | -62% | -29% | **1.8x** |. Below is a visualization of the microbenchmark suite results which helps show; the distribution of results that is somewhat lost in the summary. The y-axis is; a log-scale speedup ratio of load hardening relative to `lfence` (up -> faster; -> better). Each box-and-whiskers rep",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:47255,access,access,47255,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['access'],['access']
Security,"root_hist`; in your home directory. ROOT uses this file to allow for navigation in; the command history with the up-arrow and down-arrow keys. It is also; convenient to extract successful ROOT commands with the help of a text; editor for use in your own macros. ### ROOT Global Pointers ###. All global pointers in ROOT begin with a small ""g"". Some of them were; already implicitly introduced (for example in the section; [Configure ROOT at start-up](#configure-root-at-start-up)).; The most important among them are presented in the following:. - **[gROOT](https://root.cern.ch/doc/master/classTROOT.html)**: the `gROOT`; variable is the entry point to the ROOT system. Technically it is an; instance of the `TROOT` class. Using the `gROOT` pointer one has; access to basically every object created in a ROOT based program.; The `TROOT` object is essentially a container of several lists; pointing to the main `ROOT` objects. - **[gStyle](https://root.cern.ch/doc/master/classTStyle.html)**: By default; ROOT creates a default style that can be accessed via the `gStyle`; pointer. This class includes functions to set some of the following; object attributes. - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles; - etc ... - **[gSystem](https://root.cern.ch/doc/master/classTSystem.html)**: An; instance of a base class defining a generic interface to the; underlying Operating System, in our case `TUnixSystem`. - **[gInterpreter](http://root.cern.ch/htmldoc/html/TInterpreter.html)**: The; entry point for the ROOT interpreter. Technically an abstraction level; over a singleton instance of `TCling`. At this point you have already learnt quite a bit about some basic; features of ROOT. ***Please move on to become an expert!***. [^2]: All ROOT classes' names start with the letter T. A notable exception is; RooFit. In this context all classes' names are of the form Roo*. Starting with; ROOT7, all names start with and R.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md:20643,access,accessed,20643,documentation/primer/ROOT_as_calculator.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/ROOT_as_calculator.md,1,['access'],['accessed']
Security,"ros_mask = 0;; void leak(int data);; void example(int* pointer1, int* pointer2) {; uintptr_t predicate_state = all_ones_mask;; switch (condition) {; case 0:; // Assuming ?: is implemented using branchless logic...; predicate_state = (condition != 0) ? all_zeros_mask : predicate_state;; // ... lots of code ...; //; // Harden the pointer so it can't be loaded; pointer1 &= predicate_state;; leak(*pointer1);; break;. case 1:; predicate_state = (condition != 1) ? all_zeros_mask : predicate_state;; // ... more code ...; //; // Alternative: Harden the loaded value; int value2 = *pointer2 & predicate_state;; leak(value2);; break;. // ...; }; }; ```. The core idea remains the same: validate the control flow using data-flow and; use that validation to check that loads cannot leak information along; misspeculated paths. Typically this involves passing the desired target of such; control flow across the edge and checking that it is correct afterwards. Note; that while it is tempting to think that this mitigates variant #2 attacks, it; does not. Those attacks go to arbitrary gadgets that don't include the checks. ### Variant #1.1 and #1.2 attacks: ""Bounds Check Bypass Store"". Beyond the core variant #1 attack, there are techniques to extend this attack.; The primary technique is known as ""Bounds Check Bypass Store"" and is discussed; in this research paper: https://people.csail.mit.edu/vlk/spectre11.pdf. We will analyze these two variants independently. First, variant #1.1 works by; speculatively storing over the return address after a bounds check bypass. This; speculative store then ends up being used by the CPU during speculative; execution of the return, potentially directing speculative execution to; arbitrary gadgets in the binary. Let's look at an example.; ```; unsigned char local_buffer[4];; unsigned char *untrusted_data_from_caller = ...;; unsigned long untrusted_size_from_caller = ...;; if (untrusted_size_from_caller < sizeof(local_buffer)) {; // Speculative execution e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:10854,attack,attacks,10854,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacks']
Security,"rotocol, i.e. (abstract) member functions,; for:. - Object I/O (`Read()`, `Write())`. - Error handling (`Warning()`, `Error()`, `SysError()`, `Fatal())`. - Sorting (`IsSortable()`, `Compare()`, `IsEqual()`, `Hash())`. - Inspection (`Dump()`, `Inspect()`). - Printing (`Print())`. - Drawing (`Draw()`, `Paint()`, `ExecuteEvent())`. - Bit handling (`SetBit()`, `TestBit()`). - Memory allocation (operator` new and delete`, `IsOnHeap())`. - Access to meta information (`IsA()`, `InheritsFrom())`. - Object browsing (`Browse()`, `IsFolder())`. ## Global Variables. ROOT has a set of global variables that apply to the session. For; example,; ***`gDirectory`*** always holds the current directory, and; ***`gStyle`*** holds the current style. All global variables begin with ""*g*"" followed by a capital letter. ### gROOT. The single instance of **`TROOT`** is accessible via the global; ***`gROOT`*** and holds information relative to the current session.; By using the ***`gROOT`*** pointer, you get the access to every object; created in a ROOT program. The **`TROOT`** object has several lists; pointing to the main ROOT objects. During a ROOT session, the; ***`gROOT`*** keeps a series of collections to manage objects. They; can be accessed via ***`gROOT`***`::GetListOf...` methods. ``` {.cpp}; gROOT->GetListOfClasses(); gROOT->GetListOfColors(); gROOT->GetListOfTypes(); gROOT->GetListOfGlobals(); gROOT->GetListOfGlobalFunctions(); gROOT->GetListOfFiles(); gROOT->GetListOfMappedFiles(); gROOT->GetListOfSockets(); gROOT->GetListOfCanvases(); gROOT->GetListOfStyles(); gROOT->GetListOfFunctions(); gROOT->GetListOfSpecials(); gROOT->GetListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or traversing the list and calling a method for each of the; members. See the **`TCollection`** class description for the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:32605,access,access,32605,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['access']
Security,"roup figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'l",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:14150,secur,security-sensitive,14150,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security-sensitive']
Security,"roup judged 2 of these; reports to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=5; * https://bugs.chromium.org/p/llvm/issues/detail?id=11. Both issues were addressed with source changes: #5 in clangd/vscode-clangd, and; #11 in llvm-project. No dedicated LLVM release was made for either. We believe that with the publishing of this first annual transparency report,; the security group now has implemented all necessary processes for the group to; operate as promised. The group's processes can be improved further, and we do; expect further improvements to get implemented in 2022. Many of the potential; improvements end up being discussed on the `monthly public call on LLVM's; security group <https://llvm.org/docs/GettingInvolved.html#online-sync-ups>`_. 2022; ----. In this section we report on the issues the group received in 2022, or on issues; that were received earlier, but were disclosed in 2022. In 2022, the llvm security group received 15 issues that have been disclosed at; the time of writing this transparency report. 5 of these were judged to be security issues:. * https://bugs.chromium.org/p/llvm/issues/detail?id=17 reports a miscompile in; LLVM that can result in the frame pointer and return address being; overwritten. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=19 reports a vulnerability; in `std::filesystem::remove_all` in libc++. This was fixed. * https://bugs.chromium.org/p/llvm/issues/detail?id=23 reports a new Spectre; gadget variant that Speculative Load Hardening (SLH) does not mitigate. No; extension to SLH was implemented to also mitigate against this variant. * https://bugs.chromium.org/p/llvm/issues/detail?id=30 reports missing memory; safety protection on the (C++) exception handling path. A number of fixes; were implemented. * https://bugs.chromium.org/p/llvm/issues/detail?id=33 reports the RETBLEED; vulnerability. The outcome was clang growing a new security hardening feature; `-mfunction-return",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst:2254,secur,security,2254,interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SecurityTransparencyReports.rst,1,['secur'],['security']
Security,"roxy for CVMFS; : An URL specifying the proxy server for CernVM-FS, such as; `http://ca-proxy.cern.ch:3128/`. If you leave it empty, proxy will; be automatically discovered. HTCondor shared secret; : VMs part of the same cluster should have the same value of this; field. It is used to mutually authenticate VMs and it is used like a; password. Context password; : Current profile will be saved on the [CernVM Online; repository](http://cernvm-online.cern.ch/). If you don't want the; information there to be publicly available to other users, type in; a value for protecting the context with an encryption password. You will have to create a profile for the **master** and the **slave**. Since; most of the configuration variables are the same (like the *HTCondor; shared secret*) you can create one, clone it and change only what's; needed to change. Deploy it on the cloud; ----------------------. Provided you have access to a certain cloud API, you'll need to; instantiate a certain number of CernVM batch images with proper; contextualization: one for the master, as many as you want as slaves. CernVM supports contextualization through the ""user data"" field; supported by all cloud infrastructures. Each cloud infrastructure has a different method of setting the ""user; data"". The following description will focus on:. - [OpenNebula](http://opennebula.org/). - OpenStack (such as the [CERN Agile; infrastructure](https://openstack.cern.ch/)). - [Amazon EC2](http://aws.amazon.com/ec2/)-compatible interfaces via; the open [Eucalyptus](http://www.eucalyptus.com/); [Euca2ools](http://www.eucalyptus.com/eucalyptus-cloud/tools): many popular; clouds support such interface and tools. ### Download the CernVM Online contextualizations. Go to the CernVM Online Dashboard page where you have previously; customized the contexts for your master and your slaves. Click on the rightmost button on the line of the desired context and; select **Get rendered context** from the dropdown: save the output ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md:3598,access,access,3598,proof/doc/confman/DeployVirtualAnalysisFacility.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/DeployVirtualAnalysisFacility.md,1,['access'],['access']
Security,"rprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like in; ""total-ordering"", we will track every number and flag, but instead of; comparison, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are two main important fields in the class:. ``FnTree`` – the set of all unique functions. It keeps items that couldn't be; merged with each other. It is defined as:. ``std::set<FunctionNode> FnTree;``. Here ``FunctionNode`` is a wrapper for ``llvm::Function`` class, with; implemented “<” operator among the functions set (below we explain how it works; exactly; this is a key point in fast functions comparison). ``Deferred`` – merging process can affect bodies of functions that are in; ``FnTree`` already. Obviously, such functions should be rechecked again. In this; case, we remove them from ``FnTree``, and mark them to be rescanned, namely; put them into ``Deferred`` list. runOnModule; """"""""""""""""""""""; The algorithm is pretty simple:. 1. Put all module's functions into the *worklist*. 2. Scan *worklist*'s functions twice: first enumer",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:7555,access,access,7555,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['access'],['access']
Security,"rrently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. \image html geometry013.jpg ""Ray-traced view in a pad"". ~~~{.cpp}; myVolume->Raytrace(); ~~~. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corresponding volumes is still accessible. \anchor GP04ca; #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. 1. `TGeoShape *clip1, *clip2, ...`; One might switch between several clipping shapes. Note that these; shapes are considered defined in the current `MARS`. Composite shapes; may be used.; 2. `gGeoManager->SetClippingShape(clip1);`; One can activate or deactivate clipping at any time:; `gGeoManager->SetClipping(flag);`; 3. Perform ray-tracing:` gGeoManager->GetTopVolume()->Raytrace();`. One can redo the steps 2-3 as many times as needed. Let us look how the; rootgeom.C example looks clipped with a tube. \image html geometry014.png ""Ray-tracing example with box-clipping"". \anchor GP05; ## Representing Misali",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:105046,access,accessible,105046,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['accessible']
Security,"rs are not required - specified item will be displayed automatically when web page is opened.; One also can configure to display several items at once. For that one also can configure layout of the drawing area:. ```cpp; serv->SetItemField(""/"", ""_layout"", ""grid2x2""); // layout for drawing area; serv->SetItemField(""/"", ""_drawitem"", ""[Files/job1.root/hpxpy,Files/job1.root/hpx]""); // items; serv->SetItemField(""/"", ""_drawopt"", ""[colz,hist]""); // options; ```. One also can change appearance of hierarchy browser on the left side of the web page:. ```cpp; serv->SetItemField(""/"", ""_browser"", ""off""); // allowed ""fix"" (default), ""float"", ""no"", ""off""; serv->SetItemField(""/"", ""_toptitle"", ""Custom title""); // title of web page, shown when browser off; ```. If necessary, one also can automatically open ROOT file when web page is opened:. ```cpp; serv->SetItemField(""/"", ""_loadfile"", ""currentdir/hsimple.root""); // name of ROOT file to load; ```. ## Configuring user access. By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the **htdigest** utility. ```bash; [shell] htdigest -c .htdigest domain_name user_name; ```. It is recommended not to use special symbols in domain or user names. Several users can be add to the "".htdigest"" file. When starting the server, the following arguments should be specified:. ```cpp; auto serv = new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; ```. After that, the web browser will automatically request to input a name/password for the domain ""domain_name"". Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using `THttpServer::Restrict()` method. For instance, one could hide complete folder from 'guest' account:. ```cpp; serv->Restrict(""/Folder"", ""hidden=guest"");; ```. Or one could hide from all but 'admin' account:. ```cpp; serv->Re",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md:8175,access,access,8175,documentation/HttpServer/HttpServer.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/HttpServer/HttpServer.md,1,['access'],['access']
Security,"rs can query constraint bounds to improve diagnostic messages.; (`#74141 <https://github.com/llvm/llvm-project/pull/74141>`_). - Improved the generated initializers for modules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77040,secur,security,77040,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['secur'],['security']
Security,"rs compilation of the symbol(s) searched for; (if they have not been compiled already), and (2) it provides the; synchronization mechanism for concurrent compilation. The pseudo-code for the; lookup process is:. .. code-block:: none. construct a query object from a query set and query handler; lock the session; lodge query against requested symbols, collect required materializers (if any); unlock the session; dispatch materializers (if any). In this context a materializer is something that provides a working definition; of a symbol upon request. Usually materializers are just wrappers for compilers,; but they may also wrap a jit-linker directly (if the program representation; backing the definitions is an object file), or may even be a class that writes; bits directly into memory (for example, if the definitions are; stubs). Materialization is the blanket term for any actions (compiling, linking,; splatting bits, registering with runtimes, etc.) that are required to generate a; symbol definition that is safe to call or access. As each materializer completes its work it notifies the JITDylib, which in turn; notifies any query objects that are waiting on the newly materialized; definitions. Each query object maintains a count of the number of symbols that; it is still waiting on, and once this count reaches zero the query object calls; the query handler with a *SymbolMap* (a map of symbol names to addresses); describing the result. If any symbol fails to materialize the query immediately; calls the query handler with an error. The collected materialization units are sent to the ExecutionSession to be; dispatched, and the dispatch behavior can be set by the client. By default each; materializer is run on the calling thread. Clients are free to create new; threads to run materializers, or to send the work to a work queue for a thread; pool (this is what LLJIT/LLLazyJIT do). Top Level APIs; ==============. Many of ORC's top-level APIs are visible in the example above:. -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst:10375,access,access,10375,interpreter/llvm-project/llvm/docs/ORCv2.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ORCv2.rst,1,['access'],['access']
Security,"rs must not change the number of; volatile operations or change their order of execution relative to other; volatile operations. The optimizers *may* change the order of volatile; operations relative to non-volatile operations. This is not Java's; ""volatile"" and has no cross-thread synchronization behavior. A volatile load or store may have additional target-specific semantics.; Any volatile operation can have side effects, and any volatile operation; can read and/or modify state which is not accessible via a regular load; or store in this module. Volatile operations may use addresses which do; not point to memory (like MMIO registers). This means the compiler may; not use a volatile operation to prove a non-volatile access to that; address has defined behavior. The allowed side-effects for volatile accesses are limited. If a; non-volatile store to a given address would be legal, a volatile; operation may modify the memory at that address. A volatile operation; may not modify any other memory accessible by the module being compiled.; A volatile operation may not call any code in the current module. In general (without target specific context), the address space of a; volatile operation may not be changed. Different address spaces may; have different trapping behavior when dereferencing an invalid; pointer. The compiler may assume execution will continue after a volatile operation,; so operations which modify memory or may have undefined behavior can be; hoisted past a volatile operation. As an exception to the preceding rule, the compiler may not assume execution; will continue after a volatile store operation. This restriction is necessary; to support the somewhat common pattern in C of intentionally storing to an; invalid pointer to crash the program. In the future, it might make sense to; allow frontends to control this behavior. IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy; or llvm.memmove intrinsics even when those intrinsics ar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:147001,access,accessible,147001,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessible']
Security,"rt of the `ROOTNTupleUtil` library. ### RNTupleInspector; The RNTupleInspector provides insights of an RNTuple, e.g. the distribution of data volume wrt. column types.; It is part of the `ROOTNTupleUtil` library. Ownership Model; ---------------. By default, objects involved in RNTuple I/O (objects read from disk or written to disk) are passed to RNTuple as shared pointers.; Both RNTuple or the application may create the object.; Raw pointers to objects can be passed to RNTuple -- such objects are considered as owned by the application.; The caller has to ensure that the lifetime of the object lasts during the I/O operations. An RNTuple writer that is constructed without a `TFile` object (`RNTupleWriter::Recreate()`) assumes exclusive access to the underlying file.; An RNTuple writer that uses a `TFile` for writing (`RNTupleWriter::Append()`) assumes that the `TFile` object outlives the writer's lifetime.; The serial writer assumes exclusive access to the underlying file during construction, destruction and `Fill()` as well as `CommitCluster()` and `FlushCluster()`.; For `FlushColumns()` and `FillNoFlush()`, the sequential writer assumes exclusive access only if buffered writing is turned off.; The parallel writer assumes exclusive access to the underlying file during all operations on the writer (e.g. construction and destruction) and all operations on any created fill context (e.g. `Fill()` and `FlushCluster()`).; Notable exceptions are `FlushColumns()` and `FillNoFlush()` which are guaranteed to never access the underlying `TFile` during parallel writing (which is always buffered). A `TFile` does not take ownership of any `RNTuple` objects. When reading data, RNTuple uses the `RMiniFile` and `RRawFile` classes to open a given storage path and find the `RNTuple` anchor.; When creating a `RNTupleReader` from an existing anchor object, RNTuple uses `RRawFile` only for files of dynamic type `TFile`, `TDavixFile`, and `TNetXNGFile`.; In either case, the `RRawFile` own",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:17821,access,access,17821,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"rted.; - *RISCV64* only supports up to 11 bit type parameters, 4; 32-bit floating-point parameters, and 4 64-bit floating-point; parameters. This calling convention supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; both the caller and callee are using it.; ""``cc 11``"" - The HiPE calling convention; This calling convention has been implemented specifically for use by; the `High-Performance Erlang; (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the*; native code compiler of the `Ericsson's Open Source Erlang/OTP; system <http://www.erlang.org/download.shtml>`_. It uses more; registers for argument passing than the ordinary C calling; convention and defines no callee-saved registers. The calling; convention properly supports `tail call; optimization <CodeGenerator.html#tail-call-optimization>`_ but requires; that both the caller and the callee use it. It uses a *register pinning*; mechanism, similar to GHC's convention, for keeping frequently; accessed runtime components pinned to specific hardware registers.; At the moment only X86 supports this convention (both 32 and 64; bit).; ""``anyregcc``"" - Dynamic calling convention for code patching; This is a special convention that supports patching an arbitrary code; sequence in place of a call site. This convention forces the call; arguments into registers but allows them to be dynamically; allocated. This can currently only be used with calls to; llvm.experimental.patchpoint because only this intrinsic records; the location of its arguments in a side table. See :doc:`StackMaps`.; ""``preserve_mostcc``"" - The `PreserveMost` calling convention; This calling convention attempts to make the code in the caller as; unintrusive as possible. This convention behaves identically to the `C`; calling convention on how arguments and return values are passed, but it; uses a different set of caller/callee-saved registers. This alleviates the; burden of saving and recovering a lar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:15569,access,accessed,15569,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"rts 16 bytes at; ``%ymm0``, then the runtime can safely optimize by saving only; ``%xmm0``. The stack map format is a contract between an LLVM SVN revision and; the runtime. It is currently experimental and may change in the short; term, but minimizing the need to update the runtime is; important. Consequently, the stack map design is motivated by; simplicity and extensibility. Compactness of the representation is; secondary because the runtime is expected to parse the data; immediately after compiling a module and encode the information in its; own format. Since the runtime controls the allocation of sections, it; can reuse the same stack map space for multiple modules. Stackmap support is currently only implemented for 64-bit; platforms. However, a 32-bit implementation should be able to use the; same format with an insignificant amount of wasted space. .. _stackmap-section:. Stack Map Section; ^^^^^^^^^^^^^^^^^. A JIT compiler can easily access this section by providing its own; memory manager via the LLVM C API; ``LLVMCreateSimpleMCJITMemoryManager()``. When creating the memory; manager, the JIT provides a callback:; ``LLVMMemoryManagerAllocateDataSectionCallback()``. When LLVM creates; this section, it invokes the callback and passes the section name. The; JIT can record the in-memory address of the section at this time and; later parse it to recover the stack map data. For MachO (e.g. on Darwin), the stack map section name is; ""__llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". For ELF (e.g. on Linux), the stack map section name is; "".llvm_stackmaps"". The segment name is ""__LLVM_STACKMAPS"". Stack Map Usage; ===============. The stack map support described in this document can be used to; precisely determine the location of values at a specific position in; the code. LLVM does not maintain any mapping between those values and; any higher-level entity. The runtime must be able to interpret the; stack map record given only the ID, offset, and the order of ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst:16197,access,access,16197,interpreter/llvm-project/llvm/docs/StackMaps.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/StackMaps.rst,1,['access'],['access']
Security,"ructions, or by flat instructions. Multi-dword; access is not supported except by flat and scratch instructions in; GFX9-GFX11. Code that manipulates the stack values in other lanes of a wavefront,; such as by ``addrspacecast``-ing stack pointers to generic ones and taking offsets; that reach other lanes or by explicitly constructing the scratch buffer descriptor,; triggers undefined behavior when it modifies the scratch values of other lanes.; The compiler may assume that such modifications do not occur.; When using code object V5 ``LIBOMPTARGET_STACK_SIZE`` may be used to provide the; private segment size in bytes, for cases where a dynamic stack is used. **Constant 32-bit**; *TODO*. **Buffer Fat Pointer**; The buffer fat pointer is an experimental address space that is currently; unsupported in the backend. It exposes a non-integral pointer that is in; the future intended to support the modelling of 128-bit buffer descriptors; plus a 32-bit offset into the buffer (in total encapsulating a 160-bit; *pointer*), allowing normal LLVM load/store/atomic operations to be used to; model the buffer descriptors used heavily in graphics workloads targeting; the backend. The buffer descriptor used to construct a buffer fat pointer must be *raw*:; the stride must be 0, the ""add tid"" flag must be 0, the swizzle enable bits; must be off, and the extent must be measured in bytes. (On subtargets where; bounds checking may be disabled, buffer fat pointers may choose to enable; it or not). **Buffer Resource**; The buffer resource pointer, in address space 8, is the newer form; for representing buffer descriptors in AMDGPU IR, replacing their; previous representation as `<4 x i32>`. It is a non-integral pointer; that represents a 128-bit buffer descriptor resource (`V#`). Since, in general, a buffer resource supports complex addressing modes that cannot; be easily represented in LLVM (such as implicit swizzled access to structured; buffers), it is **illegal** to perform non-trivial a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:28633,expose,exposes,28633,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['expose'],['exposes']
Security,"ructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const char*``' is; StringRef. For more information on choosing string containers for APIs, please see; :ref:`Passing Strings <string_apis>`. .. _dss_stringref:. llvm/ADT/StringRef.h; ^^^^^^^^^^^^^^^^^^^^. The StringRef class is a simple value class that contains a pointer to a; character and a length, and is quite related to the :ref:`ArrayRef; <dss_arrayref>` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70820,access,access,70820,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"rupted header is not accessed, the corruption; will remain undetected). The following information is stored in the header:. - the class ID for that chunk, which identifies the region where the chunk; resides for Primary backed allocations, or 0 for Secondary backed allocations;. - the state of the chunk (available, allocated or quarantined);. - the allocation type (malloc, new, new[] or memalign), to detect potential; mismatches in the allocation APIs used;. - the size (Primary) or unused bytes amount (Secondary) for that chunk, which is; necessary for reallocation or sized-deallocation operations;. - the offset of the chunk, which is the distance in bytes from the beginning of; the returned chunk to the beginning of the backend allocation (the ""block"");. - the 16-bit checksum;. This header fits within 8 bytes on all platforms supported, and contributes to a; small overhead for each allocation. The checksum is computed using a CRC32 (made faster with hardware support); of the global secret, the chunk pointer itself, and the 8 bytes of header with; the checksum field zeroed out. It is not intended to be cryptographically; strong. The header is atomically loaded and stored to prevent races. This is important; as two consecutive chunks could belong to different threads. We work on local; copies and use compare-exchange primitives to update the headers in the heap; memory, and avoid any type of double-fetching. Randomness; ----------; Randomness is a critical factor to the additional security provided by the; allocator. The allocator trusts the memory mapping primitives of the OS to; provide pages at (mostly) non-predictable locations in memory, as well as the; binaries to be compiled with ASLR. In the event one of those assumptions is; incorrect, the security will be greatly reduced. Scudo further randomizes how; blocks are allocated in the Primary, can randomize how caches are assigned to; threads. Memory reclaiming; -----------------; Primary and Secondary allocators ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:3871,checksum,checksum,3871,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,2,['checksum'],['checksum']
Security,"ry cache. |; +---------------------------+-------------------------------------------------------+; | M_CACHE_SIZE_MAX | Sets the maximum size of entries that can be cached |; | | in the Secondary cache. |; +---------------------------+-------------------------------------------------------+; | M_TSDS_COUNT_MAX | Increases the maximum number of TSDs that can be used |; | | up to the limit specified at compile time. |; +---------------------------+-------------------------------------------------------+. Error Types; ===========. The allocator will output an error message, and potentially terminate the; process, when an unexpected behavior is detected. The output usually starts with; ``""Scudo ERROR:""`` followed by a short summary of the problem that occurred as; well as the pointer(s) involved. Once again, Scudo is meant to be a mitigation,; and might not be the most useful of tools to help you root-cause the issue,; please consider `ASan <https://github.com/google/sanitizers/wiki/AddressSanitizer>`_; for this purpose. Here is a list of the current error messages and their potential cause:. - ``""corrupted chunk header""``: the checksum verification of the chunk header; has failed. This is likely due to one of two things: the header was; overwritten (partially or totally), or the pointer passed to the function is; not a chunk at all;. - ``""race on chunk header""``: two different threads are attempting to manipulate; the same header at the same time. This is usually symptomatic of a; race-condition or general lack of locking when performing operations on that; chunk;. - ``""invalid chunk state""``: the chunk is not in the expected state for a given; operation, eg: it is not allocated when trying to free it, or it's not; quarantined when trying to recycle it, etc. A double-free is the typical; reason this error would occur;. - ``""misaligned pointer""``: we strongly enforce basic alignment requirements, 8; bytes on 32-bit platforms, 16 bytes on 64-bit platforms. If a pointer p",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst:14995,sanitiz,sanitizers,14995,interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ScudoHardenedAllocator.rst,1,['sanitiz'],['sanitizers']
Security,"ry subregions in a; memcpy are padding and what the TBAA tags of the struct are. The current metadata format is very simple. ``!tbaa.struct`` metadata; nodes are a list of operands which are in conceptual groups of three.; For each group of three, the first operand gives the byte offset of a; field in bytes, the second gives its size in bytes, and the third gives; its tbaa tag. e.g.:. .. code-block:: llvm. !4 = !{ i64 0, i64 4, !1, i64 8, i64 4, !2 }. This describes a struct with two fields. The first is at offset 0 bytes; with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes; and has size 4 bytes and has tbaa tag !2. Note that the fields need not be contiguous. In this example, there is a; 4 byte gap between the two fields. This gap represents padding which; does not carry useful data and need not be preserved. '``noalias``' and '``alias.scope``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``noalias`` and ``alias.scope`` metadata provide the ability to specify generic; noalias memory-access sets. This means that some collection of memory access; instructions (loads, stores, memory-accessing calls, etc.) that carry; ``noalias`` metadata can specifically be specified not to alias with some other; collection of memory access instructions that carry ``alias.scope`` metadata.; Each type of metadata specifies a list of scopes where each scope has an id and; a domain. When evaluating an aliasing query, if for some domain, the set; of scopes with that domain in one instruction's ``alias.scope`` list is a; subset of (or equal to) the set of scopes for that domain in another; instruction's ``noalias`` list, then the two memory accesses are assumed not to; alias. Because scopes in one domain don't affect scopes in other domains, separate; domains can be used to compose multiple independent noalias sets. This is; used for example during inlining. As the noalias function parameters are; turned into noalias scope metadata, a new domain is used every",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:281084,access,access,281084,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ry. It is higher; performance than global memory. It is allocated by the runtime. The data; store (DS) instructions can be used to access it. **Local**; The local address space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates the wavefronts of a; work-group, and freed when all the wavefronts of a work-group have; terminated. All wavefronts belonging to the same work-group will access the; same memory for any given local address. However, the same local address; accessed by wavefronts belonging to different work-groups will access; different memory. It is higher performance than global memory. The data store; (DS) instructions can be used to access it. **Private**; The private address space uses the hardware scratch memory support which; automatically allocates memory when it creates a wavefront and frees it when; a wavefronts terminates. The memory accessed by a lane of a wavefront for any; given private address will be different to the memory accessed by another lane; of the same or different wavefront for the same private address. If a kernel dispatch uses scratch, then the hardware allocates memory from a; pool of backing memory allocated by the runtime for each wavefront. The lanes; of the wavefront access this using dword (4 byte) interleaving. The mapping; used from private address to backing memory address is:. ``wavefront-scratch-base +; ((private-address / 4) * wavefront-size * 4) +; (wavefront-lane-id * 4) + (private-address % 4)``. If each lane of a wavefront accesses the same private address, the; interleaving results in adjacent dwords being accessed and hence requires; fewer cache lines to be fetched. There are different ways that the wavefront scratch base address is; determined by a wavefront (see; :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). Scratch memory can be accessed in an interleaved manner using buffer; instructions with the scratch buffer descriptor and per wavefront scratch; offset",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:26699,access,accessed,26699,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],['accessed']
Security,"ry:; %promise = alloca i32; %id = call token @llvm.coro.id(i32 0, ptr %promise, ptr null, ptr null); %need.dyn.alloc = call i1 @llvm.coro.alloc(token %id); br i1 %need.dyn.alloc, label %dyn.alloc, label %coro.begin; dyn.alloc:; %size = call i32 @llvm.coro.size.i32(); %alloc = call ptr @malloc(i32 %size); br label %coro.begin; coro.begin:; %phi = phi ptr [ null, %entry ], [ %alloc, %dyn.alloc ]; %hdl = call noalias ptr @llvm.coro.begin(token %id, ptr %phi); br label %loop; loop:; %n.val = phi i32 [ %n, %coro.begin ], [ %inc, %loop ]; %inc = add nsw i32 %n.val, 1; store i32 %n.val, ptr %promise; %0 = call i8 @llvm.coro.suspend(token none, i1 false); switch i8 %0, label %suspend [i8 0, label %loop; i8 1, label %cleanup]; cleanup:; %mem = call ptr @llvm.coro.free(token %id, ptr %hdl); call void @free(ptr %mem); br label %suspend; suspend:; %unused = call i1 @llvm.coro.end(ptr %hdl, i1 false, token none); ret ptr %hdl; }. A coroutine consumer can rely on the `coro.promise`_ intrinsic to access the; coroutine promise. .. code-block:: llvm. define i32 @main() {; entry:; %hdl = call ptr @f(i32 4); %promise.addr = call ptr @llvm.coro.promise(ptr %hdl, i32 4, i1 false); %val0 = load i32, ptr %promise.addr; call void @print(i32 %val0); call void @llvm.coro.resume(ptr %hdl); %val1 = load i32, ptr %promise.addr; call void @print(i32 %val1); call void @llvm.coro.resume(ptr %hdl); %val2 = load i32, ptr %promise.addr; call void @print(i32 %val2); call void @llvm.coro.destroy(ptr %hdl); ret i32 0; }. After example in this section is compiled, result of the compilation will be:. .. code-block:: llvm. define i32 @main() {; entry:; tail call void @print(i32 4); tail call void @print(i32 5); tail call void @print(i32 6); ret i32 0; }. .. _final:; .. _final suspend:. Final Suspend; -------------. A coroutine author or a frontend may designate a particular suspend to be final,; by setting the second argument of the `coro.suspend`_ intrinsic to `true`.; Such a suspend point has two properti",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst:23700,access,access,23700,interpreter/llvm-project/llvm/docs/Coroutines.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Coroutines.rst,1,['access'],['access']
Security,"s ... / (4; workers still sending). This asserts socket activity and fixes the timeout; problems during long merging phases reported in a few cases.; In TFileMerger, create directly the output file at the; final destination do not make a local copy in the temp directory first; (if needed, one can always set the temporary destination to temp; followed by a TFile::Cp to the final destination); this allows to avoid; reported problems with small temp partitions (see Forum).; In XrdProofConn, enable cycling through the; authentication protocol presented by the server. This only holds for; the choice of the protocol, because the server currently supports only; one full handshake.; In test/stressProof.cxx, avoid interferences between the; settings used for the PROOF tutorial and possible local settings; (daemon, dataset manager).; Add possibility to control the automatic re-loading of; the <proof.conf> file via the keyword; 'reload:1'/'reload:0'; in the xpd.resource directive.; Move the validation of <proof.conf> at the; moment of use; this allows to specify a file path and to dynamically; create/modify/destroy the file; used by PoD.; Improve displaying speed of large log files. Fixes. Fix two severe; bugs in the way TTreeCache; was used in PROOF: one bug was de facto disactivating the cache; the; other was causing a std::bad_alloc exception to be thrown on workers; when opening a remote file after a local one.    ; Fix several problems in TChain::Draw including. drawing into an existing histogram, i.e.; chain->Draw(""var>>myhist"");. treatment of histogram merging in case of small; statistics, i.e. when; the autobinning is not or only partially active;. usage of existing canvases when different histogram; names are specified;. Fix a problem causing a duplication of the final feedback; object. Fix problem with determining the subdir name in; TFileMerger::MergeRecursive on Windows; Make sure that the default sandbox is under $HOME/.proof; Fix a problem with dataset validation",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html:8444,validat,validation,8444,proof/doc/v524/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v524/index.html,2,['validat'],['validation']
Security,"s a global pointer since only the device global memory is visible; and managed on the host side. The vector and scalar L1 caches are invalidated; of volatile data before each kernel dispatch execution to allow constant; memory to change values between kernel dispatches. **Region**; The region address space uses the hardware Global Data Store (GDS). All; wavefronts executing on the same device will access the same memory for any; given region address. However, the same region address accessed by wavefronts; executing on different devices will access different memory. It is higher; performance than global memory. It is allocated by the runtime. The data; store (DS) instructions can be used to access it. **Local**; The local address space uses the hardware Local Data Store (LDS) which is; automatically allocated when the hardware creates the wavefronts of a; work-group, and freed when all the wavefronts of a work-group have; terminated. All wavefronts belonging to the same work-group will access the; same memory for any given local address. However, the same local address; accessed by wavefronts belonging to different work-groups will access; different memory. It is higher performance than global memory. The data store; (DS) instructions can be used to access it. **Private**; The private address space uses the hardware scratch memory support which; automatically allocates memory when it creates a wavefront and frees it when; a wavefronts terminates. The memory accessed by a lane of a wavefront for any; given private address will be different to the memory accessed by another lane; of the same or different wavefront for the same private address. If a kernel dispatch uses scratch, then the hardware allocates memory from a; pool of backing memory allocated by the runtime for each wavefront. The lanes; of the wavefront access this using dword (4 byte) interleaving. The mapping; used from private address to backing memory address is:. ``wavefront-scratch-base +; ((private-a",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:26218,access,access,26218,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"s active after the first modification has been; applied. It allows restoring the initial parameters of the shape. NOTE: In this version the ""*Undo*"" does not allow restoring an; intermediate state of the parameters that was applied - it will always; restore the parameters at the moment the shape was edited. All material properties changes are undoable. The mixture editor; currently allows adding elements one by one in the mixture composition.; This can be done either by element weight fraction or by number of; atoms. Once an element was added using one method the other method is not; selectable anymore. Summing component fractions up to 1 in the final; mixture is the user responsibility. Adding materials as components of a; mixture is not supported in this version. The elements that were added to the mixture appear in the bottom of the; mixture editor. The operations performed on mixture are not undoable. ### Creation of New Objects. As described above, all geometry object creators are accessible within; the geometry manager editor frame. Generally, if the new object that; needs to be created does not depend on other objects, it will be built; with a set of default parameters. This is the case for all shapes; (except composite shapes) and matrices. For all the other objects the; interface forces the selection of components before creating the object. ### Editing Volumes. Volumes are hierarchical components in the geometry, therefore their; editor is more complex. It provides the following functionalities:. - *General*. This category allows changing the name of the volume and; selecting other shape or medium among existing ones. - *Daughters*. The category allows removing existing daughter nodes or; adding new ones. The button ""*Position*"" allows editing the; positioning matrix of a given node. ![Setting volume properties and modifying volume hierarchy](pictures/020001F5.jpg); ![Setting volume properties and modifying volume hierarchy](pictures/020001F6.jpg). - *Visua",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:171843,access,accessible,171843,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessible']
Security,"s data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"")",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66744,attack,attacker,66744,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,2,"['attack', 'inject']","['attacker', 'inject']"
Security,"s declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should read a; good C++ book if they want more details. Especially since, besides; public and private, a member can be protected. Usually, one puts; private the methods that the class uses internally, like some; utilities classes, and that the programmer does not want to be seen; in the outside world. With ""good"" C++ practice (which we have tried to use in ROOT), all; data members of a class are private. This is called data encapsulation; and is one of the strongest advantages of Object Oriented Programming; (OOP). Private data members of a class are not visible, except to the; class itself. So, from the outside world, if one wants to access those; data members, one should use so called ""getters"" and ""setters""; methods, which are special methods used only to get or set the data; members. The advantage is that if the programmers want to modify the; inner workings of their classes, they can do so without changing what; the user sees. The user does not even have to know that something has; changed (for the better, hopefully). For example, in our **`TArrow`**; class, we would have set the data member `ArrowHeadSize` private. The; setter method is `SetArrowSize()`, we do not need a getter method:. ``` {.cpp}; class TArrow : public TLine {; private:; int ArrowHeadSize;; public:; void Draw();; void SetArrowSize(int arrowsize);; }; ```. To define an arrow object you call the constructor. This will also; call the constructor of **`TLine`**, which is the parent class of; **`TArrow`**, automatically. Then we can call any of the line or arrow; public methods:. ``` {.cpp}; root[] TArrow *myarrow = new TArrow(1,5,89,124);; root[] myarrow->SetArrowSize(10);; root[] myarrow->Draw();; `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:6253,access,access,6253,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['access'],['access']
Security,"s for debug-info"" OFF). set(LLVM_CODESIGNING_IDENTITY """" CACHE STRING; ""Sign executables and dylibs with the given identity or skip if empty (Darwin Only)""). # If enabled, verify we are on a platform that supports oprofile.; if( LLVM_USE_OPROFILE ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""OProfile support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_OPROFILE ). option(LLVM_USE_PERF; ""Use perf JIT interface to inform perf about JIT code"" OFF). # If enabled, verify we are on a platform that supports perf.; if( LLVM_USE_PERF ); if( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); message(FATAL_ERROR ""perf support is available on Linux only.""); endif( NOT CMAKE_SYSTEM_NAME MATCHES ""Linux"" ); endif( LLVM_USE_PERF ). set(LLVM_USE_SANITIZER """" CACHE STRING; ""Define the sanitizer used to build binaries and tests.""); option(LLVM_OPTIMIZE_SANITIZED_BUILDS ""Pass -O1 on debug sanitizer builds"" ON); set(LLVM_UBSAN_FLAGS; ""-fsanitize=undefined -fno-sanitize=vptr,function -fno-sanitize-recover=all""; CACHE STRING; ""Compile flags set to enable UBSan. Only used if LLVM_USE_SANITIZER contains 'Undefined'.""); set(LLVM_LIB_FUZZING_ENGINE """" CACHE PATH; ""Path to fuzzing library for linking with fuzz targets""). option(LLVM_USE_SPLIT_DWARF; ""Use -gsplit-dwarf when compiling llvm and --gdb-index when linking."" OFF). # Define an option controlling whether we should build for 32-bit on 64-bit; # platforms, where supported.; if( CMAKE_SIZEOF_VOID_P EQUAL 8 AND NOT (WIN32 OR ${CMAKE_SYSTEM_NAME} MATCHES ""AIX"")); # TODO: support other platforms and toolchains.; option(LLVM_BUILD_32_BITS ""Build 32 bits executables and libraries."" OFF); endif(). # Define the default arguments to use with 'lit', and an option for the user to; # override.; set(LIT_ARGS_DEFAULT ""-sv""); if (MSVC_IDE OR XCODE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFAULT} --no-progress-bar""); endif(); if(LLVM_INDIVIDUAL_TEST_COVERAGE); set(LIT_ARGS_DEFAULT ""${LIT_ARGS_DEFA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt:28411,sanitiz,sanitizer,28411,interpreter/llvm-project/llvm/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/CMakeLists.txt,3,['sanitiz'],"['sanitize', 'sanitize-recover', 'sanitizer']"
Security,"s groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determin",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311760,access,access,311760,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"s initializing a parameter include?; Unknown. 2600; DR; Type dependency of placeholder types; Unknown. 2601; C++23; Tracking of created and destroyed subobjects; Unknown. 2602; C++23; consteval defaulted functions; Unknown. 2603; C++23; Holistic functional equivalence for function templates; Unknown. 2604; C++23; Attributes for an explicit specialization; Unknown. 2605; C++23; Implicit-lifetime aggregates; Unknown. 2606; CD6; static_cast from ""pointer to void"" does not handle similar types; Unknown. 2607; drafting; Visibility of enumerator names; Not resolved. 2608; CD6; Omitting an empty template argument list; Unknown. 2609; open; Padding in class types; Not resolved. 2610; C++23; Indirect private base classes in aggregates; Unknown. 2611; C++23; Missing parentheses in expansion of fold-expression could cause syntactic reinterpretation; Unknown. 2612; C++23; Incorrect comment in example; Unknown. 2613; C++23; Incomplete definition of resumer; Unknown. 2614; C++23; Unspecified results for class member access; Unknown. 2615; C++23; Missing __has_cpp_attribute(assume); Unknown. 2616; C++23; Imprecise restrictions on break and continue; Unknown. 2617; review; Default template arguments for template members of non-template classes; Not resolved. 2618; C++23; Substitution during deduction should exclude exception specifications; Unknown. 2619; C++23; Kind of initialization for a designated-initializer-list; Unknown. 2620; C++23; Nonsensical disambiguation rule; Unknown. 2621; C++23; Kind of lookup for using enum declarations; Clang 16. 2622; C++23; Compounding types from function and pointer-to-member types; Unknown. 2623; drafting; Invoking destroying operator delete for constructor failure; Not resolved. 2624; C++23; Array delete expression with no array cookie; Unknown. 2625; C++23; Deletion of pointer to out-of-lifetime object; Unknown. 2626; C++23; Rephrase ones' complement using base-2 representation; Unknown. 2627; C++23; Bit-fields and narrowing conversions; Unkn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:180110,access,access,180110,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"s is a violation or which action; will be taken. Specific guidance is in the checklist below. For in-person events that have a violation reported, the report should be sent; to the Code of Conduct committee within 24 hours by the on-site CoC response; team. . .. _Immediate Response Checklist:. Immediate Response Checklist; ============================. The CoC committee generally works, decides, and communicates together. If the; report indicates that an immediate response is required and other committee; members are not available, any committee member may take the immediate action; they think is necessary. In-person Code of Conduct response teams should use; this checklist to determine if an immediate response is needed. * If the incident involves physical danger, contact the appropriate law; enforcement or event security immediately. Ensure the reporter feels safe and; stay with them if possible until help arrives.; * If the act is ongoing and involves harassment or threats against someone in; any space (online or physical), any appropriate response (e.g., ban, physical; removal, or moderation) may be used to immediately stop it.; * For events that include talks, organizers should end talks early if the; violations include harassment or violent threats. There may be talks where; other types of code of conduct violations occur and organizers should do ; their best to determine if a talk should be ended early or not. . When undertaking an immediate response, document the action and notify the; committee within 24 hours. . Response Procedure; ==================. The following is a summary of the steps the committee takes when responding to; a reported incident. . 1. Determine if there is a need for an :ref:`immediate response<Immediate; Response Checklist>`. 2. :ref:`Acknowledge the report<Receiving a report>` within 24 hours. 3. :ref:`Discuss the incident report<Incident Response Assessment>`, gather; more information, and determine a :ref:`resolution<Resolutions>`. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst:2503,threat,threats,2503,interpreter/llvm-project/llvm/docs/ResponseGuide.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ResponseGuide.rst,1,['threat'],['threats']
Security,"s is not recommended. If it's; absolutely necessary to use this attribute, be very explicit about using the; typedef, and do not assume that it will be preserved by language features like; ``__typeof`` and C++ template argument substitution. .. admonition:: Rationale. Any compiler operation which incidentally strips type ""sugar"" from a type; will yield a type without the attribute, which may result in unexpected; behavior. .. _arc.objects.retains:. Retain count semantics; ----------------------. A retainable object pointer is either a :arc-term:`null pointer` or a pointer; to a valid object. Furthermore, if it has block pointer type and is not; ``null`` then it must actually be a pointer to a block object, and if it has; ``Class`` type (possibly protocol-qualified) then it must actually be a pointer; to a class object. Otherwise ARC does not enforce the Objective-C type system; as long as the implementing methods follow the signature of the static type.; It is undefined behavior if ARC is exposed to an invalid pointer. For ARC's purposes, a valid object is one with ""well-behaved"" retaining; operations. Specifically, the object must be laid out such that the; Objective-C message send machinery can successfully send it the following; messages:. * ``retain``, taking no arguments and returning a pointer to the object.; * ``release``, taking no arguments and returning ``void``.; * ``autorelease``, taking no arguments and returning a pointer to the object. The behavior of these methods is constrained in the following ways. The term; :arc-term:`high-level semantics` is an intentionally vague term; the intent is; that programmers must implement these methods in a way such that the compiler,; modifying code in ways it deems safe according to these constraints, will not; violate their requirements. For example, if the user puts logging statements; in ``retain``, they should not be surprised if those statements are executed; more or less often depending on optimization settings",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:12912,expose,exposed,12912,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['expose'],['exposed']
Security,"s it. Because of this, any reference to; the value produced by an instruction (or the value available as an incoming; argument, for example) is represented as a direct pointer to the instance of the; class that represents this value. Although this may take some getting used to,; it simplifies the representation and makes it easier to manipulate. .. _m_Value:. Important Public Members of the ``Value`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. * | ``Value::use_iterator`` - Typedef for iterator over the use-list; | ``Value::const_use_iterator`` - Typedef for const_iterator over the; use-list; | ``unsigned use_size()`` - Returns the number of users of the value.; | ``bool use_empty()`` - Returns true if there are no users.; | ``use_iterator use_begin()`` - Get an iterator to the start of the; use-list.; | ``use_iterator use_end()`` - Get an iterator to the end of the use-list.; | ``User *use_back()`` - Returns the last element in the list. These methods are the interface to access the def-use information in LLVM.; As with all other iterators in LLVM, the naming conventions follow the; conventions defined by the STL_. * ``Type *getType() const``; This method returns the Type of the Value. * | ``bool hasName() const``; | ``std::string getName() const``; | ``void setName(const std::string &Name)``. This family of methods is used to access and assign a name to a ``Value``, be; aware of the :ref:`precaution above <nameWarning>`. * ``void replaceAllUsesWith(Value *V)``. This method traverses the use list of a ``Value`` changing all User_\ s of the; current value to refer to ""``V``"" instead. For example, if you detect that an; instruction always produces a constant value (for example through constant; folding), you can replace all uses of the instruction with the constant like; this:. .. code-block:: c++. Inst->replaceAllUsesWith(ConstVal);. .. _User:. The ``User`` class; ------------------. ``#include ""llvm/IR/User.h""``. header source: `User.h <https://llvm.org/d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:143780,access,access,143780,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"s linked with %ROOT graphical libraries loaded on demand in order to; control visualization actions. \anchor GP02; ## Navigation and Tracking. Tracking is the feature allowing the transport of a given particle; knowing its kinematics. A state is determined by any combination of the; position \f$\vec{r}\f$ and direction \f$\vec{n}\f$ with respect to the world; reference frame. The direction \f$\vec{n}\f$ must be a unit vector having as; components the director cosines. The full classification of a given; state will provide the following information: the deepest physical node; containing the position vector, the distance to the closest boundary; along the direction vector, the next physical node after propagating the; current point with this distance and the safety distance to the nearest; boundary. This information allows the propagation of particles inside a; detector geometry by taking into account both geometrical and physical; constraints. We will hereby describe the user interface of `TGeo` to access; tracking functionality. This allows either developing a tracker for; simple navigation within a given geometry, either interfacing to an; external tracking engine such as GEANT. Note that the abstract interface; for external trackers can be found in `$ROOTSYS/vmc` folder and it can; be used to run GEANT3, GEANT4 and FLUKA-based simulations (\*) by using; directly a geometry described with %ROOT. The interface methods related to tracking are incorporated into; TGeoManager class and implemented in the navigator class; TGeoNavigator. In order to be able to start tracking, one has to; define the initial state providing the starting point \f$\vec{r_0}\f$; and direction \f$\vec{n_0}\f$ .; There are several ways of doing that. \anchor GP02a; ### TGeoNavigator Class. One geometry may have several independent navigators to query to; localize points or compute distances. The geometry manager holds a list; of active navigators accessible via:. ~~~{.cpp}; TObjArray *navigators",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:62129,access,access,62129,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['access'],['access']
Security,"s makes up the *guarded; allocation pool*. Buffer Underflow/Overflow Detection; -----------------------------------. We gain buffer-overflow and buffer-underflow detection through these guard; pages. When a memory access overruns the allocated buffer, it will touch the; inaccessible guard page, causing memory exception. This exception is caught and; handled by the internal crash handler. Because each allocation is recorded with; metadata about where (and by what thread) it was allocated and deallocated, we; can provide information that will help identify the root cause of the bug. Allocations are randomly selected to be either left- or right-aligned to provide; equal detection of both underflows and overflows. Use after Free Detection; ------------------------. The guarded allocation pool also provides use-after-free detection. Whenever a; sampled allocation is deallocated, we map its guarded slot as inaccessible. Any; memory accesses after deallocation will thus trigger the crash handler, and we; can provide useful information about the source of the error. Please note that the use-after-free detection for a sampled allocation is; transient. To keep memory overhead fixed while still detecting bugs, deallocated; slots are randomly reused to guard future allocations. Usage; =====. GWP-ASan already ships by default in the; `Scudo Hardened Allocator <https://llvm.org/docs/ScudoHardenedAllocator.html>`_,; so building with ``-fsanitize=scudo`` is the quickest and easiest way to try out; GWP-ASan. Options; -------. GWP-ASan's configuration is managed by the supporting allocator. We provide a; generic configuration management library that is used by Scudo. It allows; several aspects of GWP-ASan to be configured through the following methods:. - When the GWP-ASan library is compiled, by setting; ``-DGWP_ASAN_DEFAULT_OPTIONS`` to the options string you want set by default.; If you're building GWP-ASan as part of a compiler-rt/LLVM build, add it during; cmake configure time (e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst:4420,access,accesses,4420,interpreter/llvm-project/llvm/docs/GwpAsan.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GwpAsan.rst,1,['access'],['accesses']
Security,"s may grow very large, even for small functions. Path Tracking; =============. These checkers print information about the path taken by the analyzer engine. - debug.DumpCalls: Prints out every function or method call encountered during a; path traversal. This is indented to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2351,secur,security,2351,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,1,['secur'],['security']
Security,"s non-checked code to be the first; code executed. However, this requires a load from TLS in the entry block, a store to TLS; before every call and every ret, and a load from TLS after every call. As a; consequence it is expected to be substantially more expensive even than using; `%rsp` and potentially `lfence` within the function entry block. ##### Define a new ABI and/or calling convention. We could define a new ABI and/or calling convention to explicitly pass the; predicate state in and out of functions. This may be interesting if none of the; alternatives have adequate performance, but it makes deployment and adoption; dramatically more complex, and potentially infeasible. ## High-Level Alternative Mitigation Strategies. There are completely different alternative approaches to mitigating variant 1; attacks. [Most](https://lwn.net/Articles/743265/); [discussion](https://lwn.net/Articles/744287/) so far focuses on mitigating; specific known attackable components in the Linux kernel (or other kernels) by; manually rewriting the code to contain an instruction sequence that is not; vulnerable. For x86 systems this is done by either injecting an `lfence`; instruction along the code path which would leak data if executed speculatively; or by rewriting memory accesses to have branch-less masking to a known safe; region. On Intel systems, `lfence` [will prevent the speculative load of secret; data](https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf)). However, this relies on finding and enumerating all possible points in code; which could be attacked to leak information. While in some cases static; analysis is effective at doing this ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:43696,attack,attackable,43696,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attackable']
Security,"s not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3669,access,access,3669,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,1,['access'],['access']
Security,"s of scratch memory used by the shader.; "".lds_size"" integer Size in bytes of LDS memory.; "".vgpr_count"" integer Number of VGPRs used by the shader.; "".sgpr_count"" integer Number of SGPRs used by the shader.; "".stack_frame_size_in_bytes"" integer Amount of stack size used by the shader.; "".shader_subtype"" string Shader subtype/kind. Values include:. - ""Unknown"". ============================= ============== =================================================================. .. .. table:: AMDPAL Code Object Register Map; :name: amdgpu-amdpal-code-object-register-map-table. ========================== ============== ====================================================================; 32-bit Integer Key Value Type Description; ========================== ============== ====================================================================; ``reg offset`` 32-bit integer ``reg offset`` is the dword offset into the GFXIP register space of; a GRBM register (i.e., driver accessible GPU register number, not; shader GPR register number). The driver is required to program each; specified register to the corresponding specified value when; executing this pipeline. Typically, the ``reg offsets`` are the; ``uint16_t`` offsets to each register as defined by the hardware; chip headers. The register is set to the provided value. However, a; ``reg offset`` that specifies a user data register (e.g.,; COMPUTE_USER_DATA_0) needs special treatment. See; :ref:`amdgpu-amdpal-code-object-user-data-section` section for more; information.; ========================== ============== ====================================================================. .. _amdgpu-amdpal-code-object-user-data-section:. User Data; +++++++++. Each hardware stage has a set of 32-bit physical SPI *user data registers*; (either 16 or 32 based on graphics IP and the stage) which can be; written from a command buffer and then loaded into SGPRs when waves are; launched via a subsequent dispatch or draw operation. This is the w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:412621,access,accessible,412621,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessible']
Security,"s r2, ha16(.CPI_X_2); lfd f1, lo16(.CPI_X_2)(r2); lis r2, ha16(.CPI_X_3); lfd f2, lo16(.CPI_X_3)(r2); fmadd f1, f0, f1, f2; blr. It would be better to materialize .CPI_X into a register, then use immediates; off of the register to avoid the lis's. This is even more important in PIC ; mode. Note that this (and the static variable version) is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. Here's another example (the sgn function):; double testf(double a) {; return a == 0.0 ? 0.0 : (a > 0.0 ? 1.0 : -1.0);; }. it produces a BB like this:; LBB1_1: ; cond_true; lis r2, ha16(LCPI1_0); lfs f0, lo16(LCPI1_0)(r2); lis r2, ha16(LCPI1_1); lis r3, ha16(LCPI1_2); lfs f2, lo16(LCPI1_2)(r3); lfs f3, lo16(LCPI1_1)(r2); fsub f0, f0, f1; fsel f1, f0, f2, f3; blr . ===-------------------------------------------------------------------------===. PIC Code Gen IPO optimization:. Squish small scalar globals together into a single global struct, allowing the ; address of the struct to be CSE'd, avoiding PIC accesses (also reduces the size; of the GOT on targets with one). Note that this is discussed here for GCC:; http://gcc.gnu.org/ml/gcc-patches/2006-02/msg00133.html. ===-------------------------------------------------------------------------===. Fold add and sub with constant into non-extern, non-weak addresses so this:. static int a;; void bar(int b) { a = b; }; void foo(unsigned char *c) {; *c = a;; }. So that . _foo:; lis r2, ha16(_a); la r2, lo16(_a)(r2); lbz r2, 3(r2); stb r2, 0(r3); blr. Becomes. _foo:; lis r2, ha16(_a+3); lbz r2, lo16(_a+3)(r2); stb r2, 0(r3); blr. ===-------------------------------------------------------------------------===. We should compile these two functions to the same thing:. #include <stdlib.h>; void f(int a, int b, int *P) {; *P = (a-b)>=0?(a-b):(b-a);; }; void g(int a, int b, int *P) {; *P = abs(a-b);; }. Further, they should compile to something better than:. _g:; subf r2, r4, r3; subfic r3, r2, 0; cmpwi cr0, r2, -1;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt:2644,access,accesses,2644,interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/README.txt,2,['access'],['accesses']
Security,"s section we only mention loads. Stores have exactly the same problems as their associated loads, so have been skipped for brevity. Considerations; ==============. LLVM IR Lane ordering; ---------------------. LLVM IR has first class vector types. In LLVM IR, the zero'th element of a vector resides at the lowest memory address. The optimizer relies on this property in certain areas, for example when concatenating vectors together. The intention is for arrays and vectors to have identical memory layouts - ``[4 x i8]`` and ``<4 x i8>`` should be represented the same in memory. Without this property there would be many special cases that the optimizer would have to cleverly handle. Use of ``LDR`` would break this lane ordering property. This doesn't preclude the use of ``LDR``, but we would have to do one of two things:. 1. Insert a ``REV`` instruction to reverse the lane order after every ``LDR``.; 2. Disable all optimizations that rely on lane layout, and for every access to an individual lane (``insertelement``/``extractelement``/``shufflevector``) reverse the lane index. AAPCS; -----. The ARM procedure call standard (AAPCS) defines the ABI for passing vectors between functions in registers. It states:. When a short vector is transferred between registers and memory it is treated as an opaque object. That is a short vector is stored in memory as if it were stored with a single ``STR`` of the entire register; a short vector is loaded from memory using the corresponding ``LDR`` instruction. On a little-endian system this means that element 0 will always contain the lowest addressed element of a short vector; on a big-endian system element 0 will contain the highest-addressed element of a short vector. -- Procedure Call Standard for the ARM 64-bit Architecture (AArch64), 4.1.2 Short Vectors. The use of ``LDR`` and ``STR`` as the ABI defines has at least one advantage over ``LD1`` and ``ST1``. ``LDR`` and ``STR`` are oblivious to the size of the individual lanes of a ve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst:5414,access,access,5414,interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/BigEndianNEON.rst,1,['access'],['access']
Security,"s system, in particular; if you have already drawn for example a histogram in the mother pad. The; only thing left is to draw the pad:. ``` {.cpp}; root[] spad1->Draw(); ```. If you want more sub-pads, you have to repeat this procedure as many; times as necessary. #### Dividing a Canvas into Sub-Pads. The manual way of dividing a pad into sub-pads is sometimes very; tedious. There is a way to automatically generate horizontal and; vertical sub-pads inside a given pad. ``` {.cpp}; root[] pad1->Divide(3,2); ```. ![Dividing a pad into 6 sub-pads](pictures/030000A5.png). ![Dividing a pad into 6 sub-pads](pictures/020000A6.jpg). If `pad1` is a pad then, it will divide the pad into 3 columns of 2; sub-pads. The generated sub-pads get names `pad1_i` where the index; `i=1` to `nxm` (in our case `pad1_1`, `pad1_2`...`pad1_6)`. The names; `pad1_1 `etc... correspond to new variables in Cling, so you may use them; as soon as the executed method was `pad->Divide()`. However, in a; compiled program, one has to access these objects. Remember that a pad; contains other objects and that these objects may themselves be pads. So; we can use the `GetPrimitive()` method:. ``` {.cpp}; TPad* pad1_1 = (TPad*)(pad1->GetPrimitive(""pad1_1"")); ```. One question remains. In case one does an automatic divide, how one can; set the default margins between pads? This is done by adding two; parameters to `Divide()`, which are the margins in `x` and `y`:. ``` {.cpp}; root[] pad1->Divide(3,2,0.1,0.1); ```. The margins are here set to 10% of the parent pad width. ### Updating the Pad. For performance reasons, a pad is not updated with every change. For; example, changing the coordinates of the pad does not automatically; redraw it. Instead, the pad has a ""bit-modified"" that triggers a redraw.; This bit is automatically set by:. - Touching the pad with the mouse - for example resizing it with the; mouse. - Finishing the execution of a script. - Adding a new primitive or modifying some primitives for exa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md:25621,access,access,25621,documentation/users-guide/Graphics.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Graphics.md,1,['access'],['access']
Security,"s the JIT know about sin and cos? The answer is surprisingly; simple: The KaleidoscopeJIT has a straightforward symbol resolution rule that; it uses to find symbols that aren't available in any given module: First; it searches all the modules that have already been added to the JIT, from the; most recent to the oldest, to find the newest definition. If no definition is; found inside the JIT, it falls back to calling ""``dlsym(""sin"")``"" on the; Kaleidoscope process itself. Since ""``sin``"" is defined within the JIT's; address space, it simply patches up calls in the module to call the libm; version of ``sin`` directly. But in some cases this even goes further:; as sin and cos are names of standard math functions, the constant folder; will directly evaluate the function calls to the correct result when called; with constants like in the ""``sin(1.0)``"" above. In the future we'll see how tweaking this symbol resolution rule can be used to; enable all sorts of useful features, from security (restricting the set of; symbols available to JIT'd code), to dynamic code generation based on symbol; names, and even lazy compilation. One immediate benefit of the symbol resolution rule is that we can now extend; the language by writing arbitrary C++ code to implement operations. For example,; if we add:. .. code-block:: c++. #ifdef _WIN32; #define DLLEXPORT __declspec(dllexport); #else; #define DLLEXPORT; #endif. /// putchard - putchar that takes a double and returns 0.; extern ""C"" DLLEXPORT double putchard(double X) {; fputc((char)X, stderr);; return 0;; }. Note, that for Windows we need to actually export the functions because; the dynamic symbol loader will use ``GetProcAddress`` to find the symbols. Now we can produce simple output to the console by using things like:; ""``extern putchard(x); putchard(120);``"", which prints a lowercase 'x'; on the console (120 is the ASCII code for 'x'). Similar code could be; used to implement file I/O, console input, and many other capabilities;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst:23570,secur,security,23570,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl04.rst,1,['secur'],['security']
Security,"s this metadata to efficiently; check (at each call site) that a given address corresponds to either a; valid vtable or function pointer for a given class or function type, and its; whole-program devirtualization pass uses the metadata to identify potential; callees for a given virtual call. To use the mechanism, a client creates metadata nodes with two elements:. 1. a byte offset into the global (generally zero for functions); 2. a metadata object representing an identifier for the type. These metadata nodes are associated with globals by using global object; metadata attachments with the ``!type`` metadata kind. Each type identifier must exclusively identify either global variables; or functions. .. admonition:: Limitation. The current implementation only supports attaching metadata to functions on; the x86-32 and x86-64 architectures. An intrinsic, :ref:`llvm.type.test <type.test>`, is used to test whether a; given pointer is associated with a type identifier. .. _control flow integrity: https://clang.llvm.org/docs/ControlFlowIntegrity.html. Representing Type Information using Type Metadata; =================================================. This section describes how Clang represents C++ type information associated with; virtual tables using type metadata. Consider the following inheritance hierarchy:. .. code-block:: c++. struct A {; virtual void f();; };. struct B : A {; virtual void f();; virtual void g();; };. struct C {; virtual void h();; };. struct D : A, C {; virtual void f();; virtual void h();; };. The virtual table objects for A, B, C and D look like this (under the Itanium ABI):. .. csv-table:: Virtual Table Layout for A, B, C, D; :header: Class, 0, 1, 2, 3, 4, 5, 6. A, A::offset-to-top, &A::rtti, &A::f; B, B::offset-to-top, &B::rtti, &B::f, &B::g; C, C::offset-to-top, &C::rtti, &C::h; D, D::offset-to-top, &D::rtti, &D::f, &D::h, D::offset-to-top, &D::rtti, thunk for &D::h. When an object of type A is constructed, the address of ``&A::f`` in A's; vir",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst:1240,integrity,integrity,1240,interpreter/llvm-project/llvm/docs/TypeMetadata.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/TypeMetadata.rst,1,['integrity'],['integrity']
Security,"s to require the user to specify types for every variable; definition, and record the type of the variable in the symbol table; along with its Value\*.; - **arrays, structs, vectors, etc** - Once you add types, you can start; extending the type system in all sorts of interesting ways. Simple; arrays are very easy and are quite useful for many different; applications. Adding them is mostly an exercise in learning how the; LLVM `getelementptr <../../LangRef.html#getelementptr-instruction>`_ instruction; works: it is so nifty/unconventional, it `has its own; FAQ <../../GetElementPtr.html>`_!; - **standard runtime** - Our current language allows the user to access; arbitrary external functions, and we use it for things like ""printd""; and ""putchard"". As you extend the language to add higher-level; constructs, often these constructs make the most sense if they are; lowered to calls into a language-supplied runtime. For example, if; you add hash tables to the language, it would probably make sense to; add the routines to a runtime, instead of inlining them all the way.; - **memory management** - Currently we can only access the stack in; Kaleidoscope. It would also be useful to be able to allocate heap; memory, either with calls to the standard libc malloc/free interface; or with a garbage collector. If you would like to use garbage; collection, note that LLVM fully supports `Accurate Garbage; Collection <../../GarbageCollection.html>`_ including algorithms that; move objects and need to scan/update the stack.; - **exception handling support** - LLVM supports generation of `zero; cost exceptions <../../ExceptionHandling.html>`_ which interoperate with; code compiled in other languages. You could also generate code by; implicitly making every function return an error value and checking; it. You could also make explicit use of setjmp/longjmp. There are; many different ways to go here.; - **object orientation, generics, database access, complex numbers,; geometric programming",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst:3083,hash,hash,3083,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl10.rst,1,['hash'],['hash']
Security,"s value encodes lambda functions based on a; stable numbering order in which they appear in their local declaration contexts.; Once this builtin is evaluated in a constexpr context, it is erroneous to use; it in an instantiation which changes its value. In order to produce the unique name, the current implementation of the builtin; uses Itanium mangling even if the host compilation uses a different name; mangling scheme at runtime. The mangler marks all the lambdas required to name; the SYCL kernel and emits a stable local ordering of the respective lambdas.; The resulting pattern is demanglable. When non-lambda types are passed to the; builtin, the mangler emits their usual pattern without any special treatment. **Syntax**:. .. code-block:: c. // Computes a unique stable name for the given type.; constexpr const char * __builtin_sycl_unique_stable_name( type-id );. Multiprecision Arithmetic Builtins; ----------------------------------. Clang provides a set of builtins which expose multiprecision arithmetic in a; manner amenable to C. They all have the following form:. .. code-block:: c. unsigned x = ..., y = ..., carryin = ..., carryout;; unsigned sum = __builtin_addc(x, y, carryin, &carryout);. Thus one can form a multiprecision addition chain in the following manner:. .. code-block:: c. unsigned *x, *y, *z, carryin=0, carryout;; z[0] = __builtin_addc(x[0], y[0], carryin, &carryout);; carryin = carryout;; z[1] = __builtin_addc(x[1], y[1], carryin, &carryout);; carryin = carryout;; z[2] = __builtin_addc(x[2], y[2], carryin, &carryout);; carryin = carryout;; z[3] = __builtin_addc(x[3], y[3], carryin, &carryout);. The complete list of builtins are:. .. code-block:: c. unsigned char __builtin_addcb (unsigned char x, unsigned char y, unsigned char carryin, unsigned char *carryout);; unsigned short __builtin_addcs (unsigned short x, unsigned short y, unsigned short carryin, unsigned short *carryout);; unsigned __builtin_addc (unsigned x, unsigned y, unsigned carryin, un",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:124415,expose,expose,124415,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['expose'],['expose']
Security,"s within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, v_sqrt_f32 and v_sqrt_f16; (on targets with half support). Performs sqrt function. llvm.amdgcn.log Provides direct access to v_log_f32 and v_log_f16; (on targets with half support). Performs log2 function. llvm.amdgcn.exp2 Provides direct access to v_exp_f32 and v_exp_f16; (on targets with half support). Performs exp2 function. :ref:`llvm.frexp <int_frexp>` Implemented for half, float and double. :ref:`llvm.log2 <int_log2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.sqrt <int_sqrt>` Implemented for double, float and half (and vectors). :ref:`llvm.log <int_log>` Implemented for float and half (and vectors). :ref:`llvm.exp <int_exp>` Implemented for float and half (and vectors). :ref:`llvm.log10 <int_log10>` Implemented for float and half (and vectors). :ref:`llvm.exp2 <int_exp2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.stacksave.p5 <int_stacksave>` Implemented, must use",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:36098,access,access,36098,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"s"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }""; ```. - For REFLEX dictionaries:. ``` {.cpp}; <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; ```. The variables in the rules have the following meaning:. * sourceClass; - The field defines the on-disk class that is the input for the rule.; * source; - A semicolon-separated list of values defining the source class data members; that need to be cached and accessible via object proxy when the rule is; executed. The values are either the names of the data members or the type-name; pairs (separated by a space). If types are specified then the ondisk structure; can be generated and used in the code snippet defined by the user.; * version; - A list of versions of the source class that can be an input for this rule.; The list has to be enclosed in a square bracket and be a comma-separated; list of versions or version ranges. The version is an integer number, whereas; the version range is one of the following:; - ""a-b"": a and b are integers and the expression means all the numbers between; and including a and b; - ""-a"": a is an integer and the expression means all the version numbers smaller; than or equal to a; - ""a-"": a is an integer and the expression means all the version numbers greater; than or equal to a; * checksum; - A list of checksums of the source class that can be an input for this; rule. The list ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md:79660,access,accessible,79660,documentation/users-guide/InputOutput.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/InputOutput.md,1,['access'],['accessible']
Security,"s"", @""Indicates multiple reminders""),; reminderCount];; }. Security Alpha Checkers. Name, DescriptionExample. alpha.security.ArrayBound; (C); Warn about buffer overflows (older checker). void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. alpha.security.ArrayBoundV2; (C); Warn about buffer overflows (newer checker). void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. alpha.security.MallocOverflow; (C); Check for overflows in the arguments to malloc(). void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. alpha.security.MmapWriteExec; (C); Warn on mmap() calls that are both writable and executable. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. alpha.security.ReturnPtrRange; (C); Check for an out-of-bound pointer being returned to callers. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.taint.TaintPropagation; (C); Generate taint information used by other checkers. void te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:10730,secur,security,10730,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['secur'],['security']
Security,"s) after the ROOT; command. Be warned: after finishing the execution of the script,; ROOT will normally enter a new session. - -q process command line script files and exit. For example if you would like to run a script `myMacro.C` in the; background, redirect the output into a file `myMacro.log`, and exit; after the script execution, use the following syntax:. ```; root -b -q myMacro.C > myMacro.log; ```. If you need to pass a parameter to the script use:. ```; root -b -q 'myMacro.C(3)' > myMacro.log; ```. Be mindful of the quotes, i.e. if you need to pass a string as a; parameter, the syntax is:. ```; root -b -q 'myMacro.C(""text"")' > myMacro.log; ```. You can build a shared library with ACLiC and then use this shared; library on the command line for a quicker execution (i.e. the compiled; speed rather than the interpreted speed). See also ""Cling the C++; Interpreter"". ```; root -b -q myMacro.so > myMacro.log; ```. ROOT has a powerful C/C++ interpreter giving you access to all available; ROOT classes, global variables, and functions via the command line. By; typing C++ statements at the prompt, you can create objects, call; functions, execute scripts, etc. For example:. ``` {.cpp}; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; ```. To exit the ROOT session, type `.q`. ``` {.cpp}; root[] .q; ```. ## Using the GUI. The basic whiteboard on which an object is drawn in ROOT is called a; canvas (defined by the class **`TCanvas`**). Every object in the; canvas is a graphical object in the sense that you can grab it, resize; it, and change some characteristics using the mouse. The canvas area; can be divided in several sub areas, so-called pads; (the class **`TPad`**). A pad is a canvas sub area that can contain; other pads or graphical objects. At any one time, just one pad is the; so-called active pad. Any object at the moment of drawing will be; drawn",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:4794,access,access,4794,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['access']
Security,"s, buffers, and; leafs, are explained a little later in this chapter, but for now, it is; important to realize that each object is not written individually, but; rather collected and written a bunch at a time. This is where the **`TTree`** takes advantage of compression and will; produce a much smaller file than if the objects were written; individually. Since the unit to be compressed is a buffer, and the; **`TTree`** contains many same-class objects, the header of the objects; can be compressed. The **`TTree`** reduces the header of each object, but it still contains; the class name. Using compression, the class name of each same-class; object has a good chance of being compressed, since the compression; algorithm recognizes the bit pattern representing the class name. Using; a **`TTree`** and compression the header is reduced to about 4 bytes; compared to the original 60 bytes. However, if compression is turned; off, you will not see these large savings. The **`TTree`** is also used to optimize the data access. A tree uses a; hierarchy of branches, and each branch can be read independently from; any other branch. Now, assume that `Px` and `Py` are data members of the; event, and we would like to compute `Px2 + Py2` for every event; and histogram the result. If we had saved the million events without a **`TTree`** we would have; to:. - read each event in its entirety into memory; - extract the `Px` and `Py` from the event; - compute the sum of the squares; - fill a histogram. We would have to do that a million times! This is very time consuming,; and we really do not need to read the entire event, every time. All we; need are two little data members (`Px` and `Py`). On the other hand, if; we use a tree with one branch containing `Px` and another branch; containing `Py`, we can read all values of `Px` and `Py` by only reading; the `Px` and `Py` branches. This makes the use of the **`TTree`** very; attractive. ## A Simple TTree. This script builds a **`TTree`** from",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md:1723,access,access,1723,documentation/users-guide/Trees.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Trees.md,1,['access'],['access']
Security,s-extra/unittests/clang-doc/GeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/HTMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MDGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MergeTest.cpp; clang-tools-extra/unittests/clang-doc/SerializeTest.cpp; clang-tools-extra/unittests/clang-doc/YAMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-tidy/AddConstTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyDiagnosticConsumerTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyTest.h; clang-tools-extra/unittests/clang-tidy/DeclRefExprUtilsTest.cpp; clang-tools-extra/unittests/clang-tidy/GlobListTest.cpp; clang-tools-extra/unittests/clang-tidy/OptionsProviderTest.cpp; clang-tools-extra/unittests/clang-tidy/OverlappingReplacementsTest.cpp; clang-tools-extra/unittests/clang-tidy/ReadabilityModuleTest.cpp; clang-tools-extra/unittests/clang-tidy/TransformerClangTidyCheckTest.cpp; compiler-rt/include/sanitizer/linux_syscall_hooks.h; compiler-rt/include/sanitizer/memprof_interface.h; compiler-rt/include/sanitizer/netbsd_syscall_hooks.h; compiler-rt/include/xray/xray_interface.h; compiler-rt/include/xray/xray_log_interface.h; compiler-rt/lib/asan/asan_activation.h; compiler-rt/lib/asan/asan_lock.h; compiler-rt/lib/asan/asan_mapping.h; compiler-rt/lib/asan/asan_mapping_sparc64.h; compiler-rt/lib/asan/asan_rtl_static.cpp; compiler-rt/lib/asan/tests/asan_globals_test.cpp; compiler-rt/lib/builtins/fp_extend.h; compiler-rt/lib/builtins/fp_lib.h; compiler-rt/lib/builtins/fp_mode.h; compiler-rt/lib/builtins/fp_trunc.h; compiler-rt/lib/builtins/int_endianness.h; compiler-rt/lib/builtins/int_math.h; compiler-rt/lib/builtins/int_types.h; compiler-rt/lib/builtins/int_util.h; compiler-rt/lib/builtins/unwind-ehabi-helpers.h; compiler-rt/lib/builtins/ppc/DD.h; compiler-rt/lib/dfsan/dfsan_allocator.cpp; compiler-rt/lib/dfsan/dfsan_allocator.h; compiler-rt/lib/dfsan/dfsan_chained_origin_depot.cpp; compiler-rt/lib/dfsan/dfsan_chained_origin_depot.h; compi,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:89486,sanitiz,sanitizer,89486,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['sanitiz'],['sanitizer']
Security,"s. Dump compiland information. .. option:: -xme. Dump cross module exports (DEBUG_S_CROSSSCOPEEXPORTS CodeView subsection). .. option:: -xmi. Dump cross module imports (DEBUG_S_CROSSSCOPEIMPORTS CodeView subsection). Symbol Options; ++++++++++++++. .. option:: -globals. dump global symbol records. .. option:: -global-extras. dump additional information about the globals, such as hash buckets and hash; values. .. option:: -publics. dump public symbol records. .. option:: -public-extras. dump additional information about the publics, such as hash buckets and hash; values. .. option:: -symbols. dump symbols (functions, variables, etc) for each module dumped. .. option:: -sym-data. For each symbol record dumped as a result of the :option:`-symbols` option,; display the full bytes of the record in binary as well. Type Record Options; +++++++++++++++++++. .. option:: -types. Dump CodeView type records from TPI stream. .. option:: -type-extras. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI stream, such as hashes and the type; index offsets array. .. option:: -id-data. For each ID record dumped, display the full bytes of the record in binary as; well. .. option:: -id-index=<uint>. only dump ID records with the specified hexadecimal type index. .. option:: -dependents. When used in conjunction with :option:`-type-index` or :option:`-id-index`,; dumps the entire dependency graph for the specified index instead of just the; single record with the specified index. For example, if type index 0x4000 is; a function whose return type has index 0x3000, and you specify; `-dependents=0x4000`, then this would dump both recor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:9343,hash,hashes,9343,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['hash'],['hashes']
Security,"s. The value is an empty null-terminated string if no source is available. If; the source is available but is an empty file then the value is a; null-terminated single ""\ ``\n``\ "". *When the source field is present, consumers can use the embedded source; instead of attempting to discover the source on disk using the file path; provided by the* ``DW_LNCT_path`` *field. When the source field is absent,; consumers can access the file to get the source text.*. *This is particularly useful for programming languages that support runtime; compilation and runtime generation of source text. In these cases, the; source text does not reside in any permanent file. For example, the OpenCL; language [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`] supports online compilation.*. 2. ``DW_LNCT_LLVM_is_MD5``. ``DW_LNCT_LLVM_is_MD5`` indicates if the ``DW_LNCT_MD5`` content kind, if; present, is valid: when 0 it is not valid and when 1 it is valid. If; ``DW_LNCT_LLVM_is_MD5`` content kind is not present, and ``DW_LNCT_MD5``; content kind is present, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM_udata`` form. *This allows a compilation unit to have a mixture of files with and without; MD5 checksums. This can happen when multiple relocatable files are linked; together.*. .. _amdgpu-dwarf-call-frame-information:. A.6.4 Call Frame Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section provides changes to existing call frame information and defines; instructions added by these extensions. Additional support is added for; address spaces. Register unwind DWARF expressions are generalized to allow any; location description, including those with composite and implicit location; descriptions. These changes would be incorporated into the DWARF Version 5 section 6.4. .. _amdgpu-dwarf-structure_of-call-frame-information:. A.6.4.1 Structure of Call Frame Information; +++++++++++++++++++++++++++++++++++++++++++. The register rules are:. *undefined*; A r",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:189625,checksum,checksum,189625,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['checksum'],['checksum']
Security,"s.com/mybucket/path/to/my/file"") // Uses environmental variables for retrieving credentials; ```. Limitations:. - we cannot efficiently detect that a S3 server is able to respond to; multi-range HTTP GET requests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is; configurable. If the server is known to support this feature, ROOT; will send multi-range requests, otherwise it will issue multiple; single-range GET requests, which is also the default behavior.; - currently the virtual host syntax:; ""s3://mybucket.s3.amazonaws.com/path/to/my/file"" is not supported; but can be added if this is considered useful. The TAS3File class will be removed and should not have been used; directly by users anyway as it was only accessed via the plugin manager; in TFile::Open(). ### New HTTP Server package. A new HTTP Server package has been introduced. The idea behind such server is to provide direct access to the data from a running ROOT application. Any object can be streamed when requested and delivered to the browser. ##### Starting HTTP server. To start http server, at any time create instance; of the **`THttpServer`** class like:. ``` {.cpp}; serv = new THttpServer(""http:8080"");; ```. This will start civetweb-based http server on port 8080.; Then, one should be able to open address ""http://localhost:8080""; in any modern browser and browse objects created in application. By default, the server can access files, canvases and histograms via gROOT. All such objects can be displayed with JSRootIO graphics. At any time one could register other objects with the command:. ``` {.cpp}; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; ```. If t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:2459,access,accessed,2459,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,1,['access'],['accessed']
Security,"s.html#ts>`_ for; information on the version of SD-6 supported by each Clang release, and the; macros provided by that revision of the recommendations. C++98; -----. The features listed below are part of the C++98 standard. These features are; enabled by default when compiling C++ code. C++ exceptions; ^^^^^^^^^^^^^^. Use ``__has_feature(cxx_exceptions)`` to determine if C++ exceptions have been; enabled. For example, compiling code with ``-fno-exceptions`` disables C++; exceptions. C++ RTTI; ^^^^^^^^. Use ``__has_feature(cxx_rtti)`` to determine if C++ RTTI has been enabled. For; example, compiling code with ``-fno-rtti`` disables the use of RTTI. C++11; -----. The features listed below are part of the C++11 standard. As a result, all; these features are enabled with the ``-std=c++11`` or ``-std=gnu++11`` option; when compiling C++ code. C++11 SFINAE includes access control; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_access_control_sfinae)`` or; ``__has_extension(cxx_access_control_sfinae)`` to determine whether; access-control errors (e.g., calling a private constructor) are considered to; be template argument deduction errors (aka SFINAE errors), per `C++ DR1170; <http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1170>`_. C++11 alias templates; ^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alias_templates)`` or; ``__has_extension(cxx_alias_templates)`` to determine if support for C++11's; alias declarations and alias templates is enabled. C++11 alignment specifiers; ^^^^^^^^^^^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_alignas)`` or ``__has_extension(cxx_alignas)`` to; determine if support for alignment specifiers using ``alignas`` is enabled. Use ``__has_feature(cxx_alignof)`` or ``__has_extension(cxx_alignof)`` to; determine if support for the ``alignof`` keyword is enabled. C++11 attributes; ^^^^^^^^^^^^^^^^. Use ``__has_feature(cxx_attributes)`` or ``__has_extension(cxx_attributes)`` to; determine if support for attribute parsing ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst:40315,access,access-control,40315,interpreter/llvm-project/clang/docs/LanguageExtensions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LanguageExtensions.rst,1,['access'],['access-control']
Security,"s:; """""""""""""""""""". The first argument is a pointer to be tested. The second argument is a; metadata object representing a :doc:`type identifier <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.test`` intrinsic tests whether the given pointer is associated; with the given type identifier. .. _type.checked.load:. '``llvm.type.checked.load``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare {ptr, i1} @llvm.type.checked.load(ptr %ptr, i32 %offset, metadata %type) nounwind memory(argmem: read). Arguments:; """""""""""""""""""". The first argument is a pointer from which to load a function pointer. The; second argument is the byte offset from which to load the function pointer. The; third argument is a metadata object representing a :doc:`type identifier; <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.checked.load`` intrinsic safely loads a function pointer from a; virtual table pointer using type metadata. This intrinsic is used to implement; control flow integrity in conjunction with virtual call optimization. The; virtual call optimization pass will optimize away ``llvm.type.checked.load``; intrinsics associated with devirtualized calls, thereby removing the type; check in cases where it is not needed to enforce the control flow integrity; constraint. If the given pointer is associated with a type metadata identifier, this; function returns true as the second element of its return value. (Note that; the function may also return true if the given pointer is not associated; with a type metadata identifier.) If the function's return value's second; element is true, the following rules apply to the first element:. - If the given pointer is associated with the given type metadata identifier,; it is the function pointer loaded from the given byte offset from the given; pointer. - If the given pointer is not associated with the given type metadata; identifier, it is one of the following (the choice of which is unspecified):. 1. The function poi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:938368,integrity,integrity,938368,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['integrity'],['integrity']
Security,"s; ====================. If none of the built in GC strategy descriptions met your needs above, you will; need to define a custom GCStrategy and possibly, a custom LLVM pass to perform; lowering. Your best example of where to start defining a custom GCStrategy; would be to look at one of the built in strategies. You may be able to structure this additional code as a loadable plugin library.; Loadable plugins are sufficient if all you need is to enable a different; combination of built in functionality, but if you need to provide a custom; lowering pass, you will need to build a patched version of LLVM. If you think; you need a patched build, please ask for advice on llvm-dev. There may be an; easy way we can extend the support to make it work for your use case without; requiring a custom build. Collector Requirements; ----------------------. You should be able to leverage any existing collector library that includes the following elements:. #. A memory allocator which exposes an allocation function your compiled; code can call. #. A binary format for the stack map. A stack map describes the location; of references at a safepoint and is used by precise collectors to identify; references within a stack frame on the machine stack. Note that collectors; which conservatively scan the stack don't require such a structure. #. A stack crawler to discover functions on the call stack, and enumerate the; references listed in the stack map for each call site. #. A mechanism for identifying references in global locations (e.g. global; variables). #. If you collector requires them, an LLVM IR implementation of your collectors; load and store barriers. Note that since many collectors don't require; barriers at all, LLVM defaults to lowering such barriers to normal loads; and stores unless you arrange otherwise. Implementing a collector plugin; -------------------------------. User code specifies which GC code generation to use with the ``gc`` function; attribute or, equivalently, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst:22513,expose,exposes,22513,interpreter/llvm-project/llvm/docs/GarbageCollection.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GarbageCollection.rst,1,['expose'],['exposes']
Security,"s; Clang 17. 2522; open; Removing placemarker tokens and retention of whitespace; Not resolved. 2523; C++23; Undefined behavior via omitted destructor call in constant expressions; Unknown. 2524; NAD; Distinguishing user-defined conversion sequences by ref-qualifier; Unknown. 2525; drafting; Incorrect definition of implicit conversion sequence; Not resolved. 2526; C++23; Relational comparison of void* pointers; Unknown. 2527; NAD; Non-class potentially-overlapping objects; Unknown. 2528; C++23; Three-way comparison and the usual arithmetic conversions; Unknown. 2529; C++23; Constant destruction of constexpr references; Unknown. 2530; C++23; Multiple definitions of enumerators; Unknown. 2531; DR; Static data members redeclared as constexpr; Unknown. 2532; open; Kind of pointer value returned by new T[0]; Not resolved. 2533; review; Storage duration of implicitly created objects; Not resolved. 2534; CD6; Value category of pseudo-destructor expression; Unknown. 2535; CD6; Type punning in class member access; Unknown. 2536; open; Partially initialized variables during constant initialization; Not resolved. 2537; drafting; Overbroad grammar for parameter-declaration; Not resolved. 2538; C++23; Can standard attributes be syntactically ignored?; Unknown. 2539; C++23; Three-way comparison requiring strong ordering for floating-point types; Unknown. 2540; CD6; Unspecified interpretation of numeric-escape-sequence; Unknown. 2541; open; Linkage specifications, module purview, and module attachment; Not resolved. 2542; DRWP; Is a closure type a structural type?; Unknown. 2543; C++23; constinit and optimized dynamic initialization; Unknown. 2544; open; Address of past-the-end of a potentially-overlapping subobject; Not resolved. 2545; open; Transparently replacing objects in constant expressions; Not resolved. 2546; tentatively ready; Defaulted secondary comparison operators defined as deleted; Unknown. 2547; tentatively ready; Defaulted comparison operator function for non-class",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:173967,access,access,173967,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"s; Using ccache materially improves average build times. Incremental builds; can be slightly faster, but introduce the risk of build corruption due to; e.g. state changes, etc... At this point, the recommendation is not to; use incremental builds and instead use ccache as the latter captures the; majority of the benefit with less risk of false positives. One of the non-obvious benefits of using ccache is that it makes the; builder less sensitive to which projects are being monitored vs built.; If a change triggers a build request, but doesn't change the build output; (e.g. doc changes, python utility changes, etc..), the build will entirely; hit in cache and the build request will complete in just the testing time. With multiple workers, it is tempting to try to configure a shared cache; between the workers. Experience to date indicates this is difficult to; well, and that having local per-worker caches gets most of the benefit; anyways. We don't currently recommend shared caches. CCache does depend on the builder hardware having sufficient IO to access; the cache with reasonable access times - i.e. a fast disk, or enough memory; for a RAM cache, etc.. For builders without, incremental may be your best; option, but is likely to require higher ongoing involvement from the; sponsor. Enable batch builds; As a last resort, you can configure your builder to batch build requests.; This makes the build failure notifications markedly less actionable, and; should only be done once all other reasonable measures have been taken. Leave it on the staging buildmaster; While most of this section has been biased towards builders intended for; the main buildmaster, it is worth highlighting that builders can run; indefinitely on the staging buildmaster. Such a builder may still be; useful for the sponsoring organization, without concern of negatively; impacting the broader community. The sponsoring organization simply; has to take on the responsibility of all bisection and triage. ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:12145,access,access,12145,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,2,['access'],['access']
Security,"s; ^^^^^. The optional ``Calls`` field looks like:. .. code-block:: text. calls: ((Callee)[, (Callee)]*). where each ``Callee`` looks like:. .. code-block:: text. callee: ^1[, hotness: None]?[, relbf: 0]?. The ``callee`` refers to the summary entry id of the callee. At most one; of ``hotness`` (which can take the values ``Unknown``, ``Cold``, ``None``,; ``Hot``, and ``Critical``), and ``relbf`` (which holds the integer; branch frequency relative to the entry frequency, scaled down by 2^8); may be specified. The defaults are ``Unknown`` and ``0``, respectively. .. _params_summary:. Params; ^^^^^^. The optional ``Params`` is used by ``StackSafety`` and looks like:. .. code-block:: text. Params: ((Param)[, (Param)]*). where each ``Param`` describes pointer parameter access inside of the; function and looks like:. .. code-block:: text. param: 4, offset: [0, 5][, calls: ((Callee)[, (Callee)]*)]?. where the first ``param`` is the number of the parameter it describes,; ``offset`` is the inclusive range of offsets from the pointer parameter to bytes; which can be accessed by the function. This range does not include accesses by; function calls from ``calls`` list. where each ``Callee`` describes how parameter is forwarded into other; functions and looks like:. .. code-block:: text. callee: ^3, param: 5, offset: [-3, 3]. The ``callee`` refers to the summary entry id of the callee, ``param`` is; the number of the callee parameter which points into the callers parameter; with offset known to be inside of the ``offset`` range. ``calls`` will be; consumed and removed by thin link stage to update ``Param::offset`` so it; covers all accesses possible by ``calls``. Pointer parameter without corresponding ``Param`` is considered unsafe and we; assume that access with any offset is possible. Example:. If we have the following function:. .. code-block:: text. define i64 @foo(ptr %0, ptr %1, ptr %2, i8 %3) {; store ptr %1, ptr @x; %5 = getelementptr inbounds i8, ptr %2, i64 5; %6 = load",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:344606,access,accessed,344606,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"s; passed in the kernarg. "".value_type"" string Unused and deprecated. This should no longer; be emitted, but is accepted for compatibility. "".pointee_align"" integer Alignment in bytes of pointee; type for pointer type kernel; argument. Must be a power; of 2. Only present if; "".value_kind"" is; ""dynamic_shared_pointer"".; "".address_space"" string Kernel argument address space; qualifier. Only present if; "".value_kind"" is ""global_buffer"" or; ""dynamic_shared_pointer"". Values; are:. - ""private""; - ""global""; - ""constant""; - ""local""; - ""generic""; - ""region"". .. TODO::. Is ""global_buffer"" only ""global""; or ""constant""? Is; ""dynamic_shared_pointer"" always; ""local""? Can HCC allow ""generic""?; How can ""private"" or ""region""; ever happen?. "".access"" string Kernel argument access; qualifier. Only present if; "".value_kind"" is ""image"" or; ""pipe"". Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". .. TODO::. Does this apply to; ""global_buffer""?. "".actual_access"" string The actual memory accesses; performed by the kernel on the; kernel argument. Only present if; "".value_kind"" is ""global_buffer"",; ""image"", or ""pipe"". This may be; more restrictive than indicated; by "".access"" to reflect what the; kernel actual does. If not; present then the runtime must; assume what is implied by; "".access"" and "".is_const"" . Values; are:. - ""read_only""; - ""write_only""; - ""read_write"". "".is_const"" boolean Indicates if the kernel argument; is const qualified. Only present; if "".value_kind"" is; ""global_buffer"". "".is_restrict"" boolean Indicates if the kernel argument; is restrict qualified. Only; present if "".value_kind"" is; ""global_buffer"". "".is_volatile"" boolean Indicates if the kernel argument; is volatile qualified. Only; present if "".value_kind"" is; ""global_buffer"". "".is_pipe"" boolean Indicates if the kernel argument; is pipe qualified. Only present; if "".value_kind"" is ""pipe"". .. TODO::. Can ""global_buffer"" be pipe; qualified?. ====================== ============== ========= ===================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:139779,access,accesses,139779,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"s; that every name declared public is seen by the outside world. This is; opposed to ""`private`"" that means only the class where the name was; declared private could see this name. For example, suppose we declare; in **`TArrow`** the variable `ArrowHeadSize` private. ``` {.cpp}; private:; int ArrowHeadSize;; ```. Then, only the methods (i.e. member functions) of **`TArrow`** will be; able to access this variable. Nobody else will see it. Even the; classes that we could derive from **`TArrow`** will not see it. On the; other hand, if we declare the method `Draw()` as public, everybody will; be able to see it and use it. You see that the character public or; private does not depend of the type of argument. It can be a data; member, a member function, or even a class. For example, in the case; of **`TArrow`**, the base class **`TLine`** is declared as public:. ``` {.cpp}; class TArrow : public TLine { ...; ```. This means that all methods of **`TArrow`** will be able to access all; methods of **`TLine`**, but this will be also true for anybody in the; outside world. Of course, this is true if **`TLine`** accepts the; outside world to see its methods/data members. If something is; declared private in **`TLine`**, nobody will see it, not even; **`TArrow`** members, even if **`TLine`** is declared as a public; base class. What if **`TLine`** is declared ""`private`"" instead of ""`public`"" ?; Well, it will behave as any other name declared private in; **`TArrow`**: only the data members and methods of **`TArrow`** will; be able to access **`TLine`**, its methods and data members, nobody; else. This may seem a little bit confusing and readers should read a; good C++ book if they want more details. Especially since, besides; public and private, a member can be protected. Usually, one puts; private the methods that the class uses internally, like some; utilities classes, and that the programmer does not want to be seen; in the outside world. With ""good"" C++ practice (which we h",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md:4931,access,access,4931,documentation/users-guide/ALittleC++.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/ALittleC++.md,1,['access'],['access']
Security,"s;; ~~~. Example to create a symmetric matrix from a ROOT::Math::SVector containing the lower/upper data block:. ~~~ {.cpp}; ROOT::Math::SVector<double, 6> v(1,2,3,4,5,6);; SMatrixSym3 s1(v); // lower block (default); // this will produce the symmetric matrix; // ( 1 2 4; // 2 3 5; // 4 5 6 ). SMatrixSym3 s2(v,false); // upper block; // this will produce the symmetric matrix; // ( 1 2 3; // 2 4 5; // 3 5 6 ); ~~~. ### Accessing and Setting Methods. The matrix elements can be set using the _operator()(irow,icol)_, where irow and icol are; the row and column indexes or by using the iterator interface. Notice that the indexes start; from zero and not from one as in FORTRAN. All the matrix elements can be set also by using; the ROOT::Math::SetElements function passing a generic iterator.; The elements can be accessed by these same methods and also by using the; ROOT::Math::SMatrix::apply function. The _apply(i)_ function has exactly the same behavior; for general and symmetric matrices, in contrast to the iterator access methods which behave; differently (it follows the data order). ~~~ {.cpp}; SMatrix33 m;; m(0,0) = 1; // set the element in first row and first column; *(m.begin()+1) = 2; // set the second element (0,1); double d[9]={1,2,3,4,5,6,7,8,9};; m.SetElements(d,d+9); // set the d[] values in m. double x = m(2,1); // return the element in third row and first column; x = m.apply(7); // return the 8-th element (row=2,col=1); x = *(m.begin()+7); // return the 8-th element (row=2,col=1); // symmetric matrices (note the difference in behavior between apply and the iterators); x = *(m.begin()+4) // return the element (row=2,col=1).; x = m.apply(7); // returns again the (row=2,col=1) element; ~~~. There are methods to place and/or retrieve ROOT::Math::SVector objects as rows or columns; in (from) a matrix. In addition one can put (get) a sub-matrix as another; ROOT::Math::SMatrix object in a matrix. If the size of the sub-vector or sub-matrix are; larger than the matrix",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SMatrixClass.md:5292,access,access,5292,math/smatrix/doc/SMatrixClass.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/doc/SMatrixClass.md,1,['access'],['access']
Security,"s`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` int",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:3550,access,accesses,3550,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,2,['access'],['accesses']
Security,"sanitiser config into any non-sanitised executable, e.g. python.; 2. ROOT executables will get the config automatically, using a static version of the config library, `libROOTStaticSanitizerConfig.a`.; All ROOT executables statically link against it, so they start up without reporting lots of unfixable memory leaks (e.g. llvm). #### Small linker magic to get the config symbols into ROOT's executables; When linking a ROOT executable, the setup functions from the sanitiser config library might get ignored, because they are not used in any of our executables.; In `cmake/modules/SetUp{Linux|MacOS}.cmake`, the functions are therefore marked as ""undefined"" for the linker, so it starts copying; them into all ROOT executables.; This way, root.exe, cling, ... can start up with a sane default config. ### Use your own address/leak sanitizer configuration; The default configurations can be overridden using the environment variables `ASAN_OPTIONS` and `LSAN_OPTIONS`. Refer to the; [address sanitizer documentation](https://github.com/google/sanitizers/wiki/AddressSanitizer) or use `ASAN_OPTIONS=help=1` when starting; up a sanitised executable (e.g. `root.exe`). A template for a leak suppression file can be found in `$ROOTSYS/etc/lsan-root.supp`. ## Create your own sanitised executable; ROOT exports a library target called `ROOT::ROOTStaticSanitizerConfig` that can be used to create sanitised executables with ROOT's default; address sanitizer config. Linking against this target will add the above setup functions and also add the address sanitizer flags that; ROOT was built with. It should be sufficient to; - Link all executables against this target; - And have `-fsanitize=address` in the `CXXFLAGS`. ## Use sanitised ROOT libraries from a non-sanitised executable (e.g. `python`); When ROOT libraries are built with sanitizers, the address sanitizer runtime needs to be loaded at startup. However, when calling into ROOT; functions from python, that won't happen, since python is not sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md:1834,sanitiz,sanitizer,1834,core/sanitizer/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/sanitizer/README.md,1,['sanitiz'],['sanitizer']
Security,"schema evolution from:; TParameter<Int_t>* MyInt; //-> version 1to; TParameter<Int_t> MyInt; // version 2. The TZIPFile compressed archive reader now supports the Zip64 format for; archives and file members greater than 2 and 4 GB, respectively. MakeProject. Add support for the case when the requested project/files in path that in not under the current directory; Generate the code/dictonary only for pair type that do not already have a dictionary. Object Merging; We introduced a new explicit interface for providing merging; capability. If a class has a method with the name and; signature:. Long64_t Merge(TCollection *input, TFileMergeInfo*);. it will be used by a TFileMerger (and thus by PROOF) to merge one or more; other objects into the current object. Merge should; return a negative value if the merging failed. If this method does not exist, the TFileMerger will use; a method with the name and signature:. Long64_t Merge(TCollection *input);. TClass now provides a quick access to these merging; function via TClass::GetMerge. The wrapper function; is automatically created by rootcint and can be installed; via TClass::SetMerge. The wrapper function should have; the signature/type ROOT::MergeFunc_t:. Long64_t (*)(void *thisobj, TCollection *input, TFileMergeInfo*);. We added the new Merge function to TTree and THStack.; We also added the new Merge function to TQCommand as the; existing TQCommand::Merge does not have the right; semantic (in part because TQCommand is a collection). In TFileMerger, we added a PrintLevel to allow hadd to request; more output than regular TFileMerger. We removed all hard dependencies of TFileMerger on TH1 and TTree.; (Soft dependencies still exist to be able to disable the; merging of TTrees and to be able to disable the AutoAdd; behavior of TH1). The object TFileMergeInfo can be used inside the Merge; function to pass information between runs of the Merge; (see below). In particular it contains:. TDirectory *fOutputDirectory; // Target d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html:3095,access,access,3095,io/doc/v530/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/doc/v530/index.html,2,['access'],['access']
Security,"scope. However, some passes want to peek up or; down the IR hierarchy. For example, an SCC pass may want to look at function; analyses for the functions inside the SCC. Or it may want to look at some; immutable global analysis. In these cases, the analysis manager can provide a; proxy to an outer or inner level analysis manager. For example, to get a; ``FunctionAnalysisManager`` from a ``CGSCCAnalysisManager``, you can call. .. code-block:: c++. FunctionAnalysisManager &FAM =; AM.getResult<FunctionAnalysisManagerCGSCCProxy>(InitialC, CG); .getManager();. and use ``FAM`` as a typical ``FunctionAnalysisManager`` that a function pass; would have access to. To get access to an outer level IR analysis, you can; call. .. code-block:: c++. const auto &MAMProxy =; AM.getResult<ModuleAnalysisManagerCGSCCProxy>(InitialC, CG);; FooAnalysisResult *AR = MAMProxy.getCachedResult<FooAnalysis>(M);. Asking for a cached and immutable outer level IR analysis works via; ``getCachedResult()``, but getting direct access to an outer level IR analysis; manager to compute an outer level IR analysis is not allowed. This is for a; couple reasons. The first reason is that running analyses across outer level IR in inner level; IR passes can result in quadratic compile time behavior. For example, a module; analysis often scans every function and allowing function passes to run a module; analysis may cause us to scan functions a quadratic number of times. If passes; could keep outer level analyses up to date rather than computing them on demand; this wouldn't be an issue, but that would be a lot of work to ensure every pass; updates all outer level analyses, and so far this hasn't been necessary and; there isn't infrastructure for this (aside from function analyses in loop passes; as described below). Self-updating analyses that gracefully degrade also handle; this problem (e.g. GlobalsAA), but they run into the issue of having to be; manually recomputed somewhere in the optimization pipeline if w",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:8754,access,access,8754,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['access'],['access']
Security,"scover the stream's MSF stream index. Several important streams (such as the; global string table, which is called ``/names``) can only be located this way, and; so it is important to both produce and consume this correctly as tools will not; function correctly without it. .. important::; Some streams are located by fixed indices (e.g TPI Stream has index 2), but; other streams are located by fixed names (e.g. the string table is called; ``/names``) and can only be located by consulting the Named Stream Map. The on-disk layout of the Named Stream Map consists of 2 components. The first is; a buffer of string data prefixed by a 32-bit length. The second is a serialized; hash table whose key and value types are both ``uint32_t``. The key is the offset; of a null-terminated string in the string data buffer specifying the name of the; stream, and the value is the MSF stream index of the stream with said name.; Note that although the key is an integer, the hash function used to find the right; bucket hashes the string at the corresponding offset in the string data buffer. The on-disk layout of the serialized hash table is described at :doc:`HashTable`. Note that the entire Named Stream Map is not length-prefixed, so the only way to; get to the data following it is to de-serialize it in its entirety. .. _pdb_stream_features:. PDB Feature Codes; =================; Following the Named Stream Map, and consuming all remaining bytes of the PDB; Stream is a list of values from the following enumeration:. .. code-block:: c++. enum class PdbRaw_FeatureSig : uint32_t {; VC110 = 20091201,; VC140 = 20140508,; NoTypeMerge = 0x4D544F4E,; MinimalDebugInfo = 0x494E494D,; };. The meaning of these values is summarized by the following table:. +------------------+-------------------------------------------------+; | Flag | Meaning |; +==================+=================================================+; | VC110 | - No other features flags are present |; | | - PDB contains an :doc:`IPI Stre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst:3659,hash,hash,3659,interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/PdbStream.rst,2,['hash'],"['hash', 'hashes']"
Security,"scriminator>, i64 <integer discriminator>); ```. ##### Overview:. The '`llvm.ptrauth.blend`' intrinsic blends a pointer address discriminator; with a small integer discriminator to produce a new ""blended"" discriminator. ##### Arguments:. The `address discriminator` argument is a pointer value.; The `integer discriminator` argument is a small integer, as specified by the; target. ##### Semantics:. The '`llvm.ptrauth.blend`' intrinsic combines a small integer discriminator; with a pointer address discriminator, in a way that is specified by the target; implementation. ### Operand Bundle. Function pointers used as indirect call targets can be signed when materialized,; and authenticated before calls. This can be accomplished with the; [`llvm.ptrauth.auth`](#llvm-ptrauth-auth) intrinsic, feeding its result to; an indirect call. However, that exposes the intermediate, unauthenticated pointer, e.g., if it; gets spilled to the stack. An attacker can then overwrite the pointer in; memory, negating the security benefit provided by pointer authentication.; To prevent that, the `ptrauth` operand bundle may be used: it guarantees that; the intermediate call target is kept in a register and never stored to memory.; This hardening benefit is similar to that provided by; [`llvm.ptrauth.resign`](#llvm-ptrauth-resign)). Concretely:. ```llvm; define void @f(void ()* %fp) {; call void %fp() [ ""ptrauth""(i32 <key>, i64 <data>) ]; ret void; }; ```. is functionally equivalent to:. ```llvm; define void @f(void ()* %fp) {; %fp_i = ptrtoint void ()* %fp to i64; %fp_auth = call i64 @llvm.ptrauth.auth(i64 %fp_i, i32 <key>, i64 <data>); %fp_auth_p = inttoptr i64 %fp_auth to void ()*; call void %fp_auth_p(); ret void; }; ```. but with the added guarantee that `%fp_i`, `%fp_auth`, and `%fp_auth_p`; are not stored to (and reloaded from) memory. ## AArch64 Support. AArch64 is currently the only architecture with full support of the pointer; authentication primitives, based on Armv8.3-A instructions.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md:6776,attack,attacker,6776,interpreter/llvm-project/llvm/docs/PointerAuth.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PointerAuth.md,3,"['attack', 'authenticat', 'secur']","['attacker', 'authentication', 'security']"
Security,"scriptors; plus a 32-bit offset into the buffer (in total encapsulating a 160-bit; *pointer*), allowing normal LLVM load/store/atomic operations to be used to; model the buffer descriptors used heavily in graphics workloads targeting; the backend. The buffer descriptor used to construct a buffer fat pointer must be *raw*:; the stride must be 0, the ""add tid"" flag must be 0, the swizzle enable bits; must be off, and the extent must be measured in bytes. (On subtargets where; bounds checking may be disabled, buffer fat pointers may choose to enable; it or not). **Buffer Resource**; The buffer resource pointer, in address space 8, is the newer form; for representing buffer descriptors in AMDGPU IR, replacing their; previous representation as `<4 x i32>`. It is a non-integral pointer; that represents a 128-bit buffer descriptor resource (`V#`). Since, in general, a buffer resource supports complex addressing modes that cannot; be easily represented in LLVM (such as implicit swizzled access to structured; buffers), it is **illegal** to perform non-trivial address computations, such as; ``getelementptr`` operations, on buffer resources. They may be passed to; AMDGPU buffer intrinsics, and they may be converted to and from ``i128``. Casting a buffer resource to a buffer fat pointer is permitted and adds an offset; of 0. Buffer resources can be created from 64-bit pointers (which should be either; generic or global) using the `llvm.amdgcn.make.buffer.rsrc` intrinsic, which; takes the pointer, which becomes the base of the resource,; the 16-bit stride (and swzizzle control) field stored in bits `63:48` of a `V#`,; the 32-bit NumRecords/extent field (bits `95:64`), and the 32-bit flags field; (bits `127:96`). The specific interpretation of these fields varies by the; target architecture and is detailed in the ISA descriptions. **Buffer Strided Pointer**; The buffer index pointer is an experimental address space. It represents; a 128-bit buffer descriptor and a 32-bit offset, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:29735,access,access,29735,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"se issues at; runtime. - Clang now passes relevant LTO options to the linker (LLD) in MinGW mode. LoongArch Support; ^^^^^^^^^^^^^^^^^; - Added builtins support for all LSX (128-bits SIMD) and LASX (256-bits SIMD); instructions.; - Added builtins support for approximate calculation instructions that were; introduced in LoongArch Reference Manual V1.10.; - Made ``-mcmodel=`` compatible with LoongArch gcc that accepted ``normal``,; ``medium`` and ``extreme``.; - The ``model`` attribute was now supported for overriding the default code; model used to access global variables. The following values were supported:; ``normal``, ``medium`` and ``extreme``. *Example Code*:. .. code-block:: c. int var __attribute((model(""extreme"")));. - Default to ``-fno-direct-access-external-data`` for non-PIC.; - An ABI mismatch with gcc/g++ about empty structs/unions passing was fixed.; - ``_mcount`` was generated instead of ``mcount``. RISC-V Support; ^^^^^^^^^^^^^^; - Unaligned memory accesses can be toggled by ``-m[no-]unaligned-access`` or the; aliases ``-m[no-]strict-align``.; - CodeGen of RV32E/RV64E was supported experimentally.; - CodeGen of ilp32e/lp64e was supported experimentally. - Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f; for RV64. - ``__attribute__((rvv_vector_bits(N)))`` is now supported for RVV vbool*_t types.; - ``-mtls-dialect=desc`` is now supported to enable TLS descriptors (TLSDESC). CUDA/HIP Language Changes; ^^^^^^^^^^^^^^^^^^^^^^^^^. CUDA Support; ^^^^^^^^^^^^. - Clang now supports CUDA SDK up to 12.3; - Added support for sm_90a. PowerPC Support; ^^^^^^^^^^^^^^^. - Added ``nmmintrin.h`` to intrinsics headers.; - Added ``__builtin_ppc_fence`` as barrier of code motion, and; ``__builtin_ppc_mffsl`` for corresponding instruction.; - Supported ``__attribute__((target(""tune=cpu"")))``.; - Emit ``float-abi`` module flag on 64-bit ELFv2 PowerPC targets if; ``long double`` type is used in current module. AIX Support; ^^^^^^^^^^^. - Introdu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:64222,access,accesses,64222,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,['access'],"['access', 'accesses']"
Security,"se such class to; create JSON files for selected objects and write such files in a directory,; which can be accessed via web server. Then one can use JSROOT to read such files and display objects in a web browser. There is a demonstration page showing such functionality: <https://root.cern/js/latest/demo/update_draw.htm>.; This demo page reads in cycle 20 json files and displays them. If one has a web server which already provides such JSON file, one could specify the URL to this file like:. <https://root.cern/js/latest/demo/update_draw.htm?addr=../httpserver.C/Canvases/c1/root.json.gz>. Here the same problem with [Cross-Origin Request](https://developer.mozilla.org/en/http_access_control) can appear. If the web server configuration cannot be changed, just copy JSROOT to the web server itself. ### Binary file-based monitoring (not recommended). Theoretically, one could use binary ROOT files to implement monitoring.; With such approach, a ROOT-based application creates and regularly updates content of a ROOT file, which can be accessed via normal web server. From the browser side, JSROOT could regularly read the specified objects and update their drawings. But such solution has three major caveats. First of all, one need to store the data of all objects, which only potentially could be displayed in the browser. In case of 10 objects it does not matter, but for 1000 or 100000 objects this will be a major performance penalty. With such big amount of data one will never achieve higher update rate. The second problem is I/O. To read the first object from the ROOT file, one need to perform several (about 5) file-reading operations via http protocol.; There is no http file locking mechanism (at least not for standard web servers),; therefore there is no guarantee that the file content is not changed/replaced between consequent read operations. Therefore, one should expect frequent I/O failures while trying to monitor data from ROOT binary files. There is a workaround for th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md:32382,access,accessed,32382,documentation/JSROOT/JSROOT.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/JSROOT/JSROOT.md,1,['access'],['accessed']
Security,"se tags with the YAML I/O; model. Recently, we added support to YAML I/O for checking/setting the optional; tag on a map. Using this functionality it is even possible to support different; mappings, as long as they are convertible. To check a tag, inside your mapping() method you can use io.mapTag() to specify; what the tag should be. This will also add that tag when writing yaml. Validation; ----------. Sometimes in a YAML map, each key/value pair is valid, but the combination is; not. This is similar to something having no syntax errors, but still having; semantic errors. To support semantic level checking, YAML I/O allows; an optional ``validate()`` method in a MappingTraits template specialization. When parsing YAML, the ``validate()`` method is call *after* all key/values in; the map have been processed. Any error message returned by the ``validate()``; method during input will be printed just a like a syntax error would be printed.; When writing YAML, the ``validate()`` method is called *before* the YAML; key/values are written. Any error during output will trigger an ``assert()``; because it is a programming error to have invalid struct values. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; };. template <>; struct MappingTraits<Stuff> {; static void mapping(IO &io, Stuff &stuff) {; ...; }; static std::string validate(IO &io, Stuff &stuff) {; // Look at all fields in 'stuff' and if there; // are any bad values return a string describing; // the error. Otherwise return an empty string.; return std::string{};; }; };. Flow Mapping; ------------; A YAML ""flow mapping"" is a mapping that uses the inline notation; (e.g { x: 1, y: 0 } ) when written to YAML. To specify that a type should be; written in YAML using flow mapping, your MappingTraits specialization should; add ""static const bool flow = true;"". For instance:. .. code-block:: c++. using llvm::yaml::MappingTraits;; using llvm::yaml::IO;. struct Stuff {; ...; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst:23610,validat,validate,23610,interpreter/llvm-project/llvm/docs/YamlIO.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/YamlIO.rst,1,['validat'],['validate']
Security,"sed as; the address space identifier. The DWARF expression is ill-formed if AS is not one of the values defined by; the target architecture specific ``DW_ASPACE_LLVM_*`` values. .. note::. Could also consider adding ``DW_OP_LLVM_aspace_breg0,; DW_OP_LLVM_aspace_breg1, ..., DW_OP_LLVM_aspace_bref31`` which would save; encoding size. .. _amdgpu-dwarf-register-location-description-operations:. A.2.5.4.4.4 Register Location Description Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces DWARF Version 5 section 2.6.1.1.3. There is a register location storage that corresponds to each of the target; architecture registers. The size of each register location storage corresponds; to the size of the corresponding target architecture register. A register location description specifies a register location storage. The bit; offset corresponds to a bit position within the register. Bits accessed using a; register location description access the corresponding target architecture; register starting at the specified bit offset. 1. ``DW_OP_reg0``, ``DW_OP_reg1``, ..., ``DW_OP_reg31``. ``DW_OP_reg<N>`` operations encode the numbers of up to 32 registers,; numbered from 0 through 31, inclusive. The target architecture register; number R corresponds to the N in the operation name. The operation is equivalent to performing ``DW_OP_regx R``. 2. ``DW_OP_regx``. ``DW_OP_regx`` has a single unsigned LEB128 integer operand that represents; a target architecture register number R. If the current call frame is the top call frame, it pushes a location; description L that specifies one register location description SL on the; stack. SL specifies the register location storage that corresponds to R with; a bit offset of 0 for the current thread. If the current call frame is not the top call frame, call frame information; (see :ref:`amdgpu-dwarf-call-frame-information`) is used to determine the; location description that holds the register for the curre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:118222,access,accessed,118222,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,2,['access'],"['access', 'accessed']"
Security,"sed to identify the entries created from this model.; Unless a model is created as ""bare model"", it owns a default entry that is used by default by the `RNTupleReader` and the `RNTupleWriter`. A model can add _projected fields_.; Projected fields map existing physical fields to a different type.; For instance, a `std::vector<Event>` can be projected onto a `std::vector<float>` for a float member of `Event`.; Projected fields are stored as header meta-data. Fields can be added to a model after the writing process has started (cf. `RNTupleWriter::CreateModelUpdater()`).; This is called _late model extension_.; Addition of fields invalidates previously created entries.; The values of deferred fields for the already written entries is set to the default constructed type of the field. ### REntry; The REntry represents a row/entry in an RNTuple.; It contains a list of `RValue` objects that correspond to the top-level fields of the originating model.; The entry gives access to the shared pointers corresponding to the top-level fields.; It also provides functionality to bind application-provided pointers. An REntry can be passed to `RNTupleWriter::Fill()` and `RNTupleReader::LoadEntry()`.; Otherwise, the reader/writer uses the default entry of its model. An entry can safely outlive its originating model.; New objects cannot anymore be created (`EmplaceNewValue` will throw an exception), but the entry is still properly destructed. ### RNTupleWriter, RNTupleParallelWriter; The RNTupleWriter is the primary interface to create an RNTuple.; The writer takes ownership of a given model.; The writer can either add an RNTuple to an existing ROOT file (`RNTupleWriter::Append()`) or create a new ROOT file with an RNTuple (`RNTupleWriter::Recreate()`).; Once created, entries are added to an RNTuple either serially (`RNTupleWriter::Fill()`) or in concurrently in multiple threads with the `RNTupleParallelWriter`.; Once committed (e.g. by releasing the RNTupleWriter), the RNTuple is immut",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:11605,access,access,11605,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"seful methods. All of them can be considered as building blocks; for an application, and most of them can be found in dialogs. Provided; snippets of the code will give you practical guidelines where and how to; use certain widgets. The macro `$ROOTSYS/tutorials/gui/guitest.C`; contains the complete source code. ![Widgets created by ROOT GUI classes](pictures/02000204.jpg). Any custom widget can be created by sub classing existing widgets. To; achieve a better understanding of the widgets' properties they are; separated by their type and their inheritance. As all of them inherit; from **`TGObject`** and most from **`TGWidget`**, these base classes are; described first. ### TGObject. **`TGObject`** is the base class for all ROOT GUI classes. It inherits; from **`TObject`**. The two data members of this class contain important; information about X11/Win32 window identifier and the connection to the; host's graphics system. Every GUI element, which derives from; **`TGObject`** has access to the **`TGClient`** via the data member; `fClient` of **`TGObject. TGClient`** creates the connection with the; host's graphics system and sets up the complete graphics system for all; widgets. ### TGWidget. The widgets base class **`TGWidget`** is typically used as a mix-in; class via multiple inheritances. Its properties are available for all; deriving widgets: **`TGButton`**, **`TGComboBox`**, **`TGTab`**,; **`TGColorPalette`**, **`TGColorPick`**, **`TGDoubleSlider`**,; **`TGListTree`**, **`TGNumberEntry`**, **`TGScrollBar`**,; **`TGShutterItem`**, **`TGTextEntry`**, **`TGSlider`**, **`TGListBox`**,; **`TGView.`**. This class has four data members keeping information about the widget id; - important for event processing, the window which handles the widget's; events, the widget status flags and the assigned command (if there is; any). The general properties of **`TGWidget`** are specified by; `SetFlags(Int_t flags)` and `ClearFlags(Int_t flags)` methods. The; status flags are: `kWi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:21259,access,access,21259,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security,"sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passe",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66958,attack,attacker,66958,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['attack'],['attacker']
Security,"servables and their values; // are taken from the dataset:; model.fitTo(*data);. // You can still define the set of global observables yourself, but the values; // will be takes from the dataset if available:; model.fitTo(*data, GlobalObservables(g1, g2));. // To force `fitTo` to take the global observable values from the model even; // though they are in the dataset, you can use the new `GlobalObservablesSource`; // command argument:; model.fitTo(*data, GlobalObservables(g1, g2), GlobalObservablesSource(""model""));; // The only other allowed value for `GlobalObservablesSource` is ""data"", which; // corresponds to the new default behavior explained above.; ```. In case you create a RooFit dataset directly by calling its constructor, you can also pass the global observables in a command argument instead of calling `setGlobalObservables()` later:; ```C++; RooDataSet data{""dataset"", ""dataset"", x, RooFit::GlobalObservables(g1, g2)};; ```. To access the set of global observables stored in a `RooAbsData`, call `RooAbsData::getGlobalObservables()`.; It returns a `nullptr` if no global observable snapshots are stored in the dataset. For more information of global observables and how to attach them to the toy datasets, please take a look at the new; [rf613_global_observables.C](https://root.cern/doc/v626/rf613__global_observables_8C.html) / [.py](https://root.cern/doc/v626/rf613__global_observables_8py.html) tutorial. ### Changes in `RooAbsPdf::fitTo` behaviour for multi-range fits. The `RooAbsPdf::fitTo` and `RooAbsPdf::createNLL` functions accept a command argument to specify the fit range.; One can also fit in multiple ranges simultaneously.; The definition of such multi-range likelihoods for non-extended fits changes in this release.; Previously, the individual likelihoods were normalized separately in each range, which meant that the relative number of events in each sub-range was not used to estimate the PDF parameters.; From now on, the likelihoods are normalized by the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md:29106,access,access,29106,README/ReleaseNotes/v626/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v626/index.md,1,['access'],['access']
Security,"server.C macro on Apache webserver; 3. Evaluate 'monitoring' parameter for online server like:; <http://localhost:8080/?monitoring=1000>; Parameter defines how often displayed objects should be updated.; 4. Implement 'opt' and 'opts' URL parameters for main page.; 5. Show progress with scripts loading in the browser window; 6. When one appends ""+"" to the filename, its content read completely with first I/O operation.; 7. Implement JS custom streamer for TCanvas, restore aspect ratio when drawing; 8. Major redesign of drawing classes. Resize and update of TCanvas are implemented.; All major draw functions working with HTML element id as first argument.; 9. Extract 3D drawings into separate JSRoot3DPainter.js script; 10. Use newest three.min.js (r68) for 3D drawings, solves problem with Firefox.; 11. Introduce generic list of draw functions for all supported classes.; 12. Add possibility to 'expand' normal objects in the hierarchy browser.; For instance, this gives access to single elements of canvas,; when whole canvas cannot be drawn.; 13. Correct usage of colors map, provided with TCanvas.; 14. Introduce JSROOT.redraw() function which is capable to create or update object drawing.; 15. In main index.htm page browser can be disabled (nobrowser parameter) and; page can be used to display only specified items from the file; 16. Add support of TPolyMarker3D in binary I/O. ### September 2014; 1. First try to handle resize of the browser,; for the moment works only with collapsible layout; 2. Also first try to interactively move separation line between; browser and drawing field.; 3. Small fix of minor ticks drawing on the axis; 4. Introduce display class for MDI drawing. Provide two implementations -; 'collapsible' for old kind and 'tabs' for new kinds.; 5. Adjust size of color palette drawing when labels would take more place as provided.; 6. Add correct filling of statistic for TProfile,; fix small problem with underflow/overflow bins.; 7. Provide way to select display",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/changes.md:71519,access,access,71519,js/changes.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/changes.md,1,['access'],['access']
Security,"set and compression settings.; The order of the outer items must match the order of columns in the header and the extension header (small to large). The order of the inner items must match the order of pages or elements, resp.; Every inner item (that describes a page) has the following structure followed by a locator for the page. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of Elements |C|; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. Note that locators for byte ranges in a file may reference identical byte ranges,; but they must not reference arbitrarily overlapping byte ranges. _C(hecksum)_: If set, an XxHash-3 64bit checksum of the compressed page data is stored just after the page.; This bit should be interpreted as the sign bit of the number of elements,; i.e. negative values indicate pages with checksums.; Note that the page size stored in the locator does _not_ include the checksum. Note that we do not need to store the uncompressed size of the page; because the uncompressed size is given by the number of elements in the page and the element size.; We do need, however, the per-column and per-cluster element offset in order to read a certain entry range; without inspecting the meta-data of all the previous clusters. The hierarchical structure of the frames in the page list envelope is as follows:. # this is `List frame of cluster group record frames` mentioned above; - Top-most cluster list frame (one item for each cluster in this RNTuple); |; |---- Cluster 1 column list frame (outer list frame, one item for each column in this RNTuple); | |---- Column 1 page list frame (inner list frame, one item for each page in this column); | | |---- Page 1 description (inner item); | | |---- Page 2 description (inner item); | | | ...; | |---- Column 1 element offset (Int64), negative if the column is suppressed; | |---- Column 1 compres",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:34902,checksum,checksum,34902,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['checksum'],['checksum']
Security,"set, by the scratch; instructions, or by flat instructions. If each lane of a wavefront accesses the; same private address, the interleaving results in adjacent dwords being accessed; and hence requires fewer cache lines to be fetched. Multi-dword access is not; supported except by flat and scratch instructions in GFX9-GFX11. The generic address space uses the hardware flat address support available in; GFX7-GFX11. This uses two fixed ranges of virtual addresses (the private and; local apertures), that are outside the range of addressible global memory, to; map from a flat address to a private or local address. FLAT instructions can take a flat address and access global, private (scratch); and group (LDS) memory depending on if the address is within one of the; aperture ranges. Flat access to scratch requires hardware aperture setup and; setup in the kernel prologue (see; :ref:`amdgpu-amdhsa-kernel-prolog-flat-scratch`). Flat access to LDS requires; hardware aperture setup and M0 (GFX7-GFX8) register setup (see; :ref:`amdgpu-amdhsa-kernel-prolog-m0`). To convert between a segment address and a flat address the base address of the; apertures address can be used. For GFX7-GFX8 these are available in the; :ref:`amdgpu-amdhsa-hsa-aql-queue` the address of which can be obtained with; Queue Ptr SGPR (see :ref:`amdgpu-amdhsa-initial-kernel-execution-state`). For; GFX9-GFX11 the aperture base addresses are directly available as inline constant; registers ``SRC_SHARED_BASE/LIMIT`` and ``SRC_PRIVATE_BASE/LIMIT``. In 64 bit; address mode the aperture sizes are 2^32 bytes and the base is aligned to 2^32; which makes it easier to convert from flat to segment or segment to flat. Image and Samplers; ~~~~~~~~~~~~~~~~~~. Image and sample handles created by an HSA compatible runtime (see; :ref:`amdgpu-os`) are 64-bit addresses of a hardware 32-byte V# and 48 byte S#; object respectively. In order to support the HSA ``query_sampler`` operations; two extra dwords are used to store the H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:155967,access,access,155967,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"setPreservesCFG`` method can be used by transformations that change; instructions in the program but do not modify the CFG or terminator; instructions. ``addPreserved`` is particularly useful for transformations like; ``BreakCriticalEdges``. This pass knows how to update a small set of loop and; dominator related analyses if they exist, so it can preserve them, despite the; fact that it hacks on the CFG. Example implementations of ``getAnalysisUsage``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. // This example modifies the program, but does not modify the CFG; void LICM::getAnalysisUsage(AnalysisUsage &AU) const {; AU.setPreservesCFG();; AU.addRequired<LoopInfoWrapperPass>();; }. .. _writing-an-llvm-pass-getAnalysis:. The ``getAnalysis<>`` and ``getAnalysisIfAvailable<>`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``Pass::getAnalysis<>`` method is automatically inherited by your class,; providing you with access to the passes that you declared that you required; with the :ref:`getAnalysisUsage <writing-an-llvm-pass-getAnalysisUsage>`; method. It takes a single template argument that specifies which pass class; you want, and returns a reference to that pass. For example:. .. code-block:: c++. bool LICM::runOnFunction(Function &F) {; LoopInfo &LI = getAnalysis<LoopInfoWrapperPass>().getLoopInfo();; //...; }. This method call returns a reference to the pass desired. You may get a; runtime assertion failure if you attempt to get an analysis that you did not; declare as required in your :ref:`getAnalysisUsage; <writing-an-llvm-pass-getAnalysisUsage>` implementation. This method can be; called by your ``run*`` method implementation, or by any other local method; invoked by your ``run*`` method. A module level pass can use function level analysis info using this interface.; For example:. .. code-block:: c++. bool ModuleLevelPass::runOnModule(Module &M) {; //...; DominatorTree &DT = getAnalysis<DominatorTree>(Func)",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:32997,access,access,32997,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['access'],['access']
Security,"should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime library with proper arguments. '``llvm.instrprof.mcdc.parameters``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.parameters(ptr <name>, i64 <hash>,; i32 <bitmap-bytes>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.parameters``' intrinsic is used to initiate MC/DC; code coverage instrumentation for a function. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. This should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. The third argument is the number of bitmap bytes required by the function to; record the number of test vectors executed for each boolean expression. Semantics:; """""""""""""""""""". This intrinsic represents basic MC/DC parameters initiating one or more MC/DC; instrumentation sequences in a function. It will cause the ``-instrprof`` pass; to generate the appropriate data structures and the code to instrument MC/DC; test vectors in a format that can be written out by a compiler runtime and; consumed via the ``llvm-profdata`` tool. '``llvm.instrprof.mcdc.condbitmap.update``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.mcdc.condbitmap.update(ptr <name>, i64 <hash>,; i32 <condition-id>,; ptr <mcdc-temp-addr>,; i1 <bool-value>). Overview:; """""""""""""""""". The '``llvm.instrprof.mcdc.condbitmap.update``' intrinsic is used to track; MC/DC condition evaluation for eac",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:532666,hash,hash,532666,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security,"sible by an optimizer with only incomplete information about a; program. Essentially, dependence is carried to ""obvious"" uses of a; pointer. Merely passing a pointer argument to a function does not; itself cause dependence, but since generally the optimizer will not; be able to prove that the function doesn't depend on that parameter,; it will be forced to conservatively assume it does. Dependency propagates to values loaded from a pointer because those; values might be invalidated by deallocating the object. For; example, given the code ``__strong id x = p->ivar;``, ARC must not; move the release of ``p`` to between the load of ``p->ivar`` and the; retain of that value for storing into ``x``. Dependency does not propagate through stores of dependent pointer; values because doing so would allow dependency to outlive the; full-expression which produced the original value. For example, the; address of an instance variable could be written to some global; location and then freely accessed during the lifetime of the local,; or a function could return an inner pointer of an object and store; it to a local. These cases would be potentially impossible to; reason about and so would basically prevent any optimizations based; on imprecise lifetime. There are also uncommon enough to make it; reasonable to require the precise-lifetime annotation if someone; really wants to rely on them. Dependency does propagate through return values of pointer type.; The compelling source of need for this rule is a property accessor; which returns an un-autoreleased result; the calling function must; have the chance to operate on the value, e.g. to retain it, before; ARC releases the original pointer. Note again, however, that; dependence does not survive a store, so ARC does not guarantee the; continued validity of the return value past the end of the; full-expression. .. _arc.optimization.object_lifetime:. No object lifetime extension; ----------------------------. If, in the formal computati",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst:81506,access,accessed,81506,interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/AutomaticReferenceCounting.rst,1,['access'],['accessed']
Security,"simply a; string:. .. code-block:: llvm. define void @f() gc ""name"" { ... }. The supported values of *name* includes those :ref:`built in to LLVM; <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC; strategy will cause the compiler to alter its output in order to support the; named garbage collection algorithm. Note that LLVM itself does not contain a; garbage collector, this functionality is restricted to generating machine code; which can interoperate with a collector provided externally. .. _prefixdata:. Prefix Data; -----------. Prefix data is data associated with a function which the code; generator will emit immediately before the function's entrypoint.; The purpose of this feature is to allow frontends to associate; language-specific runtime metadata with specific functions and make it; available through the function pointer while still allowing the; function pointer to be called. To access the data for a given function, a program may bitcast the; function pointer to a pointer to the constant's type and dereference; index -1. This implies that the IR symbol points just past the end of; the prefix data. For instance, take the example of a function annotated; with a single ``i32``,. .. code-block:: llvm. define void @f() prefix i32 123 { ... }. The prefix data can be referenced as,. .. code-block:: llvm. %a = getelementptr inbounds i32, ptr @f, i32 -1; %b = load i32, ptr %a. Prefix data is laid out as if it were an initializer for a global variable; of the prefix data's type. The function will be placed such that the; beginning of the prefix data is aligned. This means that if the size; of the prefix data is not a multiple of the alignment size, the; function's entrypoint will not be aligned. If alignment of the; function's entrypoint is desired, padding must be added to the prefix; data. A function may have prefix data but no body. This has similar semantics; to the ``available_externally`` linkage in that the data may be used by the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:72809,access,access,72809,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"sing fill area colors. - `""CONT4"":`Draw a contour plot using surface colors (SURF2 option; at theta = 0); see also options ""`AITOFF`"", ""`MERCATOR`"", etc.; below. - `""CONT5"":` Use Delaunay triangles to compute the contours. ![Different contour options](pictures/02000032.png). The default number of contour levels is 20 equidistant levels. It can; be changed with **`TH1`**`::SetContour`. When option ""`LIST`"" is; specified together with option ""`CONT`"", all points used for contour; drawing, are saved in the **`TGraph`** object and are accessible in; the following way:. ``` {.cpp}; TObjArray *contours =; gROOT->GetListOfSpecials()->FindObject(""contours"");; Int_t ncontours = contours->GetSize(); TList *list =; (TList*)contours->At(i);; ```. Where ""`i`"" is a contour number and list contains a list of; **`TGraph`** objects. For one given contour, more than one disjoint; poly-line may be generated. The **`TGraph`** numbers per contour are; given by `list->GetSize()`. Here we show how to access the first graph; in the list. ``` {.cpp}; TGraph *gr1 = (TGraph*)list->First();; ```. - ""`AITOFF`"": Draw a contour via an AITOFF projection. - ""`MERCATOR`"": Draw a contour via a Mercator projection. - ""`SINUSOIDAL`"": Draw a contour via a Sinusoidal projection. - ""`PARABOLIC`"": Draw a contour via a Parabolic projection. The tutorial macro `earth.C` uses these four options and produces the; following picture:. ![The `earth.C` macro output](pictures/03000033.png). #### The LEGO Options. In a lego plot, the cell contents are drawn as 3D boxes, with the; height of the box proportional to the cell content. ![""LEGO"" and ""SURF"" options](pictures/02000034.png). - ""`LEGO`"": Draw a lego plot with hidden line removal. - ""`LEGO1`"": Draw a lego plot with hidden surface removal. - ""`LEGO2`"": Draw a lego plot using colors to show the cell contents. A lego plot can be represented in several coordinate systems; the; default system is Cartesian coordinates. Other possible coordinate; systems are `CYL` , `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:26067,access,access,26067,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['access'],['access']
Security,"sion of PoD on CernVM-FS you can use; that one. Experiment-independent versions are available from the PH-SFT; cvmfs repository. Only if you have specific reasons while you want to use a customly built; PoD version, download the source code and compile it using the; installation instructions. Please note that [CMake](http://www.cmake.org/) and; [Boost](http://www.boost.org/) are required to build PoD. - After you have built PoD, install it with:. make install. - After installing PoD, run:. pod-server getbins. This has to be done only once and downloads the binary packages that; will be dynamically transferred to the worker nodes as binary; payload, and prevents us from installing PoD on each cluster node. It is important to do this step now, because in case PoD has been; installed in a directory where the user has no write privileges, as; in the case of system-wide installations, the user won't be able to; download those required packages in the PoD binary directory. > There is no need to ""configure"" PoD for your specific cluster: it is; > just enough to install it on your head node.; >; > PoD does not have any system-wide persistent daemon running or any; > system-wide configuration to be performed. Also, no part of PoD will; > be ever run as root.; >; > Do not worry about environment or software configuration at this time:; > there is no system configuration for that. All the environment for; > your software dependencies will be set via proper scripts from the PoD; > client.; >; > PoD client configuration and running is properly covered in the; > appropriate manual page. ### Firewall configuration. The head node only requires **TCP ports 22 (SSH) and 443 (HTTPS)** to accept; connections from the outside. Users will get an authentication ""token""; from port 443 and all PROOF traffic will be automatically tunneled in a; SSH connection on port 22 by PoD. In case you are not using the HTTPS+SSH token+authentication method, access to; the sole port 22 is all you need.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md:6806,authenticat,authentication,6806,proof/doc/confman/ConfigProofPoD.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/confman/ConfigProofPoD.md,3,"['access', 'authenticat']","['access', 'authentication']"
Security,"sitive in mutation check when using pointer to member function.; (`#66204 <https://github.com/llvm/llvm-project/issues/66204>`_). - Fixed a crash in ``security.cert.env.InvalidPtr`` checker when accidentally; matched user-defined ``strerror`` and similar library functions.; (`#88181 <https://github.com/llvm/llvm-project/issues/88181>`_). Improvements; ^^^^^^^^^^^^. - Improved the ``unix.StdCLibraryFunctions`` checker by modeling more; functions like ``send``, ``recv``, ``readlink``, ``fflush``, ``mkdtemp``,; ``getcwd`` and ``errno`` behavior.; (`52ac71f92d38 <https://github.com/llvm/llvm-project/commit/52ac71f92d38f75df5cb88e9c090ac5fd5a71548>`_,; `#77040 <https://github.com/llvm/llvm-project/pull/77040>`_,; `#76671 <https://github.com/llvm/llvm-project/pull/76671>`_,; `#71373 <https://github.com/llvm/llvm-project/pull/71373>`_,; `#76557 <https://github.com/llvm/llvm-project/pull/76557>`_,; `#71392 <https://github.com/llvm/llvm-project/pull/71392>`_). - Fixed a false negative for when accessing a nonnull property (ObjC).; (`1dceba3a3684 <https://github.com/llvm/llvm-project/commit/1dceba3a3684d12394731e09a6cf3efcebf07a3a>`_). - ``security.insecureAPI.DeprecatedOrUnsafeBufferHandling`` now considers; ``fprintf`` calls unsafe.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-insecureapi-deprecatedorunsafebufferhandling-c>`__. - Improved the diagnostics of the ``optin.core.EnumCastOutOfRange`` checker.; It will display the name and the declaration of the enumeration along with; the concrete value being cast to the enum.; (`#74503 <https://github.com/llvm/llvm-project/pull/74503>`_). - Improved the ``alpha.security.ArrayBoundV2`` checker for detecting buffer; accesses prior the buffer; and also reworked the diagnostic messages.; (`3e014038b373 <https://github.com/llvm/llvm-project/commit/3e014038b373e5a4a96d89d46cea17e4d2456a04>`_,; `#70056 <https://github.com/llvm/llvm-project/pull/70056>`_,; `#72107 <https://github.com/llvm/llvm-project/pull",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:73202,access,accessing,73202,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['access'],['accessing']
Security,"sitory:. git clone https://github.com/llvm/llvm-project.git. At this point you have every sub-project (llvm, clang, lld, lldb, ...), which; :ref:`doesn't imply you have to build all of them <build_single_project>`. You; can still build only compiler-rt for instance. In this way it's not different; from someone who would check out all the projects with SVN today. If you want to avoid checking out all the sources, you can hide the other; directories using a Git sparse checkout::. git config core.sparseCheckout true; echo /compiler-rt > .git/info/sparse-checkout; git read-tree -mu HEAD. The data for all sub-projects is still in your `.git` directory, but in your; checkout, you only see `compiler-rt`.; Before you push, you'll need to fetch and rebase (`git pull --rebase`) as; usual. Note that when you fetch you'll likely pull in changes to sub-projects you don't; care about. If you are using sparse checkout, the files from other projects; won't appear on your disk. The only effect is that your commit hash changes. You can check whether the changes in the last fetch are relevant to your commit; by running::. git log origin/main@{1}..origin/main -- libcxx. This command can be hidden in a script so that `git llvmpush` would perform all; these steps, fail only if such a dependent change exists, and show immediately; the change that prevented the push. An immediate repeat of the command would; (almost) certainly result in a successful push.; Note that today with SVN or git-svn, this step is not possible since the; ""rebase"" implicitly happens while committing (unless a conflict occurs). Checkout/Clone Multiple Projects, with Commit Access; ----------------------------------------------------. Let's look how to assemble llvm+clang+libcxx at a given revision. Currently; ^^^^^^^^^. ::. svn co https://llvm.org/svn/llvm-project/llvm/trunk llvm -r $REVISION; cd llvm/tools; svn co https://llvm.org/svn/llvm-project/clang/trunk clang -r $REVISION; cd ../projects; svn co https://llvm.o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:14602,hash,hash,14602,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['hash'],['hash']
Security,"size S is defined as the address bit size of the target; architecture specific address space that corresponds to AS. A is adjusted to S bits by zero extending if necessary, and then treating; the least significant S bits as an unsigned value A'. It pushes a location description L with one memory location description SL; on the stack. SL specifies the memory location storage LS that corresponds; to AS with a bit offset equal to A' scaled by 8 (the byte size). If AS is an address space that is specific to context elements, then LS; corresponds to the location storage associated with the current context. *For example, if AS is for per thread storage then LS is the location; storage for the current thread. For languages that are implemented using a; SIMT execution model, then if AS is for per lane storage then LS is the; location storage for the current lane of the current thread. Therefore, if L; is accessed by an operation, the location storage selected when the location; description was created is accessed, and not the location storage associated; with the current context of the access operation.*. The DWARF expression is ill-formed if AS is not one of the values defined by; the target architecture specific ``DW_ASPACE_LLVM_*`` values. See :ref:`amdgpu-dwarf-implicit-location-description-operations` for special; rules concerning implicit pointer values produced by dereferencing implicit; location descriptions created by the ``DW_OP_implicit_pointer`` and; ``DW_OP_LLVM_aspace_implicit_pointer`` operations. 4. ``DW_OP_form_tls_address``. ``DW_OP_form_tls_address`` pops one stack entry that must be an integral; type value and treats it as a thread-local storage address TA. It pushes a location description L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environme",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:111442,access,accessed,111442,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,3,['access'],"['access', 'accessed']"
Security,"size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Anot",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4208,access,accesses,4208,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['access'],['accesses']
Security,"size limit. ``align`` must be; explicitly specified on atomic stores. Note: if the alignment is not greater or; equal to the size of the `<value>` type, the atomic operation is likely to; require a lock and have poor performance. ``!nontemporal`` does not have any; defined semantics for atomic stores. The optional constant ``align`` argument specifies the alignment of the; operation (that is, the alignment of the memory address). It is the; responsibility of the code emitter to ensure that the alignment information is; correct. Overestimating the alignment results in undefined behavior.; Underestimating the alignment may produce less efficient code. An alignment of; 1 is always safe. The maximum possible alignment is ``1 << 32``. An alignment; value higher than the size of the loaded type implies memory up to the; alignment value bytes can be safely loaded without trapping in the default; address space. Access of the high bytes can interfere with debugging tools, so; should not be accessed if the function has the ``sanitize_thread`` or; ``sanitize_address`` attributes. The alignment is only optional when parsing textual IR; for in-memory IR, it is; always present. An omitted ``align`` argument means that the operation has the; ABI alignment for the target. The optional ``!nontemporal`` metadata must reference a single metadata; name ``<nontemp_node>`` corresponding to a metadata node with one ``i32`` entry; of value 1. The existence of the ``!nontemporal`` metadata on the instruction; tells the optimizer and code generator that this load is not expected to; be reused in the cache. The code generator may select special; instructions to save cache bandwidth, such as the ``MOVNT`` instruction on; x86. The optional ``!invariant.group`` metadata must reference a; single metadata name ``<empty_node>``. See ``invariant.group`` metadata. Semantics:; """""""""""""""""""". The contents of memory are updated to contain ``<value>`` at the; location specified by the ``<pointer>`` operand. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:421650,access,accessed,421650,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accessed']
Security,"sly they were treated as chars, which meant they could; alias with all other types.; - Clang now supports the C-only attribute ``counted_by``. When applied to a; struct's flexible array member, it points to the struct field that holds the; number of elements in the flexible array member. This information can improve; the results of the array bound sanitizer and the; ``__builtin_dynamic_object_size`` builtin. C23 Feature Support; ^^^^^^^^^^^^^^^^^^^; - Clang now accepts ``-std=c23`` and ``-std=gnu23`` as language standard modes,; and the ``__STDC_VERSION__`` macro now expands to ``202311L`` instead of its; previous placeholder value. Clang continues to accept ``-std=c2x`` and; ``-std=gnu2x`` as aliases for C23 and GNU C23, respectively.; - Clang now supports `requires c23` for module maps.; - Clang now supports ``N3007 Type inference for object definitions``. - Clang now supports ``<stdckdint.h>`` which defines several macros for performing; checked integer arithmetic. It is also exposed in pre-C23 modes. - Completed the implementation of; `N2508 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2508.pdf>`_. We; previously implemented allowing a label at the end of a compound statement,; and now we've implemented allowing a label to be followed by a declaration; instead of a statement.; - Implemented; `N2940 <https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2940.pdf>`_ which; removes support for trigraphs in C23 and later. In earlier language modes,; trigraphs remain enabled by default in conforming modes (e.g. ``-std=c17``); and disabled by default in GNU and Microsoft modes (e.g., ``-std=gnu17`` or; ``-fms-compatibility``). If needed, you can enable trigraphs by passing; ``-ftrigraphs``. Non-comprehensive list of changes in this release; -------------------------------------------------. * Clang now has a ``__builtin_vectorelements()`` function that determines the number of elements in a vector.; For fixed-sized vectors, e.g., defined via ``__attribute__((vector_s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:13181,expose,exposed,13181,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,1,['expose'],['exposed']
Security,"software systems which receive less detailed scrutiny but remain sensitive to; these attacks, this seems like an impractical security model. We need an; automatic and systematic mitigation strategy. ### Automatic `lfence` on Conditional Edges. A natural way to scale up the existing hand-coded mitigations is simply to; inject an `lfence` instruction into both the target and fallthrough; destinations of every conditional branch. This ensures that no predicate or; bounds check can be bypassed speculatively. However, the performance overhead; of this approach is, simply put, catastrophic. Yet it remains the only truly; ""secure by default"" approach known prior to this effort and serves as the; baseline for performance. One attempt to address the performance overhead of this and make it more; realistic to deploy is [MSVC's /Qspectre; switch](https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/).; Their technique is to use static analysis within the compiler to only insert; `lfence` instructions into conditional edges at risk of attack. However,; [initial](https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/); [analysis](https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html); has shown that this approach is incomplete and only catches a small and limited; subset of attackable patterns which happen to resemble very closely the initial; proofs of concept. As such, while its performance is acceptable, it does not; appear to be an adequate systematic mitigation. ## Performance Overhead. The performance overhead of this style of comprehensive mitigation is very; high. However, it compares very favorably with previously recommended; approaches such as the `lfence` instruction. Just as users can restrict the; scope of `lfence` to control its performance impact, this mitigation technique; could be restricted in scope as well. However, it is important to understand what",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:45926,attack,attack,45926,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attack']
Security,"solved. 2233; CD5; Function parameter packs following default arguments; Clang 11. 2234; CD5; Missing rules for simple-template-id as class-name; Unknown. 2235; CD5; Partial ordering and non-dependent types; Unknown. 2236; drafting; When is an alias template specialization dependent?; Not resolved. 2237; CD5; Can a template-id name a constructor?; Unknown. 2238; NAD; Contradictory alignment requirements for allocation; Unknown. 2239; NAD; Sized deallocation with a trivial destructor; Unknown. 2240; NAD; this is not odr-used in a constant expression; Unknown. 2241; CD5; Overload resolution is not invoked with a single function; Unknown. 2242; C++23; ODR violation with constant initialization possibly omitted; Unknown. 2243; drafting; Incorrect use of implicit conversion sequence; Not resolved. 2244; open; Base class access in aggregate initialization; Not resolved. 2245; drafting; Point of instantiation of incomplete class template; Not resolved. 2246; drafting; Access of indirect virtual base class constructors; Not resolved. 2247; C++17; Lambda capture and variable argument list; Unknown. 2248; C++17; Problems with sized delete; Unknown. 2249; CD5; identifiers and id-expressions; Unknown. 2250; open; Implicit instantiation, destruction, and TUs; Not resolved. 2251; C++17; Unreachable enumeration list-initialization; Unknown. 2252; DR; Enumeration list-initialization from the same type; Unknown. 2253; CD5; Unnamed bit-fields and zero-initialization; Unknown. 2254; CD5; Standard-layout classes and bit-fields; Unknown. 2255; CD5; Instantiated static data member templates; Unknown. 2256; CD5; Lifetime of trivially-destructible objects; Unknown. 2257; CD5; Lifetime extension of references vs exceptions; Unknown. 2258; open; Storage deallocation during period of destruction; Not resolved. 2259; C++17; Unclear context describing ambiguity; Unknown. 2260; CD5; Explicit specializations of deleted member functions; Unknown. 2261; extension; Explicit instantiation of in-class",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:153071,Access,Access,153071,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"source.html>`_. doxygen info: `User Class <https://llvm.org/doxygen/classllvm_1_1User.html>`_. Superclass: Value_. The ``User`` class is the common base class of all LLVM nodes that may refer to; ``Value``\ s. It exposes a list of ""Operands"" that are all of the ``Value``\ s; that the User is referring to. The ``User`` class itself is a subclass of; ``Value``. The operands of a ``User`` point directly to the LLVM ``Value`` that it refers; to. Because LLVM uses Static Single Assignment (SSA) form, there can only be; one definition referred to, allowing this direct connection. This connection; provides the use-def information in LLVM. .. _m_User:. Important Public Members of the ``User`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``User`` class exposes the operand list in two ways: through an index access; interface and through an iterator based interface. * | ``Value *getOperand(unsigned i)``; | ``unsigned getNumOperands()``. These two methods expose the operands of the ``User`` in a convenient form for; direct access. * | ``User::op_iterator`` - Typedef for iterator over the operand list; | ``op_iterator op_begin()`` - Get an iterator to the start of the operand; list.; | ``op_iterator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:145769,expose,expose,145769,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,"['access', 'expose']","['access', 'expose']"
Security,"space (a *layout unit*). Many interesting low level; operations on ``LinkGraph`` instances involve inspecting or mutating block; content or edges. * ``Content`` is represented as an ``llvm::StringRef``, and accessible via; the ``getContent`` method. Content is only available for content blocks,; and not for zero-fill blocks (use ``isZeroFill`` to check, and prefer; ``getSize`` when only the block size is needed as it works for both; zero-fill and content blocks). * ``Section`` is represented as a ``Section&`` reference, and accessible via; the ``getSection`` method. The ``Section`` class is described in more detail; below. * ``Size`` is represented as a ``size_t``, and is accessible via the; ``getSize`` method for both content and zero-filled blocks. * ``Alignment`` is represented as a ``uint64_t``, and available via the; ``getAlignment`` method. It represents the minimum alignment requirement (in; bytes) of the start of the block. * ``AlignmentOffset`` is represented as a ``uint64_t``, and accessible via the; ``getAlignmentOffset`` method. It represents the offset from the alignment; required for the start of the block. This is required to support blocks; whose minimum alignment requirement comes from data at some non-zero offset; inside the block. E.g. if a block consists of a single byte (with byte; alignment) followed by a uint64_t (with 8-byte alignment), then the block; will have 8-byte alignment with an alignment offset of 7. * list of ``Edge`` instances. An iterator range for this list is returned by; the ``edges`` method. The ``Edge`` class is described in more detail below. * ``Symbol`` -- An offset from an ``Addressable`` (often a ``Block``), with an; optional ``Name``, a ``Linkage``, a ``Scope``, a ``Callable`` flag, and a; ``Live`` flag. Symbols make it possible to name content (blocks and addressables are; anonymous), or target content with an ``Edge``. * ``Name`` is represented as an ``llvm::StringRef`` (equal to; ``llvm::StringRef()`` if the symbol ha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst:9197,access,accessible,9197,interpreter/llvm-project/llvm/docs/JITLink.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/JITLink.rst,1,['access'],['accessible']
Security,"specialization whose declaration is; instantiated in one module and whose definition is instantiated in another; module may end up with members associated with the wrong declaration of the; class, which can result in miscompiles in some cases.; - Fix crash on use of a variadic overloaded operator.; (`#42535 <https://github.com/llvm/llvm-project/issues/42535>`_); - Fix a hang on valid C code passing a function type as an argument to; ``typeof`` to form a function declaration.; (`#64713 <https://github.com/llvm/llvm-project/issues/64713>`_); - Clang now reports missing-field-initializers warning for missing designated; initializers in C++.; (`#56628 <https://github.com/llvm/llvm-project/issues/56628>`_); - Clang now respects ``-fwrapv`` and ``-ftrapv`` for ``__builtin_abs`` and; ``abs`` builtins.; (`#45129 <https://github.com/llvm/llvm-project/issues/45129>`_,; `#45794 <https://github.com/llvm/llvm-project/issues/45794>`_); - Fixed an issue where accesses to the local variables of a coroutine during; ``await_suspend`` could be misoptimized, including accesses to the awaiter; object itself.; (`#56301 <https://github.com/llvm/llvm-project/issues/56301>`_); The current solution may bring performance regressions if the awaiters have; non-static data members. See; `#64945 <https://github.com/llvm/llvm-project/issues/64945>`_ for details.; - Clang now prints unnamed members in diagnostic messages instead of giving an; empty ''. Fixes; (`#63759 <https://github.com/llvm/llvm-project/issues/63759>`_); - Fix crash in __builtin_strncmp and related builtins when the size value; exceeded the maximum value representable by int64_t. Fixes; (`#64876 <https://github.com/llvm/llvm-project/issues/64876>`_); - Fixed an assertion if a function has cleanups and fatal erors.; (`#48974 <https://github.com/llvm/llvm-project/issues/48974>`_); - Clang now emits an error if it is not possible to deduce array size for a; variable with incomplete array type.; (`#37257 <https://github.com/llvm/llvm",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:33996,access,accesses,33996,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,['access'],['accesses']
Security,"spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX90A are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table`. .. table:: AMDHSA Memory Model Code Sequences GFX90A; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX90A; Space; ============ ============ ============== ========== ==================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:241355,access,accessed,241355,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX940, GFX941, GFX942; are defined in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table`. .. table:: AMDHSA Memory Model Code Sequences GFX940, GFX941, GFX942; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX940, GFX941, GFX942; S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:291373,access,accessed,291373,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"ss manager is to use a ``PassBuilder`` and call something like; ``PassBuilder::buildPerModuleDefaultPipeline()`` which creates a typical; pipeline for a given optimization level. Sometimes either frontends or backends will want to inject passes into the; pipeline. For example, frontends may want to add instrumentation, and target; backends may want to add passes that lower custom intrinsics. For these; cases, ``PassBuilder`` exposes callbacks that allow injecting passes into; certain parts of the pipeline. For example,. .. code-block:: c++. PassBuilder PB;; PB.registerPipelineStartEPCallback([&](ModulePassManager &MPM,; PassBuilder::OptimizationLevel Level) {; MPM.addPass(FooPass());; };. will add ``FooPass`` near the very beginning of the pipeline for pass; managers created by that ``PassBuilder``. See the documentation for; ``PassBuilder`` for the various places that passes can be added. If a ``PassBuilder`` has a corresponding ``TargetMachine`` for a backend, it; will call ``TargetMachine::registerPassBuilderCallbacks()`` to allow the; backend to inject passes into the pipeline. Clang's ``BackendUtil.cpp`` shows examples of a frontend adding (mostly; sanitizer) passes to various parts of the pipeline.; ``AMDGPUTargetMachine::registerPassBuilderCallbacks()`` is an example of a; backend adding passes to various parts of the pipeline. Pass plugins can also add passes into default pipelines. Different tools have; different ways of loading dynamic pass plugins. For example, ``opt; -load-pass-plugin=path/to/plugin.so`` loads a pass plugin into ``opt``. For; information on writing a pass plugin, see :doc:`WritingAnLLVMNewPMPass`. Using Analyses; ==============. LLVM provides many analyses that passes can use, such as a dominator tree.; Calculating these can be expensive, so the new pass manager has; infrastructure to cache analyses and reuse them when possible. When a pass runs on some IR, it also receives an analysis manager which it can; query for analyses. Querying f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst:6179,inject,inject,6179,interpreter/llvm-project/llvm/docs/NewPassManager.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/NewPassManager.rst,1,['inject'],['inject']
Security,"ss matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; properties over time. In all cases the LLVM Security Group should be consulted,; since they'll be responding to security issues filed against these parts of the; codebase. If you're not sure whether an issue is in-scope for this security process or; not, err towards assuming that it is. The Security Group might agree or disagree; and will explain its rationale in the report, as well as update this document; through the above process. The security-sensitive parts of the LLVM Project currently are the following.; Note that this list can change over time. * None are currently defined. Please don't let this stop you from reporting; issues to the security group that you believe are security-sensitive. The parts of the LLVM Project which are currently treated as non-security; sensitive are the following. Note that this list can change over time. * Language front-ends, such as clang, for which a malicious input file can cause; undesirable behavior. For example, a maliciously crafted C or Rust source file; can cause arbitrary code to execute in LLVM. These parts of LLVM haven't been; hardened, and compiling untrusted code usually also includes running utilities; such as `make` which can more readily perform malicious things. .. _CVE process: https://cve.mitre.org; .. _open a new issue: https://bugs.chromium.org/p/llvm/issues/entry; .. _chromium issue tracker: https://crbug.com; .. _GitHub security: https://help.github.com/en/articles/about-maintainer-security-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:15466,secur,security-sensitive,15466,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security-sensitive']
Security,"ssLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify arbitrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). #### Matrix properties. A matrix has five properties, which are all set in the constructor:. - `precision` <br>; If the `precision` is float (i.e. single precision), use the `TMatrixF` class family. If the precision is double, use the `TMatrixD` class family. - `type`<br>; Possible values are: `general` (`TMatrixD`), `symmetric` (`TMatrixDSym`) or `sparse` (`TMatrixDSparse`). - `size`<br>; Number of rows and columns. - `index`<br>; Range start of row and column index. By default these start at 0. - `sparse map`<br>; Only relevant for a sparse matrix. It indicates where elements are unequal 0. #### Accessing matrix properties. Use one of the following methods to access the information about the relevant matrix property:. - `Int_t GetRowLwb()`: Row lower-bound index. - `Int_t GetRowUpb()`: Row upper-bound index. - `Int_t GetNrows()`: Number of rows. - `Int_t GetColLwb()`: Column lower-bound index. - `Int_t GetColUpb()`: Column upper-bound index. - `Int_t GetNcols()`: Number of columns. - `Int_t GetNoElements()`: Number of elements, for a dense matrix this equals: `fNrows x fNcols`. - `Double_t GetTol()`: Tolerance number that is used in decomposition operations. - `Int_t *GetRowIndexArray()`: For sparse matrices, access to the row index of `fNrows+1` entries. - `Int_t *GetColIndexArray()`: For sparse matrices, access to the column index of `fNelems` entries. #### Setting matrix properties. Use one of the following methods to set a matrix property:. - `SetTol (Double_t tol)`<br>; Sets the tolerance number. - `ResizeTo (Int_t nrows,Int_t ncols, Int_t nr_nonzeros=-1)`<br>; Changes the matrix shape to `nrows x ncols`. Index will start at 0. - `ResizeTo(Int_t ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md:2532,access,access,2532,math/matrix/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/doc/index.md,1,['access'],['access']
Security,"sses; ===============. This section describes the LLVM Analysis Passes. ``aa-eval``: Exhaustive Alias Analysis Precision Evaluator; ----------------------------------------------------------. This is a simple N^2 alias analysis accuracy evaluator. Basically, for each; function in the program, it simply queries to see how the alias analysis; implementation answers alias queries between each pair of pointers in the; function. This is inspired and adapted from code by: Naveen Neelakantam, Francesco; Spadini, and Wojciech Stryjewski. ``basic-aa``: Basic Alias Analysis (stateless AA impl); ------------------------------------------------------. A basic alias analysis pass that implements identities (two different globals; cannot alias, etc), but does no stateful analysis. ``basiccg``: Basic CallGraph Construction; -----------------------------------------. Yet to be written. .. _passes-da:. ``da``: Dependence Analysis; ---------------------------. Dependence analysis framework, which is used to detect dependences in memory; accesses. ``domfrontier``: Dominance Frontier Construction; ------------------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominator frontiers. ``domtree``: Dominator Tree Construction; ----------------------------------------. This pass is a simple dominator construction algorithm for finding forward; dominators. ``dot-callgraph``: Print Call Graph to ""dot"" file; -------------------------------------------------. This pass, only available in ``opt``, prints the call graph into a ``.dot``; graph. This graph can then be processed with the ""dot"" tool to convert it to; postscript or some other suitable format. ``dot-cfg``: Print CFG of function to ""dot"" file; ------------------------------------------------. This pass, only available in ``opt``, prints the control flow graph into a; ``.dot`` graph. This graph can then be processed with the :program:`dot` tool; to convert it to postscript or s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst:2096,access,accesses,2096,interpreter/llvm-project/llvm/docs/Passes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Passes.rst,1,['access'],['accesses']
Security,"ssible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user of the library; from the burden of locking. A thread suffers from **`deadlock`** if it is blocked waiting for a; condition that will never occur. Typically, this occurs when one thread; needs to access a resource that is already locked by another thread, and; that other thread is trying to access a resource that has already been; locked by the first thread. In this situation, neither thread is able to; progress; they are deadlocked. A **`multiprocessor`** is a hardware system with multiple processors or; multiple, simultaneous execution units. - Examples can be found at; <http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html>; (the thread authors' web site - Jörn Adamczewski and Marc; Hemberger). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:24860,access,access,24860,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,2,['access'],['access']
Security,"ssing the data interval and the number of bins, you have to pass an; array (single or double precision) of bin edges. When the histogram; has `n` bins, then there are `n+1` distinct edges, so the array you; pass must be of size `n+1`. ``` {.cpp}; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; ```. Each histogram object contains three **`TAxis`** objects: `fXaxis` ,; `fYaxis,` and `fZaxis`, but for one-dimensional histograms only the; X-axis is relevant, while for two-dimensional histograms the X-axis; and Y-axis are relevant. See the class **` TAxis`** for a description; of all the access methods. The bin edges are always stored internally; in double precision. You can examine the actual edges / limits of the histogram bins by; accessing the axis parameters, like in the example below:. ``` {.cpp}; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; ```. ## Bin Numbering. All histogram types support fixed or variable bin sizes. 2-D; histograms may have fixed size bins along X and variable size bins; along Y or vice-versa. The functions to fill, manipulate, draw, or; access histograms are identical in both cases. ### Convention. For all histogram types: `nbins` , `xlow` , `xup`. Bin\# 0 contains the underflow.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md:5458,access,accessing,5458,documentation/users-guide/Histograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Histograms.md,1,['access'],['accessing']
Security,st common; alignment of ``&`` and ``*``.; Pointer and reference alignment styles are going to be updated according; to the preferences found in the file.; ``PointerAlignment`` is then used only as fallback. .. _DisableFormat:. **DisableFormat** (``Boolean``) :versionbadge:`clang-format 3.7` :ref:`¶ <DisableFormat>`; Disables formatting completely. .. _EmptyLineAfterAccessModifier:. **EmptyLineAfterAccessModifier** (``EmptyLineAfterAccessModifierStyle``) :versionbadge:`clang-format 13` :ref:`¶ <EmptyLineAfterAccessModifier>`; Defines when to put an empty line after access modifiers.; ``EmptyLineBeforeAccessModifier`` configuration handles the number of; empty lines between two access modifiers. Possible values:. * ``ELAAMS_Never`` (in configuration: ``Never``); Remove all empty lines after access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELAAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines after access modifiers.; MaxEmptyLinesToKeep is applied instead. * ``ELAAMS_Always`` (in configuration: ``Always``); Always add empty line after access modifiers if there are none.; MaxEmptyLinesToKeep is applied also. .. code-block:: c++. struct foo {; private:. int i;; protected:. int j;; /* comment */; public:. foo() {}; private:. protected:. };. .. _EmptyLineBeforeAccessModifier:. **EmptyLineBeforeAccessModifier** (``EmptyLineBeforeAccessModifierStyle``) :versionbadge:`clang-format 12` :ref:`¶ <EmptyLineBeforeAccessModifier>`; Defines in which cases to put empty line before access modifiers. Possible values:. * ``ELBAMS_Never`` (in configuration: ``Never``); Remove all empty lines before access modifiers. .. code-block:: c++. struct foo {; private:; int i;; protected:; int j;; /* comment */; public:; foo() {}; private:; protected:; };. * ``ELBAMS_Leave`` (in configuration: ``Leave``); Keep existing empty lines before access modifiers. * ``ELBAMS_LogicalBl,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:61237,access,access,61237,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"st. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instructions belong to an access; group referred to by ``llvm.loop.parallel_accesses``, then the loop must; not be considered trivially parallel. Additional; memory dependence analysis is required to make that determination. As a fail; safe mechanism, this causes loops that were originally parallel to be considered; sequential (if optimization passes that are unaware of the parallel semantics; insert new memory instructions into the loop body). Example of a loop that is considered parallel due to its correct use of; both ``llvm.access.group`` and ``llvm.loop.parallel_accesses``; metadata types. .. code-block:: llvm. for.body:; ...; %val0 = load i32, ptr %arrayidx, !llvm.access.group !1; ...; store i32 %val0, ptr %arrayidx1, !llvm.access.group !1; ...; br i1 %exitcond, label %for.end, label %for.body, !llvm.loop !0. for.end:; ...; !0 = distinct !{!0, !{!""llvm.loop.parallel_accesses"", !1}}; !1 = distinct !{}. It is also possible to have nested parallel loops:. .. code-block:: llvm. outer.for.body:; ...; %val1 = load i32, ptr %arrayidx3, !llvm.access.group !4; ...; br label %inner.for.body. inner.for.body:; ...; %val0 = load i32, ptr %arrayidx1, !llvm.access.group !3; ...; store i32 %val0, ptr %arrayidx2, !llvm.access.group !3; ...; br i1 %exitcond, label %inner.for.end, label %inner.for.body, !llvm.loop !1. inner.for.end:; ...; store i32 %val1, ptr %arrayidx4, !llvm.access.group !4; ...; br i1 %exitcond, label %outer.for.end, label %outer.for.body, !llvm.loop !2. outer.for.end: ; preds = %for.body; ...; !1 = distinct !{!1, !{!""llvm.loop.parallel_accesses"", !3}} ; metadata for the inner loop; !2 = distinct !{!2, !{!""llvm.loop.parallel_accesses"", !3, !4}} ; m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:313225,access,access,313225,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,stant expressions; Unknown. 1827; drafting; Reference binding with ambiguous conversions; Not resolved. 1828; CD6; nested-name-specifier ambiguity; Unknown. 1829; CD6; Dependent unnamed types; Unknown. 1830; CD4; Repeated specifiers; Unknown. 1831; NAD; Explicitly vs implicitly deleted move constructors; Unknown. 1832; CD4; Casting to incomplete enumeration; Unknown. 1833; NAD; friend declarations naming implicitly-declared member functions; Unknown. 1834; CD4; Constant initialization binding a reference to an xvalue; Unknown. 1835; CD6; Dependent member lookup before <; Unknown. 1836; CD5; Use of class type being defined in trailing-return-type; Unknown. 1837; CD6; Use of this in friend and local class declarations; Clang 3.3. 1838; CD4; Definition via unqualified-id and using-declaration; Unknown. 1839; CD6; Lookup of block-scope extern declarations; Unknown. 1840; drafting; Non-deleted explicit specialization of deleted function template; Not resolved. 1841; CD6; < following template injected-class-name; Unknown. 1842; open; Unevaluated operands and “carries a dependency”; Not resolved. 1843; CD4; Bit-field in conditional operator with throw operand; Unknown. 1844; open; Defining “immediate context”; Not resolved. 1845; drafting; Point of instantiation of a variable template specialization; Not resolved. 1846; CD4; Declaring explicitly-defaulted implicitly-deleted functions; Unknown. 1847; CD4; Clarifying compatibility during partial ordering; Unknown. 1848; CD4; Parenthesized constructor and destructor declarators; Unknown. 1849; CD6; Variable templates and the ODR; Unknown. 1850; CD4; Differences between definition context and point of instantiation; Unknown. 1851; CD4; decltype(auto) in new-expressions; Unknown. 1852; CD4; Wording issues regarding decltype(auto); Unknown. 1853; dup; Defining “allocated storage”; Unknown. 1854; drafting; Disallowing use of implicitly-deleted functions; Not resolved. 1855; dup; Out-of-lifetime access to nonstatic data members; U,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:125034,inject,injected-class-name,125034,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['inject'],['injected-class-name']
Security,"state and one can have multiple instances of MnMigrad objects. ### M fails to find a minimum ###. If M fails to find a minimum, the user is notified by a warning message; issued by M when running into troubles. Problems can be:. - a bug in M. - an error in the $\mbox{FCN}$. - a highly difficult problem (usually strong correlations among; parameters). - floating–point precision. ## The output from minimization ##. ### The FunctionMinimum ###. The output of the minimizers is the FunctionMinimum. The FunctionMinimum; contains the result of the minimization in both internal parameter; representation and external parameter representation. ### User representable format: MnUserParameterState ###. On request, the result of the minimization is transformed into a user; representable format for parameters and errors, the; MnUserParameterState. ### Access values, errors, covariance ###. The result can be accessed via methods like; MnUserParameterState::value(unsigned int n) and; MnUserParameterState::error(unsigned int n), where $n$ is the index of; the parameter in the list of parameters defined by the user. ### Printout of the result ###. The FunctionMinimum can be printed on the output simply via std::cout.; It will print both the internal and external state, that is parameters,; errors and the covariance matrix (if available). It also tells the user; if M did converge or not by issuing an appropriate message. If a; covariance matrix is available, the global correlation coefficients are; printed as well. ### Global correlation coefficients ###. The global correlation coefficient for parameter $n$ is a number between; zero and one which gives the correlation between parameter $n$ and that; linear combination of all other parameters which is most strongly; correlated with $n$. # M application programming interface (API) #. [api:api]. ## FunctionMinimum ##. [api:fm] The FunctionMinimum is the output of the minimizers and; contains the minimization result. The state at the minimu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:36116,access,accessed,36116,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['access'],['accessed']
Security,"state between; functions. This avoids direct ABI implications by using a side channel between; callers and callees to communicate the predicate state. It also allows implicit; zero-initialization of the state, which allows non-checked code to be the first; code executed. However, this requires a load from TLS in the entry block, a store to TLS; before every call and every ret, and a load from TLS after every call. As a; consequence it is expected to be substantially more expensive even than using; `%rsp` and potentially `lfence` within the function entry block. ##### Define a new ABI and/or calling convention. We could define a new ABI and/or calling convention to explicitly pass the; predicate state in and out of functions. This may be interesting if none of the; alternatives have adequate performance, but it makes deployment and adoption; dramatically more complex, and potentially infeasible. ## High-Level Alternative Mitigation Strategies. There are completely different alternative approaches to mitigating variant 1; attacks. [Most](https://lwn.net/Articles/743265/); [discussion](https://lwn.net/Articles/744287/) so far focuses on mitigating; specific known attackable components in the Linux kernel (or other kernels) by; manually rewriting the code to contain an instruction sequence that is not; vulnerable. For x86 systems this is done by either injecting an `lfence`; instruction along the code path which would leak data if executed speculatively; or by rewriting memory accesses to have branch-less masking to a known safe; region. On Intel systems, `lfence` [will prevent the speculative load of secret; data](https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf).; On AMD systems `lfence` is currently a no-op, but can be made; dispatch-serializing by setting an MSR, and thus preclude misspeculation of the; code path ([mitigation G-2 +; V1-1](https://developer.amd.com/wp-content/resources/Managing-S",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:43553,attack,attacks,43553,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attacks']
Security,"std::set <dss_set>`. A sorted vector; (where you don't delete duplicate entries) or some other approach is almost; always better. .. _ds_map:. Map-Like Containers (std::map, DenseMap, etc); ---------------------------------------------. Map-like containers are useful when you want to associate data to a key. As; usual, there are a lot of different ways to do this. :). .. _dss_sortedvectormap:. A sorted 'vector'; ^^^^^^^^^^^^^^^^^. If your usage pattern follows a strict insert-then-query approach, you can; trivially use the same approach as :ref:`sorted vectors for set-like containers; <dss_sortedvectorset>`. The only difference is that your query function (which; uses std::lower_bound to get efficient log(n) lookup) should only compare the; key, not both the key and value. This yields the same advantages as sorted; vectors for sets. .. _dss_stringmap:. llvm/ADT/StringMap.h; ^^^^^^^^^^^^^^^^^^^^. Strings are commonly used as keys in maps, and they are difficult to support; efficiently: they are variable length, inefficient to hash and compare when; long, expensive to copy, etc. StringMap is a specialized container designed to; cope with these issues. It supports mapping an arbitrary range of bytes to an; arbitrary other object. The StringMap implementation uses a quadratically-probed hash table, where the; buckets store a pointer to the heap allocated entries (and some other stuff).; The entries in the map must be heap allocated because the strings are variable; length. The string data (key) and the element object (value) are stored in the; same allocation with the string data immediately after the element object.; This container guarantees the ""``(char*)(&Value+1)``"" points to the key string; for a value. The StringMap is very fast for several reasons: quadratic probing is very cache; efficient for lookups, the hash value of strings in buckets is not recomputed; when looking up an element, StringMap rarely has to touch the memory for; unrelated objects when looking u",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:88602,hash,hash,88602,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['hash'],['hash']
Security,"stems Inc) []; * Boovaragavan Dasarathan (Nvidia) [@mrragava]; * Dimitry Andric (individual; FreeBSD) [@DimitryAndric]; * Ed Maste (individual; FreeBSD) [@emaste]; * George Burgess IV (Google) [@gburgessiv]; * Josh Stone (Red Hat; Rust) [@cuviper]; * Kate McInnes (Apple) []; * Kristof Beyls (ARM) [@kbeyls]; * Matthew Riley (Google) [@mmdriley]; * Nikhil Gupta (Nvidia) []; * Oliver Hunt (Apple) [@ojhunt]; * Paul Robinson (Sony) [@pogo59]; * Peter Smith (ARM) [@smithp35]; * Pietro Albini (Ferrous Systems; Rust) [@pietroalbini]; * Serge Guelton (Mozilla) [@serge-sans-paille]; * Sergey Maslov (Intel) [@smaslov-intel]; * Shayne Hiet-Block (Microsoft) [@GreatKeeper]; * Tim Penge (Sony) []. Criteria; --------. * Nominees for LLVM Security Group membership should fall in one of these groups:. - Individual contributors:. + Specializes in fixing compiler-based security related issues or often participates in their exploration and resolution.; + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities.; + Has actively contributed non-trivial code to the LLVM project in the last year. - Researchers:. + Has a track record of finding security vulnerabilities and responsible disclosure of those vulnerabilities.; + Is a compiler expert who has specific interests in knowing about, resolving, and preventing future security vulnerabilities. - Vendor contacts:. + Represents an organization or company which ships products that include their own copy of LLVM. Due to their position in the organization, the nominee has a reasonable need to know about security issues and disclosure embargoes. * Additionally, the following are necessary but not sufficient criteria for membership in the LLVM Security Group:. - If already in the LLVM Security Group, has actively participated in one (if any) security issue in the last ye",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:3420,secur,security,3420,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"ster overlaps with another). In addition to the per-register description, the ``TargetRegisterInfo`` class; exposes a set of processor specific register classes (instances of the; ``TargetRegisterClass`` class). Each register class contains sets of registers; that have the same properties (for example, they are all 32-bit integer; registers). Each SSA virtual register created by the instruction selector has; an associated register class. When the register allocator runs, it replaces; virtual registers with a physical register in the set. The target-specific implementations of these classes is auto-generated from a; :doc:`TableGen/index` description of the register file. .. _TargetInstrInfo:. The ``TargetInstrInfo`` class; -----------------------------. The ``TargetInstrInfo`` class is used to describe the machine instructions; supported by the target. Descriptions define things like the mnemonic for; the opcode, the number of operands, the list of implicit register uses and defs,; whether the instruction has certain target-independent properties (accesses; memory, is commutable, etc), and holds any target-specific flags. The ``TargetFrameLowering`` class; ---------------------------------. The ``TargetFrameLowering`` class is used to provide information about the stack; frame layout of the target. It holds the direction of stack growth, the known; stack alignment on entry to each function, and the offset to the local area.; The offset to the local area is the offset from the stack pointer on function; entry to the first location where function data (local variables, spill; locations) can be stored. The ``TargetSubtarget`` class; -----------------------------. The ``TargetSubtarget`` class is used to provide information about the specific; chip set being targeted. A sub-target informs code generation of which; instructions are supported, instruction latencies and instruction execution; itinerary; i.e., which processing units are used, in what order, and for how; long.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:13847,access,accesses,13847,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['access'],['accesses']
Security,"still; used as local cache of the experiment information or to store the work-in-progress status of the dataset manager daemon. This model addresses the scalability issues observed at ALICE AFs.; - Improvements in [TProofBench](https://root.cern.ch/doc/master/classTProofBench.html):; - Recording and display of the maximum rate during query, CPU efficiency calculation for PROOF-Lite runs, better measurement of wall time.; - Support for dynamic startup mode. - Test program xpdtest to test the status of xproofd (see also man page under $ROOTSYS/man/man1):. ``` {.sh}; $ xpdtest [options]; --help, -h; Gives a short list of options avaliable, and exit; -t <test>; type of test to be run:; 0 ping the daemon (includes process existence check if pid specified; see below); 1 ping the daemon and check connection for default user; 2 ping the daemon and check connection for the default user and all recent users; ...; ```; - Interface with **igprof** for fast statistic profiling. Like valgrind, it can be specified as option to TProof::Open and the output is available via the log viewer technology:. ``` {.cpp}; root[] p = TProof::Open(""master"", ""igprof-pp""); ```; - Miscellanea:; - Added functions [Getenv](http://root.cern.ch/root/htmldoc/TProof.html#TProof:Getenv) and [GetRC](http://root.cern.ch/root/htmldoc/TProof.html#TProof:GetRC); in TProof to retrieve environment information from the nodes, typically from the master.; - Add support unix secondary groups in group access control. This allows more flexibility in, for example, assigning group-shared credential files to the daemon.; - Several new tests and options in the test program _stressProof_. ### Bug fixes. Several consolidation fixes in several parts of the system (see the [5.34 patch release notes for details](https://root.cern/install/all_releases/root-version-v5-34-00-patch-release-notes/)). In particular, those for 'xproofd' were provided by B. Butler and M. Swiatlowski and greatly contributed to consolidate the daemon. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v600/index.md:2498,access,access,2498,proof/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v600/index.md,1,['access'],['access']
Security,"stinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the content must be updated which, because metadata is; immutable by design, would required finding and updating all references; to the access group node. The access group can be used to refer to a memory access instruction; without pointing to it directly (which is not possible in global; metadata). Currently, the only metadata making use of it is; ``llvm.loop.parallel_accesses``. '``llvm.loop.parallel_accesses``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``llvm.loop.parallel_accesses`` metadata refers to one or more; access group metadata nodes (see ``llvm.access.group``). It denotes that; no loop-carried memory dependence exist between it and other instructions; in the loop with this metadata. Let ``m1`` and ``m2`` be two instructions that both have the; ``llvm.access.group`` metadata to the access group ``g1``, respectively; ``g2`` (which might be identical). If a loop contains both access groups; in its ``llvm.loop.parallel_accesses`` metadata, then the compiler can; assume that there is no dependency between ``m1`` and ``m2`` carried by; this loop. Instructions that belong to multiple access groups are; considered having this property if at least one of the access groups; matches the ``llvm.loop.parallel_accesses`` list. If all memory-accessing instructions in a loop have; ``llvm.access.group`` metadata that each refer to one of the access; groups of a loop's ``llvm.loop.parallel_accesses`` metadata, then the; loop has no loop carried memory dependences and is considered to be a; parallel loop. Note that if not all memory access instruct",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:311550,access,access,311550,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"stop, then stop. Persisting in such; behavior after being asked to stop is considered harassment. .. _when we disagree, try to understand why:. * **When we disagree, try to understand why.** Disagreements, both social and; technical, happen all the time and LLVM is no exception. It is important that; we resolve disagreements and differing views constructively. Remember that; we're different. The strength of LLVM comes from its varied community, people; from a wide range of backgrounds. Different people have different; perspectives on issues. Being unable to understand why someone holds; a viewpoint doesn't mean that they're wrong. Don't forget that it is human to; err and blaming each other doesn't get us anywhere. Instead, focus on helping; to resolve issues and learning from mistakes. Reporting; =========. If you believe someone is violating the code of conduct you can always report; it to the LLVM Foundation Code of Conduct Committee by emailing; conduct@llvm.org. All reports will be kept confidential. This isn't a public; list and only members of the advisory committee will receive the report. For; details on what to include in the report, please see the :doc:`Reporting Guide; <ReportingGuide>`. If you believe anyone is in physical danger, please notify appropriate law; enforcement first. If you are unsure what law enforcement agency is; appropriate, please include this in your report and we will attempt to notify; them. If the violation occurs at an event such as a Developer Meeting and requires; immediate attention, you can also reach out to any of the event organizers or; staff. Event organizers and staff will be prepared to handle the incident and; able to help. If you cannot find one of the organizers, the venue staff can; locate one for you. We will also post detailed contact information for specific; events as part of each events' information. In person reports will still be; kept confidential exactly as above, but also feel free to (anonymously if; needed",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:5635,confidential,confidential,5635,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['confidential'],['confidential']
Security,"sts whether the given pointer is associated; with the given type identifier. .. _type.checked.load:. '``llvm.type.checked.load``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare {ptr, i1} @llvm.type.checked.load(ptr %ptr, i32 %offset, metadata %type) nounwind memory(argmem: read). Arguments:; """""""""""""""""""". The first argument is a pointer from which to load a function pointer. The; second argument is the byte offset from which to load the function pointer. The; third argument is a metadata object representing a :doc:`type identifier; <TypeMetadata>`. Overview:; """""""""""""""""". The ``llvm.type.checked.load`` intrinsic safely loads a function pointer from a; virtual table pointer using type metadata. This intrinsic is used to implement; control flow integrity in conjunction with virtual call optimization. The; virtual call optimization pass will optimize away ``llvm.type.checked.load``; intrinsics associated with devirtualized calls, thereby removing the type; check in cases where it is not needed to enforce the control flow integrity; constraint. If the given pointer is associated with a type metadata identifier, this; function returns true as the second element of its return value. (Note that; the function may also return true if the given pointer is not associated; with a type metadata identifier.) If the function's return value's second; element is true, the following rules apply to the first element:. - If the given pointer is associated with the given type metadata identifier,; it is the function pointer loaded from the given byte offset from the given; pointer. - If the given pointer is not associated with the given type metadata; identifier, it is one of the following (the choice of which is unspecified):. 1. The function pointer that would have been loaded from an arbitrarily chosen; (through an unspecified mechanism) pointer associated with the type; metadata. 2. If the function has a non-void return type, a pointer to a function that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:938649,integrity,integrity,938649,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['integrity'],['integrity']
Security,"sts.png. Opting Out; ^^^^^^^^^^. In case you want to opt-out entirely of pre-merge testing, add yourself to the; `OPT OUT project <https://reviews.llvm.org/project/view/83/>`_. If you decide; to opt-out, please let us know why, so we might be able to improve in the future. Operational Details; ^^^^^^^^^^^^^^^^^^^. The code responsible for running the pre-merge flow can be found in the `external; repository <https://github.com/google/llvm-premerge-checks>`_. For enhancement; ideas and most bugs, please file an issue on said repository. For immediate; operational problems, the point of contact is; `Mikhail Goncharov <mailto:goncharo@google.com>`_. Background on the pre-merge infrastructure can be found in `this 2020 DevMeeting; talk <https://llvm.org/devmtg/2020-09/slides/Goncharov-Pre-merge_checks.pdf>`_. Committing a change; -------------------. Once a patch has been reviewed and approved on Phabricator it can then be; committed to trunk. If you do not have commit access, someone has to; commit the change for you (with attribution). It is sufficient to add; a comment to the approved review indicating you cannot commit the patch; yourself. If you have commit access, there are multiple workflows to commit the; change. Whichever method you follow it is recommended that your commit message; ends with the line:. ::. Differential Revision: <URL>. where ``<URL>`` is the URL for the code review, starting with; ``https://reviews.llvm.org/``. This allows people reading the version history to see the review for; context. This also allows Phabricator to detect the commit, close the; review, and add a link from the review to the commit. Note that if you use the Arcanist tool the ``Differential Revision`` line will; be added automatically. If you don't want to use Arcanist, you can add the; ``Differential Revision`` line (as the last line) to the commit message; yourself. Using the Arcanist tool can simplify the process of committing reviewed code as; it will retrieve reviewers, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst:13322,access,access,13322,interpreter/llvm-project/llvm/docs/Phabricator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Phabricator.rst,1,['access'],['access']
Security,"style>. .. contents::; :local:. .. warning::; This is a work in progress. Introduction; ============. The LLVM target-independent code generator is a framework that provides a suite; of reusable components for translating the LLVM internal representation to the; machine code for a specified target---either in assembly form (suitable for a; static compiler) or in binary machine code format (usable for a JIT; compiler). The LLVM target-independent code generator consists of six main; components:. 1. `Abstract target description`_ interfaces which capture important properties; about various aspects of the machine, independently of how they will be used.; These interfaces are defined in ``include/llvm/Target/``. 2. Classes used to represent the `code being generated`_ for a target. These; classes are intended to be abstract enough to represent the machine code for; *any* target machine. These classes are defined in; ``include/llvm/CodeGen/``. At this level, concepts like ""constant pool; entries"" and ""jump tables"" are explicitly exposed. 3. Classes and algorithms used to represent code at the object file level, the; `MC Layer`_. These classes represent assembly level constructs like labels,; sections, and instructions. At this level, concepts like ""constant pool; entries"" and ""jump tables"" don't exist. 4. `Target-independent algorithms`_ used to implement various phases of native; code generation (register allocation, scheduling, stack frame representation,; etc). This code lives in ``lib/CodeGen/``. 5. `Implementations of the abstract target description interfaces`_ for; particular targets. These machine descriptions make use of the components; provided by LLVM, and can optionally provide custom target-specific passes,; to build complete code generators for a specific target. Target descriptions; live in ``lib/Target/``. 6. The target-independent JIT components. The LLVM JIT is completely target; independent (it uses the ``TargetJITInfo`` structure to interface for; tar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst:1568,expose,exposed,1568,interpreter/llvm-project/llvm/docs/CodeGenerator.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeGenerator.rst,1,['expose'],['exposed']
Security,"such as hash buckets and hash; values. .. option:: -publics. dump public symbol records. .. option:: -public-extras. dump additional information about the publics, such as hash buckets and hash; values. .. option:: -symbols. dump symbols (functions, variables, etc) for each module dumped. .. option:: -sym-data. For each symbol record dumped as a result of the :option:`-symbols` option,; display the full bytes of the record in binary as well. Type Record Options; +++++++++++++++++++. .. option:: -types. Dump CodeView type records from TPI stream. .. option:: -type-extras. Dump additional information from the TPI stream, such as hashes and the type; index offsets array. .. option:: -type-data. For each type record dumped, display the full bytes of the record in binary as; well. .. option:: -type-index=<uint>. Only dump types with the specified type index. .. option:: -ids. Dump CodeView type records from IPI stream. .. option:: -id-extras. Dump additional information from the IPI stream, such as hashes and the type; index offsets array. .. option:: -id-data. For each ID record dumped, display the full bytes of the record in binary as; well. .. option:: -id-index=<uint>. only dump ID records with the specified hexadecimal type index. .. option:: -dependents. When used in conjunction with :option:`-type-index` or :option:`-id-index`,; dumps the entire dependency graph for the specified index instead of just the; single record with the specified index. For example, if type index 0x4000 is; a function whose return type has index 0x3000, and you specify; `-dependents=0x4000`, then this would dump both records (as well as any other; dependents in the tree). Miscellaneous Options; +++++++++++++++++++++. .. option:: -all. Implies most other options. .. option:: -section-contribs. Dump section contributions. .. option:: -section-headers. Dump image section headers. .. option:: -section-map. Dump section map. .. option:: -string-table. Dump PDB string table. .. _bytes_subcommand",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst:9717,hash,hashes,9717,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-pdbutil.rst,1,['hash'],['hashes']
Security,"suosl/master/config/workers.py``; * builders are added to ``buildbot/osuosl/master/config/builders.py``. Please make sure your builder name and its builddir are unique through the; file. All new builders should default to using the ""'collapseRequests': False""; configuration. This causes the builder to build each commit individually; and not merge build requests. To maximize quality of feedback to developers,; we *strongly prefer* builders to be configured not to collapse requests.; This flag should be removed only after all reasonable efforts have been; exhausted to improve build times such that the builder can keep up with; commit flow. It is possible to allow email addresses to unconditionally receive; notifications on build failure; for this you'll need to add an; ``InformativeMailNotifier`` to ``buildbot/osuosl/master/config/status.py``.; This is particularly useful for the staging buildmaster which is silent; otherwise. #. Send the buildbot-worker access name and the access password directly to; `Galina Kistanova <mailto:gkistanova@gmail.com>`_, and wait until she; lets you know that your changes are applied and buildmaster is; reconfigured. #. Make sure you can start the buildbot-worker and successfully connect; to the silent buildmaster. Then set up your buildbot-worker to start; automatically at the start up time. See the buildbot documentation; for help. You may want to restart your computer to see if it works. #. Check the status of your buildbot-worker on the `Waterfall Display (Staging); <http://lab.llvm.org/staging/#/waterfall>`_ to make sure it is; connected, and the `Workers Display (Staging); <http://lab.llvm.org/staging/#/workers>`_ to see if administrator; contact and worker information are correct. #. At this point, you have a working builder connected to the staging; buildmaster. You can now make sure it is reliably green and keeps; up with the build queue. No notifications will be sent, so you can; keep an unstable builder connected to staging i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:6288,access,access,6288,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,3,"['access', 'password']","['access', 'password']"
Security,"support for linker relaxation.; * Assorted codegen improvements. Changes to the MIPS Backend; ---------------------------. Changes to the PowerPC Backend; ------------------------------. * LLJIT's JIT linker now defaults to JITLink on 64-bit ELFv2 targets.; * Initial-exec TLS model is supported on AIX.; * Implemented new resource based scheduling model of POWER7 and POWER8.; * ``frexp`` libcall now references correct symbol name for ``fp128``.; * Optimized materialization of 64-bit immediates, code generation of; ``vec_promote`` and atomics.; * Global constant strings are pooled in the TOC under one entry to reduce the; number of entries in the TOC.; * Added a number of missing Power10 extended mnemonics.; * Added the SCV instruction.; * Fixed register class for the paddi instruction.; * Optimize VPERM and fix code order for swapping vector operands on LE.; * Added various bug fixes and code gen improvements. AIX Support/improvements:. * Support for a non-TOC-based access sequence for the local-exec TLS model (called small local-exec).; * XCOFF toc-data peephole optimization and bug fixes.; * Move less often used __ehinfo TOC entries to the end of the TOC section.; * Fixed problems when the AIX libunwind unwinds starting from a signal handler; and the function that raised the signal happens to be a leaf function that; shares the stack frame with its caller or a leaf function that does not store; the stack frame backchain. Changes to the RISC-V Backend; -----------------------------. * The Zfa extension version was upgraded to 1.0 and is no longer experimental.; * Zihintntl extension version was upgraded to 1.0 and is no longer experimental.; * Intrinsics were added for Zk*, Zbb, and Zbc. See https://github.com/riscv-non-isa/riscv-c-api-doc/blob/master/riscv-c-api.md#scalar-bit-manipulation-extension-intrinsics; * Default ABI with F but without D was changed to ilp32f for RV32 and to lp64f for RV64.; * The Zvbb, Zvbc, Zvkb, Zvkg, Zvkn, Zvknc, Zvkned, Zvkng, Zvknha, Z",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst:6290,access,access,6290,interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ReleaseNotes.rst,1,['access'],['access']
Security,"sure that e.g. `clang -v` reports a; user-friendly revision number (e.g. `main-12345` or `4.0-5321`), addressing; the objections raised above with respect to this aspect of Git. What About Branches and Merges?; -------------------------------. In contrast to SVN, Git makes branching easy. Git's commit history is; represented as a DAG, a departure from SVN's linear history. However, we propose; to mandate making merge commits illegal in our canonical Git repository. Unfortunately, GitHub does not support server side hooks to enforce such a; policy. We must rely on the community to avoid pushing merge commits. GitHub offers a feature called `Status Checks`: a branch protected by; `status checks` requires commits to be explicitly allowed before the push can happen.; We could supply a pre-push hook on the client side that would run and check the; history, before allowing the commit being pushed [statuschecks]_.; However this solution would be somewhat fragile (how do you update a script; installed on every developer machine?) and prevents SVN access to the; repository. What About Commit Emails?; -------------------------. We will need a new bot to send emails for each commit. This proposal leaves the; email format unchanged besides the commit URL. Straw Man Migration Plan; ========================. Step #1 : Before The Move; -------------------------. 1. Update docs to mention the move, so people are aware of what is going on.; 2. Set up a read-only version of the GitHub project, mirroring our current SVN; repository.; 3. Add the required bots to implement the commit emails, as well as the; umbrella repository update (if the multirepo is selected) or the read-only; Git views for the sub-projects (if the monorepo is selected). Step #2 : Git Move; ------------------. 4. Update the buildbots to pick up updates and commits from the GitHub; repository. Not all bots have to migrate at this point, but it'll help; provide infrastructure testing.; 5. Update Phabricator to pick up",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:6385,access,access,6385,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['access'],['access']
Security,"system of the higher level language; being compiled. **Scalar type descriptors** describe types that do not; contain other types. Each scalar type has a parent type, which must also; be a scalar type or the TBAA root. Via this parent relation, scalar types; within a TBAA root form a tree. **Struct type descriptors** denote types; that contain a sequence of other type descriptors, at known offsets. These; contained type descriptors can either be struct type descriptors themselves; or scalar type descriptors. **Access tags** are metadata nodes attached to load and store instructions.; Access tags use type descriptors to describe the *location* being accessed; in terms of the type system of the higher level language. Access tags are; tuples consisting of a base type, an access type and an offset. The base; type is a scalar type descriptor or a struct type descriptor, the access; type is a scalar type descriptor, and the offset is a constant integer. The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two; things:. * If ``BaseTy`` is a struct type, the tag describes a memory access (load; or store) of a value of type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is; ``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as; described in the TBAA metadata. ``ImmediateParent(BaseTy, Offset)`` is; undefined if ``Offset`` is non-zero. * If ``BaseTy`` is a struct type then ``ImmediateParent(BaseTy, Offset)``; is ``(NewTy, NewOffset)`` where ``NewTy`` is the type contained in; ``BaseTy`` at offset ``Offset`` and ``NewOffset`` is ``Offset`` adjusted; to be relative within that inner",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:274959,access,access,274959,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"t --trees Events --all-branches --threads 8; ```. ## Core Libraries. ### Interpreter. #### Support for profiling/debugging interpreted/JITted code. This version of ROOT adds an LLVM JIT event listener to create perf map files; during runtime. This allows profiling of interpreted/JITted code generated by; cling. Instead of function addresses, the perf data will contain full function; names. In addition, stack frame pointers are enabled in JITted code, so full; stack traces can be generated. Debugging is aided by switching off optimisations; and adding frame pointers for better stack traces. However, since both have a; runtime cost, they are disabled by default. Similar to `LD_DEBUG` and `LD_PROFILE`; for `ld.so`, the environment variables `CLING_DEBUG=1` and/or `CLING_PROFILE=1`; can be set to enable debugging and/or profiling. ### Other changes. - Shadowing of declarations in the `std` namespace is now diagnosed. Specifically, given that ROOT injects `using namespace std` directive, _all_ the names in the `std` namespace become available in the global scope. However, in some circumstances users inadvertently introduce a declaration that conflicts with a name in `std` making references to the former declaration result in ambiguous lookup.; A fairly common case is trying to declare a global variable named `data` which conflict with [`std::data`](https://en.cppreference.com/w/cpp/iterator/data) [C++17]. See [ROOT-5971](https://sft.its.cern.ch/jira/browse/ROOT-5971) for a discussion.; As of v6.28, such declarations result in; ```; root [] int data;; ROOT_prompt_0:1:1: warning: 'data' shadows a declaration with the same name in the 'std' namespace; use '::data' to reference this declaration; int data;; ^; ```. - Line editing at the ROOT interactive prompt has been improved. This version introduces useful shortcuts for common actions, e.g. Xterm-like fast movement between words using Ctrl+Left and Ctrl+Right, Ctrl+Del to delete the word under the cursor, or clearing the s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md:6414,inject,injects,6414,README/ReleaseNotes/v628/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v628/index.md,1,['inject'],['injects']
Security,"t a given port of a given host.; Improvements. In PROOF-Bench, file generation, add the possibility to change; only the generating function, passed as TMacro. Add also check on the; free space on the device and skip file generation if less than 10% or; less than 1 GB.; Record in TStatus also the max memory usage on the master and printed; via TStatus::Print; this allow a quick visualisation of the overall; memory usage at the end of the query.; Import version 0.9.6 of afdsmgrd; Make sure that the name(s) of the processed dataset(s) are registered; in the TFileInfo objects being processed, so that it can be used for; monitoring.; In XrdProofd, add possibility to skip the checks for the data; directories during session startup, as they may significantly slowdown; the startup process is the medium is busy. In such a case, admins; are responsible to create the directories in advance; the session; releated part fo the path is created by the session once up.; In XrdProofd, move the check for the username after authentication.; This is because authentication may run some credentials-to-user mapping; which can modify the requested username. This way we really check the; final username and not the one requested by the client, which may even; not exist on the machines. Side modification: when the mapping function; returns more usernames, the username specified by the client is used to; help choosing the effective username among the available choices; if not; match is found the handshake does any longer fail, the first mapped; username is chosen instead.; In XrdProofd, allow 'xpd.allowedgroups' to control also PROOF; groups, not only UNIX ones.In XrdProofd, simplify error; messages in case of login failure because of non-authorization.; Remove hardcoded additions of dirname(COMPILER) and of; '/bin:/usr/bin:/usr/local/bin' in front of PATH. These uncontrolled; additions could hide specific settings in PATH and be the source of; weird problems appearing in PROOF only.; Add more f",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html:2268,authenticat,authentication,2268,proof/doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v532/index.html,2,['authenticat'],['authentication']
Security,"t a; specific AMDGPU processor as a single architecture regardless of how it is; configured at run time. The compiler explicitly specifies the DWARF registers; that match the mode in which the code it is generating will be executed. DWARF registers are encoded as numbers, which are mapped to architecture; registers. The mapping for AMDGPU is defined in; :ref:`amdgpu-dwarf-register-mapping-table`. All AMDGPU targets use the same; mapping. .. table:: AMDGPU DWARF Register Mapping; :name: amdgpu-dwarf-register-mapping-table. ============== ================= ======== ==================================; DWARF Register AMDGPU Register Bit Size Description; ============== ================= ======== ==================================; 0 PC_32 32 Program Counter (PC) when; executing in a 32-bit process; address space. Used in the CFI to; describe the PC of the calling; frame.; 1 EXEC_MASK_32 32 Execution Mask Register when; executing in wavefront 32 mode.; 2-15 *Reserved* *Reserved for highly accessed; registers using DWARF shortcut.*; 16 PC_64 64 Program Counter (PC) when; executing in a 64-bit process; address space. Used in the CFI to; describe the PC of the calling; frame.; 17 EXEC_MASK_64 64 Execution Mask Register when; executing in wavefront 64 mode.; 18-31 *Reserved* *Reserved for highly accessed; registers using DWARF shortcut.*; 32-95 SGPR0-SGPR63 32 Scalar General Purpose; Registers.; 96-127 *Reserved* *Reserved for frequently accessed; registers using DWARF 1-byte ULEB.*; 128 STATUS 32 Status Register.; 129-511 *Reserved* *Reserved for future Scalar; Architectural Registers.*; 512 VCC_32 32 Vector Condition Code Register; when executing in wavefront 32; mode.; 513-767 *Reserved* *Reserved for future Vector; Architectural Registers when; executing in wavefront 32 mode.*; 768 VCC_64 64 Vector Condition Code Register; when executing in wavefront 64; mode.; 769-1023 *Reserved* *Reserved for future Vector; Architectural Registers when; executing in wavefront 64 mode.*",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:87434,access,accessed,87434,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"t and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76663,sanitiz,sanitize-recover,76663,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitize-recover']
Security,"t and usage are defined by the shader compiler. Each shader's table in the ``.data`` section is referenced by the symbol; ``_amdgpu_``\ *xs*\ ``_shdr_intrl_data`` where *xs* corresponds with the; hardware shader stage the data is for. E.g.,; ``_amdgpu_cs_shdr_intrl_data`` for the compute shader hardware stage. .. _amdgpu-amdpal-code-object-metadata-user-data-spill-table-section:. Spill Table; ###########. It is possible for a hardware shader to need access to more *user data; entries* than there are slots available in user data registers for one; or more hardware shader stages. In that case, the PAL runtime expects; the necessary *user data entries* to be spilled to GPU memory and use; one user data register to point to the spilled user data memory. The; value of the *user data entry* must then represent the location where; a shader expects to read the low 32-bits of the table's GPU virtual; address. The *spill table* itself represents a set of 32-bit values; managed by the PAL runtime in GPU-accessible memory that can be made; indirectly accessible to a hardware shader. Unspecified OS; --------------. This section provides code conventions used when the target triple OS is; empty (see :ref:`amdgpu-target-triples`). Trap Handler ABI; ~~~~~~~~~~~~~~~~. For code objects generated by AMDGPU backend for non-amdhsa OS, the runtime does; not install a trap handler. The ``llvm.trap`` and ``llvm.debugtrap``; instructions are handled as follows:. .. table:: AMDGPU Trap Handler for Non-AMDHSA OS; :name: amdgpu-trap-handler-for-non-amdhsa-os-table. =============== =============== ===========================================; Usage Code Sequence Description; =============== =============== ===========================================; llvm.trap s_endpgm Causes wavefront to be terminated.; llvm.debugtrap *none* Compiler warning given that there is no; trap handler installed.; =============== =============== ===========================================. Source Languages; ===========",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:419967,access,accessible,419967,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,2,['access'],['accessible']
Security,"t argument substitution during macro expansion; Yes. 39; NAD; Questions about the ""C"" locale; Yes. 40; NAD; 9 unrelated questions about C89. Partial; Question 6 has full support, the rest of the questions are currently unknown.; . 41; NAD; Do characters defined in 5.2.1 impact 7.3.1?; N/A. 42; NAD; On the behavior of library functions and overlapping objects; N/A. 43; C89; On the definition of the NULL macro; Yes. 44; NAD; On the result of the offsetof macro; Yes. 45; NAD; Is the behavior of freopen defined when the file is invalid?; N/A. 46; NAD; Use of typedef names in parameter declarations; Yes. 47; NAD; Questions about declaration conformance; Yes. 48; NAD; Clarifications on the abort() function; N/A. 49; C89; Can strxfrm() output more characters than were input?; N/A. 50; NAD; Do wide string literals implicitly include <stddef.h>?; Yes. 51; NAD; Question on pointer arithmetic; Yes. 52; C89; Editorial corrections; Yes. 53; C89; Accessing a pointer to a function with a prototype through a pointer to pointer to function without a prototype; Yes. 54; C89; Can the string handling functions have a length of 0?; N/A. 55; C89; Signal handler macros should have distinct values; N/A. 56; NAD; Floating-point representation precision requirements; Yes. 57; NAD; Is there an integral type for every pointer?; Yes. 58; NAD; Is there a limit on the number of digits processed by scanf and strtdo?; N/A. 59; NAD; Do types have to be completed?; Yes. 60; C89; Array initialization from a string literal; Yes. 61; NAD; Whitespace in scanf format string; N/A. 62; NAD; Can the rename function be defined to fail?; N/A. 63; Dup; Floating-point representation precision requirements; Duplicate of 56. 64; NAD; Null pointer constants; Yes. 65; C89; Questions on locales; N/A. 66; NAD; Another question on locales; N/A. 67; NAD; Integer and integral type confusion; Yes. 68; NAD; 'char' and signed vs unsigned integer types; Yes. 69; NAD; Questions about the representation of integer types; Yes. 7",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html:4543,Access,Accessing,4543,interpreter/llvm-project/clang/www/c_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/c_dr_status.html,1,['Access'],['Accessing']
Security,"t by 1. Possible solutions; ^^^^^^^^^^^^^^^^^^; Let's briefly consider possible options about how and what we have to implement; in order to create full-featured functions merging, and also what it would; mean for us. Equal function detection obviously supposes that a ""detector"" method to be; implemented and latter should answer the question ""whether functions are equal"".; This ""detector"" method consists of tiny ""sub-detectors"", which each answers; exactly the same question, but for function parts. As the second step, we should merge equal functions. So it should be a ""merger""; method. ""Merger"" accepts two functions *F1* and *F2*, and produces *F1F2*; function, the result of merging. Having such routines in our hands, we can process a whole module, and merge all; equal functions. In this case, we have to compare every function with every another function. As; the reader may notice, this way seems to be quite expensive. Of course we could; introduce hashing and other helpers, but it is still just an optimization, and; thus the level of O(N*N) complexity. Can we reach another level? Could we introduce logarithmical search, or random; access lookup? The answer is: ""yes"". Random-access; """"""""""""""""""""""""""; How it could this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and te",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:5411,hash,hashing,5411,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,1,['hash'],['hashing']
Security,"t can only do so from the entry block. The ``func`` argument to '``llvm.localrecover``' must be a constant; bitcasted pointer to a function defined in the current module. The code; generator cannot determine the frame allocation offset of functions defined in; other modules. The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a; call frame that is currently live. The return value of '``llvm.localaddress``'; is one way to produce such a value, but various runtimes also expose a suitable; pointer in platform-specific ways. The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to; '``llvm.localescape``' to recover. It is zero-indexed. Semantics:; """""""""""""""""""". These intrinsics allow a group of functions to share access to a set of local; stack allocations of a one parent function. The parent function may call the; '``llvm.localescape``' intrinsic once from the function entry block, and the; child functions can use '``llvm.localrecover``' to access the escaped allocas.; The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where; the escaped allocas are allocated, which would break attempts to use; '``llvm.localrecover``'. '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.seh.try.begin(); declare void @llvm.seh.try.end(). Overview:; """""""""""""""""". The '``llvm.seh.try.begin``' and '``llvm.seh.try.end``' intrinsics mark; the boundary of a _try region for Windows SEH Asynchrous Exception Handling. Semantics:; """""""""""""""""""". When a C-function is compiled with Windows SEH Asynchrous Exception option,; -feh_asynch (aka MSVC -EHa), these two intrinsics are injected to mark _try; boundary and to prevent potential exceptions from being moved across boundary.; Any set of operations can then be confined to the region by reading their leaf; inputs via volatile loads and writing their root outputs via volatile",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:514951,access,access,514951,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"t don't modify memory. An example of; a ``MemoryUse`` is a ``load``, or a ``readonly`` function call. Every function that exists has a special ``MemoryDef`` called ``liveOnEntry``.; It dominates every ``MemoryAccess`` in the function that ``MemorySSA`` is being; run on, and implies that we've hit the top of the function. It's the only; ``MemoryDef`` that maps to no ``Instruction`` in LLVM IR. Use of; ``liveOnEntry`` implies that the memory being used is either undefined or; defined before the function begins. An example of all of this overlaid on LLVM IR (obtained by running ``opt; -passes='print<memoryssa>' -disable-output`` on an ``.ll`` file) is below. When; viewing this example, it may be helpful to view it in terms of clobbers.; The operands of a given ``MemoryAccess`` are all (potential) clobbers of said; ``MemoryAccess``, and the value produced by a ``MemoryAccess`` can act as a clobber; for other ``MemoryAccess``\ es. If a ``MemoryAccess`` is a *clobber* of another, it means that these two; ``MemoryAccess``\ es may access the same memory. For example, ``x = MemoryDef(y)``; means that ``x`` potentially modifies memory that ``y`` modifies/constrains; (or has modified / constrained).; In the same manner, ``a = MemoryPhi({BB1,b},{BB2,c})`` means that; anyone that uses ``a`` is accessing memory potentially modified / constrained; by either ``b`` or ``c`` (or both). And finally, ``MemoryUse(x)`` means; that this use accesses memory that ``x`` has modified / constrained; (as an example, think that if ``x = MemoryDef(...)``; and ``MemoryUse(x)`` are in the same loop, the use can't; be hoisted outside alone). Another useful way of looking at it is in terms of memory versions.; In that view, operands of a given ``MemoryAccess`` are the version; of the entire memory before the operation, and if the access produces; a value (i.e. ``MemoryDef/MemoryPhi``),; the value is the new version of the memory after the operation. .. code-block:: llvm. define void @foo() {; entry:; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:4695,access,access,4695,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['access']
Security,"t element) serving as the upper bound. This applies to all; types of arrays including constant-length arrays, variable-length arrays (VLAs),; and flexible array members annotated with `__counted_by`. In the following example, reference to ``vla`` promotes to ``int; *__bidi_indexable``, with ``&vla[n]`` as the upper bound and ``&vla[0]`` as the; lower bound. Then, it's copied to ``int *p``, which is implicitly ``int; *__bidi_indexable p``. Please note that value of ``n`` used to create the upper; bound is ``10``, not ``100``, in this case because ``10`` is the actual length; of ``vla``, the value of ``n`` at the time when the array is being allocated. .. code-block:: c. void foo(void) {; int n = 10;; int vla[n];; n = 100;; int *p = vla; // { .ptr: &vla[0], .upper: &vla[10], .lower: &vla[0] }; // it's `&vla[10]` because the value of `n` was 10 at the; // time when the array is actually allocated.; // ...; }. By promoting array references to ``__bidi_indexable``, all array accesses are; bounds checked in ``-fbounds-safety``, just as ``__bidi_indexable`` pointers; are. Maintaining correctness of bounds annotations; ---------------------------------------------. ``-fbounds-safety`` maintains correctness of bounds annotations by performing; additional checks when a pointer object and/or its related value containing the; bounds information is updated. For example, ``__single`` expresses an invariant that the pointer must either; point to a single valid object or be a null pointer. To maintain this invariant,; the compiler inserts checks when initializing a ``__single`` pointer, as shown; in the following example:. .. code-block:: c. void foo(void *__sized_by(size) vp, size_t size) {; // Inserted check:; // if ((int*)upper_bound(vp) - (int*)vp < sizeof(int) && !!vp) trap();; int *__single ip = (int *)vp;; }. Additionally, an explicit bounds annotation such as ``int *__counted_by(count); buf`` defines a relationship between two variables, ``buf`` and ``count``:; namely, that",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:35008,access,accesses,35008,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['access'],['accesses']
Security,"t executes on each single entry single exit region in the function.; ``RegionPass`` processes regions in nested order such that the outer most; region is processed last. ``RegionPass`` subclasses are allowed to update the region tree by using the; ``RGPassManager`` interface. You may override three virtual methods of; ``RegionPass`` to implement your own region pass. All these methods should; return ``true`` if they modified the program, or ``false`` if they did not. The ``doInitialization(Region *, RGPassManager &)`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doInitialization(Region *, RGPassManager &RGM);. The ``doInitialization`` method is designed to do simple initialization type of; stuff that does not depend on the functions being processed. The; ``doInitialization`` method call is not scheduled to overlap with any other; pass executions (thus it should be very fast). ``RPPassManager`` interface; should be used to access ``Function`` or ``Module`` level analysis information. .. _writing-an-llvm-pass-runOnRegion:. The ``runOnRegion`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool runOnRegion(Region *, RGPassManager &RGM) = 0;. The ``runOnRegion`` method must be implemented by your subclass to do the; transformation or analysis work of your pass. As usual, a true value should be; returned if the region is modified. ``RGPassManager`` interface should be used to; update region tree. The ``doFinalization()`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. code-block:: c++. virtual bool doFinalization();. The ``doFinalization`` method is an infrequently used method that is called; when the pass framework has finished calling :ref:`runOnRegion; <writing-an-llvm-pass-runOnRegion>` for every region in the program being; compiled. The ``MachineFunctionPass`` class; ---------------------------------. A ``MachineFunctionPass`` is a part of the LLVM code generator that executes on; the machine-de",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst:23818,access,access,23818,interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/WritingAnLLVMPass.rst,1,['access'],['access']
Security,"t factor costs than ``std::vector``. If possible, use ``std::vector`` or; something cheaper. .. _dss_list:. <list>; ^^^^^^. ``std::list`` is an extremely inefficient class that is rarely useful. It; performs a heap allocation for every element inserted into it, thus having an; extremely high constant factor, particularly for small data types.; ``std::list`` also only supports bidirectional iteration, not random access; iteration. In exchange for this high cost, std::list supports efficient access to both ends; of the list (like ``std::deque``, but unlike ``std::vector`` or; ``SmallVector``). In addition, the iterator invalidation characteristics of; std::list are stronger than that of a vector class: inserting or removing an; element into the list does not invalidate iterator or pointers to other elements; in the list. .. _dss_ilist:. llvm/ADT/ilist.h; ^^^^^^^^^^^^^^^^. ``ilist<T>`` implements an 'intrusive' doubly-linked list. It is intrusive,; because it requires the element to store and provide access to the prev/next; pointers for the list. ``ilist`` has the same drawbacks as ``std::list``, and additionally requires an; ``ilist_traits`` implementation for the element type, but it provides some novel; characteristics. In particular, it can efficiently store polymorphic objects,; the traits class is informed when an element is inserted or removed from the; list, and ``ilist``\ s are guaranteed to support a constant-time splice; operation. An ``ilist`` and an ``iplist`` are ``using`` aliases to one another and the; latter only currently exists for historical purposes. These properties are exactly what we want for things like ``Instruction``\ s and; basic blocks, which is why these are implemented with ``ilist``\ s. Related classes of interest are explained in the following subsections:. * :ref:`ilist_traits <dss_ilist_traits>`. * :ref:`llvm/ADT/ilist_node.h <dss_ilist_node>`. * :ref:`Sentinels <dss_ilist_sentinel>`. .. _dss_packedvector:. llvm/ADT/PackedVector.h; ^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:66745,access,access,66745,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['access']
Security,"t hash value, the string itself, and the data; for the current string value. .. code-block:: none. .------------.; 0x000034f0: | 0x00003500 | next pointer; | 0x12345678 | 32 bit hash; | ""erase"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003500: | 0x00003550 | next pointer; | 0x29273623 | 32 bit hash; | ""dump"" | string value; | data[n] | HashData for this bucket; |------------|; 0x00003550: | 0x00000000 | next pointer; | 0x82638293 | 32 bit hash; | ""main"" | string value; | data[n] | HashData for this bucket; `------------'. The problem with this layout for debuggers is that we need to optimize for the; negative lookup case where the symbol we're searching for is not present. So; if we were to lookup ""``printf``"" in the table above, we would make a 32-bit; hash for ""``printf``"", it might match ``bucket[3]``. We would need to go to; the offset 0x000034f0 and start looking to see if our 32 bit hash matches. To; do so, we need to read the next pointer, then read the hash, compare it, and; skip to the next bucket. Each time we are skipping many bytes in memory and; touching new pages just to do the compare on the full 32 bit hash. All of; these accesses then tell us that we didn't have a match. Name Hash Tables; """""""""""""""""""""""""""""""". To solve the issues mentioned above we have structured the hash tables a bit; differently: a header, buckets, an array of all unique 32 bit hash values,; followed by an array of hash value data offsets, one for each hash value, then; the data for all hash values:. .. code-block:: none. .-------------.; | HEADER |; |-------------|; | BUCKETS |; |-------------|; | HASHES |; |-------------|; | OFFSETS |; |-------------|; | DATA |; `-------------'. The ``BUCKETS`` in the name tables are an index into the ``HASHES`` array. By; making all of the full 32 bit hash values contiguous in memory, we allow; ourselves to efficiently check for a match while touching as little memory as; possible. Most often checking the 32 bit hash",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:62549,hash,hash,62549,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"t have; # an effect, which is fine.; # (Note that the option is very counter-intuitive: We turn *on* disabling it...); set(CMAKE_DISABLE_FIND_PACKAGE_CUDA ON). # will be set again in case NOT builtin_llvm; set(LLVM_DIR ""${CMAKE_BINARY_DIR}/interpreter/llvm-project/llvm""); if (clad); set(CLING_BUILD_PLUGINS ON); endif(). # We only use llvm/clang through TCling which is (with the help of core/meta) already taking a lock; # to serialize access to llvm. We can later review how to make this finer grained by using llvm's own locking; # mechanism.; set(LLVM_ENABLE_THREADS OFF CACHE BOOL """"). # The llvm::ReverseIterate<bool>::value symbol from llvm's SmallPtrSet.h; # somehow lands in our cling libraries on OS X and doesn't get hidden; # by visibility-inlines-hidden, so we suddenly have a global weak symbol; # from LLVM in cling which our visiblity=hidden compiled LLVM libraries; # reference. This is triggering some build system warnings like this:; # ld: warning: direct access in function '(anonymous namespace)::NewGVN::runGVN()'; # from file 'interpreter/llvm-project/llvm/lib/libLLVMScalarOpts.a(NewGVN.cpp.o)' to global weak symbol; # 'llvm::ReverseIterate<bool>::value' from file 'interpreter/llvm-project/llvm/lib/libclingUtils.a(AST.cpp.o)'; # means the weak symbol cannot be overridden at runtime. This was likely caused by different; # translation units being compiled with different visibility settings.; # There is no apparent reason why this is happening and it looks like a compiler bug,; # so let's just disable the part of the code that provides this symbol.; # As it's in the validation part of LLVM and not in something that providing functionality,; # this shouldn't cause any problems.; # TODO: We maybe can remove this code once we upgrade to LLVM>=6.0 as this symbol; # was introduced quite recently into LLVM 5.0 and probably is also causing problems; # for some other projects.; set(LLVM_ENABLE_ABI_BREAKING_CHECKS OFF CACHE BOOL """" FORCE); set(LLVM_ABI_BREAKING_CHECKS ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt:3452,access,access,3452,interpreter/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/CMakeLists.txt,1,['access'],['access']
Security,"t in memory from the column data. A view can iterate over the entry range, over the field range, and over the range of a collection within an entry.; For instance, for a field `std::vector<float> pt`, a view can iterate over all `pt` values of all entries, or over the `pt` values of a particular entry. A view can safely outlive its originating reader.; Once the reader is deconstructed, any attempt to read data will throw an exception, but the view is still properly destructed. Views that originate from the same reader _cannot_ be used concurrently by different threads. Internal Classes; ----------------. ### RNTupleDS; The `RNTupleDS` class is an internal class that provides an RNTuple data source for RDataFrame.; It is part of the `ROOTDataFrame` library.; The RNTuple data source supports chains with a constructor that takes a list of input files.; The RNTuple data source also supports multi-threaded dataframes, parallelized on the file and cluster level. The data source exposes inner fields of complex collections.; For instance, if the data model contains a vector of `Event` classes, where each `Event` has `pt` and `eta` floats,; the dataframe can use the event vector itself (`Event` column) as well as the `float` columns `Event.pt` and `Event.eta`. ### RClusterPool; The RClusterPool is an internal class owned be a page source.; The cluster pool maintains an I/O thread that asynchronously prefetches the next few clusters.; Through `RPageSource::SetEntryRange()`, the cluster pool is instructed to not read beyond the given limit.; This is used in the RNTuple data source when multiple threads work on different clusters of the same file. ### RMiniFile; The RMiniFile is an internal class used to read and write RNTuple data in a ROOT file.; It provides a minimal subset of the `TFile` functionality.; Its purpose is to reduce the coupling between RNTuple and the ROOT I/O library. For writing data, the RMiniFile can either use a proper `TFile` (descendant) or a C file strea",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:14792,expose,exposes,14792,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['expose'],['exposes']
Security,"t limited; to members of any race, ethnicity, culture, national origin, colour,; immigration status, social and economic class, educational level, sex, sexual; orientation, gender identity and expression, age, size, family status,; political belief, religion or lack thereof, and mental and physical ability. .. _be considerate:. * **Be considerate.** Your work will be used by other people, and you in turn; will depend on the work of others. Any decision you take will affect users; and colleagues, and you should take those consequences into account. Remember; that we're a world-wide community, so you might not be communicating in; someone else's primary language. .. _be respectful:. * **Be respectful.** Not all of us will agree all the time, but disagreement is; no excuse for poor behavior and poor manners. We might all experience some; frustration now and then, but we cannot allow that frustration to turn into; a personal attack. It's important to remember that a community where people; feel uncomfortable or threatened is not a productive one. Members of the LLVM; community should be respectful when dealing with other members as well as; with people outside the LLVM community. .. _be careful in the words that you choose and be kind to others:. * **Be careful in the words that you choose and be kind to others.** Do not; insult or put down other participants. Harassment and other exclusionary; behavior aren't acceptable. This includes, but is not limited to:. * Violent threats or language directed against another person.; * Discriminatory jokes and language.; * Posting sexually explicit or violent material.; * Posting (or threatening to post) other people's personally identifying; information (""doxing"").; * Personal insults, especially those using racist or sexist terms.; * Unwelcome sexual attention.; * Advocating for, or encouraging, any of the above behavior. In general, if someone asks you to stop, then stop. Persisting in such; behavior after being asked to stop i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst:3724,threat,threatened,3724,interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CodeOfConduct.rst,1,['threat'],['threatened']
Security,"t making the change. Attribution of Changes; ----------------------. When contributors submit a patch to an LLVM project, other developers with; commit access may commit it for the author once appropriate (based on the; progression of code review, etc.). When doing so, it is important to retain; correct attribution of contributions to their contributors. However, we do not; want the source code to be littered with random attributions ""this code written; by J. Random Hacker"" (this is noisy and distracting). In practice, the revision; control system keeps a perfect history of who changed what, and the CREDITS.txt; file describes higher-level contributions. If you commit a patch for someone; else, please follow the attribution of changes in the simple manner as outlined; by the `commit messages`_ section. Overall, please do not add contributor names; to the source code. Also, don't commit patches authored by others unless they have submitted the; patch to the project or you have been authorized to submit them on their behalf; (you work together and your company authorized you to contribute the patches,; etc.). The author should first submit them to the relevant project's commit; list, development list, or LLVM bug tracker component. If someone sends you; a patch privately, encourage them to submit it to the appropriate list first. Our previous version control system (subversion) did not distinguish between the; author and the committer like git does. As such, older commits used a different; attribution mechanism. The previous method was to include ""Patch by John Doe.""; in a separate line of the commit message and there are automated processes that; rely on this format. .. _IR backwards compatibility:. IR Backwards Compatibility; --------------------------. When the IR format has to be changed, keep in mind that we try to maintain some; backwards compatibility. The rules are intended as a balance between convenience; for llvm users and not imposing a big burden on llvm d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst:30567,authoriz,authorized,30567,interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/DeveloperPolicy.rst,2,['authoriz'],['authorized']
Security,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65650,secur,security,65650,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,6,"['attack', 'inject', 'secur']","['attack', 'attacker', 'inject', 'injection', 'security']"
Security,"t syntax tree (AST);; .dynamicExtensions - Turns on cling's dynamic extensions. This in turn enables the dynamic lookup and the late resolving of the identifier. With that option cling tries to heal the compile-time failed lookups at runtime;. Details; Command line. The interactive prompt supports an emacs-like command line editor, just like bash terminal, which makes it easy to integrate and use. Cling uses TextInput and doesn't depend on ncurses.; . Autocompletion should be coming soon!; ; #Include Declarations. Cling allows #include-s to be not only before the declarations. The includes could be mixed with other declarations. For example:; [cling]$ #include ""math.h""; [cling]$ sin(1); (double const) 8.414710e-01; [cling]$ #include ""stdio.h""; [cling]$ printf(""%f\n"", sin(1));; 0.841471. More statements could be combined using semicolon (;). This doesn't stay when the command is #include; The following example is invalid:[cling]$ #include ""math.h""; sin(1). The same rules are applicable for the other preprocessor directives (commands starting with # - such as #define); ; Variable Declarations. Cling allows statements to be entered onto the global scope. In order to be compiled and executed by the compiler these statements need to be wrapped into functions, which body contains the statement and afterwards to run the function. The semantics of the statements that declare variables is that variables should be accessed by other statements. If the statement that declare variable is wrapped into function the variables won't be accessible from outside anymore. In this case variables are extracted onto the global scope.; ; TODO: There should be dedicated entry for that in the docs; Builtins; Cling starts with very few builtins loaded. Users could extend the available builtins via extending the RuntimeUniverse.h, which is loaded at cling's startup.; . Copyright © Cling Team; . The ROOT Framework |; LLVM |; Clang |; Web Design. Page was modified on $Date$ in $Rev$ by $Author$. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html:3907,access,accessed,3907,interpreter/cling/www/old/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/www/old/index.html,4,['access'],"['accessed', 'accessible']"
Security,"t system, ``sizeof(Token)`` is currently 16 bytes. Tokens occur in two forms: :ref:`annotation tokens <AnnotationToken>` and; normal tokens. Normal tokens are those returned by the lexer, annotation; tokens represent semantic information and are produced by the parser, replacing; normal tokens in the token stream. Normal tokens contain the following; information:. * **A SourceLocation** --- This indicates the location of the start of the; token. * **A length** --- This stores the length of the token as stored in the; ``SourceBuffer``. For tokens that include them, this length includes; trigraphs and escaped newlines which are ignored by later phases of the; compiler. By pointing into the original source buffer, it is always possible; to get the original spelling of a token completely accurately. * **IdentifierInfo** --- If a token takes the form of an identifier, and if; identifier lookup was enabled when the token was lexed (e.g., the lexer was; not reading in ""raw"" mode) this contains a pointer to the unique hash value; for the identifier. Because the lookup happens before keyword; identification, this field is set even for language keywords like ""``for``"". * **TokenKind** --- This indicates the kind of token as classified by the; lexer. This includes things like ``tok::starequal`` (for the ""``*=``""; operator), ``tok::ampamp`` for the ""``&&``"" token, and keyword values (e.g.,; ``tok::kw_for``) for identifiers that correspond to keywords. Note that; some tokens can be spelled multiple ways. For example, C++ supports; ""operator keywords"", where things like ""``and``"" are treated exactly like the; ""``&&``"" operator. In these cases, the kind value is set to ``tok::ampamp``,; which is good for the parser, which doesn't have to consider both forms. For; something that cares about which form is used (e.g., the preprocessor; ""stringize"" operator) the spelling indicates the original form. * **Flags** --- There are currently four flags tracked by the; lexer/preprocessor syste",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:46258,hash,hash,46258,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['hash'],['hash']
Security,"t the optimizers; should perform tail call optimization. The ``tail`` marker is a hint that; `can be ignored <CodeGenerator.html#tail-call-optimization>`_. The; ``musttail`` marker means that the call must be tail call optimized in order; for the program to be correct. This is true even in the presence of; attributes like ""disable-tail-calls"". The ``musttail`` marker provides these; guarantees:. #. The call will not cause unbounded stack growth if it is part of a; recursive cycle in the call graph.; #. Arguments with the :ref:`inalloca <attr_inalloca>` or; :ref:`preallocated <attr_preallocated>` attribute are forwarded in place.; #. If the musttail call appears in a function with the ``""thunk""`` attribute; and the caller and callee both have varargs, then any unprototyped; arguments in register or memory are forwarded to the callee. Similarly,; the return value of the callee is returned to the caller's caller, even; if a void return type is in use. Both markers imply that the callee does not access allocas from the caller.; The ``tail`` marker additionally implies that the callee does not access; varargs from the caller. Calls marked ``musttail`` must obey the following; additional rules:. - The call must immediately precede a :ref:`ret <i_ret>` instruction,; or a pointer bitcast followed by a ret instruction.; - The ret instruction must return the (possibly bitcasted) value; produced by the call, undef, or void.; - The calling conventions of the caller and callee must match.; - The callee must be varargs iff the caller is varargs. Bitcasting a; non-varargs function to the appropriate varargs type is legal so; long as the non-varargs prefixes obey the other rules.; - The return type must not undergo automatic conversion to an `sret` pointer. In addition, if the calling convention is not `swifttailcc` or `tailcc`:. - All ABI-impacting function attributes, such as sret, byval, inreg,; returned, and inalloca, must match.; - The caller and callee prototypes must match. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:473619,access,access,473619,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"t width parameters for the left and right sides of the Gaussian core. The new `RooCrystalBall` class can substitute the `RooDSCBShape` and `RooSDSCBShape`, which were passed around in the community. ## 2D Graphics Libraries. - Add the method `AddPoint`to `TGraph(x,y)` and `TGraph2D(x,y,z)`, equivalent to `SetPoint(g->GetN(),x,y)`and `SetPoint(g->GetN(),x,y,z)`; - Option `E0` draws error bars and markers are drawn for bins with 0 contents. Now, combined; with options E1 and E2, it avoids error bars clipping. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ### Multithreaded support for FastCGI. Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests; received via FastCGI channel. This significantly increase a performance, especially when; several clients are connected. ### Better security for THttpServer with webgui. If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will; provide access to the widgets via websocket connection - any other kind of requests like root.json; or exe.json will be refused completely. Combined with connection tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:25414,access,access,25414,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['access'],['access']
Security,"t would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive un",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63620,secur,security,63620,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"t) so that they're accessible to ``VariableExprAST`` nodes. .. code-block:: c++. if (Value *RetVal = Body->codegen()) {; // Finish off the function.; Builder->CreateRet(RetVal);. // Validate the generated code, checking for consistency.; verifyFunction(*TheFunction);. return TheFunction;; }. Once the insertion point has been set up and the NamedValues map populated,; we call the ``codegen()`` method for the root expression of the function. If no; error happens, this emits code to compute the expression into the entry block; and returns the value that was computed. Assuming no error, we then create an; LLVM `ret instruction <../../LangRef.html#ret-instruction>`_, which completes the function.; Once the function is built, we call ``verifyFunction``, which is; provided by LLVM. This function does a variety of consistency checks on; the generated code, to determine if our compiler is doing everything; right. Using this is important: it can catch a lot of bugs. Once the; function is finished and validated, we return it. .. code-block:: c++. // Error reading body, remove function.; TheFunction->eraseFromParent();; return nullptr;; }. The only piece left here is handling of the error case. For simplicity,; we handle this by merely deleting the function we produced with the; ``eraseFromParent`` method. This allows the user to redefine a function; that they incorrectly typed in before: if we didn't delete it, it would; live in the symbol table, with a body, preventing future redefinition. This code does have a bug, though: If the ``FunctionAST::codegen()`` method; finds an existing IR Function, it does not validate its signature against the; definition's own prototype. This means that an earlier 'extern' declaration will; take precedence over the function definition's signature, which can cause; codegen to fail, for instance if the function arguments are named differently.; There are a number of ways to fix this bug, see what you can come up with! Here; is a testcase:. ::. e",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst:16350,validat,validated,16350,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl03.rst,1,['validat'],['validated']
Security,"t**: byte offset into the array or record, used to step back to the; parent array or record.; * **IsConst**: flag indicating if the field is const-qualified.; * **IsInitialized**: flag indicating whether the field or element was; initialized. For non-primitive fields, this is only relevant to determine; the dynamic type of objects during construction.; * **IsBase**: flag indicating whether the record is a base class. In that; case, the offset can be used to identify the derived class.; * **IsActive**: indicates if the field is the active field of a union.; * **IsMutable**: indicates if the field is marked as mutable. Inline descriptors are filled in by the `CtorFn` of blocks, which leaves storage; in an uninitialised, but valid state. Descriptors; -----------. Descriptors are generated at bytecode compilation time and contain information; required to determine if a particular memory access is allowed in constexpr.; They also carry all the information required to emit a diagnostic involving; a memory access, such as the declaration which originates the block.; Currently there is a single kind of descriptor encoding information for all; block types. Pointers; --------. Pointers, implemented in ``Pointer.h`` are represented as a tagged union.; Some of these may not yet be available in upstream ``clang``. * **BlockPointer**: used to reference memory allocated and managed by the; interpreter, being the only pointer kind which allows dereferencing in the; interpreter; * **ExternPointer**: points to memory which can be addressed, but not read by; the interpreter. It is equivalent to APValue, tracking a declaration and a path; of fields and indices into that allocation.; * **TargetPointer**: represents a target address derived from a base address; through pointer arithmetic, such as ``((int *)0x100)[20]``. Null pointers are; target pointers with a zero offset.; * **TypeInfoPointer**: tracks information for the opaque type returned by; ``typeid``; * **InvalidPointer**: is dum",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst:8506,access,access,8506,interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ConstantInterpreter.rst,1,['access'],['access']
Security,"t, integer arithmetic wrapping may occur, so the comparison may not; be meaningful. Can I do GEP with a different pointer type than the type of the underlying object?; ----------------------------------------------------------------------------------. Yes. There are no restrictions on bitcasting a pointer value to an arbitrary; pointer type. The types in a GEP serve only to define the parameters for the; underlying integer computation. They need not correspond with the actual type of; the underlying object. Furthermore, loads and stores don't have to use the same types as the type of; the underlying object. Types in this context serve only to specify memory size; and alignment. Beyond that there are merely a hint to the optimizer indicating; how the value will likely be used. Can I cast an object's address to integer and add it to null?; -------------------------------------------------------------. You can compute an address that way, but if you use GEP to do the add, you can't; use that pointer to actually access the object, unless the object is managed; outside of LLVM. The underlying integer computation is sufficiently defined; null has a defined; value --- zero --- and you can add whatever value you want to it. However, it's invalid to access (load from or store to) an LLVM-aware object; with such a pointer. This includes ``GlobalVariables``, ``Allocas``, and objects; pointed to by noalias pointers. If you really need this functionality, you can do the arithmetic with explicit; integer instructions, and use inttoptr to convert the result to an address. Most; of GEP's special aliasing rules do not apply to pointers computed from ptrtoint,; arithmetic, and inttoptr sequences. Can I compute the distance between two objects, and add that value to one address to compute the other address?; ---------------------------------------------------------------------------------------------------------------. As with arithmetic on null, you can use GEP to compute an address t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:15603,access,access,15603,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['access']
Security,"t-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; i",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66523,attack,attack,66523,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['attack'],['attack']
Security,"t-unsigned-integer-truncation``,; ``-fsanitize=implicit-signed-integer-truncation``: Implicit conversion from; integer of larger bit width to smaller bit width, if that results in data; loss. That is, if the demoted value, after casting back to the original; width, is not equal to the original value before the downcast.; The ``-fsanitize=implicit-unsigned-integer-truncation`` handles conversions; between two ``unsigned`` types, while; ``-fsanitize=implicit-signed-integer-truncation`` handles the rest of the; conversions - when either one, or both of the types are signed.; Issues caught by these sanitizers are not undefined behavior,; but are often unintentional.; - ``-fsanitize=implicit-integer-sign-change``: Implicit conversion between; integer types, if that changes the sign of the value. That is, if the; original value was negative and the new value is positive (or zero),; or the original value was positive, and the new value is negative.; Issues caught by this sanitizer are not undefined behavior,; but are often unintentional.; - ``-fsanitize=integer-divide-by-zero``: Integer division by zero.; - ``-fsanitize=nonnull-attribute``: Passing null pointer as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer ca",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:6105,sanitiz,sanitizer,6105,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,1,['sanitiz'],['sanitizer']
Security,"t. !0 = !DICompileUnit(language: DW_LANG_C99, file: !1, producer: ""clang"",; isOptimized: true, flags: ""-O2"", runtimeVersion: 2,; splitDebugFilename: ""abc.debug"", emissionKind: FullDebug,; enums: !2, retainedTypes: !3, globals: !4, imports: !5,; macros: !6, dwoId: 0x0abcd). Compile unit descriptors provide the root scope for objects declared in a; specific compilation unit. File descriptors are defined using this scope. These; descriptors are collected by a named metadata node ``!llvm.dbg.cu``. They keep; track of global variables, type information, and imported entities (declarations; and namespaces). .. _DIFile:. DIFile; """""""""""". ``DIFile`` nodes represent files. The ``filename:`` can include slashes. .. code-block:: none. !0 = !DIFile(filename: ""path/to/file"", directory: ""/path/to/dir"",; checksumkind: CSK_MD5,; checksum: ""000102030405060708090a0b0c0d0e0f""). Files are sometimes used in ``scope:`` fields, and are the only valid target; for ``file:`` fields. The ``checksum:`` and ``checksumkind:`` fields are optional. If one of these; fields is present, then the other is required to be present as well. Valid; values for ``checksumkind:`` field are: {CSK_MD5, CSK_SHA1, CSK_SHA256}. .. _DIBasicType:. DIBasicType; """""""""""""""""""""". ``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` and; ``float``. ``tag:`` defaults to ``DW_TAG_base_type``. .. code-block:: text. !0 = !DIBasicType(name: ""unsigned char"", size: 8, align: 8,; encoding: DW_ATE_unsigned_char); !1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: ""decltype(nullptr)""). The ``encoding:`` describes the details of the type. Usually it's one of the; following:. .. code-block:: text. DW_ATE_address = 1; DW_ATE_boolean = 2; DW_ATE_float = 4; DW_ATE_signed = 5; DW_ATE_signed_char = 6; DW_ATE_unsigned = 7; DW_ATE_unsigned_char = 8. .. _DISubroutineType:. DISubroutineType; """""""""""""""""""""""""""""""". ``DISubroutineType`` nodes represent subroutine types. Their ``types:`` field; refers to a tuple; the first operan",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:247664,checksum,checksum,247664,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['checksum'],"['checksum', 'checksumkind']"
Security,"t. The Darwin and Linux implementation; relies on padding and the ability to map a file over the existing memory; mapping which is generally only available on POSIX systems and isn't suitable; for other platforms. On Fuchsia, we rely on the ability to relocate counters at runtime using a; level of indirection. On every counter access, we add a bias to the counter; address. This bias is stored in ``__llvm_profile_counter_bias`` symbol that's; provided by the profile runtime and is initially set to zero, meaning no; relocation. The runtime can map the profile into memory at arbitrary locations,; and set bias to the offset between the original and the new counter location,; at which point every subsequent counter access will be to the new location,; which allows updating profile directly akin to the continuous mode. The advantage of this approach is that doesn't require any special OS support.; The disadvantage is the extra overhead due to additional instructions required; for each counter access (overhead both in terms of binary size and performance); plus duplication of counters (i.e. one copy in the binary itself and another; copy that's mapped into memory). This implementation can be also enabled for; other platforms by passing the ``-runtime-counter-relocation`` option to the; backend during compilation. For a program such as the `Lit <https://llvm.org/docs/CommandGuide/lit.html>`_; testing tool which invokes other programs, it may be necessary to set; ``LLVM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profd",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:5044,access,access,5044,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,1,['access'],['access']
Security,"t1<<el1|dataset2<<el2|"".; The datasets to be processed can also be specified on one or multiple lines in a text file.; Add; support for automatic download of a package when available on the; master but not locally. The downloaded packages are store under <sandbox>/packages/downloaded; and automatically checked for updates against the master repository. If; a local version of the same package is created (using the; UploadPackage) the entry in downloaded is; cleared, so that the behaviour is unchanged.; Add; the possibility to remap the server for the files in a dataset. This; allows, for example, to reuse the dataset information for the same; files stored in a different cluster.; Add a local cache for; TDataSetManagerFile. This is mainly used to improve the speed of; TDataSetManager::ShowDataSets, which is run very often by users and may; be very slow if the number of dataset is large. The cache is also used; to cache frequently received dataset objects.Add the possibility to audit the activity on the nodes via syslog. .; New packetizer TPacketizerFile generating packets which contain a single; file path to be used in processing single files. Used, for example, in; tasks generating files. The files are specified into a TMap - named; 'PROOF_FilesToProcess' - containing the list of files to be generated; per host (the key is the host name, the value the TList of TObjString; (or TFileInfo) with the files names - or a TFileCollection: the output; of TFileCollection::GetFilesPerServer() can be directly passed as files; map). Workers are first assigned files belonging to; the list with host name matching the worker name. The map is; distributed to the master via the input list.Add support for; automatic setting of pointer data members to the relevant object in the; output list. The use of fOutputList->FindObject(""name"") in; TSelector::Terminate is not needed anymore for pointer data members,; e.g. histograms.; Add the possibility to define an external list of environment; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html:1781,audit,audit,1781,proof/doc/v528/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/doc/v528/index.html,2,['audit'],['audit']
Security,"tListOfGeometries(); gROOT->GetListOfBrowsers(); gROOT->GetListOfMessageHandlers(); ```. These methods return a **`TSeqCollection`**, meaning a collection of; objects, and they can be used to do list operations such as finding an; object, or traversing the list and calling a method for each of the; members. See the **`TCollection`** class description for the full set; of methods supported for a collection. For example, to find a canvas; called `c1 `you can do`:`. ``` {.cpp}; root[] gROOT->GetListOfCanvases()->FindObject(""c1""); ```. This returns a pointer to a **`TObject`**, and before you can use it; as a canvas you need to cast it to a **`TCanvas*`.**. ### gFile. ***`gFile`*** is the pointer to the current opened file in the ROOT; session. ### gDirectory. ***`gDirectory`*** is a pointer to the current directory. The concept; and role of a directory is explained in the chapter ""Input/Output"". ### gPad. A graphic object is always drawn on the active pad. It is convenient; to access the active pad, no matter what it is. For that, we have; ***`gPad`*** that is always pointing to the active pad. For example,; if you want to change the fill color of the active pad to blue, but; you do not know its name, you can use ***`gPad`***. ``` {.cpp}; root[] gPad->SetFillColor(38); ```. To get the list of colors, if you have an open canvas, click in the; ""View"" menu, selecting the ""Colors"" entry. ### gRandom. ***`gRandom`*** is a pointer to the current random number generator.; By default, it points to a **`TRandom3`** object, based on the; ""Mersenne-Twister"" generator. This generator is very fast and has very; good random proprieties (a very long period of 10^600^). Setting the; seed to 0 implies that the seed will be uniquely generated using the; **`TUUID`**. Any other value will be used as a constant. The following; basic random distributions are provided: `Rndm()` or; `Uniform(min,max)`, `Gaus(mean,sigma)`, `Exp(tau)`,; `BreitWigner(mean,sigma)`, `Landau(mean,sigma)`, `Poisson(",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md:34233,access,access,34233,documentation/users-guide/GettingStarted.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/GettingStarted.md,1,['access'],['access']
Security,"t_err.push_back(0.1);; init_err.push_back(0.1);. // create minimizer (default constructor); VariableMetricMinimizer theMinimizer;. // minimize; FunctionMinimum min =; theMinimizer.minimize(theFCN, init_par, init_err);. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate standard minimization using MIGRAD; // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create MIGRAD minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;; }. {; // demonstrate full interaction with parameters over subsequent; // minimizations. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // access parameter by name to set limits...; upar.setLimits(""mean"", mean-0.01, mean+0.01);. // ... or access parameter by index; upar.setLimits(1, rms-0.1, rms+0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // fix a parameter...; migrad.fix(""mean"");. // ... and minimize; FunctionMinimum min = migrad();. // output; std::cout<<""minimum: ""<<min<<std::endl;. // release a parameter...; migrad.release(""mean"");. // ... and fix another one; migrad.fix(1);. // and minimize again; FunctionMinimum min1 = migrad();. // output; std::cout<<""minimum1: ""<<min1<<std::endl;. // release the parameter...; migrad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Min",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:80139,access,access,80139,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['access'],['access']
Security,"ta file will be; generated for each object file. These ``.gcno`` files contain half of the; coverage data. The other half of the data comes from ``.gcda`` files that are; generated when you run the instrumented program, with a separate ``.gcda``; file for each object file. Each time you run the program, the execution counts; are summed into any existing ``.gcda`` files, so be sure to remove any old; files if you do not want their contents to be included. By default, the ``.gcda`` files are written into the same directory as the; object files, but you can override that by setting the ``GCOV_PREFIX`` and; ``GCOV_PREFIX_STRIP`` environment variables. The ``GCOV_PREFIX_STRIP``; variable specifies a number of directory components to be removed from the; start of the absolute path to the object file directory. After stripping those; directories, the prefix from the ``GCOV_PREFIX`` variable is added. These; environment variables allow you to run the instrumented program on a machine; where the original object file directories are not accessible, but you will; then need to copy the ``.gcda`` files back to the object file directories; where :program:`llvm-cov gcov` expects to find them. Once you have generated the coverage data files, run :program:`llvm-cov gcov`; for each main source file where you want to examine the coverage results. This; should be run from the same directory where you previously ran the; compiler. The results for the specified source file are written to a file named; by appending a ``.gcov`` suffix. A separate output file is also created for; each file included by the main source file, also with a ``.gcov`` suffix added. The basic content of an ``.gcov`` output file is a copy of the source file with; an execution count and line number prepended to every line. The execution; count is shown as ``-`` if a line does not contain any executable code. If; a line contains code but that code was never executed, the count is displayed; as ``#####``. OPTIONS; ^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:2622,access,accessible,2622,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['access'],['accessible']
Security,"ta, and may load from memory and; leak the loaded values through various side channels that survive even when the; speculative execution is unwound due to being incorrect. Mispredicted paths can; cause code to be executed with data inputs that never occur in correct; executions, making checks against malicious inputs ineffective and allowing; attackers to use malicious data inputs to leak secret data. Here is an example,; extracted and simplified from the Project Zero paper:; ```; struct array {; unsigned long length;; unsigned char data[];; };; struct array *arr1 = ...; // small array; struct array *arr2 = ...; // array of size 0x400; unsigned long untrusted_offset_from_caller = ...;; if (untrusted_offset_from_caller < arr1->length) {; unsigned char value = arr1->data[untrusted_offset_from_caller];; unsigned long index2 = ((value&1)*0x100)+0x200;; unsigned char value2 = arr2->data[index2];; }; ```. The key of the attack is to call this with `untrusted_offset_from_caller` that; is far outside of the bounds when the branch predictor will predict that it; will be in-bounds. In that case, the body of the `if` will be executed; speculatively, and may read secret data into `value` and leak it via a; cache-timing side channel when a dependent access is made to populate `value2`. ## High Level Mitigation Approach. While several approaches are being actively pursued to mitigate specific; branches and/or loads inside especially risky software (most notably various OS; kernels), these approaches require manual and/or static analysis aided auditing; of code and explicit source changes to apply the mitigation. They are unlikely; to scale well to large applications. We are proposing a comprehensive; mitigation approach that would apply automatically across an entire program; rather than through manual changes to the code. While this is likely to have a; high performance cost, some applications may be in a good position to take this; performance / security tradeoff. The specific ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md:1959,attack,attack,1959,interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SpeculativeLoadHardening.md,1,['attack'],['attack']
Security,"ta; resides. *Target architecture specific DWARF address spaces may correspond to hardware; supported facilities such as memory utilizing base address registers, scratchpad; memory, and memory with special interleaving. The size of addresses in these; address spaces may vary. Their access and allocation may be hardware managed; with each thread or group of threads having access to independent storage. For; these reasons they may have properties that do not allow them to be viewed as; part of the unified global virtual address space accessible by all threads.*. *It is target architecture specific whether multiple DWARF address spaces are; supported and how source language memory spaces map to target architecture; specific DWARF address spaces. A target architecture may map multiple source; language memory spaces to the same target architecture specific DWARF address; class. Optimization may determine that variable lifetime and access pattern; allows them to be allocated in faster scratchpad memory represented by a; different DWARF address space than the default for the source language memory; space.*. Although DWARF address space identifiers are target architecture specific,; ``DW_ASPACE_LLVM_none`` is a common address space supported by all target; architectures, and defined as the target architecture default address space. DWARF address space identifiers are used by:. * The ``DW_AT_LLVM_address_space`` attribute. * The DWARF expression operations: ``DW_OP_aspace_bregx``,; ``DW_OP_form_aspace_address``, ``DW_OP_aspace_implicit_pointer``, and; ``DW_OP_xderef*``. * The CFI instructions: ``DW_CFA_def_aspace_cfa`` and; ``DW_CFA_def_aspace_cfa_sf``. .. note::. Currently, DWARF defines address class values as being target architecture; specific, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal'",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:149034,access,access,149034,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['access']
Security,"tack, and other context elements corresponding to the source language; thread of execution upon which the user is focused, if any. The resulting; value V\ :sub:`3` is the value in L\ :sub:`2` at the time of the call made; by the call site. The result of these attributes is undefined if the current call frame is not; for the subprogram containing the ``DW_TAG_call_site_parameter`` debugger; information entry or the current program location is not for the call site; containing the ``DW_TAG_call_site_parameter`` debugger information entry in; the current call frame. *The consumer may have to virtually unwind to the call site (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) in order to evaluate these; attributes. This will ensure the source language thread of execution upon; which the user is focused corresponds to the call site needed to evaluate; the expression.*. If it is not possible to avoid the expressions of these attributes from; accessing registers or memory locations that might be clobbered by the; subprogram being called by the call site, then the associated attribute; should not be provided. *The reason for the restriction is that the parameter may need to be; accessed during the execution of the callee. The consumer may virtually; unwind from the called subprogram back to the caller and then evaluate the; attribute expressions. The call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) will not be able to restore; registers that have been clobbered, and clobbered memory will no longer have; the value at the time of the call.*. 3. Each call site parameter entry may also have a ``DW_AT_call_parameter``; attribute which contains a reference to a ``DW_TAG_formal_parameter`` entry,; ``DW_AT_type attribute`` referencing the type of the parameter or; ``DW_AT_name`` attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:170829,access,accessing,170829,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['access'],['accessing']
Security,"tack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binar",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77033,sanitiz,sanitizers,77033,interpreter/llvm-project/clang/docs/UsersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst,1,['sanitiz'],['sanitizers']
Security,"tadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. If loop versioning is necessary, this metadata defined the attributes; the non-distributed fallback version will have. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.loop.distribute.followup_all``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The attributes in this metadata is added to all followup loops of the; loop distribution pass. See; :ref:`Transformation Metadata <transformation-metadata>` for details. '``llvm.licm.disable``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This metadata indicates that loop-invariant code motion (LICM) should not be; performed on this loop. The metadata has a single operand which is the string; ``llvm.licm.disable``. For example:. .. code-block:: llvm. !0 = !{!""llvm.licm.disable""}. Note that although it operates per loop it isn't given the llvm.loop prefix; as it is not affected by the ``llvm.loop.disable_nonforced`` metadata. '``llvm.access.group``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ``llvm.access.group`` metadata can be attached to any instruction that; potentially accesses memory. It can point to a single distinct metadata; node, which we call access group. This node represents all memory access; instructions referring to it via ``llvm.access.group``. When an; instruction belongs to multiple access groups, it can also point to a; list of accesses groups, illustrated by the following example. .. code-block:: llvm. %val = load i32, ptr %arrayidx, !llvm.access.group !0; ...; !0 = !{!1, !2}; !1 = distinct !{}; !2 = distinct !{}. It is illegal for the list node to be empty since it might be confused; with an access group. The access group metadata node must be 'distinct' to avoid collapsing; multiple access groups by content. An access group metadata node must; always be empty which can be used to distinguish an access group; metadata node from a list of access groups. Being empty avoids the; situation that the c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:309970,access,access,309970,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"tal number of times the instruction; is executed, followed by uint64_t value and execution count pairs.; The value profiling kind is 0 for indirect call targets and 1 for memory; operations. For indirect call targets, each profile value is a hash; of the callee function name, and for memory operations each value is the; byte length. Note that the value counts do not need to add up to the total count; listed in the third operand (in practice only the top hottest values; are tracked and reported). Indirect call example:. .. code-block:: llvm. call void %f(), !prof !1; !1 = !{!""VP"", i32 0, i64 1600, i64 7651369219802541373, i64 1030, i64 -4377547752858689819, i64 410}. Note that the VP type is 0 (the second operand), which indicates this is; an indirect call value profile data. The third operand indicates that the; indirect call executed 1600 times. The 4th and 6th operands give the; hashes of the 2 hottest target functions' names (this is the same hash used; to represent function names in the profile database), and the 5th and 7th; operands give the execution count that each of the respective prior target; functions was called. .. _md_annotation:. '``annotation``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^. The ``annotation`` metadata can be used to attach a tuple of annotation strings; or a tuple of a tuple of annotation strings to any instruction. This metadata does; not impact the semantics of the program and may only be used to provide additional; insight about the program and transformations to users. Example:. .. code-block:: text. %a.addr = alloca ptr, align 8, !annotation !0; !0 = !{!""auto-init""}. Embedding tuple of strings example:. .. code-block:: text. %a.ptr = getelementptr ptr, ptr %base, i64 0. !annotation !0; !0 = !{!1}; !1 = !{!""gep offset"", !""0""}. '``func_sanitize``' Metadata; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``func_sanitize`` metadata is used to attach two values for the function; sanitizer instrumentation. The first value is the ubsan function signature.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:321787,hash,hashes,321787,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['hash'],"['hash', 'hashes']"
Security,"tance, *R*, from a set; of measurements. As a first step, a visualisation of the data is needed. Next, some; manipulations typically have to be applied, e.g. corrections or; parameter transformations. Quite often, these manipulations are complex; ones, and a powerful library of mathematical functions and procedures; should be provided - think for example of an integral or peak-search or; a Fourier transformation applied to an input spectrum to obtain the; actual measurement described by the model. One specialty of experimental physics are the inevitable uncertainties; affecting each measurement, and visualisation tools have to include; these. In subsequent analysis, the statistical nature of the errors must; be handled properly. As the last step, measurements are compared to models, and free model; parameters need to be determined in this process. See Figure [1.1](#f11) for an; example of a function (model) fit to data points. Several standard methods are; available, and a data analysis tool should provide easy access to more; than one of them. Means to quantify the level of agreement between; measurements and model must also be available.; <!--; [f11]: figures/examplefit.png ""f11""; <a name=""f11""></a>. ![Measured data points with error bars and fitted quadratic; function.\label{f11}][f11]-->. Quite often, the data volume to be analyzed is large - think of; fine-granular measurements accumulated with the aid of computers. A; usable tool therefore must contain easy-to-use and efficient methods for; storing and handling data. In Quantum mechanics, models typically only predict the probability; density function (""pdf"") of measurements depending on a number of; parameters, and the aim of the experimental analysis is to extract the; parameters from the observed distribution of frequencies at which; certain values of the measurement are observed. Measurements of this; kind require means to generate and visualize frequency distributions,; so-called histograms, and stringent",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md:1493,access,access,1493,documentation/primer/Introduction.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/primer/Introduction.md,1,['access'],['access']
Security,"tch* address register (an SP3 syntax).; [flat_scratch_hi] High 32 bits of *flat scratch* address register (an SP3 syntax).; ========================= =========================================================================. .. _amdgpu_synid_xnack:; .. _amdgpu_synid_xnack_mask:. xnack_mask; ----------. Xnack mask, 64-bits wide. Holds a 64-bit mask of which threads; received an *XNACK* due to a vector memory operation. For availability of *xnack* feature, refer to :ref:`this table<amdgpu-processors>`. ============================== =====================================================; Syntax Description; ============================== =====================================================; xnack_mask 64-bit *xnack mask* register.; [xnack_mask] 64-bit *xnack mask* register (an SP3 syntax).; [xnack_mask_lo,xnack_mask_hi] 64-bit *xnack mask* register (an SP3 syntax).; ============================== =====================================================. High and low 32 bits of *xnack mask* may be accessed as separate registers:. ===================== ==============================================================; Syntax Description; ===================== ==============================================================; xnack_mask_lo Low 32 bits of *xnack mask* register.; xnack_mask_hi High 32 bits of *xnack mask* register.; [xnack_mask_lo] Low 32 bits of *xnack mask* register (an SP3 syntax).; [xnack_mask_hi] High 32 bits of *xnack mask* register (an SP3 syntax).; ===================== ==============================================================. .. _amdgpu_synid_vcc:; .. _amdgpu_synid_vcc_lo:. vcc; ---. Vector condition code, 64-bits wide. A bit mask with one bit per thread;; it holds the result of a vector compare operation. Note that GFX10+ H/W does not use high 32 bits of *vcc* in *wave32* mode. ================ =========================================================================; Syntax Description; ================ ==============================================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst:16814,access,accessed,16814,interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUOperandSyntax.rst,1,['access'],['accessed']
Security,"tcnt vmcnt(0)`` is required to ensure; synchronization between vector memory operations of different CUs. It; ensures a previous vector memory operation has completed before executing a; subsequent vector memory or LDS operation and so can be used to meet the; requirements of acquire and release.; * The L2 cache of one agent can be kept coherent with other agents by:; using the MTYPE RW (read-write) or MTYPE CC (cache-coherent) with the PTE; C-bit for memory local to the L2; and using the MTYPE NC (non-coherent) with; the PTE C-bit set or MTYPE UC (uncached) for memory not local to the L2. * Any local memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by coherent requests. Coherent requests are caused; by GPU accesses to pages with the PTE C-bit set, by CPU accesses over; XGMI, and by PCIe requests that are configured to be coherent requests.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter and and the PTE C-bit being set.; * Since all work-groups on the same agent share the same L2, no L2; invalidation or writeback is required for coherence.; * To ensure coherence of local and remote memory writes of work-groups in; different agents a ``buffer_wbl2`` is required. It will writeback dirty L2; cache lines of MTYPE RW (used for local coarse grain memory) and MTYPE NC; ()used for remote coarse grain memory). Note that MTYPE CC (used for local; fine grain memory) causes write through to DRAM, and MTYPE UC (used for; remote fine grain memory) bypasses the L2, so both will never result in; dirty L2 cache lines.; * To ensure coherence of local and remote memory reads of work-groups in; different agents a ``buffer_invl2`` is required. It will invalidate L2; cache lines with MTYPE NC (used for remote coarse grain memory). Note tha",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:238274,access,accesses,238274,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"tcnt`` instructions when there are; no intervening memory instructions which access the corresponding address; space. The code sequences in the table indicate what can be omitted for the; OpenCL memory. The target triple environment is used to determine if the; source language is OpenCL (see :ref:`amdgpu-opencl`). ``ds/flat_load/store/atomic`` instructions to local memory are termed LDS; operations. ``buffer/global/flat_load/store/atomic`` instructions to global memory are; termed vector memory operations. Private address space uses ``buffer_load/store`` using the scratch V#; (GFX6-GFX8), or ``scratch_load/store`` (GFX9-GFX11). Since only a single thread; is accessing the memory, atomic memory orderings are not meaningful, and all; accesses are treated as non-atomic. Constant address space uses ``buffer/global_load`` instructions (or equivalent; scalar memory instructions). Since the constant address space contents do not; change during the execution of a kernel dispatch it is not legal to perform; stores, and atomic memory orderings are not meaningful, and all accesses are; treated as non-atomic. A memory synchronization scope wider than work-group is not meaningful for the; group (LDS) address space and is treated as work-group. The memory model does not support the region address space which is treated as; non-atomic. Acquire memory ordering is not meaningful on store atomic instructions and is; treated as non-atomic. Release memory ordering is not meaningful on load atomic instructions and is; treated a non-atomic. Acquire-release memory ordering is not meaningful on load or store atomic; instructions and is treated as acquire and release respectively. The memory order also adds the single thread optimization constraints defined in; table; :ref:`amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-table`. .. table:: AMDHSA Memory Model Single Thread Optimization Constraints; :name: amdgpu-amdhsa-memory-model-single-thread-optimization-constraints-ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:203574,access,accesses,203574,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"te and the destructor).; Cling does not support such a multiplexing wrapper and alternatively; interface must be used (See TClass::New and TClass::Destructor for; example). The following interfaces are not yet available:. - DeleteVariable. They might be re-implemented in a later version. ### rootcling, rootcint and genreflex. rootcling is the successor to rootcint and it preserves its old commandline; arguments and provides more (see help). The executable rootcint still exists; but it is just a redirection to rootcling.; The following *backward incompatibilities* are present between rootcint in; version 5 and rootcling in version 6:. - rootcling does not support multiline \#pragma without a line; continuation as rootcint did (rootcint support \#pragma link with a; line continutation only in ROOT v5.34/02 and above).; - rootcling no longer re-\#defines the private and protected keywords; to public. In particular this means that code compiled as part of; the dictionary no longer has access to protected and private members; of a class (except where allowed by the C++ standard).; In particular, this means that the code used for read rules (\#pragma read); can no longer access private member unless they have been mentioned as a; target of the rule.; - rootcling no longer considers a friend declaration to be a; declaration for the friended function. In particular this means that; rootcling may now issue:. ``` {.cpp}; Error: in this version of ROOT, the option '!' used in a linkdef file; implies the actual existence of customized operators.; The following declaration is now required:; TBuffer &operator<<(TBuffer &,const THit *);; ```. if the operator `<<` declaration is missing. To steer the parsing done during the execution of rootcling, a new; macro: *\_\_ROOTCLING\_\_* is now defined during the parsing. The macros; *\_\_CINT\_\_* and *\_\_MAKECINT\_\_* are defined only when looking for; `#pragma` statement. The genreflex executable is still available, it preserves the sa",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md:6414,access,access,6414,core/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v600/index.md,1,['access'],['access']
Security,"te data for hash); |------------|; 0x00003500: | 0x00001203 | String offset into .debug_str (""collision""); | 0x00000002 | A 32 bit array count - number of HashData with name ""collision""; | 0x........ | HashData[0]; | 0x........ | HashData[1]; | 0x00001203 | String offset into .debug_str (""dump""); | 0x00000003 | A 32 bit array count - number of HashData with name ""dump""; | 0x........ | HashData[0]; | 0x........ | HashData[1]; | 0x........ | HashData[2]; | 0x00000000 | String offset into .debug_str (terminate data for hash); |------------|; 0x00003550: | 0x00001203 | String offset into .debug_str (""main""); | 0x00000009 | A 32 bit array count - number of HashData with name ""main""; | 0x........ | HashData[0]; | 0x........ | HashData[1]; | 0x........ | HashData[2]; | 0x........ | HashData[3]; | 0x........ | HashData[4]; | 0x........ | HashData[5]; | 0x........ | HashData[6]; | 0x........ | HashData[7]; | 0x........ | HashData[8]; | 0x00000000 | String offset into .debug_str (terminate data for hash); `------------'. So we still have all of the same data, we just organize it more efficiently for; debugger lookup. If we repeat the same ""``printf``"" lookup from above, we; would hash ""``printf``"" and find it matches ``BUCKETS[3]`` by taking the 32 bit; hash value and modulo it by ``n_buckets``. ``BUCKETS[3]`` contains ""6"" which; is the index into the ``HASHES`` table. We would then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:67019,hash,hash,67019,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"te over an unordered collection, you are; not likely to retrieve elements in the same order they were added to the; collection. The following unordered collections are available:. - **`THashTable`**. - **`TMap`**. ## Iterators: Processing a Collection. The concept of processing all the members of a collection is generic,; i.e. independent of any specific representation of a collection. To; process each object in a collection one needs some type of cursor that; is initialized and then steps over each member of the collection in; turn. Collection objects could provide this service but there is a snag:; as there is only one collection object per collection there would only; be one cursor. Instead, to permit the use of as many cursors as; required, they are made separate classes called iterator. For each; collection class there is an associated iterator class that knows how to; sequentially retrieve each member in turn. The relationship between a; collection and its iterator is very close and may require that the; iterator has full access to the collection (i.e. it is a friend class).; In general iterator will be used via the **`TIter`** wrapper class. For; example:. - **`TList`** **`TListIter`**. - **`TMap`** **`TMapIter`**. ## Foundation Classes. All collections are based on the fundamental classes: **`TCollection`**; and **`TIterator`**. They are so generic that it is not possible to; create objects from them; they are only used as base classes for other; classes (i.e. they are abstract base classes). The **`TCollection`** class provides the basic protocol (i.e. the; minimum set of member functions) that all collection classes have to; implement. These include:. - `Add` `Adds another object to the collection.`. - `GetSize` `Returns the number of objects in the collection.`. - `Clear`; `Clears out the collection, but does not delete the removed objects.`. - `Delete`; `Clears out the collection and deletes the removed objects. This should only `; `be used if the collect",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md:6047,access,access,6047,documentation/users-guide/CollectionClasses.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/CollectionClasses.md,1,['access'],['access']
Security,"te symbol; table and debugging information, even if this is later stripped from the binary. This specification uses the ELF Build ID as the sole means of identifying; binaries. Each binary relevant to the log must have been linked with a unique; Build ID. The symbolizing filter must have some means of mapping a Build ID back; to the original ELF binary (either the whole unstripped binary, or a stripped; binary paired with a separate debug file). Colorization; ============. The markup format supports a restricted subset of ANSI X3.64 SGR (Select Graphic; Rendition) control sequences. These are unlike other markup elements:. * They specify presentation details (bold or colors) rather than semantic; information. The association of semantic meaning with color (e.g. red for; errors) is chosen by the code doing the logging, rather than by the UI; presentation of the symbolizing filter. This is a concession to existing code; (e.g. LLVM sanitizer runtimes) that use specific colors and would require; substantial changes to generate semantic markup instead. * A single control sequence changes ""the state"", rather than being an; hierarchical structure that surrounds affected text. The filter processes ANSI SGR control sequences only within a single line. If a; control sequence to enter a bold or color state is encountered, it's expected; that the control sequence to reset to default state will be encountered before; the end of that line. If a ""dangling"" state is left at the end of a line, the; filter may reset to default state for the next line. An SGR control sequence is not interpreted inside any other markup element.; However, other markup elements may appear between SGR control sequences and the; color/bold state is expected to apply to the symbolic output that replaces the; markup element in the filter's output. The accepted SGR control sequences all have the form ``""\033[%um""`` (expressed here; using C string syntax), where ``%u`` is one of these:. ==== ==================",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst:5046,sanitiz,sanitizer,5046,interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SymbolizerMarkupFormat.rst,1,['sanitiz'],['sanitizer']
Security,"te vector: LAVector parameters:. -1.82079e-05; -1.20794e-05; 6.22382e-06; -3.0465e-05. minimum internal covariance matrix: LASymMatrix parameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0. ## CVS code repository ##. How to check out (–in) code from the CVS code repository is described at; the M homepage @bib-C++MINUIT. To get the source code from the CVS; repository one needs to do:. Kerberos IV authorization:. $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit. Anonymous read-only access (if it's enabled by the librarian, see; details):. $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login. (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS; password:cvs. $ cvs co MathLibs/Minuit. (If you want to check out a tagged version SEAL\_x\_x\_x of MINUIT, then; do. $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ). ## Create a tar.gz from CVS ##. Once the sources are checked out from the CVS code repository,. 1. change to the directory:. $ cd MathLibs/Minuit. 2. run autogen:. $ ./autogen. 3. create a new directory:. $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/. 4. run configure:. $ ../Minuit/configure. 5. create the tar.gz:. $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used; as described above. ## M versions ##. The version numbers of M follow the release numbers of the SEAL projec",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md:23959,authoriz,authorization,23959,documentation/minuit2/Minuit2.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/minuit2/Minuit2.md,1,['authoriz'],['authorization']
Security,"te__((no_sanitize(""safe-stack"")))`` below). Programs that use APIs from ``ucontext.h`` are not supported yet. Security; --------. SafeStack protects return addresses, spilled registers and local variables that; are always accessed in a safe way by separating them in a dedicated safe stack; region. The safe stack is automatically protected against stack-based buffer; overflows, since it is disjoint from the unsafe stack in memory, and it itself; is always accessed in a safe way. In the current implementation, the safe stack; is protected against arbitrary memory write vulnerabilities though; randomization and information hiding: the safe stack is allocated at a random; address and the instrumentation ensures that no pointers to the safe stack are; ever stored outside of the safe stack itself (see limitations below). Known security limitations; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A complete protection against control-flow hijack attacks requires combining; SafeStack with another mechanism that enforces the integrity of code pointers; that are stored on the heap or the unsafe stack, such as `CPI; <https://dslab.epfl.ch/research/cpi/>`_, or a forward-edge control flow integrity; mechanism that enforces correct calling conventions at indirect call sites,; such as `IFCC <https://research.google.com/pubs/archive/42808.pdf>`_ with arity; checks. Clang has control-flow integrity protection scheme for :doc:`C++ virtual; calls <ControlFlowIntegrity>`, but not non-virtual indirect calls. With; SafeStack alone, an attacker can overwrite a function pointer on the heap or; the unsafe stack and cause a program to call arbitrary location, which in turn; might enable stack pivoting and return-oriented programming. In its current implementation, SafeStack provides precise protection against; stack-based buffer overflows, but protection against arbitrary memory write; vulnerabilities is probabilistic and relies on randomization and information; hiding. The randomization is currently based on s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst:3677,attack,attacks,3677,interpreter/llvm-project/clang/docs/SafeStack.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SafeStack.rst,2,"['attack', 'integrity']","['attacks', 'integrity']"
Security,"ted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are veri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68955,sanitiz,sanitized,68955,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['sanitiz'],['sanitized']
Security,"ted. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this; definition, requires the user of the library only to be familiar; with the semantic content of the objects in use. Locking access to; objects that are being shared due to extra-semantic details of; implementation (for example, copy-on-write) should remain the; responsibility of the library. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within the library. The preferred way of; providing this protection is to use mutex locks. The library also; locks an object before writing to it. The developer is not required; to explicitly lock or unlock a class object (static, global or; local) to perform a single operation on the object. Note that even; multithread safe level II hardly relieves the user",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:23662,access,access,23662,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,1,['access'],['access']
Security,"tended to be used outside of ROOT, including: `gROOTLocal` and related functions, `TSchemaHelper`, `TSchemaMatch`, `TSchemaType`, `RStl`, `ROOT::TROOTAllocator`, `TSchemaRuleProcessor`, `TStdBitsetHelper`, `TInitBehavior`, `TDefaultInitBehavior`, `DefineBehavior`, `THnBaseBrowsable`, `THnBaseBinIter`, `GenericShowMembers`, `TOperatorNewHelper` and `BranchProxy` implementations classes. Several definition where moved from the global or ROOT namespace to the ROOT::Details namespace as they are intended to be used in 'expert' level code and have a lower level of backward compatibility requirement. This includes `TCollectionProxyInfo`, `TSchemaRuleSet`. ## Interpreter. ROOT can now dump the context of STL collections, for instance `map<string,int>`. A few ROOT types print their content, too. Fixed the handling of the current directory in `#include` of system headers, avoid problem with local files named `new` or `vector`. Fixed the issue with the ROOT special variable where the objects were read from the file at each and every access by caching those object. See [ROOT-7830] for example. This release contains several bug fixes and improvements, notably in unloading and performance. > NOTE: The GCC 5 ABI is *not* supported yet, due to a lack of support in clang. ## I/O Libraries. ### hadd. We extended the `hadd` options to allow more control on the compression settings use for the; output file. In particular the new option -fk allows for a copy of the input; files with no decompressions/recompression of the TTree baskets even if they; do not match the requested compression setting. New options:. - `-ff` allows to force the compression setting to match the one from the first input; - `-fk[0-209]` allows to keep all the basket compressed as is and to compress the meta data with the given compression setting or the compression setting of the first input file.; - `-a` option append to existing file; - The verbosity level is now optional after -v. ### Command line utilities. We",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:6475,access,access,6475,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['access'],['access']
Security,"tensions for files to be considered as ""main"". For example, if this option is configured to ``(Impl\.hpp)$``,; then a file ``ClassImpl.hpp`` is considered ""main"" (in addition to; ``Class.c``, ``Class.cc``, ``Class.cpp`` and so on) and ""main; include file"" logic will be executed (with *IncludeIsMainRegex* setting; also being respected in later phase). Without this option set,; ``ClassImpl.hpp`` would not have the main include file put on top; before any other include. .. _IndentAccessModifiers:. **IndentAccessModifiers** (``Boolean``) :versionbadge:`clang-format 13` :ref:`¶ <IndentAccessModifiers>`; Specify whether access modifiers should have their own indentation level. When ``false``, access modifiers are indented (or outdented) relative to; the record members, respecting the ``AccessModifierOffset``. Record; members are indented one level below the record.; When ``true``, access modifiers get their own indentation level. As a; consequence, record members are always indented 2 levels below the record,; regardless of the access modifier presence. Value of the; ``AccessModifierOffset`` is ignored. .. code-block:: c++. false: true:; class C { vs. class C {; class D { class D {; void bar(); void bar();; protected: protected:; D(); D();; }; };; public: public:; C(); C();; }; };; void foo() { void foo() {; return 1; return 1;; } }. .. _IndentCaseBlocks:. **IndentCaseBlocks** (``Boolean``) :versionbadge:`clang-format 11` :ref:`¶ <IndentCaseBlocks>`; Indent case label blocks one level from the case label. When ``false``, the block following the case label uses the same; indentation level as for the case label, treating the case label the same; as an if-statement.; When ``true``, the block gets indented as a scope block. .. code-block:: c++. false: true:; switch (fool) { vs. switch (fool) {; case 1: { case 1:; bar(); {; } break; bar();; default: { }; plop(); break;; } default:; } {; plop();; }; }. .. _IndentCaseLabels:. **IndentCaseLabels** (``Boolean``) :versionbadge:`cla",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst:70247,access,access,70247,interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangFormatStyleOptions.rst,1,['access'],['access']
Security,"tensions. If you specify a directory, the; files are expected in that directory with the same base name as the source; file. .. option:: -p, --preserve-paths. Preserve path components when naming the coverage output files. In addition; to the source file name, include the directories from the path to that; file. The directories are separate by ``#`` characters, with ``.`` directories; removed and ``..`` directories replaced by ``^`` characters. When used with; the --long-file-names option, this applies to both the main file name and the; included file name. .. option:: -r. Only dump files with relative paths or absolute paths with the prefix specified; by ``-s``. .. option:: -s <string>. Source prefix to elide. .. option:: -t, --stdout. Print to stdout instead of producing ``.gcov`` files. .. option:: -u, --unconditional-branches. Include unconditional branches in the output for the --branch-probabilities; option. .. option:: -version. Display the version of llvm-cov. .. option:: -x, --hash-filenames. Use md5 hash of file name when naming the coverage output files. The source; file name will be suffixed by ``##`` followed by MD5 hash calculated for it. EXIT STATUS; ^^^^^^^^^^^. :program:`llvm-cov gcov` returns 1 if it cannot read input files. Otherwise,; it exits with zero. .. program:: llvm-cov show. .. _llvm-cov-show:. SHOW COMMAND; ------------. SYNOPSIS; ^^^^^^^^. :program:`llvm-cov show` [*options*] -instr-profile *PROFILE* [*BIN*] [*-object BIN*]... [*-sources*] [*SOURCE*]... DESCRIPTION; ^^^^^^^^^^^. The :program:`llvm-cov show` command shows line by line coverage of the; binaries *BIN*... using the profile data *PROFILE*. It can optionally be; filtered to only show the coverage for the files listed in *SOURCE*.... *BIN* may be an executable, object file, dynamic library, or archive (thin or; otherwise). To use :program:`llvm-cov show`, you need a program that is compiled with; instrumentation to emit profile and coverage data. To build such a program with; ``",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst:5966,hash,hash-filenames,5966,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-cov.rst,1,['hash'],['hash-filenames']
Security,"ter group record frame references the page list envelopes for groups of clusters.; A cluster group record frame has the following contents followed by a page list envelope link. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Minimum Entry Number +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + Entry Span +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of clusters |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. To compute the minimum entry number, take first entry number from all clusters in the cluster group,; and take the minimum among these numbers.; The entry span is the number of entries that are covered by this cluster group.; The entry range allows for finding the right page list for random access requests to entries.; The number of clusters information allows for using consistent cluster IDs; even if cluster groups are accessed non-sequentially. ### Page List Envelope. The page list envelope contains cluster summaries and page locations.; It has the following structure. - Header checksum (XxHash-3 64bit); - List frame of cluster summary record frames; - Nested list frame of page locations. #### Cluster Summary Record Frame; The cluster summary record frame contains the entry range of a cluster:. ```; 0 1 2 3; 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | |; + First Entry Number +; | |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; | Number of Entries |; + +-+-+-+-+-+-+-+-+; | | Flags |; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+; ```. The order of the cluster summaries defines the cluster IDs,; starting from the first cluster ID of the cluster group that corresponds to the page list. Flag 0x01 is reserved for a future specification ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md:31892,access,accessed,31892,tree/ntuple/v7/doc/BinaryFormatSpecification.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/BinaryFormatSpecification.md,1,['access'],['accessed']
Security,"ter to the Minimizer and Objective function of the last fit. The objective function depends on a reference to the data and the model function, therefore the objective function pointer is valid as far the data and the model function are maintained alive.; ; The library provides the implementation of standard objective function like the Chi2 function, the Poisson likelihood function (for binned likelihood fits) and the loh likelihood function (for unbinned fits). These standard objective functions can be created with or without gradient functionality. In the first case the minimization will be performed using the gradient provided by the function. These functions can also be used in specialized fitting methods like Fumili or the GSL non-linear least square.; . MathCore. Fixed a bug in setting the VEGAS integration mode in the GSLMCIntegrator class.; . Fumili. Add implementation of Minimizer interface using TFumili.; ; Minuit. In TMinuitMinimizer: do not delete the contained TMinuit reference, but maintain it alive, and accessible outside as gMinuit. It can then be used after fitting, for example for drawing contour plots. Add also support for Scan and Contour plots.; ; TLinearMinimizer: add support for robust fitting; . Minuit2. Add support to perform parallel minimization using a thread for each gradient calculation with openMP. In the ROOT environment the Minuit2 library can be built using openMP ( -fopenmp compilation flag for gcc) if the environment variables USE_PARALLEL_MINUIT2 and USE_OPENMP are set.; In the Minuit2 standalone built libraries (using autoconf) support for openMP is automatically enabled, whenever the compiler supports it (for example for gcc version >= 4.2). Some small changes have been applied in Minuit2 to make it thread safe. For example, when transforming from internal to external values, the parameter values are not cached anymore in MnUserTransformation class.; DavidonErrorUpdator: add an additional check to avoid a division by zero.; In M",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html:2881,access,accessible,2881,math/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/doc/v522/index.html,2,['access'],['accessible']
Security,"terType::get()`` and similar APIs are automatically converted into; opaque pointers. This simplifies migration and allows testing existing IR with; opaque pointers. .. code-block:: llvm. define i8* @test(i8* %p) {; %p2 = getelementptr i8, i8* %p, i64 1; ret i8* %p2; }. ; Is automatically converted into the following if -opaque-pointers; ; is enabled:. define ptr @test(ptr %p) {; %p2 = getelementptr i8, ptr %p, i64 1; ret ptr %p2; }. Migration Instructions; ======================. In order to support opaque pointers, two types of changes tend to be necessary.; The first is the removal of all calls to ``PointerType::getElementType()`` and; ``Type::getPointerElementType()``. In the LLVM middle-end and backend, this is usually accomplished by inspecting; the type of relevant operations instead. For example, memory access related; analyses and optimizations should use the types encoded in the load and store; instructions instead of querying the pointer type. Here are some common ways to avoid pointer element type accesses:. * For loads, use ``getType()``.; * For stores, use ``getValueOperand()->getType()``.; * Use ``getLoadStoreType()`` to handle both of the above in one call.; * For getelementptr instructions, use ``getSourceElementType()``.; * For calls, use ``getFunctionType()``.; * For allocas, use ``getAllocatedType()``.; * For globals, use ``getValueType()``.; * For consistency assertions, use; ``PointerType::isOpaqueOrPointeeTypeEquals()``.; * To create a pointer type in a different address space, use; ``PointerType::getWithSamePointeeType()``.; * To check that two pointers have the same element type, use; ``PointerType::hasSameElementTypeAs()``.; * While it is preferred to write code in a way that accepts both typed and; opaque pointers, ``Type::isOpaquePointerTy()`` and; ``PointerType::isOpaque()`` can be used to handle opaque pointers specially.; ``PointerType::getNonOpaquePointerElementType()`` can be used as a marker in; code-paths where opaque pointers have b",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst:6809,access,accesses,6809,interpreter/llvm-project/llvm/docs/OpaquePointers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/OpaquePointers.rst,1,['access'],['accesses']
Security,"terate over a subrange of entries. Each subrange corresponds to a cluster in the TTree and is processed by a task, which can potentially be run in parallel with other tasks.; * Add a new implementation of a RW lock, `ROOT::TRWSpinLock`, which is based on a `ROOT::TSpinMutex`. `TRWSpinLock` tries to make faster the scenario when readers come and go but there is no writer, while still preventing starvation of writers. ## I/O Libraries. * Support I/O of `std::unique_ptr`s and STL collections thereof.; * Support I/O of `std::array`.; * Support I/O of `std::tuple`. The dictionary for those is never auto generated and thus requires explicit request of the dictionary for each std::tuple class template instantiation used, like most other class templates.; * Custom streamers need to #include TBuffer.h explicitly (see [section Core Libraries](#core-libs)); * Check and flag short reads as errors in the xroot plugins. This fixes [ROOT-3341].; * Added support for AWS temporary security credentials to TS3WebFile by allowing the security token to be given.; * Resolve an issue when space is freed in a large `ROOT` file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. - ##### TBufferJSON:; + support data members with `//[fN]` comment; + preliminary support of STL containers; + JSON data can be produced with `TObject::SaveAs()` method. ## TTree Libraries. * TChains can now be histogrammed without any C++ code, using the command line tool `rootdrawtree`. It is based on the new class `TSimpleAnalysis`.; * Do not automatically setup read cache during `TTree::Fill()`. This fixes [ROOT-8031].; * Make sure the option ""PARA"" in `TTree::Draw` is used with at least tow variables [ROOT-8196].; * The with `goff` option one can use as many variables as needed. There no more; limitation, like with the options `para`and `candle`.; * Fix detection of errors that appears in nested TTreeFormula [ROOT-8218]; * Better basket size optimization by ta",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md:8325,secur,security,8325,README/ReleaseNotes/v608/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v608/index.md,2,['secur'],['security']
Security,"terator op_end()`` - Get an iterator to the end of the operand list. Together, these methods make up the iterator based interface to the operands; of a ``User``. .. _Instruction:. The ``Instruction`` class; -------------------------. ``#include ""llvm/IR/Instruction.h""``. header source: `Instruction.h; <https://llvm.org/doxygen/Instruction_8h_source.html>`_. doxygen info: `Instruction Class; <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. Superclasses: User_, Value_. The ``Instruction`` class is the common base class for all LLVM instructions.; It provides only a few methods, but is a very commonly used class. The primary; data tracked by the ``Instruction`` class itself is the opcode (instruction; type) and the parent BasicBlock_ the ``Instruction`` is embedded into. To; represent a specific type of instruction, one of many subclasses of; ``Instruction`` are used. Because the ``Instruction`` class subclasses the User_ class, its operands can; be accessed in the same way as for other ``User``\ s (with the; ``getOperand()``/``getNumOperands()`` and ``op_begin()``/``op_end()`` methods).; An important file for the ``Instruction`` class is the ``llvm/Instruction.def``; file. This file contains some meta-data about the various different types of; instructions in LLVM. It describes the enum values that are used as opcodes; (for example ``Instruction::Add`` and ``Instruction::ICmp``), as well as the; concrete sub-classes of ``Instruction`` that implement the instruction (for; example BinaryOperator_ and CmpInst_). Unfortunately, the use of macros in this; file confuses doxygen, so these enum values don't show up correctly in the; `doxygen output <https://llvm.org/doxygen/classllvm_1_1Instruction.html>`_. .. _s_Instruction:. Important Subclasses of the ``Instruction`` class; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. _BinaryOperator:. * ``BinaryOperator``. This subclasses represents all two operand instructions whose operands must be; the same type, ex",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:146981,access,accessed,146981,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security,"tes are used to spill SGPR registers. In this; case the AMDGPU backend ensures the memory location used to spill is never; accessed by vector memory operations at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is allocated in host memory accessed as; MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also; causes it to be treated as non-volatile and so is not invalidated by; ``*_vol``.; * On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent); and so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX6-GFX9 are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table`. .. table:: AMDHSA Memory Model Code Sequences GFX6-GFX9; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX6-GFX9; Space; ============ ============ ============== ========== =",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:210852,access,accessed,210852,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"tes locked and unlocked. A mutex is usually used to ensure; that only one thread at a time executes some critical section of code.; Before entering a critical section, a thread will attempt to lock the; mutex, which guards that section. If the mutex is already locked, the; thread will block until the mutex is unlocked, at which time it will; lock the mutex, execute the critical section, and unlock the mutex upon; leaving the critical section. A **`semaphore`** is a synchronization mechanism that starts out; initialized to some positive value. A thread may ask to wait on a; semaphore in which case the thread blocks until the value of the; semaphore is positive. At that time the semaphore count is decremented; and the thread continues. When a thread releases semaphore, the; semaphore count is incremented. Counting semaphores are useful for; coordinating access to a limited pool of some resource. **`Readers/Writer Lock`** - a multiple-reader, single-writer lock is one; that allows simultaneous read access by many threads while restricting; write access to only one thread at a time. When any thread holds the; lock for reading, other threads can also acquire the lock reading. If; one thread holds the lock for writing, or is waiting to acquire the lock; for writing, other threads must wait to acquire the lock for either; reading or writing. Use a **`condition variable`** in conjunction with a mutex lock to; automatically block threads until a particular condition is true. **`Multithread Safe Levels`** - a possible classification scheme to; describe thread-safety of libraries:. - All public and protected functions are reentrant. The library; provides protection against multiple threads trying to modify static; and global data used within a library. The developer must explicitly; lock access to objects shared between threads. No other thread can; write to a locked object unless it is unlocked. The developer needs; to lock local objects. The spirit, if not the letter of this;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md:22865,access,access,22865,documentation/users-guide/Threads.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Threads.md,2,['access'],['access']
Security,"tes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist befor",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:14093,expose,exposes,14093,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['expose'],['exposes']
Security,"tf(""INIT: %p %p\n"", start, stop);; for (uint32_t *x = start; x < stop; x++); *x = ++N; // Guards should start from 1.; }. // This callback is inserted by the compiler on every edge in the; // control flow (some optimizations apply).; // Typically, the compiler will emit the code like this:; // if(*guard); // __sanitizer_cov_trace_pc_guard(guard);; // But for large functions it will emit a simple call:; // __sanitizer_cov_trace_pc_guard(guard);; extern ""C"" void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {; if (!*guard) return; // Duplicate the guard check.; // If you set *guard to 0 this code will not be called again for this edge.; // Now you can get the PC and do whatever you want:; // store it somewhere or symbolize it and print right away.; // The values of `*guard` are as you set them in; // __sanitizer_cov_trace_pc_guard_init and so you can make them consecutive; // and use them to dereference an array or a bit vector.; void *PC = __builtin_return_address(0);; char PcDescr[1024];; // This function is a part of the sanitizer run-time.; // To use it, link with AddressSanitizer or other sanitizer.; __sanitizer_symbolize_pc(PC, ""%p %F %L"", PcDescr, sizeof(PcDescr));; printf(""guard: %p %x PC %s\n"", guard, *guard, PcDescr);; }. .. code-block:: c++. // trace-pc-guard-example.cc; void foo() { }; int main(int argc, char **argv) {; if (argc > 1) foo();; }. .. code-block:: console. clang++ -g -fsanitize-coverage=trace-pc-guard trace-pc-guard-example.cc -c; clang++ trace-pc-guard-cb.cc trace-pc-guard-example.o -fsanitize=address; ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:2; guard: 0x71bcd8 3 PC 0x4ecd9e in main trace-pc-guard-example.cc:3:7. .. code-block:: console. ASAN_OPTIONS=strip_path_prefix=`pwd`/ ./a.out with-foo. .. code-block:: console. INIT: 0x71bcd0 0x71bce0; guard: 0x71bcd4 2 PC 0x4ecd5b in main trace-pc-guard-example.cc:3; guard: 0x71bcdc ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst:3079,sanitiz,sanitizer,3079,interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SanitizerCoverage.rst,1,['sanitiz'],['sanitizer']
Security,"th 32-bit and 64-bit object files.; any; Process all the supported object files. On AIX OS, the default is to process 32-bit object files only and to ignore; 64-bit objects. The can be changed by setting the OBJECT_MODE environment; variable. For example, OBJECT_MODE=64 causes :program:`llvm-nm` to process; 64-bit objects and ignore 32-bit objects. The -X flag overrides the OBJECT_MODE; variable. On other operating systems, the default is to process all object files: the; OBJECT_MODE environment variable is not supported. .. option:: --debug-syms, -a. Show all symbols, even those usually suppressed. .. option:: --defined-only, -U. Print only symbols defined in this file. .. option:: --demangle, -C. Demangle symbol names. .. option:: --dynamic, -D. Display dynamic symbols instead of normal symbols. .. option:: --export-symbols. Print sorted symbols with their visibility (if applicable), with duplicates; removed. .. option:: --extern-only, -g. Print only symbols whose definitions are external; that is, accessible from; other files. .. option:: --format=<format>, -f. Select an output format; *format* may be *sysv*, *posix*, *darwin*, *bsd* or; *just-symbols*.; The default is *bsd*. .. option:: --help, -h. Print a summary of command-line options and their meanings. .. option:: -j. Print just the symbol names. Alias for `--format=just-symbols``. .. option:: --line-numbers, -l. Use debugging information to print the filenames and line numbers where; symbols are defined. Undefined symbols have the location of their first; relocation printed instead. .. option:: -m. Use Darwin format. Alias for ``--format=darwin``. .. option:: --no-demangle. Don't demangle symbol names. This is the default. .. option:: --no-llvm-bc. Disable the LLVM bitcode reader. .. option:: --no-sort, -p. Show symbols in the order encountered. .. option:: --no-weak, -W. Don't print weak symbols. .. option:: --numeric-sort, -n, -v. Sort symbols by address. .. option:: --portability, -P. Use POSIX.2 output",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst:4336,access,accessible,4336,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-nm.rst,1,['access'],['accessible']
Security,"th 4 pixels; distance in between, the `Help` menu - will be laid out to the right. The menu classes provide a very flexible menu system: you can enable,; disable, add or remove menu items dynamically. The method; `HideEntry(menuID)` hides the menu entry (the entry will not be shown in; the popup menu). To enable a hidden entry you should call; `EnableEntry(menuID)` method. By default all entries are enabled. The; method `DisableEntry(menuID)` helps you to disable a menu entry - it; will appear in sunken relieve. The `DeleteEntry(menuID)` method will; delete the specified entry from the menu. A few words about the menu design. A menu should be kept consistent and; simple. All related items need to be in a popup menu. The cascade menus; should be used judiciously. Try to limit them to one, maximum two; levels. There are some rules for naming the menu objects:. - Define unique names within a menu. - Use capitalized one-word names allowing the quick scan of the menu. - Define unique access key for any menu item. - Indicate by ellipsis (...) after the title with no space when a menu; item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every; application success and depends of three main factors:. - number of presented items in the menu. - how often the menu is used. - how often the menu contents may change. ### Toolbar. ![](pictures/03000217.png). A toolbar (**`TGToolBar`**) is a composite frame that contains; **`TGPictureButton `**objects. It provides an easy and fast access to; most frequently used commands or options across multiple application; screens. Also, it invokes easily a sub application within an; application. All its functions can be obtained by application menus. It; is located horizontally at the top of the main window just below the; menu bar. All other subtask and sub-feature bars are positioned along; sides of window. ``` {.cpp}; // toolbar icon files; const char *xpms[] = {; ""x_pic.xpm"",; ""y_pic.xpm"",; ""z_pic.xpm"",;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md:73754,access,access,73754,documentation/users-guide/WritingGUI.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/WritingGUI.md,1,['access'],['access']
Security,"th caution. The; guarantees in terms of synchronization are very weak, so make sure these are; only used in a pattern which you know is correct. Generally, these would; either be used for atomic operations which do not protect other memory (like; an atomic counter), or along with a ``fence``. Notes for optimizers; In terms of the optimizer, this can be treated as a read+write on the relevant; memory location (and alias analysis will take advantage of that). In addition,; it is legal to reorder non-atomic and Unordered loads around Monotonic; loads. CSE/DSE and a few other optimizations are allowed, but Monotonic; operations are unlikely to be used in ways which would make those; optimizations useful. Notes for code generation; Code generation is essentially the same as that for unordered for loads and; stores. No fences are required. ``cmpxchg`` and ``atomicrmw`` are required; to appear as a single operation. Acquire; -------. Acquire provides a barrier of the sort necessary to acquire a lock to access; other memory with normal loads and stores. Relevant standard; This corresponds to the C++/C ``memory_order_acquire``. It should also be; used for C++/C ``memory_order_consume``. Notes for frontends; If you are writing a frontend which uses this directly, use with caution.; Acquire only provides a semantic guarantee when paired with a Release; operation. Notes for optimizers; Optimizers not aware of atomics can treat this like a nothrow call. It is; also possible to move stores from before an Acquire load or read-modify-write; operation to after it, and move non-Acquire loads from before an Acquire; operation to after it. Notes for code generation; Architectures with weak memory ordering (essentially everything relevant today; except x86 and SPARC) require some sort of fence to maintain the Acquire; semantics. The precise fences required varies widely by architecture, but for; a simple implementation, most architectures provide a barrier which is strong; enough for eve",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst:11540,access,access,11540,interpreter/llvm-project/llvm/docs/Atomics.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Atomics.rst,1,['access'],['access']
Security,"that can be used.; Instead of each debug level being its own switch, we want to support the; following options, of which only one can be specified at a time:; ""``--debug-level=none``"", ""``--debug-level=quick``"",; ""``--debug-level=detailed``"". To do this, we use the exact same format as our; optimization level flags, but we also specify an option name. For this case,; the code looks like this:. .. code-block:: c++. enum DebugLev {; nodebuginfo, quick, detailed; };. // Enable Debug Options to be specified on the command line; cl::opt<DebugLev> DebugLevel(""debug_level"", cl::desc(""Set the debugging level:""),; cl::values(; clEnumValN(nodebuginfo, ""none"", ""disable debug information""),; clEnumVal(quick, ""enable quick debug information""),; clEnumVal(detailed, ""enable detailed debug information"")));. This definition defines an enumerated command line variable of type ""``enum; DebugLev``"", which works exactly the same way as before. The difference here is; just the interface exposed to the user of your program and the help output by; the ""``-help``"" option:. ::. USAGE: compiler [options] <input file>. OPTIONS:; Choose optimization level:; -g - No optimizations, enable debugging; -O1 - Enable trivial optimizations; -O2 - Enable default optimizations; -O3 - Enable expensive optimizations; -debug_level - Set the debugging level:; =none - disable debug information; =quick - enable quick debug information; =detailed - enable detailed debug information; -f - Enable binary output on terminals; -help - display available options (-help-hidden for more); -o <filename> - Specify output filename; -quiet - Don't print informational messages. Again, the only structural difference between the debug level declaration and; the optimization level declaration is that the debug level declaration includes; an option name (``""debug_level""``), which automatically changes how the library; processes the argument. The CommandLine library supports both forms so that you; can choose the form most approp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:18007,expose,exposed,18007,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['expose'],['exposed']
Security,"the ""one's; complement"" operation, which is the ""~"" operator in C. Arguments:; """""""""""""""""""". The two arguments to the '``xor``' instruction must be; :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both; arguments must have identical types. Semantics:; """""""""""""""""""". The truth table used for the '``xor``' instruction is:. +-----+-----+-----+; | In0 | In1 | Out |; +-----+-----+-----+; | 0 | 0 | 0 |; +-----+-----+-----+; | 0 | 1 | 1 |; +-----+-----+-----+; | 1 | 0 | 1 |; +-----+-----+-----+; | 1 | 1 | 0 |; +-----+-----+-----+. Example:; """""""""""""""". .. code-block:: text. <result> = xor i32 4, %var ; yields i32:result = 4 ^ %var; <result> = xor i32 15, 40 ; yields i32:result = 39; <result> = xor i32 4, 8 ; yields i32:result = 12; <result> = xor i32 %V, -1 ; yields i32:result = ~%V. Vector Operations; -----------------. LLVM supports several instructions to represent vector operations in a; target-independent manner. These instructions cover the element-access; and vector-specific operations needed to process vectors effectively.; While LLVM does directly support these vector operations, many; sophisticated algorithms will want to use target-specific intrinsics to; take full advantage of a specific target. .. _i_extractelement:. '``extractelement``' Instruction; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. <result> = extractelement <n x <ty>> <val>, <ty2> <idx> ; yields <ty>; <result> = extractelement <vscale x n x <ty>> <val>, <ty2> <idx> ; yields <ty>. Overview:; """""""""""""""""". The '``extractelement``' instruction extracts a single scalar element; from a vector at a specified index. Arguments:; """""""""""""""""""". The first operand of an '``extractelement``' instruction is a value of; :ref:`vector <t_vector>` type. The second operand is an index indicating; the position from which to extract the element. The index may be a; variable of any integer type, and will be treated as an unsigned integer. Semantics:; """""""""""""""""""". The result is a scalar of the sam",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:400604,access,access,400604,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"the array-to-pointer conversion applied?; Unknown. 702; CD2; Preferring conversion to std::initializer_list; Unknown. 703; CD2; Narrowing for literals that cannot be exactly represented; Unknown. 704; CD2; To which postfix-expressions does overload resolution apply?; Unknown. 705; CD2; Suppressing argument-dependent lookup via parentheses; Yes. 706; NAD; Use of auto with rvalue references; Unknown. 707; CD2; Undefined behavior in integral-to-floating conversions; Unknown. 708; open; Partial specialization of member templates of class templates; Not resolved. 709; C++11; Enumeration names as nested-name-specifiers in deduction failure; Unknown. 710; CD2; Data races during construction; Unknown. 711; CD2; auto with braced-init-list; Unknown. 712; CD3; Are integer constant operands of a conditional-expression “used?”; Partial. 713; CD2; Unclear note about cv-qualified function types; Unknown. 714; CD2; Static const data members and braced-init-lists; Unknown. 715; CD2; Class member access constant expressions; Unknown. 716; CD2; Specifications that should apply only to non-static union data members; Unknown. 717; CD2; Unintentional restrictions on the use of thread_local; Unknown. 718; NAD; Non-class, non-function friend declarations; Unknown. 719; CD2; Specifications for operator-function-id that should also apply to literal-operator-id; Unknown. 720; CD2; Need examples of lambda-expressions; Unknown. 721; CD2; Where must a variable be initialized to be used in a constant expression?; Unknown. 722; CD2; Can nullptr be passed to an ellipsis?; Unknown. 726; CD2; Atomic and non-atomic objects in the memory model; Unknown. 727; C++17; In-class explicit specializations; Partial. 728; NAD; Restrictions on local classes; Unknown. 729; CD3; Qualification conversions and handlers of reference-to-pointer type; Unknown. 730; CD2; Explicit specializations of members of non-template classes; Unknown. 731; CD2; Omitted reference qualification of member function type; Unknown. 732; C",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:49149,access,access,49149,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"the associated vector lane on or off. The memory addresses corresponding to the ""off"" lanes are not accessed. When all bits of the mask are on, the intrinsic is identical to a regular vector load or store. When all bits are off, no memory is accessed. .. _int_mload:. '``llvm.masked.load.*``' Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; This is an overloaded intrinsic. The loaded data is a vector of any integer, floating-point or pointer data type. ::. declare <16 x float> @llvm.masked.load.v16f32.p0(ptr <ptr>, i32 <alignment>, <16 x i1> <mask>, <16 x float> <passthru>); declare <2 x double> @llvm.masked.load.v2f64.p0(ptr <ptr>, i32 <alignment>, <2 x i1> <mask>, <2 x double> <passthru>); ;; The data is a vector of pointers; declare <8 x ptr> @llvm.masked.load.v8p0.p0(ptr <ptr>, i32 <alignment>, <8 x i1> <mask>, <8 x ptr> <passthru>). Overview:; """""""""""""""""". Reads a vector from memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand. Arguments:; """""""""""""""""""". The first operand is the base pointer for the load. The second operand is the alignment of the source location. It must be a power of two constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the base pointer and the type of the '``passthru``' operand are the same vector types. Semantics:; """""""""""""""""""". The '``llvm.masked.load``' intrinsic is designed for conditional reading of selected vector elements in a single IR operation. It is useful for targets that support vector masked loads and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differentl",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:843883,access,accesses,843883,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['accesses']
Security,"the backend so that it generates; code for the proper architecture. It's possible to override this on the; command line with the ``-mtriple`` command line option. .. _objectlifetime:. Object Lifetime; ----------------------. A memory object, or simply object, is a region of a memory space that is; reserved by a memory allocation such as :ref:`alloca <i_alloca>`, heap; allocation calls, and global variable definitions.; Once it is allocated, the bytes stored in the region can only be read or written; through a pointer that is :ref:`based on <pointeraliasing>` the allocation; value.; If a pointer that is not based on the object tries to read or write to the; object, it is undefined behavior. A lifetime of a memory object is a property that decides its accessibility.; Unless stated otherwise, a memory object is alive since its allocation, and; dead after its deallocation.; It is undefined behavior to access a memory object that isn't alive, but; operations that don't dereference it such as; :ref:`getelementptr <i_getelementptr>`, :ref:`ptrtoint <i_ptrtoint>` and; :ref:`icmp <i_icmp>` return a valid result.; This explains code motion of these instructions across operations that; impact the object's lifetime.; A stack object's lifetime can be explicitly specified using; :ref:`llvm.lifetime.start <int_lifestart>` and; :ref:`llvm.lifetime.end <int_lifeend>` intrinsic function calls. .. _pointeraliasing:. Pointer Aliasing Rules; ----------------------. Any memory access must be done through a pointer value associated with; an address range of the memory access, otherwise the behavior is; undefined. Pointer values are associated with address ranges according; to the following rules:. - A pointer value is associated with the addresses associated with any; value it is *based* on.; - An address of a global variable is associated with the address range; of the variable's storage.; - The result value of an allocation instruction is associated with the; address range of the allocat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:140825,access,access,140825,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"the client side,; but does not wait that real update is completed. Avoids blocking of caller thread.; Have to be used if called from other web-based widget to avoid logical dead-locks.; In case of normal canvas just canvas->Update() is performed. - The Delaunay triangles (used by TGraph2D) were computed by the external package `triangle.c`; included in the ROOT distribution. This package had several issues:; - It was not maintained anymore.; - Its license was not compatible with LGPL; This code is now replaced by the [CDT package](https://github.com/artem-ogre/CDT) which is; properly maintained and has a license (MLP) compatible with LGPL. It will appear in 6.03.02. ## Machine Learning integration. - ROOT now offers functionality to extract batches of events out of a dataset for use in common ML training workflows. For example, one can generate PyTorch tensors from a TTree. The functionality is available through the `RBatchGenerator` class and can be seamlessly integrated in user code, for example:; ```python; # Returns two generators that return training and validation batches as PyTorch tensors.; gen_train, gen_validation = ROOT.TMVA.Experimental.CreatePyTorchGenerators(; tree_name, file_name, batch_size, chunk_size, target=target, validation_split=0.3); ```; The functionality is also available for TensorFlow datasets and Python generators of numpy arrays. See more in the `RBatchGenerator*` tutorials under the TMVA folder. ## 3D Graphics Libraries. ## Geometry Libraries. ## Database Libraries. ## Networking Libraries. ## GUI Libraries. ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. - The default `TCanvas` and `TBrowser` is switched back to the traditional look. (`--web=off` is no longer needed). ## Tutorials. ## Class Reference Guide. ## Build, Configuration and Testing Infrastructure. - The traditional versioning convention of ROOT (e.g. 6.28/10) has been changed to standard semantic versioning (6.28.10), i.e. the slash is ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md:21053,validat,validation,21053,README/ReleaseNotes/v630/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v630/index.md,1,['validat'],['validation']
Security,"the cluster pool is instructed to not read beyond the given limit.; This is used in the RNTuple data source when multiple threads work on different clusters of the same file. ### RMiniFile; The RMiniFile is an internal class used to read and write RNTuple data in a ROOT file.; It provides a minimal subset of the `TFile` functionality.; Its purpose is to reduce the coupling between RNTuple and the ROOT I/O library. For writing data, the RMiniFile can either use a proper `TFile` (descendant) or a C file stream (only for new ROOT files with a single RNTuple).; For reading, the `RMiniFile` always uses an `RRawFile`. ### RRawFile; The RRawFile internal abstract class provides an interface to read byte ranges from a file, including vector reads.; Concrete implementations exist for local files, XRootD and HTTP (the latter two through the ROOT plugin mechanism).; The local file implementation on Linux uses uring for vector reads, if available.; `RRawFileTFile` wraps an existing `TFile` and provides access to the full set of implementations, e.g. `TMemFile`. Tooling; -------. ### RNTupleMerger; The `RNTupleMerger` is an internal class and part of the core RNTuple library.; It concatenates RNTuple data from several sources into a combined sink.; It implements ""fast merging"", i.e. copy-based merging that does not decompress and recompress pages.; The RNTupler merger is used by the `TFileMerger` and thus provides RNTuple merge support in `hadd` and `TBufferMerger`. ### RNTupleImporter; The RNTupleImporter creates RNTuple data sets from ROOT trees.; It is part of the `ROOTNTupleUtil` library. ### RNTupleInspector; The RNTupleInspector provides insights of an RNTuple, e.g. the distribution of data volume wrt. column types.; It is part of the `ROOTNTupleUtil` library. Ownership Model; ---------------. By default, objects involved in RNTuple I/O (objects read from disk or written to disk) are passed to RNTuple as shared pointers.; Both RNTuple or the application may create the obje",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:16300,access,access,16300,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,"the main one provides all functionality being; linked with the underlying ROOT visualization system. This library is; dynamically loaded by the plug-in manager only when drawing features are; requested. The geometrical structures that can be visualized are volumes; and volume hierarchies. The main component of the visualization system is volume primitive; painting in a ROOT pad. Starting from this one, several specific options; or subsystems are available, like: X3D viewing using hidden line and; surface removal algorithms, OpenGL viewing\* or ray tracing. The method TGeoManager::GetGeomPainter() loads the painting library in; memory. This is generally not needed since it is called automatically by; TGeoVolume::Draw() as well as by few other methods setting; visualization attributes. \anchor GP04a; ### Drawing Volumes and Hierarchies of Volumes. The first thing one would like to do after building some geometry is to; visualize the volume tree. This provides the fastest validation check; for most common coding or design mistakes. As soon as the geometry is; successfully closed, one should draw it starting from the top-level; volume:. ~~~{.cpp}; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; ~~~. Doing this ensures that the original top-level volume of the geometry is; drawn, even if another volume is currently the geometry `root`. OK, I; suppose you already did that with your simple geometry and immediately; noticed a new ROOT canvas popping-up and having some more or less; strange picture inside. Here are few questions that might come:. **Q:** ""The picture is strangely rotated; where are the coordinate axes?"". **A:** If drawn in a new canvas, any view has some default; viewpoint, center of view and size. One can then perform mouse/keyboard; actions to change them:. - Mouse left-click and drag will rotate the view;. - Some keys can be pressed when the view canvas is selected: J/K; zoom/un-zoom, U",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:98049,validat,validation,98049,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['validat'],['validation']
Security,"the new API ``ensureOptimizedUses()`` to keep the previous behavior and do a; one-time optimization of ``MemoryUse``\ s, if this was not done before.; New pass users are recommended to call ``ensureOptimizedUses()``. Initially it was not possible to optimize ``MemoryDef``\ s in the same way, as we; restricted ``MemorySSA`` to one operand per access.; This was changed and ``MemoryDef``\ s now keep two operands.; The first one, the defining access, is; always the previous ``MemoryDef`` or ``MemoryPhi`` in the same basic block, or; the last one in a dominating predecessor if the current block doesn't have any; other accesses writing to memory. This is needed for walking Def chains.; The second operand is the optimized access, if there was a previous call on the; walker's ``getClobberingMemoryAccess(MA)``. This API will cache information; as part of ``MA``.; Optimizing all ``MemoryDef``\ s has quadratic time complexity and is not done; by default. A walk of the uses for any MemoryDef can find the accesses that were optimized; to it.; A code snippet for such a walk looks like this:. .. code-block:: c++. MemoryDef *Def; // find who's optimized or defining for this MemoryDef; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *DefUser = cast_of_null<MemoryDef>MA); if (DefUser->isOptimized() && DefUser->getOptimized() == Def) {; // User who is optimized to Def; } else {; // User who's defining access is Def; optimized to something else or not optimized.; }; }. When ``MemoryUse``\ s are optimized, for a given store, you can find all loads; clobbered by that store by walking the immediate and transitive uses of; the store. .. code-block:: c++. checkUses(MemoryAccess *Def) { // Def can be a MemoryDef or a MemoryPhi.; for (auto& U : Def->uses()) {; MemoryAccess *MA = cast<MemoryAccess>(Use.getUser());; if (auto *MU = cast_of_null<MemoryUse>MA) {; // Process MemoryUse as needed.; }; else {; // Process MemoryDef or MemoryPhi as needed. /",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:12774,access,accesses,12774,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['accesses']
Security,"the object, unless the object is managed; outside of LLVM. The underlying integer computation is sufficiently defined; null has a defined; value --- zero --- and you can add whatever value you want to it. However, it's invalid to access (load from or store to) an LLVM-aware object; with such a pointer. This includes ``GlobalVariables``, ``Allocas``, and objects; pointed to by noalias pointers. If you really need this functionality, you can do the arithmetic with explicit; integer instructions, and use inttoptr to convert the result to an address. Most; of GEP's special aliasing rules do not apply to pointers computed from ptrtoint,; arithmetic, and inttoptr sequences. Can I compute the distance between two objects, and add that value to one address to compute the other address?; ---------------------------------------------------------------------------------------------------------------. As with arithmetic on null, you can use GEP to compute an address that way, but; you can't use that pointer to actually access the object if you do, unless the; object is managed outside of LLVM. Also as above, ptrtoint and inttoptr provide an alternative way to do this which; do not have this restriction. Can I do type-based alias analysis on LLVM IR?; ----------------------------------------------. You can't do type-based alias analysis using LLVM's built-in type system,; because LLVM has no restrictions on mixing types in addressing, loads or stores. LLVM's type-based alias analysis pass uses metadata to describe a different type; system (such as the C type system), and performs type-based aliasing on top of; that. Further details are in the; `language reference <LangRef.html#tbaa-metadata>`_. What happens if a GEP computation overflows?; --------------------------------------------. If the GEP lacks the ``inbounds`` keyword, the value is the result from; evaluating the implied two's complement integer computation. However, since; there's no guarantee of where an object will be",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:16633,access,access,16633,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['access']
Security,"the pointer beyond the; terminator is not allowed. This is a generalization of ``__null_terminated``; which is defined as ``__terminated_by(0)``. Annotation for interoperating with bounds-unsafe code; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. A pointer with the ``__unsafe_indexable`` annotation behaves the same as a plain; C pointer. That is, the pointer does not have any bounds information and pointer; operations are not checked. ``__unsafe_indexable`` can be used to mark pointers from system headers or; pointers from code that has not adopted -fbounds safety. This enables; interoperation between code using ``-fbounds-safety`` and code that does not. Default pointer types; ---------------------. ABI visibility and default annotations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Requiring ``-fbounds-safety`` adopters to add bounds annotations to all pointers; in the codebase would be a significant adoption burden. To avoid this and to; secure all pointers by default, ``-fbounds-safety`` applies default bounds; annotations to pointer types.; Default annotations apply to pointer types of declarations. ``-fbounds-safety`` applies default bounds annotations to pointer types used in; declarations. The default annotations are determined by the ABI visibility of; the pointer. A pointer type is ABI-visible if changing its size or; representation affects the ABI. For instance, changing the size of a type used; in a function parameter will affect the ABI and thus pointers used in function; parameters are ABI-visible pointers. On the other hand, changing the types of; local variables won't have such ABI implications. Hence, ``-fbounds-safety``; considers the outermost pointer types of local variables as non-ABI visible. The; rest of the pointers such as nested pointer types, pointer types of global; variables, struct fields, and function prototypes are considered ABI-visible. All ABI-visible pointers are treated as ``__single`` by default unless annotated; otherwise. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst:20225,secur,secure,20225,interpreter/llvm-project/clang/docs/BoundsSafety.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafety.rst,1,['secur'],['secure']
Security,"the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32_t offsets[Header.hashes_count]; // An offset that corresponds to each item in the ""hashes[]"" array above; };. ``buckets`` is an array of 32 bit indexes into the ``hashes`` array. The; ``hashes`` array contains all of the 32 bit hash values for all names in the; hash table. Each hash in the ``hashes`` table has an offset in the ``offsets``; array that points to the data for the hash value. This table setup makes it very eas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:70209,hash,hash,70209,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"the source field is present, consumers can use the embedded source; instead of attempting to discover the source on disk using the file path; provided by the* ``DW_LNCT_path`` *field. When the source field is absent,; consumers can access the file to get the source text.*. *This is particularly useful for programming languages that support runtime; compilation and runtime generation of source text. In these cases, the; source text does not reside in any permanent file. For example, the OpenCL; language [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`] supports online compilation.*. 2. ``DW_LNCT_LLVM_is_MD5``. ``DW_LNCT_LLVM_is_MD5`` indicates if the ``DW_LNCT_MD5`` content kind, if; present, is valid: when 0 it is not valid and when 1 it is valid. If; ``DW_LNCT_LLVM_is_MD5`` content kind is not present, and ``DW_LNCT_MD5``; content kind is present, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM_udata`` form. *This allows a compilation unit to have a mixture of files with and without; MD5 checksums. This can happen when multiple relocatable files are linked; together.*. .. _amdgpu-dwarf-call-frame-information:. A.6.4 Call Frame Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section provides changes to existing call frame information and defines; instructions added by these extensions. Additional support is added for; address spaces. Register unwind DWARF expressions are generalized to allow any; location description, including those with composite and implicit location; descriptions. These changes would be incorporated into the DWARF Version 5 section 6.4. .. _amdgpu-dwarf-structure_of-call-frame-information:. A.6.4.1 Structure of Call Frame Information; +++++++++++++++++++++++++++++++++++++++++++. The register rules are:. *undefined*; A register that has this rule has no recoverable value in the previous frame.; The previous value of this register is the undefined location description (see; :ref:`amdgpu-dwarf-undefined-lo",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:189799,checksum,checksums,189799,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,1,['checksum'],['checksums']
Security,"the top of the function. It's the only; ``MemoryDef`` that maps to no ``Instruction`` in LLVM IR. Use of; ``liveOnEntry`` implies that the memory being used is either undefined or; defined before the function begins. An example of all of this overlaid on LLVM IR (obtained by running ``opt; -passes='print<memoryssa>' -disable-output`` on an ``.ll`` file) is below. When; viewing this example, it may be helpful to view it in terms of clobbers.; The operands of a given ``MemoryAccess`` are all (potential) clobbers of said; ``MemoryAccess``, and the value produced by a ``MemoryAccess`` can act as a clobber; for other ``MemoryAccess``\ es. If a ``MemoryAccess`` is a *clobber* of another, it means that these two; ``MemoryAccess``\ es may access the same memory. For example, ``x = MemoryDef(y)``; means that ``x`` potentially modifies memory that ``y`` modifies/constrains; (or has modified / constrained).; In the same manner, ``a = MemoryPhi({BB1,b},{BB2,c})`` means that; anyone that uses ``a`` is accessing memory potentially modified / constrained; by either ``b`` or ``c`` (or both). And finally, ``MemoryUse(x)`` means; that this use accesses memory that ``x`` has modified / constrained; (as an example, think that if ``x = MemoryDef(...)``; and ``MemoryUse(x)`` are in the same loop, the use can't; be hoisted outside alone). Another useful way of looking at it is in terms of memory versions.; In that view, operands of a given ``MemoryAccess`` are the version; of the entire memory before the operation, and if the access produces; a value (i.e. ``MemoryDef/MemoryPhi``),; the value is the new version of the memory after the operation. .. code-block:: llvm. define void @foo() {; entry:; %p1 = alloca i8; %p2 = alloca i8; %p3 = alloca i8; ; 1 = MemoryDef(liveOnEntry); store i8 0, ptr %p3; br label %while.cond. while.cond:; ; 6 = MemoryPhi({entry,1},{if.end,4}); br i1 undef, label %if.then, label %if.else. if.then:; ; 2 = MemoryDef(6); store i8 0, ptr %p1; br label %if.end. if.else:",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst:4958,access,accessing,4958,interpreter/llvm-project/llvm/docs/MemorySSA.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MemorySSA.rst,1,['access'],['accessing']
Security,"the training input does not have good coverage; on all the hot functions.; ``inlinehint``; This attribute indicates that the source code contained a hint that; inlining this function is desirable (such as the ""inline"" keyword in; C/C++). It is just a hint; it imposes no requirements on the; inliner.; ``jumptable``; This attribute indicates that the function should be added to a; jump-instruction table at code-generation time, and that all address-taken; references to this function should be replaced with a reference to the; appropriate jump-instruction-table function pointer. Note that this creates; a new pointer for the original function, which means that code that depends; on function-pointer identity can break. So, any function annotated with; ``jumptable`` must also be ``unnamed_addr``.; ``memory(...)``; This attribute specifies the possible memory effects of the call-site or; function. It allows specifying the possible access kinds (``none``,; ``read``, ``write``, or ``readwrite``) for the possible memory location; kinds (``argmem``, ``inaccessiblemem``, as well as a default). It is best; understood by example:. - ``memory(none)``: Does not access any memory.; - ``memory(read)``: May read (but not write) any memory.; - ``memory(write)``: May write (but not read) any memory.; - ``memory(readwrite)``: May read or write any memory.; - ``memory(argmem: read)``: May only read argument memory.; - ``memory(argmem: read, inaccessiblemem: write)``: May only read argument; memory and only write inaccessible memory.; - ``memory(read, argmem: readwrite)``: May read any memory (default mode); and additionally write argument memory.; - ``memory(readwrite, argmem: none)``: May access any memory apart from; argument memory. The supported memory location kinds are:. - ``argmem``: This refers to accesses that are based on pointer arguments; to the function.; - ``inaccessiblemem``: This refers to accesses to memory which is not; accessible by the current module (before return from",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:84802,access,access,84802,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"the vector and scalar memory operations performed by wavefronts; executing with different L1 caches and the same L2 cache can be reordered; relative to each other.; * A ``s_waitcnt vmcnt(0)`` is required to ensure synchronization between; vector memory operations of different CUs. It ensures a previous vector; memory operation has completed before executing a subsequent vector memory; or LDS operation and so can be used to meet the requirements of acquire and; release.; * An L2 cache can be kept coherent with other L2 caches by using the MTYPE RW; (read-write) for memory local to the L2, and MTYPE NC (non-coherent) with; the PTE C-bit set for memory not local to the L2. * Any local memory cache lines will be automatically invalidated by writes; from CUs associated with other L2 caches, or writes from the CPU, due to; the cache probe caused by the PTE C-bit.; * XGMI accesses from the CPU to local memory may be cached on the CPU.; Subsequent access from the GPU will automatically invalidate or writeback; the CPU cache due to the L2 probe filter.; * To ensure coherence of local memory writes of CUs with different L1 caches; in the same agent a ``buffer_wbl2`` is required. It does nothing if the; agent is configured to have a single L2, or will writeback dirty L2 cache; lines if configured to have multiple L2 caches.; * To ensure coherence of local memory writes of CUs in different agents a; ``buffer_wbl2 sc1`` is required. It will writeback dirty L2 cache lines.; * To ensure coherence of local memory reads of CUs with different L1 caches; in the same agent a ``buffer_inv sc1`` is required. It does nothing if the; agent is configured to have a single L2, or will invalidate non-local L2; cache lines if configured to have multiple L2 caches.; * To ensure coherence of local memory reads of CUs in different agents a; ``buffer_inv sc0 sc1`` is required. It will invalidate non-local L2 cache; lines if configured to have multiple L2 caches. * PCIe access from the GPU to the CP",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:288666,access,access,288666,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"the; code. You can either reply to these, or address them and mark them as; ""done"". Note that in-line replies are **not** sent straight away! They; become ""draft"" comments and you must click ""Submit"" at the bottom of the; page. Updating your change; ~~~~~~~~~~~~~~~~~~~~. If you make changes in response to a reviewer's comments, simply update; your branch with more commits and push to your fork. It may be a good; idea to answer the comments from the reviewer explicitly. Accepting a revision; ~~~~~~~~~~~~~~~~~~~~. When the reviewer is happy with the change, they will **Accept** the; revision. They may leave some more minor comments that you should; address, but at this point the review is complete. It's time to get it; merged!. Commit by proxy; ---------------. As this is your first change, you won't have access to merge it; yourself yet. The reviewer **doesn't know this**, so you need to tell; them! Leave a message on the review like:. Thanks @somellvmdev. I don't have commit access, can you land this; patch for me?. The pull-request will be closed and you will be notified by GitHub. Review expectations; -------------------. In order to make LLVM a long-term sustainable effort, code needs to be; maintainable and well tested. Code reviews help to achieve that goal.; Especially for new contributors, that often means many rounds of reviews; and push-back on design decisions that do not fit well within the; overall architecture of the project. For your first patches, this means:. - be kind, and expect reviewers to be kind in return - LLVM has a `Code; of Conduct <https://llvm.org/docs/CodeOfConduct.html>`__;. - be patient - understanding how a new feature fits into the; architecture of the project is often a time consuming effort, and; people have to juggle this with other responsibilities in their; lives; **ping the review once a week** when there is no response;. - if you can't agree, generally the best way is to do what the reviewer; asks; we optimize for readability ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst:11441,access,access,11441,interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MyFirstTypoFix.rst,1,['access'],['access']
Security,"their base class. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void sink(NonVirtual *x) {; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. alpha.cplusplus.InvalidatedIterator; (C++); Check for use of invalidated iterators. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. alpha.cplusplus.IteratorRange; (C++); Check for iterators used outside their valid ranges. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. alpha.cplusplus.MismatchedIterator; (C++); Check for use of iterators of different containers where iterators of the same; container are expected. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. alpha.cplusplus.Move; (C++); Method calls on a moved-from object and copying a moved-from object will be; reported. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. Dead Code Alpha Checkers. Name, DescriptionExample. alpha.deadcode.UnreachableCode; (C, C++, ObjC); Check unreachable code. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. LLVM Checkers. Name, Descriptio",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html:5806,access,accessed,5806,interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/analyzer/alpha_checks.html,2,['access'],['accessed']
Security,"their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4035,access,access,4035,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,2,['access'],['access']
Security,"then uses; SEH (``__try / __except``) to resume execution with new information in the child; frame. In other words, the successive unwinding approach is incompatible with Visual; C++ exceptions and general purpose Windows exception handling. Because the C++; exception object lives in stack memory, LLVM cannot provide a custom personality; function that uses landingpads. Similarly, SEH does not provide any mechanism; to rethrow an exception or continue unwinding. Therefore, LLVM must use the IR; constructs described later in this document to implement compatible exception; handling. SEH filter expressions; -----------------------. The SEH personality functions also use funclets to implement filter expressions,; which allow executing arbitrary user code to decide which exceptions to catch.; Filter expressions should not be confused with the ``filter`` clause of the LLVM; ``landingpad`` instruction. Typically filter expressions are used to determine; if the exception came from a particular DLL or code region, or if code faulted; while accessing a particular memory address range. LLVM does not currently have; IR to represent filter expressions because it is difficult to represent their; control dependencies. Filter expressions run during the first phase of EH,; before cleanups run, making it very difficult to build a faithful control flow; graph. For now, the new EH instructions cannot represent SEH filter; expressions, and frontends must outline them ahead of time. Local variables of; the parent function can be escaped and accessed using the ``llvm.localescape``; and ``llvm.localrecover`` intrinsics. New exception handling instructions; ------------------------------------. The primary design goal of the new EH instructions is to support funclet; generation while preserving information about the CFG so that SSA formation; still works. As a secondary goal, they are designed to be generic across MSVC; and Itanium C++ exceptions. They make very few assumptions about the da",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst:24298,access,accessing,24298,interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ExceptionHandling.rst,1,['access'],['accessing']
Security,"they wonder why the ``i64; 0`` index is needed. However, a closer inspection of how globals and GEPs work; reveals the need. Becoming aware of the following facts will dispel the; confusion:. #. The type of ``%MyStruct`` is *not* ``{ ptr, i32 }`` but rather ``ptr``.; That is, ``%MyStruct`` is a pointer (to a structure), not a structure itself. #. Point #1 is evidenced by noticing the type of the second operand of the GEP; instruction (``%MyStruct``) which is ``ptr``. #. The first index, ``i64 0`` is required to step over the global variable; ``%MyStruct``. Since the second argument to the GEP instruction must always; be a value of pointer type, the first index steps through that pointer. A; value of 0 means 0 elements offset from that pointer. #. The second index, ``i32 1`` selects the second field of the structure (the; ``i32``). What is dereferenced by GEP?; ----------------------------. Quick answer: nothing. The GetElementPtr instruction dereferences nothing. That is, it doesn't access; memory in any way. That's what the Load and Store instructions are for. GEP is; only involved in the computation of addresses. For example, consider this:. .. code-block:: text. @MyVar = external global { i32, ptr }; ...; %idx = getelementptr { i32, ptr }, ptr @MyVar, i64 0, i32 1; %arr = load ptr, ptr %idx; %idx = getelementptr [40 x i32], ptr %arr, i64 0, i64 17. In this example, we have a global variable, ``@MyVar``, which is a pointer to; a structure containing a pointer. Let's assume that this inner pointer points; to an array of type ``[40 x i32]``. The above IR will first compute the address; of the inner pointer, then load the pointer, and then compute the address of; the 18th array element. This cannot be expressed in a single GEP instruction, because it requires; a memory dereference in between. However, the following example would work; fine:. .. code-block:: text. @MyVar = external global { i32, [40 x i32 ] }; ...; %idx = getelementptr { i32, [40 x i32] }, ptr @MyVar, ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst:6405,access,access,6405,interpreter/llvm-project/llvm/docs/GetElementPtr.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/GetElementPtr.rst,1,['access'],['access']
Security,"thm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations.",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22764,expose,exposed,22764,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['expose'],['exposed']
Security,"those on ``std::string``\ s. We can achieve this change simply by refining our; matcher. The rest of the rule remains unchanged:. .. code-block:: c++. llvm::StringRef s = ""str"";; makeRule(; cxxMemberCallExpr(; on(expr(hasType(namedDecl(hasName(""std::string"")))); 	 .bind(s)),; callee(cxxMethodDecl(hasName(""size"")))),; changeTo(cat(""Size("", node(s), "")"")),; cat(""Method ``size`` is deprecated in favor of free function ``Size``""));. Example: rewriting method calls; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In this example, we delete an ""intermediary"" method call in a string of; invocations. This scenario can arise, for example, if you want to collapse a; substructure into its parent. .. code-block:: c++. llvm::StringRef e = ""expr"", m = ""member"";; auto child_call = cxxMemberCallExpr(on(expr().bind(e)),; 				 callee(cxxMethodDecl(hasName(""child""))));; makeRule(cxxMemberCallExpr(on(child_call), callee(memberExpr().bind(m)),; 	 changeTo(cat(e, ""."", member(m), ""()""))),; 	 cat(""``child`` accessor is being removed; call "",; 		member(m), "" directly on parent""));. This rule isn't quite what we want: it will rewrite ``my_object.child().foo()`` to; ``my_object.foo()``, but it will also rewrite ``my_ptr->child().foo()`` to; ``my_ptr.foo()``, which is not what we intend. We could fix this by restricting; the pattern with ``not(isArrow())`` in the definition of ``child_call``. Yet, we; *want* to rewrite calls through pointers. To capture this idiom, we provide the ``access`` combinator to intelligently; construct a field/method access. In our example, the member access is expressed; as:. .. code-block:: c++. access(e, cat(member(m))). The first argument specifies the object being accessed and the second, a; description of the field/method name. In this case, we specify that the method; name should be copied from the source -- specifically, the source range of ``m``'s; member. To construct the method call, we would use this expression in ``cat``:. .. code-block:: c++. cat(access(e, cat(member(m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst:7851,access,accessor,7851,interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ClangTransformerTutorial.rst,1,['access'],['accessor']
Security,"threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only share",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:6981,access,access,6981,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,2,['access'],['access']
Security,"thus identifies a consistent version of; all LLVM sub-projects. Git does not use sequential integer revision number but instead uses a hash to; identify each commit. The loss of a sequential integer revision number has been a sticking point in; past discussions about Git:. - ""The 'branch' I most care about is mainline, and losing the ability to say; 'fixed in r1234' (with some sort of monotonically increasing number) would; be a tragic loss."" [LattnerRevNum]_; - ""I like those results sorted by time and the chronology should be obvious, but; timestamps are incredibly cumbersome and make it difficult to verify that a; given checkout matches a given set of results."" [TrickRevNum]_; - ""There is still the major regression with unreadable version numbers.; Given the amount of Bugzilla traffic with 'Fixed in...', that's a; non-trivial issue."" [JSonnRevNum]_; - ""Sequential IDs are important for LNT and llvmlab bisection tool."" [MatthewsRevNum]_. However, Git can emulate this increasing revision number:; ``git rev-list --count <commit-hash>``. This identifier is unique only; within a single branch, but this means the tuple `(num, branch-name)` uniquely; identifies a commit. We can thus use this revision number to ensure that e.g. `clang -v` reports a; user-friendly revision number (e.g. `main-12345` or `4.0-5321`), addressing; the objections raised above with respect to this aspect of Git. What About Branches and Merges?; -------------------------------. In contrast to SVN, Git makes branching easy. Git's commit history is; represented as a DAG, a departure from SVN's linear history. However, we propose; to mandate making merge commits illegal in our canonical Git repository. Unfortunately, GitHub does not support server side hooks to enforce such a; policy. We must rely on the community to avoid pushing merge commits. GitHub offers a feature called `Status Checks`: a branch protected by; `status checks` requires commits to be explicitly allowed before the push can happen.; W",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:5146,hash,hash,5146,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['hash'],['hash']
Security,"till have all of the same data, we just organize it more efficiently for; debugger lookup. If we repeat the same ""``printf``"" lookup from above, we; would hash ""``printf``"" and find it matches ``BUCKETS[3]`` by taking the 32 bit; hash value and modulo it by ``n_buckets``. ``BUCKETS[3]`` contains ""6"" which; is the index into the ``HASHES`` table. We would then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t heade",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:68027,hash,hash,68027,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"ting in the room next door; since 1995. **Andrei** and **Mihaela Gheata** (Alice collaboration) are co-authors; of the ROOT geometry classes and Virtual Monte-Carlo. They have been; working with the ROOT team since 2000. **Olivier Couet**, who after a successful development and maintenance; of PAW, has joined the ROOT team in 2000 and has been working on the; graphics sub-system. **Ilka Antcheva** has been working on the Graphical User Interface; classes. She is also responsible for this latest edition of the Users; Guide with a better style, improved index and several new chapters; (since 2002). **Bertrand Bellenot** has been developing and maintaining the Win32GDK; version of ROOT. Bertrand has also many other contributions like the; nice RootShower example (since 2001). **Valeriy Onoutchin** has been working on several ROOT packages, in; particular the graphics sub-system for Windows and the GUI Builder; (since 2000). **Gerri Ganis** has been working on the authentication procedures to; be used by the root daemons and the PROOF system (since 2002). **Maarten Ballintijn** (MIT) is one of the main developers of the; PROOF sub-system (since 1995). **Valeri Fine** (now at BNL) ported ROOT to Windows and contributed; largely to the 3-D graphics. He is currently working on the Qt layer; of ROOT (since 1995). **Victor Perevoztchikov** (BNL) worked on key elements of the I/O; system, in particular the improved support for STL collections; (1997-2001). **Nenad Buncic** developed the HTML documentation generation system; and integrated the X3D viewer inside ROOT (1995-1997). **Suzanne Panacek** was the author of the first version of this User's; Guide and very active in preparing tutorials and giving lectures about; ROOT (1999-2002). **Axel Naumann** has been developing further the HTML Reference Guide; and helps in porting ROOT under Windows (cygwin/gcc implementation); (since 2000). **Anna Kreshuk** has developed the Linear Fitter and Robust Fitter; classes as well as man",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md:2993,authenticat,authentication,2993,documentation/users-guide/Preface.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Preface.md,1,['authenticat'],['authentication']
Security,"tings. The radio button ""All"" allows viewing all volumes down; to the selected depth. ""Leaves"" will draw only the deepest nodes; that have the selected depth or lower level ones that have no; daughters inside. ""Only"" will allow drawing only the edited; volume. The check button ""Raytrace"" will just draw the current; selection in solid mode using the ray-tracing algorithm provided by; TGeo. \image html geometry024.jpg width=600px; \image html geometry025.jpg ""Volume visualisation settings and division interface for volumes"" width=600px. - *Division*. Allows dividing the edited volume according a given; pattern. The division axes that are allowed are presented in a; radio-button group. The number entries labeled ""From"", ""Step""; and ""Nslices"" correspond to the divisioning parameters on the; selected axis. The range of the division is between `start` and; `start+ndiv*step` values and its validity is checked upon changing; one of the values. NOTE: When changing a value in a number entry by typing a number, press; ENTER at the end to validate. This applies for taking into account and; validation of any number change in the geometry editors. \anchor GP08f; ### How to Create a Valid Geometry with Geometry Editors. 1. Create a new geometry manager and start the editor as described at; the beginning. 2. Create at least one material from the ""Materials"" shutter item; category. Generally, for creating objects, the interface is always in; the TGeoManagerEditor in different categories - one should just; provide a name and requested parameters. 3. Create a shape that will be used for the top volume within the; ""Shapes"" category. For the moment, the shapes that have editors are; Box, Para, Trd1, Trd2, Tube, Tube segment, Cone, Cone segment, Hype,; Pcon, Torus and Sphere. 4. Create a medium from one of the existing materials from the; ""Medium"" category. You will notice that some categories as ""Volume""; and ""Medium"" are inactive at the beginning because at that time there; is no materi",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:133960,validat,validate,133960,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['validat'],['validate']
Security,"tion going through jitted code has been repaired.; - Interpreted code is now optimized; `.O 0/1/2/3` can be used to change the optimization level, as well as `#pragma cling optimize`.; - The prompt colors are now much more visible, both on terminals with light and dark background.; - Significant speedup of `TMethodCall`.; - One can now run `.x 12file-with@funny=name.C`; it will expect a function called `_12file_with_funny_name()`. ## Core Libraries. - See ""Build, Configuration and Testing Infrastructure"" below for changes in the directory structure.; - libCling now exports only a minimal set of symbols.; - Add support for std::array_view also for C++11 builds. The implementation has been modified to work before C++14.; - Added TCollection::Notify to allow notifying more than one object.; ```{.cpp}; TList formulas;; // Add several TTreeFormula to the list;; chain.SetNotify(&formulas);; ```; - For classes that need the `ClassDef` support, `ClassDefInline(ClassName, Version)` now provides it without the need for a dictionary source: all members injected by this `ClassDef` flavor are generated by the interpreter. ### `TObjString` to `TString`. `TObjString::GetString()` now returns a `const TString&` to the `TString` inside the `TObjString`, instead of copying it.; This is to prevent very common misunderstanding of the interface. In several cases, the misunderstanding of the interface caused invalid memory accesses to the already destructed; temporary `TString` returned by `GetString()`, e.g. `objStr->GetString().Data()`. This will be fixed automatically by the; new return type. In rare cases, the caller expected `GetString()` to return a (non-const) reference to the embedded `TString`, e.g.; `objString->GetString().ReplaceAll(""a"", ""b""); // WRONG!` This will now fail to compile, instead of not doing what the author of the; code expected. Please fix that code by using the `TObjString::String()` interface, which returns a non-const `TString&`:; `objString->String().ReplaceA",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md:2890,inject,injected,2890,README/ReleaseNotes/v610/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v610/index.md,1,['inject'],['injected']
Security,"tion matrix). ### Associated Function. One or more objects (typically a **`TF1\*`**) can be added to the list; of functions (`fFunctions`) associated to each histogram. A call to; `TH1::Fit` adds the fitted function to this list. Given a histogram; `h`, one can retrieve the associated function with:. ``` {.cpp}; TF1 *myfunc = h->GetFunction(""myfunc"");; ```. ### Access to the Fit Parameters and Results. If the histogram (or graph) is made persistent, the list of associated; functions is also persistent. Retrieve a pointer to the function with; the `TH1::GetFunction()` method. Then you can retrieve the fit; parameters from the function (**`TF1`**) with calls such as:. ``` {.cpp}; root[] TF1 *fit = hist->GetFunction(function_name);; root[] Double_t chi2 = fit->GetChisquare();; // value of the first parameter; root[] Double_t p1 = fit->GetParameter(0);; // error of the first parameter; root[] Double_t e1 = fit->GetParError(0);; ```. Using the fit option `S` one can access the full result of the fit including the covariance and correlation matrix.; See later the paragraph `TFitResult`. ### Associated Errors. By default, for each bin, the sum of weights is computed at fill time.; One can also call `TH1::Sumw2` to force the storage and computation of; the sum of the square of weights per bin. If Sumw2 has been called,; the error per bin is computed as the `sqrt(sum of squares of; weights)`; otherwise, the error is set equal to the; `sqrt(bin content)`. To return the error for a given bin number, do:. ``` {.cpp}; Double_t error = h->GetBinError(bin);; ```. Empty bins are excluded in the fit when using the Chi-square fit method.; When fitting an histogram representing counts (i.e with Poisson statistics) it is recommended to; use the Log-Likelihood method (option ‘`L`' or ""`WL`""), particularly in case of low statistics.; When the histogram has been filled with weights different than one, a weighted likelihood method can be used; and the errors retrieved from the fit are corr",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md:18293,access,access,18293,documentation/users-guide/FittingHistograms.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/FittingHistograms.md,1,['access'],['access']
Security,"tion tokens and https protocol,; this makes usage of webgui components in public networks more secure. ### Enabled WLCG Bearer Tokens support in RDavix. Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according WLCG Bearer Token Discovery specification document (https://github.com/WLCG-AuthZ-WG/bearer-token-discovery/blob/master/specification.md). Short overview:. 1. If the `BEARER_TOKEN` environment variable is set, then the value is taken to be the token contents.; 2. If the `BEARER_TOKEN_FILE` environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; 3. If the `XDG_RUNTIME_DIR` environment variable is set, then take the token from the contents of `$XDG_RUNTIME_DIR/bt_u$ID`(this additional location is intended to provide improved security for shared login environments as `$XDG_RUNTIME_DIR` is defined to be user-specific as opposed to a system-wide directory.).; 4. Otherwise, take the token from `/tmp/bt_u$ID`. ## GUI Libraries. ### RBrowser improvements. - central factory methods to handle browsing, editing and drawing of different classes; - simple possibility to extend RBrowser on user-defined classes; - support of web-based geometry viewer; - better support of TTree drawing; - server-side handling of code editor and image viewer widgets; - rbrowser content is fully recovered when web-browser is reloaded; - load of widgets code only when really required (shorter startup time for RBrowser). ## Montecarlo Libraries. ## PROOF Libraries. ## Language Bindings. ## JavaScript ROOT. ### Major JSROOT update to version 6. - update all used libraries `d3.js`, `three.js`, `MathJax.js`, openui5; - change to Promise based interface for all async methods, remove call-back arguments; - change scripts",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md:26591,secur,security,26591,README/ReleaseNotes/v624/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v624/index.md,1,['secur'],['security']
Security,"tion unit; declaration <https://clang.llvm.org/doxygen/classclang_1_1TranslationUnitDecl.html>`_.; In this example, our first user written declaration is the `function; declaration <https://clang.llvm.org/doxygen/classclang_1_1FunctionDecl.html>`_; of ""``f``"". The body of ""``f``"" is a `compound; statement <https://clang.llvm.org/doxygen/classclang_1_1CompoundStmt.html>`_,; whose child nodes are a `declaration; statement <https://clang.llvm.org/doxygen/classclang_1_1DeclStmt.html>`_; that declares our result variable, and the `return; statement <https://clang.llvm.org/doxygen/classclang_1_1ReturnStmt.html>`_. AST Context; ===========. All information about the AST for a translation unit is bundled up in; the class; `ASTContext <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html>`_.; It allows traversal of the whole translation unit starting from; `getTranslationUnitDecl <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#abd909fb01ef10cfd0244832a67b1dd64>`_,; or to access Clang's `table of; identifiers <https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html#a4f95adb9958e22fbe55212ae6482feb4>`_; for the parsed translation unit. AST Nodes; =========. Clang's AST nodes are modeled on a class hierarchy that does not have a; common ancestor. Instead, there are multiple larger hierarchies for; basic node types like; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_ and; `Stmt <https://clang.llvm.org/doxygen/classclang_1_1Stmt.html>`_. Many; important AST nodes derive from; `Type <https://clang.llvm.org/doxygen/classclang_1_1Type.html>`_,; `Decl <https://clang.llvm.org/doxygen/classclang_1_1Decl.html>`_,; `DeclContext <https://clang.llvm.org/doxygen/classclang_1_1DeclContext.html>`_; or `Stmt <https://clang.llvm.org/doxygen/classclang_1_1Stmt.html>`_, with; some classes deriving from both Decl and DeclContext. There are also a multitude of nodes in the AST that are not part of a; larger hierarchy, and are only reachable from specific ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst:3665,access,access,3665,interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/IntroductionToTheClangAST.rst,1,['access'],['access']
Security,"tions at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX90A are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table`. .. table:: AMDHSA Memory Model Code Sequences GFX90A; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx90a-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX90A; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; ------------------------------------------------------------------------------------; load *none* *none* ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:241534,access,accessed,241534,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"tions at the same time. If scalar writes are used; then a ``s_dcache_wb`` is inserted before the ``s_endpgm`` and before a function; return since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU over XGMI or PCIe the kernarg backing memory is allocated in host; memory accessed as MTYPE UC (uncached) to avoid needing to invalidate the L2; cache. This also causes it to be treated as non-volatile and so is not; invalidated by ``*_vol``.; * On APU the kernarg backing memory is accessed as MTYPE CC (cache coherent) and; so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX940, GFX941, GFX942; are defined in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table`. .. table:: AMDHSA Memory Model Code Sequences GFX940, GFX941, GFX942; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx940-gfx941-gfx942-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX940, GFX941, GFX942; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; -----------------------------",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:291552,access,accessed,291552,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"tions within the same address space. ``wavefront-one-as`` Same as ``wavefront`` but only synchronizes with; other operations within the same address space. ``singlethread-one-as`` Same as ``singlethread`` but only synchronizes with; other operations within the same address space.; ======================= ===================================================. LLVM IR Intrinsics; ------------------. The AMDGPU backend implements the following LLVM IR intrinsics. *This section is WIP.*. .. table:: AMDGPU LLVM IR Intrinsics; :name: amdgpu-llvm-ir-intrinsics-table. ============================================== ==========================================================; LLVM Intrinsic Description; ============================================== ==========================================================; llvm.amdgcn.sqrt Provides direct access to v_sqrt_f64, v_sqrt_f32 and v_sqrt_f16; (on targets with half support). Performs sqrt function. llvm.amdgcn.log Provides direct access to v_log_f32 and v_log_f16; (on targets with half support). Performs log2 function. llvm.amdgcn.exp2 Provides direct access to v_exp_f32 and v_exp_f16; (on targets with half support). Performs exp2 function. :ref:`llvm.frexp <int_frexp>` Implemented for half, float and double. :ref:`llvm.log2 <int_log2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. Float; instruction does not natively support denormal; inputs. :ref:`llvm.sqrt <int_sqrt>` Implemented for double, float and half (and vectors). :ref:`llvm.log <int_log>` Implemented for float and half (and vectors). :ref:`llvm.exp <int_exp>` Implemented for float and half (and vectors). :ref:`llvm.log10 <int_log10>` Implemented for float and half (and vectors). :ref:`llvm.exp2 <int_exp2>` Implemented for float and half (and vectors of float or; half). Not implemented for double. Hardware provides; 1ULP accuracy for float, and 0.51ULP for half. F",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:35974,access,access,35974,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"tive at any given time. This; feature is designed to support incremental and atomic updates of the underlying; MSF file. While writing to an MSF file, if the active FPM is FPM1, you can; write your new modified bitfield to FPM2, and vice versa. Only when you commit; the file to disk do you need to swap the value in the SuperBlock to point to; the new ``FreeBlockMapBlock``. The Free Block Maps are stored as a series of single blocks throughout the file; at intervals of BlockSize. Because each FPM block is of size ``BlockSize``; bytes, it contains 8 times as many bits as an interval has blocks. This means; that the first block of each FPM refers to the first 8 intervals of the file; (the first 32768 blocks), the second block of each FPM refers to the next 8; blocks, and so on. This results in far more FPM blocks being present than are; required, but in order to maintain backwards compatibility the format must stay; this way. The Stream Directory; ====================; The Stream Directory is the root of all access to the other streams in an MSF; file. Beginning at byte 0 of the stream directory is the following structure:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams;; ulittle32_t StreamSizes[NumStreams];; ulittle32_t StreamBlocks[NumStreams][];; };. And this structure occupies exactly ``SuperBlock->NumDirectoryBytes`` bytes.; Note that each of the last two arrays is of variable length, and in particular; that the second array is jagged. **Example:** Suppose a hypothetical PDB file with a 4KiB block size, and 4; streams of lengths {1000 bytes, 8000 bytes, 16000 bytes, 9000 bytes}. Stream 0: ceil(1000 / 4096) = 1 block. Stream 1: ceil(8000 / 4096) = 2 blocks. Stream 2: ceil(16000 / 4096) = 4 blocks. Stream 3: ceil(9000 / 4096) = 3 blocks. In total, 10 blocks are used. Let's see what the stream directory might look; like:. .. code-block:: c++. struct StreamDirectory {; ulittle32_t NumStreams = 4;; ulittle32_t StreamSizes[] = {1000, 8000, 16000, 9",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst:5333,access,access,5333,interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/MsfFile.rst,1,['access'],['access']
Security,"to ""Needs Review"" and notify a knowledgeable reviewer.; Usually you will want to notify the person who approved the patch in Phabricator,; but you may use your best judgement on who a good reviewer would be. Once; you have identified the reviewer(s), assign the issue to them and mention; them (i.e @username) in a comment and ask them if the patch is safe to backport.; You should also review the bug yourself to ensure that it meets the requirements; for committing to the release branch. #. Once a bug has been reviewed, add the release:reviewed label and update the; issue's status to ""Needs Merge"". Check the pull request associated with the; issue. If all the tests pass, then the pull request can be merged. If not,; then add a comment on the issue asking someone to take a look at the failures. #. Once the pull request has been merged push it to the official release branch; with the script ``llvm/utils/git/sync-release-repo.sh``. Then add a comment to the issue stating that the fix has been merged along with; the git hashes from the release branch. Add the release:merged label to the issue; and close it. Release Patch Rules; -------------------. Below are the rules regarding patching the release branch:. #. Patches applied to the release branch may only be applied by the release; manager, the official release testers or the code owners with approval from; the release manager. #. Release managers are encouraged, but not required, to get approval from code; owners before approving patches. If there is no code owner or the code owner; is unreachable then release managers can ask approval from patch reviewers or; other developers active in that area. #. *Before RC1* Patches should be limited to bug fixes, important optimization; improvements, or completion of features that were started before the branch; was created. As with all phases, release managers and code owners can reject; patches that are deemed too invasive. #. *Before RC2* Patches should be limited to bug fixes o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst:12355,hash,hashes,12355,interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToReleaseLLVM.rst,1,['hash'],['hashes']
Security,"to argv,; thereby working around the command-line length limits. Top-Level Classes and Functions; -------------------------------. Despite all of the built-in flexibility, the CommandLine option library really; only consists of one function `cl::ParseCommandLineOptions`_ and three main; classes: `cl::opt`_, `cl::list`_, and `cl::alias`_. This section describes; these three classes in detail. .. _cl::getRegisteredOptions:. The ``cl::getRegisteredOptions`` function; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``cl::getRegisteredOptions`` function is designed to give a programmer; access to declared non-positional command line options so that how they appear; in ``-help`` can be modified prior to calling `cl::ParseCommandLineOptions`_.; Note this method should not be called during any static initialisation because; it cannot be guaranteed that all options will have been initialised. Hence it; should be called from ``main``. This function can be used to gain access to options declared in libraries that; the tool writer may not have direct access to. The function retrieves a :ref:`StringMap <dss_stringmap>` that maps the option; string (e.g. ``-help``) to an ``Option*``. Here is an example of how the function could be used:. .. code-block:: c++. using namespace llvm;; int main(int argc, char **argv) {; cl::OptionCategory AnotherCategory(""Some options"");. StringMap<cl::Option*> &Map = cl::getRegisteredOptions();. //Unhide useful option and put it in a different category; assert(Map.count(""print-all-options"") > 0);; Map[""print-all-options""]->setHiddenFlag(cl::NotHidden);; Map[""print-all-options""]->setCategory(AnotherCategory);. //Hide an option we don't want to see; assert(Map.count(""enable-no-infs-fp-math"") > 0);; Map[""enable-no-infs-fp-math""]->setHiddenFlag(cl::Hidden);. //Change --version to --show-version; assert(Map.count(""version"") > 0);; Map[""version""]->setArgStr(""show-version"");. //Change --help description; assert(Map.count(""help"") > 0);; Map[""help""]->setDescrip",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:51753,access,access,51753,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,2,['access'],['access']
Security,"to do so:. #. Check the existing build configurations to make sure the one you are; interested in is not covered yet or gets built on your computer much; faster than on the existing one. We prefer faster builds so developers; will get feedback sooner after changes get committed. #. The computer you will be registering with the LLVM buildbot; infrastructure should have all dependencies installed and be able to; build your configuration successfully. Please check what degree; of parallelism (-j param) would give the fastest build. You can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. Create a buildbot-worker in context of that buildbot-worker account. Point it; to the **lab.llvm.org** port **9994** (see `Buildbot documentation,; Creating a worker; <http://docs.buildbot.net/current/tutorial/firstrun.html#creating-a-worker>`_; for more details) by running the following command:. .. code-block:: bash. $ buildbot-worker create-worker <buildbot-worker-root-directory> \; lab.llvm.org:9994 \; <buildbot-worker-access-name> \; <buildbot-worker-access-password>. Only once a new worker is stable, and; approval from Galina has been received (see last step) should it; be pointed at the main buildmaster. Now start the worker:. .. code-block:: bash. $ buildbot-worker start <buildbot-worker-root-directory>. This will cause your new worker to connect to the staging buildmaster; which is silent by default. Try this once then check the log file; ``<buildbot-worker-root-directory>/worke",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:3432,access,access,3432,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,3,"['access', 'authenticat', 'password']","['access', 'authenticate', 'password']"
Security,"to enable calling external functions.; If the library or its headers are installed in a custom; location, you can also set the variables FFI_INCLUDE_DIR and; FFI_LIBRARY_DIR to the directories where ffi.h and libffi.so can be found,; respectively. Defaults to OFF. **LLVM_ENABLE_IDE**:BOOL; Tell the build system that an IDE is being used. This in turn disables the; creation of certain convenience build system targets, such as the various; ``install-*`` and ``check-*`` targets, since IDEs don't always deal well with; a large number of targets. This is usually autodetected, but it can be; configured manually to explicitly control the generation of those targets. **LLVM_ENABLE_LIBCXX**:BOOL; If the host compiler and linker supports the stdlib flag, -stdlib=libc++ is; passed to invocations of both so that the project is built using libc++; instead of stdlibc++. Defaults to OFF. **LLVM_ENABLE_LLVM_LIBC**: BOOL; If the LLVM libc overlay is installed in a location where the host linker; can access it, all built executables will be linked against the LLVM libc; overlay before linking against the system libc. Defaults to OFF. **LLVM_ENABLE_LIBPFM**:BOOL; Enable building with libpfm to support hardware counter measurements in LLVM; tools.; Defaults to ON. **LLVM_ENABLE_LLD**:BOOL; This option is equivalent to `-DLLVM_USE_LINKER=lld`, except during a 2-stage; build where a dependency is added from the first stage to the second ensuring; that lld is built before stage2 begins. **LLVM_ENABLE_LTO**:STRING; Add ``-flto`` or ``-flto=`` flags to the compile and link command; lines, enabling link-time optimization. Possible values are ``Off``,; ``On``, ``Thin`` and ``Full``. Defaults to OFF. **LLVM_ENABLE_MODULES**:BOOL; Compile with `Clang Header Modules; <https://clang.llvm.org/docs/Modules.html>`_. **LLVM_ENABLE_PEDANTIC**:BOOL; Enable pedantic mode. This disables compiler-specific extensions, if; possible. Defaults to ON. **LLVM_ENABLE_PIC**:BOOL; Add the ``-fPIC`` flag to the comp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst:22822,access,access,22822,interpreter/llvm-project/llvm/docs/CMake.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CMake.rst,1,['access'],['access']
Security,"to get the animation effect. The option provided to all track-drawing methods can trigger different; track selections:. `default: `A track (or all primary tracks) drawn without daughters. `/D:` Track and first level descendents only are drawn. `/*: ` Track and all descendents are drawn. `/Ntype:` All tracks having `name=type` are drawn. Generally several options can be concatenated in the same string (E.g.; `""/D /Npion-""`). For animating tracks, additional options can be added:. `/G:`Geometry animate. Generally when drawing or animating tracks, one; has to first perform a normal drawing of the geometry as convenient. The; tracks will be drawn over the geometry. The geometry itself will be; animated (camera moving and rotating in order to ""catch"" the majority of; current track segments.). `/S:`Save all frames in gif format in the current folder. This option; allows creating a movie based on individual frames. ## Checking the Geometry. Several checking methods are accessible from the context menu of volume; objects or of the manager class. They generally apply only to the; visible parts of the drawn geometry in order to ease geometry checking,; and their implementation is in the **`TGeoChecker`** class. The checking; package contains an overlap checker and several utility methods that; generally have visualization outputs. ### The Overlap Checker. An overlap is any region in the Euclidian space being contained by more; than one positioned volume. Due to the containment scheme used by the; modeller, all points inside a volume have to be also contained by the; mother therefore are overlapping in that sense. This category of; overlaps is ignored due to the fact that any such point is treated as; belonging to the deepest node in the hierarchy. ![Extruding volumes](pictures/030001DE.png). A volume containment region is in fact the result of the subtraction of; all daughters. On the other hand, there are two other categories of; overlaps that are considered illegal since th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md:129378,access,accessible,129378,documentation/users-guide/Geometry.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/Geometry.md,1,['access'],['accessible']
Security,"to the '``llvm.instrprof.increment``' intrinsic, but it stores zero to; the profiling variable to signify that the function has been covered. We store; zero because this is more efficient on some targets. '``llvm.instrprof.value.profile``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """""""""""""". ::. declare void @llvm.instrprof.value.profile(ptr <name>, i64 <hash>,; i64 <value>, i32 <value_kind>,; i32 <index>). Overview:; """""""""""""""""". The '``llvm.instrprof.value.profile``' intrinsic can be emitted by a; frontend for use with instrumentation based profiling. This will be; lowered by the ``-instrprof`` pass to find out the target values,; instrumented expressions take in a program at runtime. Arguments:; """""""""""""""""""". The first argument is a pointer to a global variable containing the; name of the entity being instrumented. ``name`` should generally be the; (mangled) function name for a set of counters. The second argument is a hash value that can be used by the consumer; of the profile data to detect changes to the instrumented source. It; is an error if ``hash`` differs between two instances of; ``llvm.instrprof.*`` that refer to the same name. The third argument is the value of the expression being profiled. The profiled; expression's value should be representable as an unsigned 64-bit value. The; fourth argument represents the kind of value profiling that is being done. The; supported value profiling kinds are enumerated through the; ``InstrProfValueKind`` type declared in the; ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the; index of the instrumented expression within ``name``. It should be >= 0. Semantics:; """""""""""""""""""". This intrinsic represents the point where a call to a runtime routine; should be inserted for value profiling of target expressions. ``-instrprof``; pass will generate the appropriate data structures and replace the; ``llvm.instrprof.value.profile`` intrinsic with the call to the profile; runtime ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:531004,hash,hash,531004,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['hash'],['hash']
Security,"togram, -I. Display a bucket list histogram for dynamic symbol hash tables. .. option:: --elf-linker-options. Display the linker options section. .. option:: --elf-output-style=<value>. Format ELF information in the specified style. Valid options are ``LLVM``,; ``GNU``, and ``JSON``. ``LLVM`` output is an expanded and structured format.; ``GNU`` (the default) output mimics the equivalent GNU :program:`readelf`; output. ``JSON`` is JSON formatted output intended for machine consumption. .. option:: --extra-sym-info. Display extra information (section name) when showing symbols. .. option:: --section-groups, -g. Display section groups. .. option:: --expand-relocs. When used with :option:`--relocations`, display each relocation in an expanded; multi-line format. .. option:: --file-header, -h. Display file headers. .. option:: --gnu-hash-table. Display the GNU hash table for dynamic symbols. .. option:: --hash-symbols. Display the expanded hash table with dynamic symbol data. .. option:: --hash-table. Display the hash table for dynamic symbols. .. option:: --headers, -e. Equivalent to setting: :option:`--file-header`, :option:`--program-headers`,; and :option:`--sections`. .. option:: --help. Display a summary of command line options. .. option:: --hex-dump=<section[,section,...]>, -x. Display the specified section(s) as hexadecimal bytes. ``section`` may be a; section index or section name. .. option:: --memtag. Display information about memory tagging present in the binary. This includes; various memtag-specific dynamic entries, decoded global descriptor sections,; and decoded Android-specific ELF notes. .. option:: --needed-libs. Display the needed libraries. .. option:: --no-demangle. Do not display demangled symbol names in the output. On by default. .. option:: --notes, -n. Display all notes. .. option:: --pretty-print. When used with :option:`--elf-output-style`, JSON output will be formatted in; a more readable format. .. option:: --program-headers, --segments, -",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst:2563,hash,hash-table,2563,interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandGuide/llvm-readelf.rst,1,['hash'],['hash-table']
Security,"token to open the actual RNTuple dataset with, e.g., RDF or an RNTupleReader,; and it provides the `Merge(...)` interface for the `TFileMerger`. ### RPageSource / Sink; The page source and sink can read and write pages and clusters from and to a storage backend.; There are concrete class implementations for an RNTuple stored in a ROOT file (local or remote), and for an RNTuple stored in a DAOS object store.; There is a virtual page sink for buffered writes, which also groups pages of the same column before flushing them to disk.; There is a virtual page source for aligned friend datasets (horizontal data combination). Page sources and sinks do not operate entry-based but based on pages/indices of columns.; For instance, there is no API in the page sink to write an entry, but only to write pages of columns.; The higher-level APIs, e.g. `RField`, `REntry`, `RNTupleWriter`, take care of presenting the available data as entries where necessary. The page source also gives access to an `RNTupleDescriptor` through a read/write lock guard.; The `RNTupleDescriptor` owned by the page source changes only when new cluster meta-data are loaded.; The header and the cluster group summary information is stable throughout its lifetime (cf. format specification). ### R{NTuple,Field,Column,Cluster,...}Descriptor; The descriptor classes provide read-only access to the on-disk meta-data of an RNTuple.; The meta-data include the schema (fields and columns), information about clusters and the page locations.; The descriptor classes are closely related to the format specification. For normal read and write tasks, access to the descriptor is not necessary.; One notable exception is bulk reading, where the descriptor can be used to determine entry boundaries of clusters.; The descriptors are used internally, e.g. to build an RNTupleModel from the on-disk information.; The descriptors are also useful for inspection purposes. The descriptor classes contain a copy of the meta-data; they are not ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md:6549,access,access,6549,tree/ntuple/v7/doc/Architecture.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/doc/Architecture.md,1,['access'],['access']
Security,tools-extra/unittests/clang-doc/HTMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MDGeneratorTest.cpp; clang-tools-extra/unittests/clang-doc/MergeTest.cpp; clang-tools-extra/unittests/clang-doc/SerializeTest.cpp; clang-tools-extra/unittests/clang-doc/YAMLGeneratorTest.cpp; clang-tools-extra/unittests/clang-tidy/AddConstTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyDiagnosticConsumerTest.cpp; clang-tools-extra/unittests/clang-tidy/ClangTidyTest.h; clang-tools-extra/unittests/clang-tidy/DeclRefExprUtilsTest.cpp; clang-tools-extra/unittests/clang-tidy/GlobListTest.cpp; clang-tools-extra/unittests/clang-tidy/OptionsProviderTest.cpp; clang-tools-extra/unittests/clang-tidy/OverlappingReplacementsTest.cpp; clang-tools-extra/unittests/clang-tidy/ReadabilityModuleTest.cpp; clang-tools-extra/unittests/clang-tidy/TransformerClangTidyCheckTest.cpp; compiler-rt/include/sanitizer/linux_syscall_hooks.h; compiler-rt/include/sanitizer/memprof_interface.h; compiler-rt/include/sanitizer/netbsd_syscall_hooks.h; compiler-rt/include/xray/xray_interface.h; compiler-rt/include/xray/xray_log_interface.h; compiler-rt/lib/asan/asan_activation.h; compiler-rt/lib/asan/asan_lock.h; compiler-rt/lib/asan/asan_mapping.h; compiler-rt/lib/asan/asan_mapping_sparc64.h; compiler-rt/lib/asan/asan_rtl_static.cpp; compiler-rt/lib/asan/tests/asan_globals_test.cpp; compiler-rt/lib/builtins/fp_extend.h; compiler-rt/lib/builtins/fp_lib.h; compiler-rt/lib/builtins/fp_mode.h; compiler-rt/lib/builtins/fp_trunc.h; compiler-rt/lib/builtins/int_endianness.h; compiler-rt/lib/builtins/int_math.h; compiler-rt/lib/builtins/int_types.h; compiler-rt/lib/builtins/int_util.h; compiler-rt/lib/builtins/unwind-ehabi-helpers.h; compiler-rt/lib/builtins/ppc/DD.h; compiler-rt/lib/dfsan/dfsan_allocator.cpp; compiler-rt/lib/dfsan/dfsan_allocator.h; compiler-rt/lib/dfsan/dfsan_chained_origin_depot.cpp; compiler-rt/lib/dfsan/dfsan_chained_origin_depot.h; compiler-rt/lib/dfsan/dfsan_flags.h; compiler-rt/lib/dfsa,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt:89537,sanitiz,sanitizer,89537,interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/tools/clang-formatted-files.txt,1,['sanitiz'],['sanitizer']
Security,"tor operates in C++ mode, utilizing C++ reference types, while; ``-fbounds-safety`` does not currently support C++. This means LLDB’s expression; evaluator can only evaluate a subset of the ``-fbounds-safety`` language model.; Specifically, it’s capable of evaluating the wide pointers that already exist in; the source code. All other expressions are evaluated according to C/C++; semantics. C++ support; ===========. C++ has multiple options to write code in a bounds-safe manner, such as; following the bounds-safety core guidelines and/or using hardened libc++ along; with the `C++ Safe Buffer model; <https://discourse.llvm.org/t/rfc-c-buffer-hardening/65734>`_. However, these; techniques may require ABI changes and may not be applicable to code; interoperating with C. When the ABI of an existing program needs to be preserved; and for headers shared between C and C++, ``-fbounds-safety`` offers a potential; solution. ``-fbounds-safety`` is not currently supported in C++, but we believe the; general approach would be applicable for future efforts. Upstreaming plan; ================. Gradual updates with experimental flag; --------------------------------------. The upstreaming will take place as a series of smaller PRs and we will guard our; implementation with an experimental flag ``-fexperimental-bounds-safety`` until; the usable model is fully upstreamed. Once the model is ready for use, we will; expose the flag ``-fbounds-safety``. Possible patch sets; -------------------. * External bounds annotations and the (late) parsing logic.; * Internal bounds annotations (wide pointers) and their parsing logic.; * Clang code generation for wide pointers with debug information.; * Pointer cast semantics involving bounds annotations (this could be divided; into multiple sub-PRs).; * CFG analysis for pairs of related pointer and count assignments and the likes.; * Bounds check expressions in AST and the Clang code generation (this could also; be divided into multiple sub-PRs). ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst:11435,expose,expose,11435,interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/BoundsSafetyImplPlans.rst,1,['expose'],['expose']
Security,"tors** denote types; that contain a sequence of other type descriptors, at known offsets. These; contained type descriptors can either be struct type descriptors themselves; or scalar type descriptors. **Access tags** are metadata nodes attached to load and store instructions.; Access tags use type descriptors to describe the *location* being accessed; in terms of the type system of the higher level language. Access tags are; tuples consisting of a base type, an access type and an offset. The base; type is a scalar type descriptor or a struct type descriptor, the access; type is a scalar type descriptor, and the offset is a constant integer. The access tag ``(BaseTy, AccessTy, Offset)`` can describe one of two; things:. * If ``BaseTy`` is a struct type, the tag describes a memory access (load; or store) of a value of type ``AccessTy`` contained in the struct type; ``BaseTy`` at offset ``Offset``. * If ``BaseTy`` is a scalar type, ``Offset`` must be 0 and ``BaseTy`` and; ``AccessTy`` must be the same; and the access tag describes a scalar; access with scalar type ``AccessTy``. We first define an ``ImmediateParent`` relation on ``(BaseTy, Offset)``; tuples this way:. * If ``BaseTy`` is a scalar type then ``ImmediateParent(BaseTy, 0)`` is; ``(ParentTy, 0)`` where ``ParentTy`` is the parent of the scalar type as; described in the TBAA metadata. ``ImmediateParent(BaseTy, Offset)`` is; undefined if ``Offset`` is non-zero. * If ``BaseTy`` is a struct type then ``ImmediateParent(BaseTy, Offset)``; is ``(NewTy, NewOffset)`` where ``NewTy`` is the type contained in; ``BaseTy`` at offset ``Offset`` and ``NewOffset`` is ``Offset`` adjusted; to be relative within that inner type. A memory access with an access tag ``(BaseTy1, AccessTy1, Offset1)``; aliases a memory access with an access tag ``(BaseTy2, AccessTy2,; Offset2)`` if either ``(BaseTy1, Offset1)`` is reachable from ``(Base2,; Offset2)`` via the ``Parent`` relation or vice versa. As a concrete example, the type descripto",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:275329,access,access,275329,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,2,['access'],['access']
Security,"tory(cont); add_subdirectory(dictgen); add_subdirectory(foundation); add_subdirectory(gui); add_subdirectory(imt); add_subdirectory(meta); add_subdirectory(metacling); add_subdirectory(multiproc); add_subdirectory(newdelete); add_subdirectory(rint); add_subdirectory(testsupport); add_subdirectory(textinput); add_subdirectory(thread); add_subdirectory(zip); add_subdirectory(lzma); add_subdirectory(lz4); add_subdirectory(zstd). add_subdirectory(macosx); add_subdirectory(unix); add_subdirectory(winnt). #-------------------------------------------------------------------------------. if (libcxx AND NOT APPLE); # In case we use libcxx and glibc together there is a mismatch of the; # signatures of functions in the header wchar.h. This macro tweaks the; # header in rootcling resource directory to be compatible with the one from; # libc++.; target_compile_definitions(Core PRIVATE __CORRECT_ISO_CPP_WCHAR_H_PROTO); endif(). if(MSVC); # Definitions of MATH Macros (required in MathCore) like M_PI are only; # exposed on Windows after defining the _USE_MATH_DEFINES macro. By; # specifying it as a property for Core, we ensure that the macros are; # properly exposed when using Modules on Windows.; target_compile_definitions(Core PRIVATE _USE_MATH_DEFINES); endif(). # Inclusion of `complex.h` causes havoc: `complex` and `I` become CPP macros.; # Darwin's complex.h does not implement C11's __STDC_NO_COMPLEX__, use the; # header guard instead. This prevents inclusion of complex.h in Darwin.pcm.; # GCC <=5 has _COMPLEX_H but none of the others.; # __CLANG_STDATOMIC_H prevents inclusion of stdatomic in our Darwin.pcm: its; # macros cause conflics with boost.; target_compile_definitions(Core PRIVATE; __STDC_NO_COMPLEX__; __COMPLEX_H__; _COMPLEX_H. __CLANG_STDATOMIC_H; ). if (runtime_cxxmodules); list(APPEND core_implicit_modules ""-mSystemByproducts""); # Force generation of _Builtin_intrinsics from Core.; list(APPEND core_implicit_modules ""-m"" ""_Builtin_intrinsics"" ""-mByproduct"" ""_Builtin_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/CMakeLists.txt:2702,expose,exposed,2702,core/CMakeLists.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/CMakeLists.txt,1,['expose'],['exposed']
Security,"tracing is a quite known drawing technique based on tracking rays; from the eye position through all pixels of a view port device. The; pixel color is derived from the properties of the first crossed surface,; according some illumination model and material optical properties. While; there are currently existing quite sophisticated ray tracing models,; `TGeo` is currently using a very simple approach where the light; source is matching the eye position (no shadows or back-tracing of the; reflected ray). In future we are considering providing a base class in; order to be able to derive more complex models. Due to the fact that the number of rays that have to be tracked matches; the size in pixels of the pad, the time required by this algorithm is; proportional to the pad size. On the other hand, the speed is quite; acceptable for the default ROOT pad size and the images produced by; using this technique have high quality. Since the algorithm is; practically using all navigation features, producing ray-traced pictures; is also a geometry validation check. Ray tracing can be activated at; volume level as the normal `Draw()`. \image html geometry013.jpg ""Ray-traced view in a pad"". ~~~{.cpp}; myVolume->Raytrace(); ~~~. Once ray-tracing a view, this can be zoomed or rotated as a usual one.; Objects on the screen are no longer highlighted when picking the; vertices but the corresponding volumes is still accessible. \anchor GP04ca; #### Clipping Ray-traced Images. A ray-traced view can be `clipped` with any shape known by the modeller.; This means that the region inside the clipping shape is subtracted from; the current drawn geometry (become invisible). In order to activate; clipping, one has to first define the clipping shape(s):. 1. `TGeoShape *clip1, *clip2, ...`; One might switch between several clipping shapes. Note that these; shapes are considered defined in the current `MARS`. Composite shapes; may be used.; 2. `gGeoManager->SetClippingShape(clip1);`; One can activat",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md:104678,validat,validation,104678,geom/geom/doc/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/doc/index.md,1,['validat'],['validation']
Security,"transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this c",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2421,expose,exposes,2421,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,1,['expose'],['exposes']
Security,"trictions without causing incorrect results. `std::map`; ----------. C++'s ``map`` is an associative container similar to Python's ``dict``,; albeit one that has stronger type constraints.; A ``map`` can be instantiated from a ``dict`` (and types can be inferred) or; from a collection of ``pair`` mappings. .. code-block:: python. >>> from cppyy.gbl.std import map; >>> m = map[str, int](*(""one"", 1), (""two"", 2))) # type explicit, from pairs; >>> print(m); { ""one"" => 1, ""two"" => 2 }; >>> m = map({1: ""one"", 2: ""two""}) # type implicit, from dict; >>> type(m); <class cppyy.gbl.std.map<int,std::string> at 0x12d068d60>; >>> print(m); { 1 => ""one"", 2 => ""two"" }; >>>. `std::string`; -------------. Python's `str` is a unicode type since Python3, whereas ``std::string`` is; single-byte char-based.; Having the two correctly interact therefore deserves it's own; :doc:`chapter <strings>`. `std::tuple`; ------------. C++ ``tuple`` is supported but it should be noted that its use, and in; particular instantiating (heavily overloaded) ``get<>`` functions for member; access is inefficient.; They are really only meant for use when you have to pass a ``tuple`` to C++; code; and if returned from a C++ function, it is easier to simply unpack them.; In all other cases, prefer Python's builtin ``tuple``.; Example usage:. .. code-block:: python. >>> from cppyy.gbl.std import make_tuple, get; >>> t = make_tuple(1, '2', 5.); >>> print(t); <cppyy.gbl.std.tuple<int,std::string,double> object at 0x12033ee70>; >>> len(t); 3; >>> get[0](t) # access with templated std::get<>; 1; >>> get[1](t); b'2'; >>> get[2](t); 5.0; >>> a, b, c = t # unpack through iteration; >>> print(a, b, c); 1 2 5.0; >>>. .. rubric:: Footnotes. .. [#f1] The meaning of ""temporary"" differs between Python and C++: in a statement such as ``func(std.vector[int]((1, 2, 3)))``, there is no temporary as far as Python is concerned, even as there clearly is in the case of a similar statement in C++. Thus that call will succeed even if `",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:8550,access,access,8550,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['access'],['access']
Security,"tring GetModifiers() that translates from bit-flag; options back to perl-style option characters. For all functions that do actual matching replaced the default value; of 'Int_t nMatchMax' argument from 30 to 10. PCRE internals require; the index buffer to be 3-times the number of allowed matches. This; multiplication is now performed in individual functions and nMatchMax; is really the number of allowed matches. Two function calls in; TString passing this number explicitly have been updated. TPMERegexp. New sub-class of TPRegexp with API closer to PERL.; Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. New tutorial regexp_pme.C. Meta. Add a new TClass interface to be able to trigger the ""auto addition of object; to a TDirectory object"". If a class has a member function:; DirectoryAutoAdd(TDirectory*); it will now be accessible (when the dictionary is generated via rootcint; for now) via TClass::GetDirectoryAutoAdd which return a wrapper with the; signature:; void (*)(void *this_obj,TDirectory *where_to_add). Extend #pragma create TClass; to namespaces.; Enable autoloading of the cintdlls.; rlibmap now handles #pragma create TClass; statements. Cont. Support for std algorithms and iterators for ROOT collection classes by Anar.; The background is the following. While working on the PROOF code I found; that enumerating TList is an inconvenient and a long operation, I had to; write the same code all over the place and make duplications. I tried; to use STD algorithms with it, namely std::for_each, and failed.; I therefore decided to enable std::for_each algorithm for ROOT; Containers/Iterators by making as few as possible changes, without rewriting; iterators at all. Now with only two simple lines of code one is able to; iterate through a container:. TIter iter(&list);; for_each(iter.Begin(), TIter::End(), SEnumFunctor());. or. for_each(iter.Begin(), inter_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html:3211,access,accessible,3211,core/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/doc/v520/index.html,2,['access'],['accessible']
Security,"trinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare ptr @llvm.objc.storeWeak(ptr, ptr). Lowering:; """""""""""""""""". Lowers to a call to `objc_storeWeak <https://clang.llvm.org/docs/AutomaticReferenceCounting.html#arc-runtime-objc-storeweak>`_. Preserving Debug Information Intrinsics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These intrinsics are used to carry certain debuginfo together with; IR-level operations. For example, it may be desirable to; know the structure/union name and the original user-level field; indices. Such information got lost in IR GetElementPtr instruction; since the IR types are different from debugInfo types and unions; are converted to structs in IR. '``llvm.preserve.array.access.index``' Intrinsic; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Syntax:; """"""""""""""; ::. declare <ret_type>; @llvm.preserve.array.access.index.p0s_union.anons.p0a10s_union.anons(<type> base,; i32 dim,; i32 index). Overview:; """""""""""""""""". The '``llvm.preserve.array.access.index``' intrinsic returns the getelementptr address; based on array base ``base``, array dimension ``dim`` and the last access index ``index``; into the array. The return type ``ret_type`` is a pointer type to the array element.; The array ``dim`` and ``index`` are preserved which is more robust than; getelementptr instruction which may be subject to compiler transformation.; The ``llvm.preserve.access.index`` type of metadata is attached to this call instruction; to provide array or pointer debuginfo type.; The metadata is a ``DICompositeType`` or ``DIDerivedType`` representing the; debuginfo version of ``type``. Arguments:; """""""""""""""""""". The ``base`` is the array base address. The ``dim`` is the array dimension.; The ``base`` is a pointer if ``dim`` equals 0.; The ``index`` is the last access index into the array or pointer. The ``base`` argument must be annotated with an :ref:`elementtype; <attr_elementtype>` attribute at the call-site. This attribute specifies the; getelementptr ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:972767,access,access,972767,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['access'],['access']
Security,"ts allow for some implementation freedom to the ``ilist`` how to; allocate and store the sentinel. The corresponding policy is dictated by; ``ilist_traits<T>``. By default a ``T`` gets heap-allocated whenever the need; for a sentinel arises. While the default policy is sufficient in most cases, it may break down when; ``T`` does not provide a default constructor. Also, in the case of many; instances of ``ilist``\ s, the memory overhead of the associated sentinels is; wasted. To alleviate the situation with numerous and voluminous; ``T``-sentinels, sometimes a trick is employed, leading to *ghostly sentinels*. Ghostly sentinels are obtained by specially-crafted ``ilist_traits<T>`` which; superpose the sentinel with the ``ilist`` instance in memory. Pointer; arithmetic is used to obtain the sentinel, which is relative to the ``ilist``'s; ``this`` pointer. The ``ilist`` is augmented by an extra pointer, which serves; as the back-link of the sentinel. This is the only field in the ghostly; sentinel which can be legally accessed. .. _dss_other:. Other Sequential Container options; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Other STL containers are available, such as ``std::string``. There are also various STL adapter classes such as ``std::queue``,; ``std::priority_queue``, ``std::stack``, etc. These provide simplified access; to an underlying container but don't affect the cost of the container itself. .. _ds_string:. String-like containers; ----------------------. There are a variety of ways to pass around and use strings in C and C++, and; LLVM adds a few new options to choose from. Pick the first option on this list; that will do what you need, they are ordered according to their relative cost. Note that it is generally preferred to *not* pass strings around as ``const; char*``'s. These have a number of problems, including the fact that they; cannot represent embedded nul (""\0"") characters, and do not have a length; available efficiently. The general replacement for '``const",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:70522,access,accessed,70522,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,1,['access'],['accessed']
Security,"ts both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` may specify a ``ParseKind`` field. This field; should be the same value between all arguments sharing a spelling, and; corresponds to the parsed attribute's ``Kind`` enumerator. This allows; attributes to share a parsed attribute kind, but have distinct semantic; attribute classes. For instance, ``ParsedAttr`` is the shared; parsed attribute kind, but ARMInterruptAttr and MSP430InterruptAttr are the; semantic attributes generated. By default, attribute arguments are parsed in an evaluated context. If the; arguments for an attribute should be parsed in an unevaluated context (akin to; the way the argument to a ``sizeof`` expression is parsed), set; ``ParseArgumentsAsUnevaluated`` to ``1``. If additional functionality is desired for the semantic form of the attribute,; the ``AdditionalMembers`` field specifies code to be copied verbatim into the; semantic attribute class object, with ``public`` access. If two or more attributes cannot be used in combination on the same declaration; or statement, a ``MutualExclusions`` definition can be supplied to automatically; generate diagnostic code. This will disallow the attribute combinations; regardless of spellings used. Additionally, it will diagnose combinations within; the same attribute list, different attribute list, and redeclarations, as; appropriate. Boilerplate; ^^^^^^^^^^^; All semantic processing of declaration attributes happens in `lib/Sema/SemaDeclAttr.cpp; <https://github.com/llvm/llvm-project/blob/main/clang/lib/Sema/SemaDeclAttr.cpp>`_,; and generally starts in the ``ProcessDeclAttribute()`` function. If the; attribute has the ``SimpleHandler`` field set to ``1`` then the function to; process the attribute will be automatically generated, and nothing needs to be; done here. Otherwise, write a new ``handleYourAttr()`` ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:141608,access,access,141608,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,1,['access'],['access']
Security,"ts in a single checkout makes cross-project refactoring; naturally simple:. * New sub-projects can be trivially split out for better reuse and/or layering; (e.g., to allow libSupport and/or LIT to be used by runtimes without adding a; dependency on LLVM).; * Changing an API in LLVM and upgrading the sub-projects will always be done in; a single commit, designing away a common source of temporary build breakage.; * Moving code across sub-project (during refactoring for instance) in a single; commit enables accurate `git blame` when tracking code change history.; * Tooling based on `git grep` works natively across sub-projects, allowing to; easier find refactoring opportunities across projects (for example reusing a; datastructure initially in LLDB by moving it into libSupport).; * Having all the sources present encourages maintaining the other sub-projects; when changing API. Finally, the monorepo maintains the property of the existing SVN repository that; the sub-projects move synchronously, and a single revision number (or commit; hash) identifies the state of the development across all projects. .. _build_single_project:. Building a single sub-project; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Even though there is a single source tree, you are not required to build; all sub-projects together. It is trivial to configure builds for a single; sub-project. For example::. mkdir build && cd build; # Configure only LLVM (default); cmake path/to/monorepo; # Configure LLVM and lld; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=lld; # Configure LLVM and clang; cmake path/to/monorepo -DLLVM_ENABLE_PROJECTS=clang. .. _git-svn-mirror:. Outstanding Questions; ---------------------. Read-only sub-project mirrors; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. With the Monorepo, it is undecided whether the existing single-subproject; mirrors (e.g. https://git.llvm.org/git/compiler-rt.git) will continue to; be maintained. Read/write SVN bridge; ^^^^^^^^^^^^^^^^^^^^^. GitHub supports a read/write SVN bridge ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst:9891,hash,hash,9891,interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Proposals/GitHubMove.rst,1,['hash'],['hash']
Security,"ts the required signature. ``` {.cpp}; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::HepThreeVector q(1,2,3);; XYZVector v3(q);; ```. #### Coordinate Accessors. All coordinate accessors are available through the class; `ROOT::Math::`**`DisplacementVector3D`**:. ``` {.cpp}; //returns cartesian components for the cartesian vector v1; v1.X(); v1.Y(); v1.Z();; //returns cylindrical components for the cartesian vector v1; v1.Rho(); v1.Eta(); v1.Phi();; //returns cartesian components for the cylindrical vector r2; r2.X(); r2.Y(); r2.Z(); ```. In addition, all the 3 coordinates of the vector can be retrieved with; the `GetCoordinates` method:. ``` {.cpp}; double d[3];; //fill d array with (x,y,z) components of v1; v1.GetCoordinates(d);; //fill d array with (r,eta,phi) components of r2; r2.GetCoordinates(d);; std::vector vc(3);; //fill std::vector with (x,y,z) components of v1; v1.GetCoordinates(vc.begin(),vc.end());; ```. See the reference documentation of; `ROOT::Math::`**`DisplacementVector3D`** for more details on all the; coordinate accessors. #### Setter Methods. One can set only all the three coordinates via:. ``` {.cpp}; v1.SetCoordinates(c1,c2,c3); // (x,y,z) for a XYZVector; r2.SetCoordinates(c1,c2,c3); // r,theta,phi for a Polar3DVector; r2.SetXYZ(x,y,z); // 3 cartesian components for Polar3DVector; ```. Single coordinate setter methods are available for the basic vector; coordinates, like `SetX()` for a **`XYZVector`** or `SetR()` for a polar; vector. Attempting to do a `SetX()` on a polar vector will not compile. ``` {.cpp}; XYZVector v1;; v1.SetX(1); //OK setting x for a Cartesian vector; Polar3DVector v2;; v2.SetX(1); //ERROR: cannot set X for a Polar vector.; //Method will not compile; v2.SetR(1); //OK setting r for a Polar vector; ```. In addition, there are setter methods from C arrays or iterator. ``` {.cpp}; double d[3] = {1.,2.,3.};; XYZVector v;; // set (x,y,z) components of v using values from d; v.SetCoordinates(d);; ```. or, for example, fro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md:80643,access,accessors,80643,documentation/users-guide/MathLibraries.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/MathLibraries.md,1,['access'],['accessors']
Security,"ts. llvm.amdgcn.sdot8 Provides direct access to v_dot8_u32_u4 across targets which; support such instructions. This performs signed dot product; with two i32 operands (holding a vector of 8 4bit values), summed; with the third i32 operand. The i1 fourth operand is used to clamp; the output.; When applicable (i.e. no clamping / operand modifiers), this is lowered; into v_dot8c_i32_i4 for targets which support it.; RDNA3 does not offer v_dot8_i32_i4, and rather offers; v_dot4_i32_iu4 which has operands to hold the signedness of the; vector operands. Thus, this intrinsic lowers to the signed version; of this instruction for gfx11 targets. llvm.amdgcn.sudot4 Provides direct access to v_dot4_i32_iu8 on gfx11 targets. This performs; dot product with two i32 operands (holding a vector of 4 8bit values), summed; with the fifth i32 operand. The i1 sixth operand is used to clamp; the output. The i1s preceding the vector operands decide the signedness. llvm.amdgcn.sudot8 Provides direct access to v_dot8_i32_iu4 on gfx11 targets. This performs; dot product with two i32 operands (holding a vector of 8 4bit values), summed; with the fifth i32 operand. The i1 sixth operand is used to clamp; the output. The i1s preceding the vector operands decide the signedness. llvm.amdgcn.sched_barrier Controls the types of instructions that may be allowed to cross the intrinsic; during instruction scheduling. The parameter is a mask for the instruction types; that can cross the intrinsic. - 0x0000: No instructions may be scheduled across sched_barrier.; - 0x0001: All, non-memory, non-side-effect producing instructions may be; scheduled across sched_barrier, *i.e.* allow ALU instructions to pass.; - 0x0002: VALU instructions may be scheduled across sched_barrier.; - 0x0004: SALU instructions may be scheduled across sched_barrier.; - 0x0008: MFMA/WMMA instructions may be scheduled across sched_barrier.; - 0x0010: All VMEM instructions may be scheduled across sched_barrier.; - 0x0020: VMEM read ins",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:41958,access,access,41958,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['access']
Security,"ts::; :local:. Introduction; ============. This document describes the CommandLine argument processing library. It will; show you how to use it, and what it can do. The CommandLine library uses a; declarative approach to specifying the command line options that your program; takes. By default, these options declarations implicitly hold the value parsed; for the option declared (of course this `can be changed`_). Although there are a **lot** of command line argument parsing libraries out; there in many different languages, none of them fit well with what I needed. By; looking at the features and problems of other libraries, I designed the; CommandLine library to have the following features:. #. Speed: The CommandLine library is very quick and uses little resources. The; parsing time of the library is directly proportional to the number of; arguments parsed, not the number of options recognized. Additionally,; command line argument values are captured transparently into user defined; global variables, which can be accessed like any other variable (and with the; same performance). #. Type Safe: As a user of CommandLine, you don't have to worry about; remembering the type of arguments that you want (is it an int? a string? a; bool? an enum?) and keep casting it around. Not only does this help prevent; error prone constructs, it also leads to dramatically cleaner source code. #. No subclasses required: To use CommandLine, you instantiate variables that; correspond to the arguments that you would like to capture, you don't; subclass a parser. This means that you don't have to write **any**; boilerplate code. #. Globally accessible: Libraries can specify command line arguments that are; automatically enabled in any tool that links to the library. This is; possible because the application doesn't have to keep a list of arguments to; pass to the parser. This also makes supporting `dynamically loaded options`_; trivial. #. Cleaner: CommandLine supports enum and other types di",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst:1133,access,accessed,1133,interpreter/llvm-project/llvm/docs/CommandLine.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/CommandLine.rst,1,['access'],['accessed']
Security,"ts; are accessed as negative offsets relative to ``DW_AT_frame_base``, and the; local variables and register spill slots are accessed as positive offsets; relative to ``DW_AT_frame_base``. 5. Function argument passing is implemented by copying the input physical; registers to virtual registers on entry. The register allocator can spill if; necessary. These are copied back to physical registers at call sites. The; net effect is that each function call can have these values in entirely; distinct locations. The IPRA can help avoid shuffling argument registers.; 6. Call sites are implemented by setting up the arguments at positive offsets; from SP. Then SP is incremented to account for the known frame size before; the call and decremented after the call. .. note::. The CFI will reflect the changed calculation needed to compute the CFA; from SP. 7. 4 byte spill slots are used in the stack frame. One slot is allocated for an; emergency spill slot. Buffer instructions are used for stack accesses and; not the ``flat_scratch`` instruction. .. TODO::. Explain when the emergency spill slot is used. .. TODO::. Possible broken issues:. - Stack arguments must be aligned to required alignment.; - Stack is aligned to max(16, max formal argument alignment); - Direct argument < 64 bits should check register budget.; - Register budget calculation should respect ``inreg`` for SGPR.; - SGPR overflow is not handled.; - struct with 1 member unpeeling is not checking size of member.; - ``sret`` is after ``this`` pointer.; - Caller is not implementing stack realignment: need an extra pointer.; - Should say AMDGPU passes FP rather than SP.; - Should CFI define CFA as address of locals or arguments. Difference is; apparent when have implemented dynamic alignment.; - If ``SCRATCH`` instruction could allow negative offsets, then can make FP be; highest address of stack frame and use negative offset for locals. Would; allow SP to be the same as FP and could support signal-handler-like as now; hav",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:400003,access,accesses,400003,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accesses']
Security,"ts; are reasonably small, a ``SmallSet<Type, N>`` is a good choice. This set has; space for N elements in place (thus, if the set is dynamically smaller than N,; no malloc traffic is required) and accesses them with a simple linear search.; When the set grows beyond N elements, it allocates a more expensive; representation that guarantees efficient access (for most types, it falls back; to :ref:`std::set <dss_set>`, but for pointers it uses something far better,; :ref:`SmallPtrSet <dss_smallptrset>`. The magic of this class is that it handles small sets extremely efficiently, but; gracefully handles extremely large sets without loss of efficiency. .. _dss_smallptrset:. llvm/ADT/SmallPtrSet.h; ^^^^^^^^^^^^^^^^^^^^^^. ``SmallPtrSet`` has all the advantages of ``SmallSet`` (and a ``SmallSet`` of; pointers is transparently implemented with a ``SmallPtrSet``). If more than N; insertions are performed, a single quadratically probed hash table is allocated; and grows as needed, providing extremely efficient access (constant time; insertion/deleting/queries with low constant factors) and is very stingy with; malloc traffic. Note that, unlike :ref:`std::set <dss_set>`, the iterators of ``SmallPtrSet``; are invalidated whenever an insertion occurs. Also, the values visited by the; iterators are not visited in sorted order. .. _dss_stringset:. llvm/ADT/StringSet.h; ^^^^^^^^^^^^^^^^^^^^. ``StringSet`` is a thin wrapper around :ref:`StringMap\<char\> <dss_stringmap>`,; and it allows efficient storage and retrieval of unique strings. Functionally analogous to ``SmallSet<StringRef>``, ``StringSet`` also supports; iteration. (The iterator dereferences to a ``StringMapEntry<char>``, so you; need to call ``i->getKey()`` to access the item of the StringSet.) On the; other hand, ``StringSet`` doesn't support range-insertion and; copy-construction, which :ref:`SmallSet <dss_smallset>` and :ref:`SmallPtrSet; <dss_smallptrset>` do support. .. _dss_denseset:. llvm/ADT/DenseSet.h; ^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst:78952,hash,hash,78952,interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/ProgrammersManual.rst,2,"['access', 'hash']","['access', 'hash']"
Security,"turn 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of t",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22294,secur,security,22294,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['secur'],['security']
Security,"turn since the locations may be used for vector memory instructions by a; future wavefront that uses the same scratch area, or a function call that; creates a frame at the same address, respectively. There is no need for a; ``s_dcache_inv`` as all scalar writes are write-before-read in the same thread. For kernarg backing memory:. * CP invalidates the L1 cache at the start of each kernel dispatch.; * On dGPU the kernarg backing memory is allocated in host memory accessed as; MTYPE UC (uncached) to avoid needing to invalidate the L2 cache. This also; causes it to be treated as non-volatile and so is not invalidated by; ``*_vol``.; * On APU the kernarg backing memory it is accessed as MTYPE CC (cache coherent); and so the L2 cache will be coherent with the CPU and other agents. Scratch backing memory (which is used for the private address space) is accessed; with MTYPE NC_NV (non-coherent non-volatile). Since the private address space is; only accessed by a single thread, and is always write-before-read, there is; never a need to invalidate these entries from the L1 cache. Hence all cache; invalidates are done as ``*_vol`` to only invalidate the volatile cache lines. The code sequences used to implement the memory model for GFX6-GFX9 are defined; in table :ref:`amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table`. .. table:: AMDHSA Memory Model Code Sequences GFX6-GFX9; :name: amdgpu-amdhsa-memory-model-code-sequences-gfx6-gfx9-table. ============ ============ ============== ========== ================================; LLVM Instr LLVM Memory LLVM Memory AMDGPU AMDGPU Machine Code; Ordering Sync Scope Address GFX6-GFX9; Space; ============ ============ ============== ========== ================================; **Non-Atomic**; ------------------------------------------------------------------------------------; load *none* *none* - global - !volatile & !nontemporal; - generic; - private 1. buffer/global/flat_load; - constant; - !volatile & nontemporal. 1. buffer/g",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst:211128,access,accessed,211128,interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUUsage.rst,1,['access'],['accessed']
Security,"turned,; if it is either a builtin type (int, long, float, double, and; `const char*` are supported), a Python type that can cross, or a ROOT; type. If a ROOT type is returned, an explicit cast to void\* is needed; to assign the return value to a local pointer (which may have a; different type), whereas builtin types will be cast implicitly, if; possible, to the type of the local variable to which they are assigned. `Bind(TObject* obj,const char* label)` - transfer a ROOT object from the; Cling to the Python interpreter, where it will be referenced with a; variable called ""`label`"". `Prompt()` - Transfer the interactive prompt to Python. With the ROOT v4.00/06 and later, the **`TPython`** class will be loaded; automatically on use, for older editions, the `libPyROOT.so` needs to be; loaded first with `gSystem->Load()` before use. Refer back to the other; example of the use of **`TPython`** that was given in ""Access to Python; from ROOT"". To show in detail how Python access can be used, an example Python; module is needed, as follows:. ``` {.cpp}; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; ```. This module can now be loaded into a Cling session, the class used to; instantiate objects, and their member functions called for showing how; different types can cross:. ``` {.cpp}; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; ```. Note that the `LoadMacro()` call makes the class automatically; available, such that it can be used directly. Otherwise, a; `gROOT->GetClass()` call is required first. #### Callbacks. The simplest way of setting a callback to Python from Cling, e.g. for a; button, is by providing the execution string. See for example; `tutorials/pyroot/demo.py` that comes with the ROOT installation:. ```",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md:17546,access,access,17546,documentation/users-guide/PythonRuby.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/documentation/users-guide/PythonRuby.md,1,['access'],['access']
Security,"tween Koenig and normal lookup; Yes. 165; NAD; Definitions of friends and block-scope externs; No. 166; TC1; Friend declarations of template-ids; Clang 2.9. 167; NAD; Deprecating static functions; Superseded by 1012. 168; NAD; C linkage for static member functions; No. 169; NAD; template-ids in using-declarations; Yes. 170; DRWP; Pointer-to-member conversions; Unknown. 171; TC1; Global namespace scope; Clang 3.4. 172; CD1; Unsigned int as underlying type of enum; Yes. 173; TC1; Constraints on execution character set; Yes. 174; NAD; Undeprecating global static; Superseded by 1012. 175; CD1; Class name injection and base name access; Clang 2.8. 176; TC1; Name injection and templates; Clang 3.1. 177; CD1; Lvalues vs rvalues in copy-initialization; Yes. 178; TC1; More on value-initialization; Yes. 179; TC1; Function pointers and subtraction; Yes. 180; CD1; typename and elaborated types; Clang 2.8. 181; TC1; Errors in template template-parameter example; Yes. 182; NAD; Access checking on explicit specializations; Clang 14. 183; TC1; typename in explicit specializations; Superseded by 382. 184; CD1; Default arguments in template template-parameters; Yes. 185; TC1; ""Named"" temporaries and copy elision; Unknown. 186; open; Name hiding and template template-parameters; Not resolved. 187; TC1; Scope of template parameter names; Superseded by 481. 188; TC1; Comma operator and rvalue conversion; Yes. 189; drafting; Definition of operator and punctuator; Not resolved. 190; TC1; Layout-compatible POD-struct types; Unknown. 191; CD6; Name lookup does not handle complex nesting; Yes. 192; NAD; Name lookup in parameters; Unknown. 193; TC1; Order of destruction of local automatics of destructor; Unknown. 194; TC1; Identifying constructors; Yes. 195; CD1; Converting between function and object pointers; Yes. 196; open; Arguments to deallocation functions; Not resolved. 197; CD1; Issues with two-stage lookup of dependent names; Yes. 198; CD1; Definition of ""use"" in local and nested clas",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:12097,Access,Access,12097,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,1,['Access'],['Access']
Security,"ty Group to decide if such backporting should be done, and how far back.; * The Security Group figures out how the LLVM project’s own releases, as well as individual vendors’ releases, can be timed to patch the issue simultaneously.; * Embargo date can be delayed or pulled forward at the Security Group’s discretion.; * The issue champion obtains a CVE entry from MITRE_.; * Once the embargo expires, the patch is posted publicly according to LLVM’s usual code review process.; * All security issues (as well as nomination / removal discussions) become public within approximately fourteen weeks of the fix landing in the LLVM repository. Precautions should be taken to avoid disclosing particularly sensitive data included in the report (e.g. username and password pairs). Changes to the Policy; =====================. The LLVM Security Policy may be changed by majority vote of the LLVM Security Group. Such changes also need to be approved by the LLVM Board. What is considered a security issue?; ====================================. The LLVM Project has a significant amount of code, and not all of it is; considered security-sensitive. This is particularly true because LLVM is used in; a wide variety of circumstances: there are different threat models, untrusted; inputs differ, and the environment LLVM runs in is varied. Therefore, what the; LLVM Project considers a security issue is what its members have signed up to; maintain securely. As this security process matures, members of the LLVM community can propose that; a part of the codebase be designated as security-sensitive (or no longer; security-sensitive). This requires a rationale, and buy-in from the LLVM; community as for any RFC. In some cases, parts of the codebase could be handled; as security-sensitive but need significant work to get to the stage where that's; manageable. The LLVM community will need to decide whether it wants to invest in; making these parts of the code securable, and maintain these security; pro",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:14011,secur,security,14011,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"ty issue. An embargo may be lifted before the agreed-upon date if all vendors planning to ship a fix have already done so, and if the reporter does not object. Collaboration; -------------. Members of the LLVM Security Group are expected to:. * Promptly share any LLVM vulnerabilities they become aware of.; * Volunteer to drive issues forward.; * Help evaluate the severity of incoming issues.; * Help write and review patches to address security issues.; * Participate in the member nomination and removal processes. Discussion Medium; =================. *FUTURE*: this section needs more work! Where discussions occur is influenced by other factors that are still open in this document. We can finalize it later.; It seems like bugzilla and email don't meet security requirements. The medium used to host LLVM Security Group discussions is security-sensitive. It should therefore run on infrastructure which can meet our security expectations. We are currently using the `chromium issue tracker`_ (as the `llvm` project) to have security discussions:. * File security issues.; * Discuss security improvements to LLVM. When a new issue is filed, a template is provided to help issue reporters provide all relevant information. *FUTURE*: The `Github security`_ workflow allows publicly disclosing resolved security issues on the github project page, and we would be interested in adopting it for that purpose. However, it does not easily allow confidential reporting of security issues, as creating Github Security Advisories is currently restricted to Github project admins. That is why we have started with the `chromium issue tracker`_ instead. We also occasionally need to discuss logistics of the LLVM Security Group itself:. * Nominate new members.; * Propose member removal.; * Suggest policy changes. We often have these discussions publicly, in our :ref:`monthly public sync-up call <online-sync-ups>` and on the Discourse forums. For internal or confidential discussions, we also use a pri",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst:11041,secur,security,11041,interpreter/llvm-project/llvm/docs/Security.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/Security.rst,1,['secur'],['security']
Security,"ty. The ``#include`` mechanism works just fine. No Exposed Functions; --------------------. Any functions defined by system libraries (i.e. not defined by ``lib/Support``); must not be exposed through the ``lib/Support`` interface, even if the header; file for that function is not exposed. This prevents inadvertent use of system; specific functionality. For example, the ``stat`` system call is notorious for having variations in the; data it provides. ``lib/Support`` must not declare ``stat`` nor allow it to be; declared. Instead it should provide its own interface to discovering; information about files and directories. Those interfaces may be implemented in; terms of ``stat`` but that is strictly an implementation detail. The interface; provided by the Support Library must be implemented on all platforms (even; those without ``stat``). No Exposed Data; ---------------. Any data defined by system libraries (i.e. not defined by ``lib/Support``) must; not be exposed through the ``lib/Support`` interface, even if the header file; for that function is not exposed. As with functions, this prevents inadvertent; use of data that might not exist on all platforms. Minimize Soft Errors; --------------------. Operating system interfaces will generally provide error results for every; little thing that could go wrong. In almost all cases, you can divide these; error results into two groups: normal/good/soft and abnormal/bad/hard. That is,; some of the errors are simply information like ""file not found"", ""insufficient; privileges"", etc. while other errors are much harder like ""out of space"", ""bad; disk sector"", or ""system call interrupted"". We'll call the first group ""*soft*""; errors and the second group ""*hard*"" errors. ``lib/Support`` must always attempt to minimize soft errors. This is a design; requirement because the minimization of soft errors can affect the granularity; and the nature of the interface. In general, if you find that you're wanting to; throw soft errors, you ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:7006,expose,exposed,7006,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,2,['expose'],['exposed']
Security,"u can build; multiple configurations on one computer. #. Install buildbot-worker (currently we are using buildbot version 2.8.4).; This specific version can be installed using ``pip``, with a command such; as ``pip3 install buildbot-worker==2.8.4``. #. Create a designated user account, your buildbot-worker will be running under,; and set appropriate permissions. #. Choose the buildbot-worker root directory (all builds will be placed under; it), buildbot-worker access name and password the build master will be using; to authenticate your buildbot-worker. #. Create a buildbot-worker in context of that buildbot-worker account. Point it; to the **lab.llvm.org** port **9994** (see `Buildbot documentation,; Creating a worker; <http://docs.buildbot.net/current/tutorial/firstrun.html#creating-a-worker>`_; for more details) by running the following command:. .. code-block:: bash. $ buildbot-worker create-worker <buildbot-worker-root-directory> \; lab.llvm.org:9994 \; <buildbot-worker-access-name> \; <buildbot-worker-access-password>. Only once a new worker is stable, and; approval from Galina has been received (see last step) should it; be pointed at the main buildmaster. Now start the worker:. .. code-block:: bash. $ buildbot-worker start <buildbot-worker-root-directory>. This will cause your new worker to connect to the staging buildmaster; which is silent by default. Try this once then check the log file; ``<buildbot-worker-root-directory>/worker/twistd.log``. If your settings; are correct you will see a refused connection. This is good and expected,; as the credentials have not been established on both ends. Now stop the; worker and proceed to the next steps. #. Fill the buildbot-worker description and admin name/e-mail. Here is an; example of the buildbot-worker description::. Windows 7 x64; Core i7 (2.66GHz), 16GB of RAM. g++.exe (TDM-1 mingw32) 4.4.0; GNU Binutils 2.19.1; cmake version 2.8.4; Microsoft(R) 32-bit C/C++ Optimizing Compiler Version 16.00.40219.01 for 80x8",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst:3957,access,access-name,3957,interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HowToAddABuilder.rst,2,['access'],"['access-name', 'access-password']"
Security,"u must give the recipients all the rights that we gave; you. You must make sure that they, too, receive or can get the source; code. If you link other code with the library, you must provide; complete object files to the recipients, so that they can relink them; with the library after making changes to the library and recompiling; it. And you must show them these terms so they know their rights. We protect your rights with a two-step method: (1) we copyright the; library, and (2) we offer you this license, which gives you legal; permission to copy, distribute and/or modify the library. To protect each distributor, we want to make it very clear that; there is no warranty for the free library. Also, if the library is; modified by someone else and passed on, the recipients should know; that what they have is not the original version, so that the original; author's reputation will not be affected by problems that might be; introduced by others.; ; Finally, software patents pose a constant threat to the existence of; any free program. We wish to make sure that a company cannot; effectively restrict the users of a free program by obtaining a; restrictive license from a patent holder. Therefore, we insist that; any patent license obtained for a version of the library must be; consistent with the full freedom of use specified in this license. Most GNU software, including some libraries, is covered by the; ordinary GNU General Public License. This license, the GNU Lesser; General Public License, applies to certain designated libraries, and; is quite different from the ordinary General Public License. We use; this license for certain libraries in order to permit linking those; libraries into non-free programs. When a program is linked with a library, whether statically or using; a shared library, the combination of the two is legally speaking a; combined work, a derivative of the original library. The ordinary; General Public License therefore permits such linking only if th",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt:2957,threat,threat,2957,LGPL2_1.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/LGPL2_1.txt,1,['threat'],['threat']
Security,"ual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void foo() {; NonVirtual *x = create();; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. .. _alpha-cplusplus-InvalidatedIterator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. .. _alpha-cplusplus-MismatchedIterator:. alpha.cplusplus.MismatchedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of iterators of different containers where iterators of the same container are expected. .. code-block:: cpp. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. .. _alpha-cplusplus-MisusedMovedObject:. alpha.cplusplus.MisusedMovedObject (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Method calls on a moved-from object and copying a moved-from object will be reported. .. code-block:: cpp. struct A {; v",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:54496,access,accessed,54496,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst,1,['access'],['accessed']
Security,"ub.com/llvm/llvm-project/issues/75426>`_); - Fix an issue where clang cannot find conversion function with template; parameter when instantiation of template class.; Fixes (`#77583 <https://github.com/llvm/llvm-project/issues/77583>`_); - Fix an issue where CTAD fails for function-type/array-type arguments.; Fixes (`#51710 <https://github.com/llvm/llvm-project/issues/51710>`_); - Fix crashes when using the binding decl from an invalid structured binding.; Fixes (`#67495 <https://github.com/llvm/llvm-project/issues/67495>`_) and; (`#72198 <https://github.com/llvm/llvm-project/issues/72198>`_); - Fix assertion failure when call noreturn-attribute function with musttail; attribute.; Fixes (`#76631 <https://github.com/llvm/llvm-project/issues/76631>`_); - The MS ``__noop`` builtin without an argument list is now accepted; in the placement-args of new-expressions, matching MSVC's behaviour.; - Fix an issue that caused MS ``__decspec(property)`` accesses as well as; Objective-C++ property accesses to not be converted to a function call; to the getter in the placement-args of new-expressions.; Fixes (`#65053 <https://github.com/llvm/llvm-project/issues/65053>`_); - Fix an issue with missing symbol definitions when the first coroutine; statement appears in a discarded ``if constexpr`` branch.; Fixes (`#78290 <https://github.com/llvm/llvm-project/issues/78290>`_); - Fixed assertion failure with deleted overloaded unary operators.; Fixes (`#78314 <https://github.com/llvm/llvm-project/issues/78314>`_); - The XCOFF object file format does not support aliases to symbols having common; linkage. Clang now diagnoses the use of an alias for a common symbol when; compiling for AIX. - Clang now doesn't produce false-positive warning `-Wconstant-logical-operand`; for logical operators in C23.; Fixes (`#64356 <https://github.com/llvm/llvm-project/issues/64356>`_).; - Clang's ``-Wshadow`` no longer warns when an init-capture is named the same as; a class field unless the lambda can captu",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:45105,access,accesses,45105,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,['access'],['accesses']
Security,"uc.edu>; Subject: another thought. I have a budding idea about making LLVM a little more ambitious: a; customizable runtime system that can be used to implement language-specific; virtual machines for many different languages. E.g., a C vm, a C++ vm, a; Java vm, a Lisp vm, .. The idea would be that LLVM would provide a standard set of runtime features; (some low-level like standard assembly instructions with code generation and; static and runtime optimization; some higher-level like type-safety and; perhaps a garbage collection library). Each language vm would select the; runtime features needed for that language, extending or customizing them as; needed. Most of the machine-dependent code-generation and optimization; features as well as low-level machine-independent optimizations (like PRE); could be provided by LLVM and should be sufficient for any language,; simplifying the language compiler. (This would also help interoperability; between languages.) Also, some or most of the higher-level; machine-independent features like type-safety and access safety should be; reusable by different languages, with minor extensions. The language; compiler could then focus on language-specific analyses and optimizations. The risk is that this sounds like a universal IR -- something that the; compiler community has tried and failed to develop for decades, and is; universally skeptical about. No matter what we say, we won't be able to; convince anyone that we have a universal IR that will work. We need to; think about whether LLVM is different or if has something novel that might; convince people. E.g., the idea of providing a package of separable; features that different languages select from. Also, using SSA with or; without type-safety as the intermediate representation. One interesting starting point would be to discuss how a JVM would be; implemented on top of LLVM a bit more. That might give us clues on how to; structure LLVM to support one or more language VMs. --Vikram. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt:1173,access,access,1173,interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/HistoricalNotes/2001-01-31-UniversalIRIdea.txt,1,['access'],['access']
Security,"uckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'HASH'``; encoded as an ASCII integer. This allows the detection of the start of the; hash table and also allows the table's byte order to be determined so the table; can be correctly extracted. The ""``magic``"" value is followed by a 16 bit; ``version`` number which allows the table to be revised and modified in the; future. The current version number is 1. ``hash_function`` is a ``uint16_t``; enumeration that specifies which hash function was used to produce this table.; The current values for the hash function enumerations include:. .. code-block:: c. enum HashFunctionType; {; eHashFunctionDJB = 0u, // Daniel J Bernstein hash function; };. ``bucket_count`` is a 32 bit unsigned integer that represents how many buckets; are in the ``BUCKETS`` array. ``hashes_count`` is the number of unique 32 bit; hash values that are in the ``HASHES`` array, and is the same number of offsets; are contained in the ``OFFSETS`` array. ``header_data_len`` specifies the size; in bytes of the ``HeaderData`` that is filled in by specialized versions of; this table. Fixed Lookup; """""""""""""""""""""""". The header is followed by the buckets, hashes, offsets, and hash value data. .. code-block:: c. struct FixedTable; {; uint32_t buckets[Header.bucket_count]; // An array of hash indexes into the ""hashes[]"" array below; uint32_t hashes [Header.hashes_count]; // Every unique 32 bit hash for the entire table is in this table; uint32_t offsets[Header.hashes_count]; // An offset that corresponds to each item in the ""hashes[",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:69904,hash,hash,69904,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,1,['hash'],['hash']
Security,"ude/llvm/Support`` and implemented in; ``lib/Support`` for all supported platforms. Don't Expose System Headers; ---------------------------. The Support Library must shield LLVM from **all** system headers. To obtain; system level functionality, LLVM source must; ``#include ""llvm/Support/Thing.h""`` and nothing else. This means that; ``Thing.h`` cannot expose any system header files. This protects LLVM from; accidentally using system specific functionality and only allows it via; the ``lib/Support`` interface. Use Standard C Headers; ----------------------. The **standard** C headers (the ones beginning with ""c"") are allowed to be; exposed through the ``lib/Support`` interface. These headers and the things they; declare are considered to be platform agnostic. LLVM source files may include; them directly or obtain their inclusion through ``lib/Support`` interfaces. Use Standard C++ Headers; ------------------------. The **standard** C++ headers from the standard C++ library and standard; template library may be exposed through the ``lib/Support`` interface. These; headers and the things they declare are considered to be platform agnostic.; LLVM source files may include them or obtain their inclusion through; ``lib/Support`` interfaces. High Level Interface; --------------------. The entry points specified in the interface of ``lib/Support`` must be aimed at; completing some reasonably high level task needed by LLVM. We do not want to; simply wrap each operating system call. It would be preferable to wrap several; operating system calls that are always used in conjunction with one another by; LLVM. For example, consider what is needed to execute a program, wait for it to; complete, and return its result code. On Unix, this involves the following; operating system calls: ``getenv``, ``fork``, ``execve``, and ``wait``. The; correct thing for ``lib/Support`` to provide is a function, say; ``ExecuteProgramAndWait``, that implements the functionality completely. what; we d",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst:3667,expose,exposed,3667,interpreter/llvm-project/llvm/docs/SupportLibrary.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SupportLibrary.rst,1,['expose'],['exposed']
Security,"uding internal linkage). As a result, global symbols do; not describe a mangled name *or* an address, since symbols with internal linkage; need not have any mangling at all, and also may not have an address. Thus, all; global symbols simply refer directly to the full symbol record via a module/offset; combination. Similarly to :ref:`public symbols <public_symbols>`, all global symbols are contained; in a single :doc:`Globals Stream <GlobalStream>`, which contains a hash table mapping; fully qualified name to the corresponding record in the globals stream (which as; mentioned, then contains information allowing one to locate the full record in the; corresponding module symbol stream). Note that a consequence and limitation of this design is that program-wide lookup; by anything other than an exact textually matching fully-qualified name of whatever; the compiler decided to emit is impractical. This differs from DWARF, where even; though we don't necessarily have O(1) lookup by basename within a given scope (including; O(1) scope, we at least have O(n) access within a given scope). .. important::; Program-wide lookup of names by anything other than an exact textually matching fully; qualified name is not possible. S_GDATA32; ^^^^^^^^^^. S_GTHREAD32 (0x1113); ^^^^^^^^^^^^^^^^^^^^. S_PROCREF (0x1125); ^^^^^^^^^^^^^^^^^^. S_LPROCREF (0x1127); ^^^^^^^^^^^^^^^^^^^. S_GMANDATA (0x111d); ^^^^^^^^^^^^^^^^^^^. .. _module_symbols:. Module Symbols; --------------. S_END (0x0006); ^^^^^^^^^^^^^^. S_FRAMEPROC (0x1012); ^^^^^^^^^^^^^^^^^^^^. S_OBJNAME (0x1101); ^^^^^^^^^^^^^^^^^^. S_THUNK32 (0x1102); ^^^^^^^^^^^^^^^^^^. S_BLOCK32 (0x1103); ^^^^^^^^^^^^^^^^^^. S_LABEL32 (0x1105); ^^^^^^^^^^^^^^^^^^. S_REGISTER (0x1106); ^^^^^^^^^^^^^^^^^^^. S_BPREL32 (0x110b); ^^^^^^^^^^^^^^^^^^. S_LPROC32 (0x110f); ^^^^^^^^^^^^^^^^^^. S_GPROC32 (0x1110); ^^^^^^^^^^^^^^^^^^. S_REGREL32 (0x1111); ^^^^^^^^^^^^^^^^^^^. S_COMPILE2 (0x1116); ^^^^^^^^^^^^^^^^^^^. S_UNAMESPACE (0x1124); ^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst:4596,access,access,4596,interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/PDB/CodeViewSymbols.rst,1,['access'],['access']
Security,ues relating to TR 10176:2003; Unknown. 1106; C++11; Need more detail in nullptr keyword description; Unknown. 1107; C++11; Overload resolution for user-defined integer literals; Unknown. 1108; NAD; User-defined literals have not been implemented; Unknown. 1109; C++11; When is “use” a reference to the ODR meaning?; Unknown. 1110; NAD; Incomplete return type should be allowed in decltype operand; Unknown. 1111; C++11; Remove dual-scope lookup of member template names; Clang 3.2. 1112; C++11; constexpr variables should have internal linkage like const; Unknown. 1113; C++11; Linkage of namespace member of unnamed namespace; Partial. 1114; C++11; Incorrect use of placement new in example; Unknown. 1115; C++11; C-compatible alignment specification; Unknown. 1116; CD4; Aliasing of union members; Unknown. 1117; C++11; Incorrect note about xvalue member access expressions; Unknown. 1118; NAD; Implicit lambda capture via explicit copy constructor; Unknown. 1119; C++11; Missing case in description of member access ambiguity; Unknown. 1120; C++11; reinterpret_cast and void*; Unknown. 1121; C++11; Unnecessary ambiguity error in formation of pointer to member; Unknown. 1122; C++11; Circular definition of std::size_t; Unknown. 1123; C++11; Destructors should be noexcept by default; Unknown. 1124; NAD; Error in description of value category of pointer-to-member expression; Unknown. 1125; C++11; Unclear definition of “potential constant expression”; Unknown. 1126; C++11; constexpr functions in const initializers; Unknown. 1127; C++11; Overload resolution in constexpr functions; Unknown. 1128; C++11; attribute-specifiers in decl-specifier-seqs; Unknown. 1129; C++11; Default nothrow for constexpr functions; Unknown. 1130; C++11; Function parameter type adjustments and decltype; Unknown. 1131; C++11; Template aliases in elaborated-type-specifiers; Unknown. 1132; NAD; Keyword vs attribute for noreturn; Unknown. 1133; C++11; Keywords vs attributes for control of hiding and overriding; U,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:74216,access,access,74216,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"uests. Some servers, such as Amazon's,; respond to such kind of requests with the whole file contents. Other; servers, such as Huawei's, respond with the exact partial content; requested. Therefore, I added the possibility of configuring the; behavior via the ROOT configuration file: the identity of the; servers known to correctly support multi-range requests is; configurable. If the server is known to support this feature, ROOT; will send multi-range requests, otherwise it will issue multiple; single-range GET requests, which is also the default behavior.; - currently the virtual host syntax:; ""s3://mybucket.s3.amazonaws.com/path/to/my/file"" is not supported; but can be added if this is considered useful. The TAS3File class will be removed and should not have been used; directly by users anyway as it was only accessed via the plugin manager; in TFile::Open(). ### New HTTP Server package. A new HTTP Server package has been introduced. The idea behind such server is to provide direct access to the data from a running ROOT application. Any object can be streamed when requested and delivered to the browser. ##### Starting HTTP server. To start http server, at any time create instance; of the **`THttpServer`** class like:. ``` {.cpp}; serv = new THttpServer(""http:8080"");; ```. This will start civetweb-based http server on port 8080.; Then, one should be able to open address ""http://localhost:8080""; in any modern browser and browse objects created in application. By default, the server can access files, canvases and histograms via gROOT. All such objects can be displayed with JSRootIO graphics. At any time one could register other objects with the command:. ``` {.cpp}; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; ```. If the object content is changing in the application, like for example histograms being continuously filled, one could enable the monitoring flag in the browser, then the object view will be regularly updated. ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md:3147,access,access,3147,net/doc/v600/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/doc/v600/index.md,1,['access'],['access']
Security,"ug"", emissionKind: FullDebug,; enums: !2, retainedTypes: !3, globals: !4, imports: !5,; macros: !6, dwoId: 0x0abcd). Compile unit descriptors provide the root scope for objects declared in a; specific compilation unit. File descriptors are defined using this scope. These; descriptors are collected by a named metadata node ``!llvm.dbg.cu``. They keep; track of global variables, type information, and imported entities (declarations; and namespaces). .. _DIFile:. DIFile; """""""""""". ``DIFile`` nodes represent files. The ``filename:`` can include slashes. .. code-block:: none. !0 = !DIFile(filename: ""path/to/file"", directory: ""/path/to/dir"",; checksumkind: CSK_MD5,; checksum: ""000102030405060708090a0b0c0d0e0f""). Files are sometimes used in ``scope:`` fields, and are the only valid target; for ``file:`` fields. The ``checksum:`` and ``checksumkind:`` fields are optional. If one of these; fields is present, then the other is required to be present as well. Valid; values for ``checksumkind:`` field are: {CSK_MD5, CSK_SHA1, CSK_SHA256}. .. _DIBasicType:. DIBasicType; """""""""""""""""""""". ``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` and; ``float``. ``tag:`` defaults to ``DW_TAG_base_type``. .. code-block:: text. !0 = !DIBasicType(name: ""unsigned char"", size: 8, align: 8,; encoding: DW_ATE_unsigned_char); !1 = !DIBasicType(tag: DW_TAG_unspecified_type, name: ""decltype(nullptr)""). The ``encoding:`` describes the details of the type. Usually it's one of the; following:. .. code-block:: text. DW_ATE_address = 1; DW_ATE_boolean = 2; DW_ATE_float = 4; DW_ATE_signed = 5; DW_ATE_signed_char = 6; DW_ATE_unsigned = 7; DW_ATE_unsigned_char = 8. .. _DISubroutineType:. DISubroutineType; """""""""""""""""""""""""""""""". ``DISubroutineType`` nodes represent subroutine types. Their ``types:`` field; refers to a tuple; the first operand is the return type, while the rest are the; types of the formal arguments in order. If the first operand is ``null``, that; represents a function with no ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst:247825,checksum,checksumkind,247825,interpreter/llvm-project/llvm/docs/LangRef.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/LangRef.rst,1,['checksum'],['checksumkind']
Security,"ugh arrays from module ``array`` (or any; other builtin-type array that implements the Python buffer interface, such; as numpy arrays) and a low-level view type from ``cppyy`` for returns and; variable access (that implements the buffer interface as well).; Out-of-bounds checking is limited to those cases where the size is known at; compile time.; Example:. .. code-block:: python. >>> from cppyy.gbl import Concrete; >>> from array import array; >>> c = Concrete(); >>> c.array_method(array('d', [1., 2., 3., 4.]), 4); 1 2 3 4; >>> c.m_data[4] # static size is 4, so out of bounds; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: buffer index out of range; >>>. Arrays of arrays are supported through the C++ low-level view objects.; This only works well if sizes are known at compile time or can be inferred.; If sizes are not known, the size is set to a large integer (depending on the; array element size) to allow access.; It is then up to the developer not to access the array out-of-bounds.; There is limited support for arrays of instances, but those should be avoided; in C++ anyway:. .. code-block:: python. >>> cppyy.cppdef('std::string str_array[3][2] = {{""aa"", ""bb""}, {""cc"", ""dd""}, {""ee"", ""ff""}};'); True; >>> type(cppyy.gbl.str_array[0][1]); <class cppyy.gbl.std.string at 0x7fd650ccb650>; >>> cppyy.gbl.str_array[0][1]; 'bb'; >>> cppyy.gbl.str_array[4][0]; Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; IndexError: tuple index out of range; >>>. `Pointers`; """""""""""""""""""". When the C++ code takes a pointer or reference type to a specific builtin; type (such as an ``unsigned int`` for example), then types need to match; exactly.; ``cppyy`` supports the types provided by the standard modules ``ctypes`` and; ``array`` for those cases.; Example of using a reference to builtin:. .. code-block:: python. >>> from ctypes import c_uint; >>> u = c_uint(0); >>> c.uint_ref_assign(u, 42); >>> u.value; 42; >>>. For objects, an o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst:4141,access,access,4141,bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/basic_types.rst,1,['access'],['access']
Security,"uilder->GetInsertBlock()->getParent();. // Create an alloca for the variable in the entry block.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName);. // Emit the start code first, without 'variable' in scope.; Value *StartVal = Start->codegen();; if (!StartVal); return nullptr;. // Store the value into the alloca.; Builder->CreateStore(StartVal, Alloca);; ... // Compute the end condition.; Value *EndCond = End->codegen();; if (!EndCond); return nullptr;. // Reload, increment, and restore the alloca. This handles the case where; // the body of the loop mutates the variable.; Value *CurVar = Builder->CreateLoad(Alloca->getAllocatedType(), Alloca,; VarName.c_str());; Value *NextVar = Builder->CreateFAdd(CurVar, StepVal, ""nextvar"");; Builder->CreateStore(NextVar, Alloca);; ... This code is virtually identical to the code `before we allowed mutable; variables <LangImpl05.html#code-generation-for-the-for-loop>`_. The big difference is that we; no longer have to construct a PHI node, and we use load/store to access; the variable as needed. To support mutable argument variables, we need to also make allocas for; them. The code for this is also pretty simple:. .. code-block:: c++. Function *FunctionAST::codegen() {; ...; Builder->SetInsertPoint(BB);. // Record the function arguments in the NamedValues map.; NamedValues.clear();; for (auto &Arg : TheFunction->args()) {; // Create an alloca for this variable.; AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName());. // Store the initial value into the alloca.; Builder->CreateStore(&Arg, Alloca);. // Add arguments to variable symbol table.; NamedValues[std::string(Arg.getName())] = Alloca;; }. if (Value *RetVal = Body->codegen()) {; ... For each argument, we make an alloca, store the input value to the; function into the alloca, and register the alloca as the memory location; for the argument. This method gets invoked by ``FunctionAST::codegen()``; right after it sets up the entry block for the ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst:15471,access,access,15471,interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/tutorial/MyFirstLanguageFrontend/LangImpl07.rst,1,['access'],['access']
Security,"uint8_t) {}""); True; >>> cppyy.gbl.somefunc(2**16); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; ValueError: void ::somefunc(uint8_t) =>; ValueError: could not convert argument 1 (integer to character: value 65536 not in range [0,255]); >>>. But if other overloads are present that fail in a different way, the error; report will be a ``TypeError``:. .. code-block:: python. >>> cppyy.cppdef(r""""""; ... void somefunc(uint8_t) {}; ... void somefunc(std::string) {}""""""); True; >>> cppyy.gbl.somefunc(2**16); Traceback (most recent call last):; File ""<stdin>"", line 1, in <module>; TypeError: none of the 2 overloaded methods succeeded. Full details:; void ::somefunc(std::string) =>; TypeError: could not convert argument 1; void ::somefunc(uint8_t) =>; ValueError: could not convert argument 1 (integer to character: value 65536 not in range [0,255]); >>>. Since C++ exceptions are converted to Python ones, there is an interplay; possible between the two as part of overload resolution and ``cppyy``; allows C++ exceptions as such, enabling detailed type disambiguation and; input validation.; (The original use case was for filling database fields, requiring an exact; field label and data type match.). If, however, all methods fail and there is only one C++ exception (the other; exceptions originating from argument conversion, never succeeding to call; into C++), this C++ exception will be preferentially reported and will have; the original C++ type. `Return values`; ---------------. Most return types are readily amenable to automatic memory management: builtin; returns, by-value returns, (const-)reference returns to internal data, smart; pointers, etc.; The important exception is pointer returns.; ; A function that returns a pointer to an object over which Python should claim; ownership, should have its ``__creates__`` flag set through its; :doc:`pythonization <pythonizations>`.; Well-written APIs will have clear clues in their naming convention about the;",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst:11921,validat,validation,11921,bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/functions.rst,1,['validat'],['validation']
Security,"uint8_t> Data);. void BLAKE3::update(StringRef Str);; ```; ```c; void llvm_blake3_hasher_update(; llvm_blake3_hasher *self,; const void *input,; size_t input_len);; ```. Add input to the hasher. This can be called any number of times. ---. ```c++; template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; using BLAKE3Result = std::array<uint8_t, NumBytes>;. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; void BLAKE3::final(BLAKE3Result<NumBytes> &Result);. template <size_t NumBytes = LLVM_BLAKE3_OUT_LEN>; BLAKE3Result<NumBytes> BLAKE3::final();; ```; ```c; void llvm_blake3_hasher_finalize(; const llvm_blake3_hasher *self,; uint8_t *out,; size_t out_len);; ```. Finalize the hasher and return an output of any length, given in bytes.; This doesn't modify the hasher itself, and it's possible to finalize; again after adding more input. The constant `LLVM_BLAKE3_OUT_LEN` provides; the default output length, 32 bytes, which is recommended for most; callers. Outputs shorter than the default length of 32 bytes (256 bits) provide; less security. An N-bit BLAKE3 output is intended to provide N bits of; first and second preimage resistance and N/2 bits of collision; resistance, for any N up to 256. Longer outputs don't provide any; additional security. Shorter BLAKE3 outputs are prefixes of longer ones. Explicitly; requesting a short output is equivalent to truncating the default-length; output. (Note that this is different between BLAKE2 and BLAKE3.). ## Less Common API Functions. ```c; void llvm_blake3_hasher_init_keyed(; llvm_blake3_hasher *self,; const uint8_t key[LLVM_BLAKE3_KEY_LEN]);; ```. Initialize a `llvm_blake3_hasher` in the keyed hashing mode. The key must be; exactly 32 bytes. ---. ```c; void llvm_blake3_hasher_init_derive_key(; llvm_blake3_hasher *self,; const char *context);; ```. Initialize a `llvm_blake3_hasher` in the key derivation mode. The context; string is given as an initialization parameter, and afterwards input key; material should be given with `llvm_blake3_",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md:3784,secur,security,3784,interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/BLAKE3/README.md,1,['secur'],['security']
Security,"uish them from positive bins.; ; In THistPainter::PaintH3 the palette is drawn in case of option; COLZ. This is useful when a TTree 4D plot is painted with that option.; ; This image has been prodiced with the command:; ntuple->Draw(""px:py:pz:px*px"","""",""COLZ"");. TGraph2D. The operator ""="" was not correct. TGraph. Protection added in PaintPolyLineHatches (division by zero in some; cases).; All the graphical code has been moved from the TGraph classes to; TGraphPainter. TGraphPolar. Protection added in case a GraphPolar is plotted with option; ""E"" but has no errors defined.; The markers clipping (in TGraphPainter) was wrong in case of TGraphPolar.; The constructor's parameters naming was wrong.; Documentation: better example (easier to understand).; In the constructors some data members were not initialized. TPie. Add the TPie::GetEntries() method that return the number slices.; (Guido Volpi).; Implement Editors for TPie and TPieSlice (Guido Volpi). TPaletteAxis. Attributes are now accessible in the context menu.; (requested by Mathieu de Naurois <denauroi@in2p3.fr>). TPolyLine. Implement the possibility to draw TPolyLine in NDC coordinates; (it was partially done but the code was not used). Documentation. Better comments in THelix.; Option ""FUNC"" was not documented in THistPainter..; Update the help for animated gif generation in TPad.; Update TAttMarker documentation about the non scalable markers.; Re-writting of the THistPainter documentation. TCutG. The graphical cuts applied on histograms did not work when the cut name; contained a mix of lower and upper case characters. This problem occured; because the option used to draw an histogram was always converted into; lower case before begin stored in a pad (in Draw and DrawCopy). Now in; Draw() and DrawCopy() the AppendPad() procedure is called with the option; string not converted in lower; case. QT; Version 3 of QT is not supported anymore. If you install ROOT with the QT option; you must have QT version 4 already ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html:5376,access,accessible,5376,graf2d/doc/v520/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/doc/v520/index.html,2,['access'],['accessible']
Security,"uivalent and are instead made available by; mapping them onto the following conventional functions:. =================== ===================; C++ Python; =================== ===================; ``operator=`` ``__assign__``; ``operator++(int)`` ``__postinc__``; ``operator++()`` ``__preinc__``; ``operator--(int)`` ``__postdec__``; ``operator--()`` ``__predec__``; ``unary operator*`` ``__deref__``; ``operator->`` ``__follow__``; ``operator&&`` ``__dand__``; ``operator||`` ``__dor__``; ``operator,`` ``__comma__``; =================== ===================. Here is an example of operator usage, using STL iterators directly (note that; this is not necessary in practice as STL and STL-like containers work; transparently in Python for-loops):. .. code-block:: python. >>> v = cppyy.gbl.std.vector[int](range(3)); >>> i = v.begin(); >>> while (i != v.end()):; ... print(i.__deref__()); ... _ = i.__preinc__(); ...; 0; 1; 2; >>>. Overridden ``operator new`` and ``operator delete``, as well as their array; equivalents, are not accessible but will be called as appropriate. `Templates`; -----------. Templated classes are instantiated using square brackets.; (For backwards compatibility reasons, parentheses work as well.); The instantiation of a templated class yields a class, which can then; be used to create instances. Templated classes need not pre-exist in the bound code, just their; declaration needs to be available.; This is true for e.g. all of STL:. .. code-block:: python. >>> cppyy.gbl.std.vector # template metatype; <cppyy.Template 'std::vector' object at 0x7fffed2674d0>; >>> cppyy.gbl.std.vector(int) # instantiates template -> class; <class cppyy.gbl.std.vector<int> at 0x1532190>; cppyy.gbl.std.vector[int]() # instantiates class -> object; <cppyy.gbl.std.vector<int> object at 0x2341ec0>; >>>. The template arguments may be actual types or their names as a string,; whichever is more convenient.; Thus, the following are equivalent:. .. code-block:: python. >>> from cppyy.gbl.s",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst:11024,access,accessible,11024,bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/classes.rst,1,['access'],['accessible']
Security,"uld be submitted when; command is executed with cmd.json requests. Introduce restriction rules for objects access with THttpServer::Restrict() method.; Up to now general read-only flag was applied - either; everything read-only or everything is fully accessible.; Now one could restrict access to different parts of; objects hierarchy or even fully 'hide' them from the client.; Restriction based on user account name, which is applied; when htdigest authentication is configured.; One also able to allow execution of selected methods. Implement multi.bin and multi.json requests.; One could request many items with single HTTP request.; Let optimize communication between server and client. With *SNIFF* tag in ClassDef() comments one could expose different properties,; which than exposed by the TRootSniffer to the client with h.json requests.; Such possibility ease implementation of client-side code for custom classes. Allow to bind http port with loopback address.; This restrict access to http server only from localhost.; One could either specify 'loopback' option in constructor:; new THttpServer(""http:8080?loopback""); or in clear text specify IP address to which http socket should be bind:; new THttpServer(""http:127.0.0.1:8080""); If host has several network interfaces, one could select one for binding:; new THttpServer(""http:192.168.1.17:8080""). ### TNetXNGFileStager; Fixed ROOT-7703. This restores the behavior of Locate() to that found with; TXNetFileStager: Rather than return only the xrootd server's reply, the endpoint; hostname is looked up and Locate() returns the full url, including the path. ### TWebFile; Fixed ROOT-7809. Returns an error for a redirect which does not specify the new; URI, rather than going into a loop. Fixed ROOT-7817. Avoid a crash under some circumstances when trying to open an; invalid path. ## GUI Libraries. ## Montecarlo Libraries. ## Multi-processing. With this version we introduce a new module, core/multiproc, for multi-processing on multi-",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md:20074,access,access,20074,README/ReleaseNotes/v606/index.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/README/ReleaseNotes/v606/index.md,1,['access'],['access']
Security,"uld set the ``ASTNode`` field to; ``0`` to avoid polluting the AST. Note that anything inheriting from; ``TypeAttr`` or ``IgnoredAttr`` automatically do not generate an AST node. All; other attributes generate an AST node by default. The AST node is the semantic; representation of the attribute. The ``LangOpts`` field specifies a list of language options required by the; attribute. For instance, all of the CUDA-specific attributes specify ``[CUDA]``; for the ``LangOpts`` field, and when the CUDA language option is not enabled, an; ""attribute ignored"" warning diagnostic is emitted. Since language options are; not table generated nodes, new language options must be created manually and; should specify the spelling used by ``LangOptions`` class. Custom accessors can be generated for an attribute based on the spelling list; for that attribute. For instance, if an attribute has two different spellings:; 'Foo' and 'Bar', accessors can be created:; ``[Accessor<""isFoo"", [GNU<""Foo"">]>, Accessor<""isBar"", [GNU<""Bar"">]>]``; These accessors will be generated on the semantic form of the attribute,; accepting no arguments and returning a ``bool``. Attributes that do not require custom semantic handling should set the; ``SemaHandler`` field to ``0``. Note that anything inheriting from; ``IgnoredAttr`` automatically do not get a semantic handler. All other; attributes are assumed to use a semantic handler by default. Attributes; without a semantic handler are not given a parsed attribute ``Kind`` enumerator. ""Simple"" attributes, that require no custom semantic processing aside from what; is automatically provided, should set the ``SimpleHandler`` field to ``1``. Target-specific attributes may share a spelling with other attributes in; different targets. For instance, the ARM and MSP430 targets both have an; attribute spelled ``GNU<""interrupt"">``, but with different parsing and semantic; requirements. To support this feature, an attribute inheriting from; ``TargetSpecificAttribute`` m",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst:139631,access,accessors,139631,interpreter/llvm-project/clang/docs/InternalsManual.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/InternalsManual.rst,2,['access'],['accessors']
Security,"uld then compare any consecutive; 32 bit hashes values in the ``HASHES`` array as long as the hashes would be in; ``BUCKETS[3]``. We do this by verifying that each subsequent hash value modulo; ``n_buckets`` is still 3. In the case of a failed lookup we would access the; memory for ``BUCKETS[3]``, and then compare a few consecutive 32 bit hashes; before we know that we have no match. We don't end up marching through; multiple words of memory and we really keep the number of processor data cache; lines being accessed as small as possible. The string hash that is used for these lookup tables is the Daniel J.; Bernstein hash which is also used in the ELF ``GNU_HASH`` sections. It is a; very good hash for all kinds of names in programs with very few hash; collisions. Empty buckets are designated by using an invalid hash index of ``UINT32_MAX``. Details; ^^^^^^^. These name hash tables are designed to be generic where specializations of the; table get to define additional data that goes into the header (""``HeaderData``""),; how the string value is stored (""``KeyType``"") and the content of the data for each; hash value. Header Layout; """""""""""""""""""""""""". The header has a fixed part, and the specialized part. The exact format of the; header is:. .. code-block:: c. struct Header; {; uint32_t magic; // 'HASH' magic value to allow endian detection; uint16_t version; // Version number; uint16_t hash_function; // The hash function enumeration that was used; uint32_t bucket_count; // The number of buckets in this hash table; uint32_t hashes_count; // The total number of unique hash values and hash data offsets in this table; uint32_t header_data_len; // The bytes to skip to get to the hash indexes (buckets) for correct alignment; // Specifically the length of the following HeaderData field - this does not; // include the size of the preceding fields; HeaderData header_data; // Implementation specific header data; };. The header starts with a 32 bit ""``magic``"" value which must be ``'H",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst:68284,hash,hash,68284,interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/SourceLevelDebugging.rst,2,['hash'],['hash']
Security,"uld this be done? Just convert each function to a number, and gather; all of them in a special hash-table. Functions with equal hashes are equal.; Good hashing means, that every function part must be taken into account. That; means we have to convert every function part into some number, and then add it; into the hash. The lookup-up time would be small, but such an approach adds some; delay due to the hashing routine. Logarithmical search; """"""""""""""""""""""""""""""""""""""""; We could introduce total ordering among the functions set, once ordered we; could then implement a logarithmical search. Lookup time still depends on N,; but adds a little of delay (*log(N)*). Present state; """"""""""""""""""""""""""; Both of the approaches (random-access and logarithmical) have been implemented; and tested and both give a very good improvement. What was most; surprising is that logarithmical search was faster; sometimes by up to 15%. The; hashing method needs some extra CPU time, which is the main reason why it works; slower; in most cases, total ""hashing"" time is greater than total; ""logarithmical-search"" time. So, preference has been granted to the ""logarithmical search"". Though in the case of need, *logarithmical-search* (read ""total-ordering"") could; be used as a milestone on our way to the *random-access* implementation. Every comparison is based either on the numbers or on the flags comparison. In; the *random-access* approach, we could use the same comparison algorithm.; During comparison, we exit once we find the difference, but here we might have; to scan the whole function body every time (note, it could be slower). Like in; ""total-ordering"", we will track every number and flag, but instead of; comparison, we should get the numbers sequence and then create the hash number.; So, once again, *total-ordering* could be considered as a milestone for even; faster (in theory) random-access approach. MergeFunctions, main fields and runOnModule; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; There are tw",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst:6589,hash,hashing,6589,interpreter/llvm-project/llvm/docs/MergeFunctions.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/MergeFunctions.rst,2,['hash'],['hashing']
Security,"uled for May 29, 2012. Bindings - packages related to the interplay with other programming languages (Python, Ruby); Cint - the C++ interpreter; Core - the basic ROOT functionality; Geometry - building, representing and drawing geometrical objects; 2D Graphics - ROOT's two dimensional graphics interface; 3D Graphics - ROOT's three dimensional graphics interface; Graphical User Interface - from basic GUI elements to ROOT's own, complete dialogs; Histograming - counting values, spectra, and drawing them; HTML - the documentation generator; Input/Ouput - storing and reading data; Mathemathics - everything one can use to calculate: minimizers, matrixes, FFT, and much more; Miscellaneous - things that didn't make it into the other groups: table ; Monte Carlo - monte carlo and physics simulation interfaces; Networking - network-related parts, e.g. protocols and authentication interfaces; PROOF - parallel ROOT facility; RooFit - a fitting library; RooStats - a collection of statistical tools ; SQL - database interfaces; TMVA - multivariate analysis tools; Trees - ROOT's unique container class and related utilities; Tutorials - ROOT's Tutorials. For more information, see:. http://root.cern.ch; The following people have contributed to this new version:; Bertrand Bellenot, CERN/SFT,; Rene Brun, CERN/SFT,; Philippe Canal, FNAL,; Olivier Couet, CERN/SFT,; Kyle Cranmer, NYU/ATLAS, RooStats,; Sven Kreiss, NYU/ATLAS, RooStats,; Gena Kukartsev, CERN and FNAL/CMS, ; Gerri Ganis, CERN/SFT,; Andrei Gheata, CERN/Alice,; Christian Gumpert, CERN and University Dresden/ATLAS, Math,; Wim Lavrijsen, LBNL, PyRoot,; Sergei Linev, GSI,; Lorenzo Moneta, CERN/SFT,; Axel Naumann, CERN/SFT,; Eddy Offermann, Renaissance, ; Giovanni Petrucciani, UCSD/CMS, RooStats, ; Fons Rademakers, CERN/SFT,; Paul Russo, FNAL, ; Joerg Stelzer, DESY/Atlas, TMVA, ; Alja Tadel, UCSD/CMS, Eve, ; Matevz Tadel, UCSD/CMS, Eve, ; Eckhard von Toerne, University Bonn, ATLAS, TMVA, ; Wouter Verkerke, NIKHEF/Atlas, RooFit, ; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html:1280,authenticat,authentication,1280,doc/v532/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/doc/v532/index.html,2,['authenticat'],['authentication']
Security,"ules. Now the calls to initialize; functions from imported module units can be omitted if the initialize; function is known to be empty.; (`#56794 <https://github.com/llvm/llvm-project/issues/56794>`_). - Clang now allow to export declarations within linkage-specification.; (`#71347 <https://github.com/llvm/llvm-project/issues/71347>`_). Moved checkers; ^^^^^^^^^^^^^^. - Move checker ``alpha.unix.Errno`` out of the ``alpha`` package; to ``unix.Errno``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-errno-c>`__. - Move checker ``alpha.unix.StdCLibraryFunctions`` out of the ``alpha`` package; to ``unix.StdCLibraryFunctions``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#unix-stdclibraryfunctions-c>`__. - Move checker ``alpha.security.cert.env.InvalidPtr`` out of the ``alpha``; package to ``security.cert.env.InvalidPtr``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#security-cert-env-invalidptr>`__. - Move checker ``alpha.cplusplus.EnumCastOutOfRange`` out of the ``alpha``; package to ``optin.core.EnumCastOutOfRange``.; `Documentation <https://clang.llvm.org/docs/analyzer/checkers.html#optin-core-enumcastoutofrange-c-c>`__. .. _release-notes-sanitizers:. Sanitizers; ----------. - ``-fsanitize=signed-integer-overflow`` now instruments ``__builtin_abs`` and; ``abs`` builtins. Python Binding Changes; ----------------------. Additional Information; ======================. A wide variety of additional information is available on the `Clang web; page <https://clang.llvm.org/>`_. The web page contains versions of the; API documentation which are up-to-date with the Git version of; the source code. You can access versions of these documents specific to; this release by going into the ""``clang/docs/``"" directory in the Clang; tree. If you have any questions or comments about Clang, please feel free to; contact us on the `Discourse forums (Clang Frontend category); <https://discourse.llvm.org/c/clang/6>`_.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst:77421,sanitiz,sanitizers,77421,interpreter/llvm-project/clang/docs/ReleaseNotes.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ReleaseNotes.rst,2,"['access', 'sanitiz']","['access', 'sanitizers']"
Security,ull pointer constant?; Yes. 457; CD1; Wording nit on use of const variables in constant expressions; Yes. 458; C++11; Hiding of member template parameters by other members; Clang 11. 459; NAD; Hiding of template parameters by base class members; Unknown. 460; CD1; Can a using-declaration name a namespace?; Yes. 461; NAD; Make asm conditionally-supported; N/A. 462; CD3; Lifetime of temporaries bound to comma expressions; Unknown. 463; CD1; reinterpret_cast<T*>(0); N/A. 464; CD1; Wording nit on lifetime of temporaries to which references are bound; N/A. 465; NAD; May constructors of global objects call exit()?; N/A. 466; CD1; cv-qualifiers on pseudo-destructor type; No. 467; NAD; Jump past initialization of local static variable; Yes. 468; CD1; Allow ::template outside of templates; Yes (C++11 onwards). 469; NAD; Const template specializations and reference arguments; No. 470; CD1; Instantiation of members of an explicitly-instantiated class template; Yes. 471; NAD; Conflicting inherited access specifications; Clang 2.8. 472; drafting; Casting across protected inheritance; Not resolved. 473; NAD; Block-scope declarations of allocator functions; Unknown. 474; CD1; Block-scope extern declarations in namespace members; Clang 3.4. 475; C++11; When is std::uncaught_exception() true? (take 2); Unknown. 476; CD5; Determining the buffer size for placement new; Unknown. 477; CD1; Can virtual appear in a friend declaration?; Clang 3.5. 478; NAD; May a function parameter be an array of an abstract class type?; Yes. 479; CD1; Copy elision in exception handling; Clang 2.8. 480; CD1; Is a base of a virtual base also virtual?; Yes. 481; CD2; Scope of template parameters; Clang 2.8. 482; CD3; Qualified declarators in redeclarations; Clang 3.5. 483; CD3; Normative requirements on integral ranges; Yes. 484; CD1; Can a base-specifier name a cv-qualified class type?; Yes. 485; CD1; What is a “name”?; Yes. 486; CD1; Invalid return types and template argument deduction; Yes. 487; NAD; Oper,MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html:32212,access,access,32212,interpreter/llvm-project/clang/www/cxx_dr_status.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/www/cxx_dr_status.html,2,['access'],['access']
Security,"ult, civetweb web server with port number 8080 will be started.; It gets access to files, canvases and trees, registered in gROOT.; One additionally could register other objects to the server:. root [1] serv->Register(""abc/fold1"", hpx);; root [2] serv->Register(""abc/fold2"", hpxpy);; root [3] serv->Register(""extra"", c1);. Once server running, just open in any browser page: http://yourhost:8080. Example macro: $ROOTSYS/tutorials/http/httpserver.C. FAST CGI:. Instead of running http server, one could use fast cgi interface; to normal web server like Apache or lighttpd or any other.; When creating server, one could specify:. root [0] serv = new THttpServer(""fastcgi:9000"");. This opens port 9000, which should be specified in web server configuration.; For instance, lighttpd.conf file could contain path like this:. fastcgi.server = (; ""/remote_scripts/"" =>; (( ""host"" => ""192.168.1.10"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ). In this case one should be able to access root application via address. http://your_lighttpd_host/remote_scripts/root.cgi/. AUTHOR:. Sergey Linev, S.Linev@gsi.de. CHANGES:. January 2015; - Provide exe.json request to execute arbitrary object method and return; result in JSON format. Server should run in non-readonly mode. Fall 2014; - Implement gzip for result of any submitted requests, automatically done ; when .gz extension is provided; - Provide access to arbitrary data member of objects, registered to the server; - Prevent data caching in the browser by setting no-cache header. April 2014; - In TCivetweb class support digest authentication method. User; can specify auth_file and auth_domain parameters to protect; access to the server; - Fix error in FastCgi, now correctly works with Apache; - Avoid direct usage of TASImage. March 2014; - Replace mongoose by civetweb due to more liberal MIT license.; Works out of the box while civetweb version fully corresponds to; previously used version of mongoose.; - Introduce TB",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt:1155,access,access,1155,net/http/README.txt,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/README.txt,2,['access'],['access']
Security,"ults. `std::map`; ----------. C++'s ``map`` is an associative container similar to Python's ``dict``,; albeit one that has stronger type constraints.; A ``map`` can be instantiated from a ``dict`` (and types can be inferred) or; from a collection of ``pair`` mappings. .. code-block:: python. >>> from cppyy.gbl.std import map; >>> m = map[str, int](*(""one"", 1), (""two"", 2))) # type explicit, from pairs; >>> print(m); { ""one"" => 1, ""two"" => 2 }; >>> m = map({1: ""one"", 2: ""two""}) # type implicit, from dict; >>> type(m); <class cppyy.gbl.std.map<int,std::string> at 0x12d068d60>; >>> print(m); { 1 => ""one"", 2 => ""two"" }; >>>. `std::string`; -------------. Python's `str` is a unicode type since Python3, whereas ``std::string`` is; single-byte char-based.; Having the two correctly interact therefore deserves it's own; :doc:`chapter <strings>`. `std::tuple`; ------------. C++ ``tuple`` is supported but it should be noted that its use, and in; particular instantiating (heavily overloaded) ``get<>`` functions for member; access is inefficient.; They are really only meant for use when you have to pass a ``tuple`` to C++; code; and if returned from a C++ function, it is easier to simply unpack them.; In all other cases, prefer Python's builtin ``tuple``.; Example usage:. .. code-block:: python. >>> from cppyy.gbl.std import make_tuple, get; >>> t = make_tuple(1, '2', 5.); >>> print(t); <cppyy.gbl.std.tuple<int,std::string,double> object at 0x12033ee70>; >>> len(t); 3; >>> get[0](t) # access with templated std::get<>; 1; >>> get[1](t); b'2'; >>> get[2](t); 5.0; >>> a, b, c = t # unpack through iteration; >>> print(a, b, c); 1 2 5.0; >>>. .. rubric:: Footnotes. .. [#f1] The meaning of ""temporary"" differs between Python and C++: in a statement such as ``func(std.vector[int]((1, 2, 3)))``, there is no temporary as far as Python is concerned, even as there clearly is in the case of a similar statement in C++. Thus that call will succeed even if ``func`` takes a non-const reference.; ",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst:9020,access,access,9020,bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy/doc/source/stl.rst,1,['access'],['access']
Security,"um class S { Red };. C c;; S s;. enumType() matches the type of the variable declarations of both c and; s. Matcher<Type>functionProtoTypeMatcher<FunctionProtoType>...; Matches FunctionProtoType nodes. Given; int (*f)(int);; void g();; functionProtoType(); matches ""int (*f)(int)"" and the type of ""g"" in C++ mode.; In C mode, ""g"" is not matched because it does not contain a prototype. Matcher<Type>functionTypeMatcher<FunctionType>...; Matches FunctionType nodes. Given; int (*f)(int);; void g();; functionType(); matches ""int (*f)(int)"" and the type of ""g"". Matcher<Type>incompleteArrayTypeMatcher<IncompleteArrayType>...; Matches C arrays with unspecified size. Given; int a[] = { 2, 3 };; int b[42];; void f(int c[]) { int d[a[0]]; };; incompleteArrayType(); matches ""int a[]"" and ""int c[]"". Matcher<Type>injectedClassNameTypeMatcher<InjectedClassNameType>...; Matches injected class name types. Example matches S s, but not S<T> s.; (matcher = parmVarDecl(hasType(injectedClassNameType()))); template <typename T> struct S {; void f(S s);; void g(S<T> s);; };. Matcher<Type>lValueReferenceTypeMatcher<LValueReferenceType>...; Matches lvalue reference types. Given:; int *a;; int &b = *a;; int &&c = 1;; auto &d = b;; auto &&e = c;; auto &&f = 2;; int g = 5;. lValueReferenceType() matches the types of b, d, and e. e is; matched since the type is deduced as int& by reference collapsing rules. Matcher<Type>macroQualifiedTypeMatcher<MacroQualifiedType>...; Matches qualified types when the qualifier is applied via a macro. Given; #define CDECL __attribute__((cdecl)); typedef void (CDECL *X)();; typedef void (__attribute__((cdecl)) *Y)();; macroQualifiedType(); matches the type of the typedef declaration of X but not Y. Matcher<Type>memberPointerTypeMatcher<MemberPointerType>...; Matches member pointer types.; Given; struct A { int i; }; A::* ptr = A::i;; memberPointerType(); matches ""A::* ptr"". Matcher<Type>objcObjectPointerTypeMatcher<ObjCObjectPointerType>...; Matches an Objective-C o",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html:48889,inject,injectedClassNameType,48889,interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/LibASTMatchersReference.html,2,['inject'],['injectedClassNameType']
Security,"um likelihood fit; rf604_constraints.C - Fitting with constraints; rf605_profilell.C - Working with the profile likelihood estimator; rf606_nllerrorhandling.C - Understanding and customizing error handling in likelihood evaluations; rf607_fitresult.C - Demonstration of options of the RooFitResult class; ; SPECIAL PDFS. rf701_efficiencyfit.C - Unbinned maximum likelihood fit of an efficiency eff(x) function; rf702_efficiencyfit_2D.C - Unbinned maximum likelihood fit of an efficiency eff(x) function to; rf703_effpdfprod.C - Using a product of an (acceptance) efficiency and a p.d.f as p.d.f.; rf704_amplitudefit.C - Using a p.d.f defined by a sum of real-valued amplitude components; rf705_linearmorph.C - Linear interpolation between p.d.f shapes using the 'Alex Read' algorithm; rf706_histpdf.C - Histogram based p.d.f.s and functions; rf707_kernelestimation.C - Using non-parametric (multi-dimensional) kernel estimation p.d.f.s; rf708_bphysics.C - Special decay pdf for B physics with mixing and/or CP violation; ; VALIDATION AND MC STUDIES. rf801_mcstudy.C - A Toy Monte Carlo study that perform cycles of event generation and fittting; rf802_mcstudy_addons.C - RooMCStudy: using separate fit and generator models, using the chi^2 calculator model; rf803_mcstudy_addons2.C - RooMCStudy: Using the randomizer and profile likelihood add-on models; rf804_mcstudy_constr.C - Using RooMCStudy on models with constrains; ; Miscellaneous small improvements. A very large number of small fixes and interface improvements have been made in the context of the systematic review of all methods for the new tutorial macros and updated Users Manual.; Listed below are the most significant functionality upgrades that were introduced in the process. ; Runtime binding of C++ functions - You can now trivially bind at run time any C++ functions as a RooFit function or p.d.f. objects, e.g. RooAbsReal* erfx = bindFunction(""erfx"",TMath::erf,x). See rf105_funcbinding.C for details; Runtime binding of TFx fun",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html:6000,VALIDAT,VALIDATION,6000,roofit/doc/v522/index.html,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/v522/index.html,1,['VALIDAT'],['VALIDATION']
Security,"ument, since the term; *Code Generation* better helps visualize the transformation that is enabling; AD support. ## Current Status of Code Generation in RooFit. RooFit is an extensive toolkit.; The initiative to add AD support/ Code Generation has been started, but has; not yet achieved full coverage for the models defined/maintained in RooFit. ## How Clad enables AD support using Source Code Transformation. [Clad] is a C++ plugin for Clang. It implements a technique called Source Code; Transformation to enable AD support. Source Code Transformation takes the source code (that needs to be; differentiated) as the input and generates an output code that represents the; derivative of the input. This output code can be used instead of the input; code for more efficient compilation. For more technical details, please see the following paper:. > [Automatic Differentiation of Binned Likelihoods with RooFit and Clad](https://arxiv.org/abs/2304.02650). ## Overview on RooFit implementation details to access source code transformation AD. In RooFit jargon, what is meant by a ""RooFit class"" is a class inheriting from; RooAbsArg that represents a mathematical function, a PDF, or any other; transformation of inputs that are also represented by RooAbsArg objects.; Almost all final classes deriving from RooAbsArg have RooAbsReal as an; intermediate base class, which is the base class for all RooAbsArg that; represent real-valued nodes in the computation graph.; As such RooFit objects are so prevalent in practice, the names RooAbsArg and; RooAbsReal are used interchangeably in this guide. Users take these classes to build a computational graph that represents the; PDF (also called ""model"") that they want to use for fitting the data.; The user then passes his final PDF and a RooAbsData object to the; RooAbsPdf::fitTo() method, which implicitly creates a negative-log likelihood; (NLL) that RooFit minimizes for parameter estimation.; The NLL object, internally created by RooAbsPdf::cre",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md:2882,access,access,2882,roofit/doc/developers/roofit_ad.md,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/doc/developers/roofit_ad.md,1,['access'],['access']
Security,"umentation can be accepted in a format of a draft that can be further; refined during the implementation. Implementation guidelines; ^^^^^^^^^^^^^^^^^^^^^^^^^. This section explains how to extend clang with the new functionality. **Parsing functionality**. If an extension modifies the standard parsing it needs to be added to; the clang frontend source code. This also means that the associated macro; indicating the presence of the extension should be added to clang. The default flow for adding a new extension into the frontend is to; modify `OpenCLExtensions.def; <https://github.com/llvm/llvm-project/blob/main/clang/include/clang/Basic/OpenCLExtensions.def>`__,; containing the list of all extensions and optional features supported by; the frontend. This will add the macro automatically and also add a field in the target; options ``clang::TargetOptions::OpenCLFeaturesMap`` to control the exposure; of the new extension during the compilation. Note that by default targets like `SPIR-V`, `SPIR` or `X86` expose all the OpenCL; extensions. For all other targets the configuration has to be made explicitly. Note that the target extension support performed by clang can be overridden; with :option:`-cl-ext` command-line flags. .. _opencl_ext_libs:. **Library functionality**. If an extension adds functionality that does not modify standard language; parsing it should not require modifying anything other than header files and; ``OpenCLBuiltins.td`` detailed in :ref:`OpenCL builtins <opencl_builtins>`.; Most commonly such extensions add functionality via libraries (by adding; non-native types or functions) parsed regularly. Similar to other languages this; is the most common way to add new functionality. Clang has standard headers where new types and functions are being added,; for more details refer to; :ref:`the section on the OpenCL Header <opencl_header>`. The macros indicating; the presence of such extensions can be added in the standard header files; conditioned on target sp",MatchSource.DOCS,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst:9126,expose,expose,9126,interpreter/llvm-project/clang/docs/OpenCLSupport.rst,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/OpenCLSupport.rst,1,['expose'],['expose']
