quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"ence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed dur",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:4440,optimiz,optimize,4440,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,10,['optimiz'],['optimize']
Performance,"ence frequencies from energies for H2O. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. dft-jk; DFT JK on-disk test. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. cc13b; Tests RHF CCSD(T)gradients. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. omp2-3; OMP2 cc-pVDZ energy for the NO radical. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cbs-xtpl-energy; Extrapolated water energies - density-fitted version. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dft-grac; Gradient regularized asymptotic ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:29868,perform,performs,29868,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"ence, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == ""CONV"":; if module in [""""]:; core.print_out(""""""\nThis method is not available with conventional integrals. Add ""set """"""; """"""cc_type df"" or ""set cc_type cd"" to input to access this method.\n""""""); elif mtd_type == ""DF"":; if module in ["""", ""OCC""]:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop(""probe"", False):; return; else:; return func(name, **kwargs). def select_cc2(name, **kwargs):; """"""Function selecting the algorithm for a CC2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [LAB Aug 2022] I'm leaving MRCC CC2 in as a route, but my c.2014 MRCC consistently yields:; # ""Approximate CC methods are not implemented for excitation level 2!""; # [LAB Aug 2022] DF CC2 enabled for test_gradient but only by deliberate `set qc_module ccenergy`; # since not advertised. See #2710. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['CCENERGY']:; func = run_ccenergy; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif reference == 'ROH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:33653,perform,performance,33653,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['perform'],['performance']
Performance,"encies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency cal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.frequencies-1.html:1133,perform,performs,1133,psi4manual/1.3.2/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.frequencies-1.html,2,['perform'],['performs']
Performance,"encies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html:1111,perform,performs,1111,psi4manual/1.1.0/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.frequencies.html,3,['perform'],['performs']
Performance,"ency calculations. Behind; the scenes, frequency() is a light wrapper over; hessian() that computes the Hessian then adds a; thermochemical analysis. frequency(name[, molecule, return_wfn, func, mode, dertype, irrep])[source]¶; Function to compute harmonic vibrational frequencies. Aliases:frequencies(), freq(). Returns:float – Total electronic energy in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'hessian' || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – -1 || 1 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/freq-1.html:1555,perform,performed,1555,psi4manual/1.0.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/freq-1.html,2,['perform'],['performed']
Performance,"ene-methane; 'MeMe' dissociation curve for methane dimer; 'PyPy_S2' dissociation curve for pyridine dimer, sandwich; 'PyPy_T3' dissociation curve for pyridine dimer, t-shaped; 'BzBz_PD32' dissociation curve for benzene dimer, parallel displaced by 3.2A; 'BzBz_PD36' dissociation curve for benzene dimer, parallel displaced by 3.6A. S22by5¶. Database (Hobza) of interaction energies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'mol1' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 1; ...; 'mol22' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 22. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. RGC10¶. Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.; Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'HeHe' 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for helium-neon complex; 'HeAr' 18-point dissociation curve for helium-argon complex; 'HeKr' 18-point dissociation curve for helium-krypton complex; 'NeNe' 18-point dissociation curve for neon dimer; 'NeAr' 18-point dissociation curve for neon-argon complex; 'NeKr' 18-point dissociation curve for neon-krypton complex; 'ArAr' 18-point dissociation curve for argon dimer; 'ArKr' 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_available_databases-1.html:2807,optimiz,optimize,2807,psi4manual/4.0b2/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_available_databases-1.html,4,['optimiz'],['optimize']
Performance,"enerate doublet-Pi states and used in conjunction with SOPERT. Type: boolean; Default: false. CFOUR_BASIS (CFOUR); CFOUR — Specifies the AO basis used in the calculation. One can either specify a basis known to CFOUR or via BASIS=SPECIAL (=0) requests an arbitrary basis (see non-standard basis-set input). However, the latter must be available in the supplied GENBAS file. As standard basis sets, currently the following are available. Psi4 Interface: Recommended to use instead BASIS for larger basis set selection and greater flexibility. When BASIS used, CFOUR_SPHERICAL is set appropriately. Type: string; Default: SPECIAL. CFOUR_BRUCK_CONV (CFOUR); CFOUR — experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER (CFOUR); CFOUR — Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS (CFOUR); CFOUR — The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL (CFOUR); CFOUR — Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Default: SCF. CFOUR_CC_CONV (CFOUR); CFOUR — Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER (CFOUR); CFOUR — Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION (CFOUR); CFOUR — Specifies the type of convergence acce",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:24336,cache,cache,24336,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. mints-helper; A general test of the MintsHelper function. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. mp2-h; check that methods can act on single atom. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. casscf-sp; CASSCF/6-31G** energy point. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-func; optimization with method defined via cbs. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. scf-occ; force occupations in scf. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc5",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:34114,optimiz,optimization,34114,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-uhf-ccsdt; single-point CCSD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:1999,optimiz,optimization,1999,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"energy('scf',return_wfn=True); scf_wfn.to_file('my_wfn'); energy('scf', restart_file='my_wfn'). For advanced users manipulating or writing custom wavefunction files, note; that PSI4 expects the numpy file on disk to have the .npy extension, not, e.g., .npz. Convergence Stabilization¶; A summary of Psi’s supported convergence stabilization techniques is presented below:. DIIS [On by Default]DIIS uses previous iterates of the Fock matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via options. ADIIS [On by Default]ADIIS uses previous iterates of the Fock and density matrices to produce an; informed estimate of the next Fock matrix. ADIIS estimates are based on minimizing; an energy estimate rather than zeroing the residual, so this performs best in the early; iterations. By default, Psi will start using ADIIS before blending the ADIIS step with; the DIIS step, eventually using the pure DIIS step. The closely-related EDIIS procedure; may be used instead by setting SCF_INITIAL_ACCELERATOR. This is formally identical; to ADIIS for HF, but the methods will differ for more general DFT. MOM [Off by Default]MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure, a partially; converged orbital which should be occupied in the fully-optimized SCF solution; has a slightly higher orbital eigenvalue than some other orbital which should be; destined to be a virtual orbital. This results in the virtual orbital being; spuriously occupied for one or more iterations. Sometimes this resolves itself; without help, other times the occupation flips back and forth between two, four,; or more orbitals. This is typically v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:21677,perform,performs,21677,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,5,['perform'],['performs']
Performance,"energy(). elif (dertype == 1):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print(info). func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # call thermo module; PsiMod.thermo(). optstash.restore(); # TODO: add return statement. else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:63945,Load,Load,63945,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Load'],['Load']
Performance,"energy(): {core.variable('CURRENT ENERGY')}""). for postcallback in hooks['energy']['post']:; postcallback(lowername, wfn=wfn, **kwargs). basisstash.restore(); optstash.restore(); optstash2.restore(). if return_wfn: # TODO current energy safer than wfn.energy() for now, but should be revisited. # TODO place this with the associated call, very awkward to call this in other areas at the moment; if lowername in ['efp', 'mrcc', 'dmrg']:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the incoming reference wavefunction.\n\n""); elif 'sapt' in lowername:; core.print_out(""\n\nWarning! %s does not have an associated derived wavefunction."" % name); core.print_out(""The returned wavefunction is the dimer SCF wavefunction.\n\n""). return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def gradient(name, **kwargs):; r""""""Function complementary to :py:func:`~psi4.optimize()`. Carries out one gradient pass,; deciding analytic or finite difference. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total electronic gradient in Hartrees/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| gradient and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). """"""; ## First half of this fn -- entry means user wants a 1st derivative by any means. kwargs = p4util.kwargs_lower(kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:34904,optimiz,optimize,34904,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimize']
Performance,"energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] single-point energy reducing the Hartree-Fock basis sets size; >>> energy('allen_focal_point', scf_basis='cc-pV[TQ5]Z'). Return type; List[Dict[str, Any]]. Additional composite aliases are easy to define by the; user. Follow models in psi4/psi4/driver/aliases.py; and cbs-xtpl-nbody and use the; psi4.driver.driver_cbs_helper.register_composite_function(); to make ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:31562,perform,performed,31562,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,1,['perform'],['performed']
Performance,"enerically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC 1. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. 1; FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CASCI, in which a full CI is performed in some smaller; set of active orbitals; it is equivalent to CASSCF except without; any orbital optimization. It can be invoked via energy('fci'); with appropriate values selected for FROZEN_DOCC and; ACTIVE. For CI computations, there is no difference between; FROZEN_DOCC and RESTRICTED_DOCC, or between; FROZEN_UOCC and RESTRICTED_UOCC. There are; differences between these keywords for MCSCF: Multi-Configurational Self-Consistent-Field. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:6433,perform,performed,6433,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,10,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"enflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). # There's three-body code somewhere so exceptions may be needed; nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF (Dimer Basis)'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF (Dimer Basis)'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). activate(monomerAm); PsiMod.IO.set_default_namespace('monomerAm'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF (Monomer Basis)'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerBm); Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:29337,LOAD,LOAD,29337,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,"engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:63469,Optimiz,Optimize,63469,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,1,['Optimiz'],['Optimize']
Performance,"eng’s implementation in Cfour. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. scf-guess-read3; Test if the the guess read in the same basis converges. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. cbs-xtpl-func; optimization with method defined via cbs. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:17094,optimiz,optimization,17094,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ensity matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. serial-wfn; A simple hf/cc-pvdz water calculation. The resulting wavefunction is written to a file, and then a new wavefunction is generated from that file. The member variables of both wavefunctions should be identical in value. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. scf-upcast-custom-basis; test scf castup with custom basis sets. cc52; CCSD Response for H2O2. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. stability2; ROHF stability analysis check f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:3653,perform,performed,3653,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"ent beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None; Loads a matrix from an ASCII file in MPQC format. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; Returns the number of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:21594,load,load,21594,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"ent density matrix; obtained from the SAD guess, so the energy is unphysically low. However, the; first true iteration is quite close to the final DF energy, highlighting the; efficiency of the SAD guess. Pulay’s DIIS procedure is then used to accelerate; SCF convergence, with the DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested PK integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/conventional procedure can significantly accelerate SCF; computations requiring exact integrals, especially when used in concert with the; integral-direct conventional algorithm.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamilt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:3662,perform,performed,3662,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,4,['perform'],['performed']
Performance,"ent for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:112130,perform,perform,112130,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"ent molecule. Type: boolean; Default: false. PRINT_BASIS¶. Flag to print the basis set. Type: boolean; Default: false. PRINT_MOS¶. Flag to print the molecular orbitals. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html:2862,perform,performing,2862,psi4manual/1.2.1/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html,2,['perform'],['performing']
Performance,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float = 1e-12) → psi4.core.Dimension¶; Takes ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:11109,load,load,11109,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,6,['load'],['load']
Performance,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11452,load,load,11452,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11517,load,load,11517,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11466,load,load,11466,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11446,load,load,11446,psi4manual/1.8.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:135699,load,load,135699,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['load'],['load']
Performance,"ent of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: float=1e-12) → psi4.core.Dimension¶; Takes the matrix to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:10912,load,load,10912,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"ent of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-db3; Test that Python Molecule class processes geometry like PsiMod Molecule class. fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mp2_5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:2241,perform,performs,2241,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['perform'],['performs']
Performance,"ent of benzene, computed at the DF-SCF cc-pVDZ geometry. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc32; CC3/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. mp2_5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:2241,perform,performs,2241,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['perform'],['performs']
Performance,"ent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR)¶CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF, EXACT; Default: NO. CFOUR_VTRAN (CFOUR)¶CFOUR — This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD (CFOUR)¶CFOUR — Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL (CFOUR)¶CFOUR — The tolerance for storing transformed integrals. Integrals less than \(10^{-N}\) are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD (CFOUR)¶CFOUR — Specifies the Y-component of an external electric field. The valu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:84084,perform,performed,84084,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['perform'],['performed']
Performance,"ent(derivfunc, method, molecule, displacement, n, ndisp, **kwargs):; """"""A helper function to perform all processing for an individual finite; difference computation. Parameters; ----------; derivfunc : func; The function computing the target derivative.; method : str; A string specifying the method to be used for the computation.; molecule: psi4.core.molecule or qcdb.molecule; The molecule for the computation. All processing is handled internally.; molecule must not be modified!; displacement : dict; A dictionary containing the necessary information for the displacement.; See driver_findif/_geom_generator.py docstring for details.; n : int; The number of the displacement being computed, for print purposes.; ndisp : int; The total number of geometries, for print purposes. Returns; -------; wfn: :py:class:`~psi4.core.Wavefunction`; The wavefunction computed.; """""". # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n, ndisp)); print("""""" %d"""""" % (n), end=('\n' if (n == ndisp) else '')); sys.stdout.flush(). parent_group = molecule.point_group(); clone = molecule.clone(); clone.reinterpret_coordentry(False); clone.fix_orientation(True). # Load in displacement (flat list) into the active molecule; geom_array = np.reshape(displacement[""geometry""], (-1, 3)); clone.set_geometry(core.Matrix.from_array(geom_array)). # If the user insists on symmetry, weaken it if some is lost when displacing.; if molecule.symmetry_from_input():; disp_group = clone.find_highest_point_group(); new_bits = parent_group.bits() & disp_group.bits(); new_symm_string = qcdb.PointGroup.bits_to_full_name(new_bits); clone.reset_point_group(new_symm_string). # clean possibly necessary for n=1 if its irrep (unsorted in displacement list) different from initial G0 for freq; core.clean(). # Perform the derivative calculation; derivative, wfn = derivfunc(method, return_wfn=True, molecule=clone, **kwargs); displacement[""energy""] = core.variable('CURRENT EN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:5955,Load,Loading,5955,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Load'],['Loading']
Performance,"ent; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. 1; 2; 3; 4; 5; 6>>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:5357,optimiz,optimize,5357,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,2,['optimiz'],['optimize']
Performance,"enter. """"""; return BasisSet(self, center). @staticmethod; [docs] def build(molecule, shells):; """"""Builder factory method; * @param molecule the molecule to build the BasisSet around; * @param shells array of *atom-numbered* GaussianShells to build the BasisSet from; * @return BasisSet corresponding to this molecule and set of shells. """"""; raise FeatureNotImplemented('BasisSet::build'). @staticmethod; [docs] def pyconstruct_combined(mol, keys, targets, fitroles, others):. # make sure the lengths are all the same; if len(keys) != len(targets) or len(keys) != len(fitroles):; raise ValidationError(""""""Lengths of keys, targets, and fitroles must be equal""""""). # Create (if necessary) and update qcdb.Molecule; if isinstance(mol, basestring):; mol = Molecule(mol); returnBasisSet = False; elif isinstance(mol, Molecule):; returnBasisSet = True; else:; raise ValidationError(""""""Argument mol must be psi4string or qcdb.Molecule""""""); mol.update_geometry(). # load in the basis sets; sets = []; name = """"; for at in range(len(keys)):; bas = BasisSet.pyconstruct(mol, keys[at], targets[at], fitroles[at], others[at]); name += targets[at] + "" + ""; sets.append(bas). name = name[:-3].strip(); # work our way through the sets merging them; combined_atom_basis_shell = OrderedDict(); for at in range(len(sets)):; atom_basis_shell = sets[at].atom_basis_shell. for label, basis_map in atom_basis_shell.items():; if label not in combined_atom_basis_shell:; combined_atom_basis_shell[label] = OrderedDict(); combined_atom_basis_shell[label][name] = []; for basis, shells in basis_map.items():; combined_atom_basis_shell[label][name].extend(shells). #for label, basis_map in combined_atom_basis_shell.items():; # # sort the shells by angular momentum; # combined_atom_basis_shell[label][name] = sorted(combined_atom_basis_shell[label][name], key=lambda shell: she. # Molecule and parser prepped, call the constructor; mol.set_basis_all_atoms(name, ""CABS""). # Construct the grand BasisSet for mol; basisset = BasisS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html:15530,load,load,15530,psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/libmintsbasisset.html,1,['load'],['load']
Performance,"ential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. cc36; CC2(RHF)/cc-pVDZ energy of H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:18460,perform,performed,18460,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance,"ents have been observed to lead, in some cases, to I-SAPT energy contributions that do not make; physical sense, for example, to a strongly repulsive electrostatic energy between two fragments connected by an; intramolecular hydrogen bond.; To overcome this issue, Luu and Patkowski proposed a reassignment of the linking electron pairs so that each fragment; (C and A/B) gets one electron [Luu:2023:356]. This electron is placed on a hybrid orbital of the connecting atom; pointing in the direction of the interfragment bond. Several schemes for determining this link hybrid were proposed; in [Luu:2023:356] and they all are implemented in PSI4. We recommend the so-called SIAO1 scheme,; fisapt_link_assignment siao1, as it has been observed to provide consistently meaningful I-SAPT terms and a; smooth basis set convergence. The SIAO1 name implies that the projection to construct the link hybrids happens in the; intrinsic atomic orbital space (as opposed to the SAO1 method where the standard atomic orbital space is used), with; one iteration of fragment orbital optimization and link orbital orthogonalization, a process that very quickly; achieves self-consistency. Altogether, the allowed values for FISAPT_LINK_ASSIGNMENT are c (default),; ab (the opposite of c where the entire linking pair is assigned to A/B), sao0, sao1, sao2,; siao0, siao1 (recommended for all I-SAPT applications), and siao2 (essentially identical to siao1 but; slightly more expensive). Advanced I-SAPT Keywords for SAOn/SIAOn Partitionings¶. FISAPT_LINK_ORTHO¶. Orthogonalization of link orbitals for FISAPT_LINK_ASSIGNMENT=SAOx/SIAOx Link A orthogonalized to A in whole (interacting) molecule or in the (noninteracting) fragment?. Type: string; Possible Values: FRAGMENT, WHOLE, NONE; Default: FRAGMENT. FISAPT_EXCH_PARPERP¶. Calculate separate exchange corrections for parallel and perpendicular spin coupling of link orbitals? When false, only the averaged out exchange corrections are computed. Type: boolean; D",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/fisapt.html:14901,optimiz,optimization,14901,psi4manual/1.8.x/fisapt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/fisapt.html,3,['optimiz'],['optimization']
Performance,"ents of the quadrupole [Debye Ang] for the; configuration interaction singles and doubles level of theory and root. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [H] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [H] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [H] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [H] of the reference stage corresponding to; the CURRENT ENERGY variable. db_name DATABASE MEAN ABSOLUTE DEVIATION¶; The mean absolute deviation [kcal mol-1] of the requested method; name from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{| \textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn} | }\]. db_name DATABASE MEAN SIGNED DEVIATION¶; The mean deviation [kcal mol-1] of the requested method name; from the stored reference values for the requested reactions in; database db_name. If no reference is available, this will be a large; and nonsensical value. \[\frac{1}{n}\sum_{rxn}^{n}{\textsf{\textsl{name}}_{rxn}-\text{REF}_{rxn}}\]. db_name DATABASE ROOT-MEAN-SQUARE SIGNED DEVIATION¶; The rms deviation [kcal mol-1] of the requested method name; from the stored reference values f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:9974,optimiz,optimizer,9974,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,6,['optimiz'],['optimizer']
Performance,"ents. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. scf3; File retention, docc, socc, and bond distances specified explicitly. phi-ao; Test computing values of basis functions (puream and non-puream) at points. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. fisapt-siao1; This test case shows an example of running the I-SAPT0/jun-cc-pVDZ computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups) The SIAO1 link partitioning algorithm is used. An F-SAPT partitioning follows I-SAPT. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dforemp-grad1; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O molecule. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. aediis-1; ADIIS test case, from 10.1063/1.3304922. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-guess-read2; Test if the the guess read in the same basis converges. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. scf-level-shift-cuhf; SCF level shift on a CUHF computation. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:42647,optimiz,optimizations,42647,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance,"ents¶; Analytic gradients are available for the DC-06 method. Gradients are only; available if the ALGORITHM option is set to TWOSTEP or SIMULTANEOUS for; the energy computation. Evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dcft-1.html:10131,perform,perform,10131,psi4manual/4.0b5/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dcft-1.html,2,['perform'],['perform']
Performance,"environment and input files; for a calculation calling Kallay’s MRCC code. run_ocepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. run_ocepa_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OCEPA gradient calculation. run_oldmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2.5 computation. run_omp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2.5 gradient calculation. run_omp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_omp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP3 gradient calculation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. run_sapt_ct(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a charge-transfer SAPT calcuation of any level. run_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a self-consistent-field theory (HF & DFT) calculation. run_scf_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SCF gradie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:10902,optimiz,optimized,10902,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Need to move to the scratch directory, perferrably into a separate directory in that location; psi_io = core.IOManager.shared_object(); os.chdir(psi_io.get_default_path()). # Make new directory specifically for mrcc; mrcc_tmpdir = 'mrcc_' + str(os.getpid()); if 'path' in kwargs:; mrcc_tmpdir = kwargs['path']. # Check to see if directory already exists, if not, create.; if os.path.exists(mrcc_tmpdir) is False:; os.mkdir(mrcc_tmpdir). # Move into the new directory; os.chdir(mrcc_tmpdir). # Generate integrals and input file (dumps files to the current directory); core.mrcc_generate_input(ref_wfn, level). # Load the fort.56 file; # and dump a copy into the outfile; core.print_out('\n===== Begin fort.56 input for MRCC ======\n'); core.print_out(open('fort.56', 'r').read()); core.print_out('===== End fort.56 input for MRCC ======\n'). # Modify the environment:; # PGI Fortan prints warning to screen if STOP is used; lenv['NO_STOP_MESSAGE'] = '1'. # Obtain the number of threads MRCC should use; lenv['OMP_NUM_THREADS'] = str(core.get_num_threads()). # If the user provided MRCC_OMP_NUM_THREADS set the environ to it; if core.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; lenv['OMP_NUM_THREADS'] = str(core.get_option('MRCC', 'MRCC_OMP_NUM_THREADS')). # Call dmrcc, directing all screen output to the output file; external_exe = 'dmrcc'; try:; retcode = subprocess.Popen([external_exe], bufsize=0, stdout=subprocess.PIPE, env=lenv); except OSError as e:; sys.stderr.write('Program %s not found in path or execution failed: %s\n' % (external_exe, e.strerror)); core.print_out('Program %s not found",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:149423,Load,Load,149423,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Load'],['Load']
Performance,"eobase interactions [manual]. scs-mp2-vdw; a special version of SCS-MP2 (from ethene dimers) [manual]. sos-mp2; spin-opposite scaled MP2 [manual]. dlpno-mp2; local MP2 with pair natural orbital domains (DLPNO) [manual]. scs-dlpno-mp2; spin-component-scaled DLPNO MP2 [manual]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. scs-mp3; spin-component scaled MP3 [manual]. sos-pi-mp2; A special version of SOS-MP2 for pi systems [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual] [details]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order Møller–Plesset (MP) perturbation theory [manual] [details]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. scs-omp2; spin-component scaled OMP2 [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. scs-omp3; spin-component scaled OMP3 [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. omp2.5; orbital-optimized MP2.5 [manual] [details]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual] [details]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual] [details]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual] [details]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual] [details]. fno-aqcc; AQCC with frozen natural orbitals [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html:3054,optimiz,optimized,3054,psi4manual/1.7.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html,12,['optimiz'],['optimized']
Performance,"eomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:14857,optimiz,optimize,14857,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,9,['optimiz'],['optimize']
Performance,"eometry optimzation, with Z-matrix input, by finite-differences. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cc51; EOM-CC3/cc-pVTZ on H2O. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. sapt9; usapt example with empty beta. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cepa1; cc-pvdz H2O Test CEPA(1) Energy. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. cc56; EOM-CCSD/6-31g excited state transition data for water cation. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. fnocc5; Test FNO-DF-CCSD(T) energy. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. scf-uhf-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:6075,perform,performs,6075,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,4,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"eon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Footnotes. 1; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dftd3 program can be run independently of the scf; through the python function run_dftd3(). (This function; is the same PSI4/dftd3 interface that is called during an scf job.); This route is much faster than running a DFT-D energy. Some set-up:; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). The same four dispersion corrections/gradients as the section above:; >>> print nene.run_dftd3('bp86', 'd', dertype=0); -7.735e-05. >>> E, G = nene.run_dftd3('pbe', 'd3bj'); >>> print G; [[0.0, 0.0, -1.1809087569358e-05], [0.0, 0.0, 1.1809087569358e-05]]. >>> E, G = nene.run_dftd3('b3lyp', 'd2', {'s6': 1.20}); >>> print E; -8.84e-05. >>> E, G = nene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dftd3-1.html:8645,optimiz,optimize,8645,psi4manual/1.4.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dftd3-1.html,2,['optimiz'],['optimize']
Performance,"eory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set global basis cc-pVDZ; >>> set global reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn = True); >>> H2.set_multiplicity(3); >>> psi4.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). Previous topic; Notes on Options; Next topic; Property. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/energy-1.html:19993,perform,perform,19993,psi4manual/1.0.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/energy-1.html,2,['perform'],['perform']
Performance,"eory and arbitrary-order coupled-cluster computations for small molecules. General Options¶. AVG_STATES¶. Array giving the root numbers of the states to average in a state-averaged procedure such as SA-CASSCF. Root numbering starts from 1. Type: array; Default: No Default. AVG_WEIGHTS¶. Array giving the weights for each state in a state-averaged procedure. Type: array; Default: No Default. CIBLKS_PRINT¶. Do print a summary of the CI blocks?. Type: boolean; Default: false. CI_NUM_THREADS¶. Number of threads for DETCI. Type: integer; Default: 1. DETCI_FREEZE_CORE¶. Do freeze core orbitals?. Type: boolean; Default: true. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-6. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. ISTOP¶. Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 12. NUM_DETS_PRINT¶. Number of important determinants to print. Type: integer; Default: 20. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. S_SQUARED¶. Do calculate the value of for eac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html:1410,perform,perform,1410,psi4manual/4.0b2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__detci-1.html,8,['perform'],['perform']
Performance,"eous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradient method. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve R_CONVERGENCE residual convergence. The listed default will be used for the default value of R_CONVERGENCE. Type: conv double; Default: 1e-7. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; Default: 50. PPL_TYPE¶. Type of the CCSD PPL term. Type: string; Possible Values: LOW_MEM, HIGH_MEM, CD, AUTO; Default: AUTO. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. READ_SCF_3INDEX¶. Do read 3-index integrals from SCF files?. Type: boolean; Default: true. REGULARIZATION¶. Do use regularized denominators?. Type: boolean; Default: false. REG_PARAM¶. Regularization parameter. Type: double; Default: 0.4. REMP_A¶. mixing parameter for the REMP hybrid perturbation theory, A specifies the Moller-Plesset fraction. Type: double; Default: 0.15e0. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dfocc.html:5744,perform,perform,5744,psi4manual/1.7.x/autodir_options_c/module__dfocc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__dfocc.html,8,['perform'],['perform']
Performance,"eous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradient method. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve R_CONVERGENCE residual convergence. The listed default will be used for the default value of R_CONVERGENCE. Type: conv double; Default: 1e-7. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; Default: 50. PPL_TYPE¶. Type of the CCSD PPL term. Type: string; Possible Values: LOW_MEM, HIGH_MEM, CD, AUTO; Default: AUTO. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. READ_SCF_3INDEX¶. Do read 3-index integrals from SCF files?. Type: boolean; Default: true. REGULARIZATION¶. Do use regularized denominators?. Type: boolean; Default: false. REG_PARAM¶. Regularization parameter. Type: double; Default: 0.4. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. TRIPLES_IABC_TYPE¶. The algorithm to handle (ia|bc) type integrals that used for (T) correction. Type: string; Pos",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html:5743,perform,perform,5743,psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html,10,['perform'],['perform']
Performance,"epa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:30040,perform,performed,30040,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"epa,; # Upon adding a method to this list, add it to the docstring in energy() below; # If you must add an alias to this list (e.g., dfmp2/df-mp2), please search the; # whole driver to find uses of name in return values and psi variables and; # extend the logic to encompass the new alias.; },; 'gradient' : {; 'scf' : run_scf_gradient,; 'ccsd' : run_cc_gradient,; 'ccsd(t)' : run_cc_gradient,; 'mp2' : run_mp2_select_gradient,; 'conv-mp2' : run_mp2_gradient,; 'df-mp2' : run_dfmp2_gradient,; 'dfmp2' : run_dfmp2_gradient,; 'eom-ccsd' : run_eom_cc_gradient,; 'dcft' : run_dcft_gradient,; 'omp2' : run_omp2_gradient,; 'omp3' : run_omp3_gradient,; 'mp3' : run_mp3_gradient,; 'mp2.5' : run_mp2_5_gradient,; 'omp2.5' : run_omp2_5_gradient,; 'cepa0' : run_cepa0_gradient,; 'ocepa' : run_ocepa_gradient; # Upon adding a method to this list, add it to the docstring in optimize() below; },; 'hessian' : {; # Upon adding a method to this list, add it to the docstring in frequency() below; },; 'property' : {; 'scf' : run_scf_property,; 'cc2' : run_cc_property,; 'ccsd' : run_cc_property,; 'df-mp2' : run_dfmp2_property,; 'dfmp2' : run_dfmp2_property,; 'eom-cc2' : run_cc_property,; 'eom-ccsd' : run_cc_property,; # Upon adding a method to this list, add it to the docstring in property() below; }}. # Integrate DFT with driver routines; for ssuper in superfunctional_list():; procedures['energy'][ssuper.name().lower()] = run_dft. for ssuper in superfunctional_list():; if ((not ssuper.is_c_hybrid()) and (not ssuper.is_c_lrc()) and (not ssuper.is_x_lrc())):; procedures['gradient'][ssuper.name().lower()] = run_dft_gradient. [docs]def energy(name, **kwargs):; r""""""Function to compute the single-point electronic energy. :returns: (*float*) Total electronic energy in Hartrees. SAPT returns interaction energy. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`; * :psivar:`CURRENT REFERENCE ENERGY <CURRENTREFERENCEENERGY>`; * :psivar:`CURRENT CORRELATION ENERGY <CURRENTCO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:4432,optimiz,optimize,4432,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['optimiz'],['optimize']
Performance,"ependent code. Using the polarizable continuum model¶; The inclusion of a PCM description of the solvent into your calculation; is achieved by setting PCM true in your input file.; PSI4 understands the additional option PCM_SCF_TYPE with possible values total; (the default) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/pcmsolver-1.html:2646,optimiz,optimize,2646,psi4manual/1.2.1/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/pcmsolver-1.html,2,['optimiz'],['optimize']
Performance,"epresentative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number \(N\).; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dft-1.html:23454,optimiz,optimized,23454,psi4manual/1.1.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dft-1.html,2,['optimiz'],['optimized']
Performance,"ept for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. scf7; Tests SCF gradient in the presence of a dipole field. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. ao-casscf-sp; CASSCF/6-31G** energy point. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfcasscf-sp; CASSCF/6-31G** energy point. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. omp2-3; OMP2 cc-pVDZ energy for the NO radical. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:13267,optimiz,optimize,13267,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimize']
Performance,"equent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. Type of PCG beta parameter (Fletcher-Reeves or Polak-Ribiere). Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html:5442,perform,performed,5442,psi4manual/4.0b4/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html,8,['perform'],['performed']
Performance,"er Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; SAPT(DFT); Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT Results; Spin-Flip SAPT; Higher-Order Exchange Terms without Single-Exchange Approximation. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; Adding Point Charges to F/I-SAPT Computations; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; Interface to adcc. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States and Reaction Paths; Constrained Optimizations; Multi-Fragment Optimizations; Dealing with problematic optimizations; Convergence Criteria; Interface to GeomeTRIC; Output; Important User Changes from cpp-optking. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stockholder. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. TDSCF: Time-dependent Hartree–Fock and density-functional theory; Introduction; Known limitations; Theory; Psithon keywords; PsiAPI usage; Plotting one-photon absorption and electronic circular dichroism spectra. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/methods.html:3861,optimiz,optimizations,3861,psi4manual/1.7.x/methods.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/methods.html,1,['optimiz'],['optimizations']
Performance,"er as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__ccresponse.html:3790,CACHE,CACHELEVEL,3790,psi4manual/master/autodir_options_c/module__ccresponse.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__ccresponse.html,1,['CACHE'],['CACHELEVEL']
Performance,"er complex Size vs cost tradeoff is rough here. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. pywrap-align-chiral; testing aligner on enantiomers based on Table 1 of 10.1021/ci100219f aka J Chem Inf Model 2010 50(12) 2129-2140. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. dfccsd-t-grad2; DF-CCSD(T) cc-pVDZ gradient for the NH molecule. cdremp-2; Cholesky decomposed REMP/cc-pVDZ energies for the CH3 radical. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. mbis-1; MBIS calculation on H2O. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. pywrap-db1; Database calculation, so no molecule section i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:28464,optimiz,optimizations,28464,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance,"er convergence criteria are the same. [3](1, 2) Counterpart NWCHEM convergence criteria are the same. [4](1, 2, 3) Convergence achieved when all active criteria are fulfilled. [5](1, 2, 3) Convergence achieved when Max Force and one of Max Energy or Max Disp are fulfilled. [6](1, 2, 3, 4, 5) Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100rms force is less; than RMS Force criterion. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:12833,optimiz,optimization,12833,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,10,['optimiz'],['optimization']
Performance,"er iterations from old \(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important \(t_1\) and \(t_2\) amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled cluster modules that is not accounted for by the internal CC memory; handling routines. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cc-1.html:6263,cache,cache,6263,psi4manual/1.2.1/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cc-1.html,15,['cache'],['cache']
Performance,"er of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:7449,cache,cache,7449,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,6,['cache'],['cache']
Performance,"er(self); docstring. print_orbitals(self); docstring. print_preiterations(self); docstring. push_back_external_potential(self, V); Add an external potential to the private external_potentials list. reset_occupation(self); docstring. rotate_orbitals(self, arg0, arg1); docstring. save_density_and_energy(self); docstring. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self, arg0, arg1); docstring. set_jk(self, arg0); Sets the internal JK object !expert. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; docstring. iteration_¶; docstring. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_potentials(self: psi4.core.HF) → None¶; Clear private external_potentials list. compute_E(self: psi4.core.HF) → float¶; docstring. compute_energy()¶; Base class Wavefunction requires this function. Here it is; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:4044,perform,performed,4044,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['perform'],['performed']
Performance,"er. psi4.core.has_variable(arg0: str) → bool¶; Returns true if the PSI variable exists/is set. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:153716,optimiz,optimization,153716,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['optimiz'],['optimization']
Performance,"er.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]; def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:44782,Perform,Perform,44782,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['Perform'],['Perform']
Performance,"er.debug(pp.pformat(plan.dict())). if kwargs.get(""return_plan"", False):; # Plan-only requested; return plan. elif not isinstance(plan, AtomicComputer):; # Advanced ""Computer"" active; plan.compute(); return plan.get_psi_results(return_wfn=return_wfn). else:; # We have unpacked to an AtomicInput; lowername = plan.method; basis = plan.basis; core.set_global_option(""BASIS"", basis). ## Second half of this fn -- entry means program running exactly analytic 1st derivative. # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util.negotiate_convergence_criterion((1, 1), lowername, return_optstash=True). # Commit to procedures[] call hereafter; core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; logger.info(f""Compute gradient(): method={lowername}, basis={core.get_global_option('BASIS').lower()}, molecule={molecule.name()}, nre={'w/EFP' if hasattr(molecule, 'EFP') else molecule.nuclear_repulsion_energy()}""); logger.debug(""w/EFP"" if hasattr(molecule, ""EFP"") else pp.pformat(molecule.to_dict())); wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs); logger.info(f""Return gradient(): {core.variable('CURRENT ENERGY')}""); logger.info(nppp(wfn.gradient().np)). basisstash.restore(); optstash.restore(). driver_findif.gradient_write(wfn). if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). [docs]def properties(*args, **kwargs):; r""""""Function to compute various properties. :aliases: prop(). :returns: none. .. caution:: Some features are not yet implemented. Buy a developer a coffee. - This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. +---",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:38095,Perform,Perform,38095,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['Perform'],['Perform']
Performance,"er/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:21090,optimiz,optimization,21090,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"er; Default: 1. SOLVER_N_ROOT¶. Number of roots to converge for all irreps during instability analysis. (Overridden by SOLVER_ROOTS_PER_IRREP.). Type: integer; Default: 1. SOLVER_ROOTS_PER_IRREP¶. Number of roots to converge, per irrep, during instability analysis. (Overrides SOLVER_N_ROOT.). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html:9289,perform,perform,9289,psi4manual/1.7.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html,8,['perform'],['perform']
Performance,"er; Default: 6. CC_DIIS_MIN_VECS¶. Minimum number of vectors used in amplitude DIIS. Type: integer; Default: 2. CC_LAMBDA¶. Do solve lambda amplitude equations?. Type: boolean; Default: false. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CHOLESKY¶. Do Cholesky decomposition of the ERI tensor. Type: boolean; Default: false. CHOLESKY_TOLERANCE¶. tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. COMPUT_S2¶. Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 8. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. EKT_IP¶. Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html:1269,perform,perform,1269,psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,48,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"er; Default: PSIF_OEI. OEI_B_FILE¶. Type: integer; Default: PSIF_OEI. OEI_FILE¶. Type: integer; Default: PSIF_OEI. OPDM_IN_FILE¶. Type: integer; Default: PSIF_MO_OPDM. OPDM_OUT_FILE¶. Type: integer; Default: PSIF_AO_OPDM. PITZER¶. Do ?. Type: boolean; Default: false. PRESORT_FILE¶. Type: integer; Default: PSIF_SO_PRESORT. PRINT_LVL¶. Type: integer; Default: 1. PRINT_MOS¶. Do ?. Type: boolean; Default: false. PRINT_OE_INTEGRALS¶. Do ?. Type: boolean; Default: false. PRINT_REORDER¶. Do ?. Type: boolean; Default: false. PRINT_SORTED_OE_INTS¶. Do ?. Type: boolean; Default: false. PRINT_SORTED_TE_INTS¶. Do ?. Type: boolean; Default: false. PRINT_TE_INTEGRALS¶. Do ?. Type: boolean; Default: false. PSIMRCC¶. Do ?. Type: boolean; Default: false. QRHF¶. Do ?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. REORDER¶. Do ?. Type: boolean; Default: false. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SORTED_TEI_FILE¶. Type: integer; Default: PSIF_MO_TEI. SO_S_FILE¶. Type: integer; Default: PSIF_OEI. SO_TEI_FILE¶. Type: integer; Default: PSIF_SO_TEI. SO_T_FILE¶. Type: integer; Default: PSIF_OEI. SO_V_FILE¶. Type: integer; Default: PSIF_OEI. TPDM_ADD_REF¶. Do ?. Type: boolean; Default: false. TPDM_FILE¶. Type: integer; Default: PSIF_MO_TPDM. Expert¶. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__transqt-1.html:2848,optimiz,optimized,2848,psi4manual/4.0b2/autodir_options_c/module__transqt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__transqt-1.html,4,['optimiz'],['optimized']
Performance,"erValue class in qcdb.libmintscoordentry. nunique() LibmintsMolecule method. O. OCC_ORBS_PRINT (OCC). OCC_TOLERANCE (FNOCC). (SAPT). OCEPA; . setting keywords. theory. OCEPA(0)CORRELATIONENERGY. OCEPA(0)TOTALENERGY. OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3], [4]. PB_LAMBDA (DFTSAPT). PCG_BETA_TYPE (OCC). PCG_CONVERGENCE (OCC). PCG_MAXITER (OCC). PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:31239,optimiz,optimize,31239,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['optimiz'],['optimize']
Performance,"eraction energy between Ne and Ar atoms. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. pywrap-align; apply linear fragmentation algorithm to a water cluster. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. mp2-h; check that methods can act on single atom. nbody-he-4b; MP2/aug-cc-pvDZ many body energies of an arbitrary Helium complex, addressing 4-body formulas. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. ao-dfcasscf-sp; CASSCF/6-31G** energy point. sapt0-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:26605,optimiz,optimization,26605,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"eral contraction scheme, and UNCONTRACTED (=2) uses the corresponding uncontracted sets. Note that even for truly segmented basis sets, the integral programs run significantly faster in the GENERAL mode. Type: string; Possible Values: SEGMENTED, GENERAL, UNCONTRACTED; Default: GENERAL. CFOUR_CONVERGENCE (CFOUR)¶CFOUR — Identical to CFOUR_GEO_CONV. Type: integer; Default: 4. CFOUR_COORDINATES (CFOUR)¶CFOUR — Specifies the type of coordinates used in the input file ZMAT. Value INTERNAL (=0) means that the geometry is supplied in the usual Z-matrix format, while CARTESIAN (=1) means that the geometry is given in Cartesian coordinates. A third option is XYZINT (=2) for which a Z-matrix connectivity is defined, but with values of the internal coordinates defined implicitly by supplying Cartesian coordinates. Note that geometry optimizations are currently only possible for INTERNAL and XYZ2INT. Psi4 Interface: Keyword set from active molecule, always CARTESIAN. Above restrictions on geometry optimizations no longer apply. Type: string; Possible Values: INTERNAL, CARTESIAN, XYZINT; Default: INTERNAL. CFOUR_CORE_ORBITALS (CFOUR)¶CFOUR — Specifies the core orbitals used in a TCSCF calculation and has to be used in combination with the keyword CFOUR_ACTIVE_ORBI. The core orbitals are specified by either NIRREP or 2*NIRREP integers specifying the number of core orbitals of each symmetry type, where NIRREP is the number of irreducible representations in the computational point group. If there are no orbitals of a particular symmetry type a zero must be entered. For more information and an example see CFOUR_OCCUPATION. Type: array; Default: No Default. CFOUR_CPHF_CONVER (CFOUR)¶CFOUR — Specifies the convergence criterion for the iterative solution of the CPHF and Z-vector equations. The solutions are considered to be converged when the residual norm of the error vector falls below \(10^N\). Type: integer; Default: 12. CFOUR_CPHF_MAXCYC (CFOUR)¶CFOUR — Specifies the maximum numbe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:30185,optimiz,optimizations,30185,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['optimiz'],['optimizations']
Performance,"eral fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; set intcos_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:8199,perform,perform,8199,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['perform'],['perform']
Performance,"eration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58062,optimiz,optimizer,58062,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['optimiz'],['optimizer']
Performance,"erative quintuples (all but the most expensive terms) |; +-------------------------+---------------------------------------------------------------------------------------+; | mrccsdtqph-3 | CC through quintuples with iterative sextuples (all but the most expensive terms) |; +-------------------------+---------------------------------------------------------------------------------------+. :type name: string; :param name: ``'scf'`` || ``'df-mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. .. comment :type cast_up: :ref:`boolean <op_py_boolean>` or string; .. comment :param cast_up: ``'on'`` || |dl| ``'off'`` |dr| || ``'3-21g'`` || ``'cc-pVDZ'`` || etc. .. comment Indicates whether, to accelerate convergence for the scf portion of; .. comment the *name* calculation, a preliminary scf should be performed with a; .. comment small basis set (3-21G if a basis name is not supplied as keyword; .. comment value) followed by projection into the full target basis. .. comment .. deprecated:: Sept-2012; .. comment Use option |scf__basis_guess| instead. .. comment :type cast_up_df: :ref:`boolean <op_py_boolean>` or string; .. comment :param cast_up_df: ``'on'`` || |dl| ``'off'`` |dr| || ``'cc-pVDZ-RI'`` || ``'aug-cc-pVDZ-JKFIT'`` || etc. .. comment Indicates whether, when *cast_up* is active, to run the preliminary; .. comment scf in density-fitted mode or what fitting basis to employ (when; .. comment available for all elements, cc-pVDZ-RI is the default). .. comment .. deprecated:: Sept-2012; .. comment Use option |scf__df_basis_guess| instead. :type bypass_scf: :ref:`boolean <op_py_boolean>`; :param bypass_scf: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether, for *name* values built atop of scf calculations,; the scf step is skipped. Suitable when special step",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:27125,perform,performed,27125,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,['perform'],['performed']
Performance,"ercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequencies; frequencies(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:2862,optimiz,optimize,2862,psi4manual/1.8.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html,2,['optimiz'],['optimize']
Performance,"ercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). table of contents. frequencies; frequencies(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequencies.html:2862,optimiz,optimize,2862,psi4manual/1.9.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequencies.html,2,['optimiz'],['optimize']
Performance,"ere the recommended exponent is \(\alpha = 1\). To obtain SAPT energies with this scaling,; simply set the keyword exch_scale_alpha true. Alternatively, another value for \(\alpha\); can be specified by setting EXCH_SCALE_ALPHA to a value. For example,; set exch_scale_alpha 1.0. will set \(\alpha = 1.0\) and scale exchange energies with \(p_{EX}(1.0)\).; Instead of this straightforward scaling, SAPT0 energies benefit from a slightly modified; recipe that involves an empirically adjusted exponent \(\alpha = 3.0\).; To distinguish it from its unscaled counterpart, this energy is denoted sSAPT0 (see [Parker:2014:094106]). (9)¶\[E_{sSAPT0} = E_{elst}^{(10)} + E_{exch}^{(10)} + E_{ind,resp}^{(20)} +; p_{EX}(3.0) E_{exch-ind,resp}^{(20)} + E_{disp}^{(20)} + p_{EX}(3.0) E_{exch-disp}^{(20)}; + \delta_{HF}^{(2)}\]; where \(\delta_{HF}^{(2)}\) is computed without any scaling. Please note that; sSAPT0 is thus not the same as requesting exch_scale_alpha 3.0, and that the; scaling is automatically performed by requesting energy('ssapt0'). A First Example¶; The following is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods,; not all of them).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis aug-cc-pvdz. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the exampl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:9890,perform,performed,9890,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,7,['perform'],['performed']
Performance,"erence gradients are not marked explicitly by “∷”, but the capability can be gleaned from the energy availability. [4]; (1,2,3); Finite difference Hessians are not marked explicitly by “∷”, but the capability can be gleaned from the gradient or energy availability. [5]; DH-DFT only available with DF-MP2. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dft.html:27032,perform,performs,27032,psi4manual/1.7.x/dft.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dft.html,4,['perform'],['performs']
Performance,"erence wavefunction type for EOM computations. Type: string; Default: RHF. EP_EA_POLES (OCC); OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC); OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC); OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI); DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI); DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT); SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM); CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF); CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF); SCF — An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS); GLOBALS (Expert) — Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. FAIL_ON_MAXITER (SCF); SCF — Fail if we reach maxiter withou",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:120032,perform,performs,120032,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,2,['perform'],['performs']
Performance,"erence""][""energy""]:15.10f}; Check energies below for precision!; Forces are for mass-weighted, symmetry-adapted cartesians [a0].\n"""""". data = _initialize_findif(mol, -1, ""1_0"", findifrec['stencil_size'], findifrec['step']['size'], init_string,; findifrec['project_translations'], findifrec['project_rotations'], False); salc_indices = data[""salc_indices_pi""][0]. # Extract the energies, and turn then into an ndarray for easy manipulating; # E(i, j) := Energy on displacing the ith SALC we care about in the jth step; # Steps are ordered, for example, -2, -1, 1, 2; max_disp = (findifrec[""stencil_size""] - 1) // 2 # The numerator had better be divisible by two.; e_per_salc = 2 * max_disp; E = np.zeros((len(salc_indices), e_per_salc)). for i, salc_index in enumerate(salc_indices):; for j in range(1, max_disp + 1):; E[i, max_disp - j] = findifrec[""displacements""][f""{salc_index}: {-j}""][""energy""]; E[i, max_disp + j - 1] = findifrec[""displacements""][f""{salc_index}: {j}""][""energy""]. # Perform the finite difference.; if findifrec[""stencil_size""] == 3:; g_q = (E[:, 1] - E[:, 0]) / (2.0 * findifrec[""step""][""size""]); elif findifrec[""stencil_size""] == 5:; g_q = (E[:, 0] - 8.0 * E[:, 1] + 8.0 * E[:, 2] - E[:, 3]) / (12.0 * findifrec[""step""][""size""]); else: # This error SHOULD have already been caught, but just in case...; raise ValidationError(""FINDIF: {} is an invalid number of points."".format(findifrec[""stencil_size""])); g_q = np.asarray(g_q). if data[""print_lvl""]:; energy_string = """"; for i in range(1, max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:21650,Perform,Perform,21650,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Perform'],['Perform']
Performance,"erence. This probably only makes sense for Full CI, and it would probably not work with unit vector guesses. Numbering starts from zero for the totally-symmetric irrep. Type: integer; Default: -1. REORDER (TRANSQT); TRANSQT — Do ?. Type: boolean; Default: false. REPL_OTF (DETCI); DETCI (Expert) — Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. RESPONSE_ALGORITHM (DCFT); DCFT — The algorithm to use for the solution of the response equations for the analytic gradients and properties. Two-step algorithm is generally more efficient than simultaneous and is used by default. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. RESTART (CCENERGY); CCENERGY — Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. RESTART (CCLAMBDA); CCLAMBDA — Do ?. Type: boolean; Default: false. RESTART (CCRESPONSE); CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk; the number of vectors specified by RESTART_VECS (obsolete) is collapsed down to one vector per root. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. RESTRICTED_DOCC (DETCI); DETCI — An array giving the number of restricted doubly-occupied orbitals per irrep (no",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:82632,optimiz,optimizations,82632,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimizations']
Performance,"erforms both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fci-h2o; 6-31G H2O Test FCI Energy Point. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. ao-casscf-sp; CASSCF/6-31G** energy point. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cubeprop; RHF orbitals and density for water. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:13519,optimiz,optimization,13519,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"erge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :ra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60209,optimiz,optimizer,60209,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['optimiz'],['optimizer']
Performance,"erge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :rais",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58435,optimiz,optimizer,58435,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,8,['optimiz'],['optimizer']
Performance,"ergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. SS vectors stored per root. Type: integer; Default: 5. T3_WS_INCORE¶. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. VECS_CC3¶. Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT¶. Vectors stored per root. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. table of contents. CCEOM; General; ABCD; CACHELEVEL; CACHETYPE; CC3_FOLLOW_ROOT; CC_NUM_THREADS; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; EOM_GUESS; EOM_REFERENCE; E_CONVERGENCE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; R_CONVERGENCE; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT. Expert; EXCITATION_RANGE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__cceom.html:7031,CACHE,CACHELEVEL,7031,psi4manual/1.8.x/autodir_options_c/module__cceom.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__cceom.html,2,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"ergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. SS vectors stored per root. Type: integer; Default: 5. T3_WS_INCORE¶. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. VECS_CC3¶. Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT¶. Vectors stored per root. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. table of contents. CCEOM; General; ABCD; CACHELEVEL; CACHETYPE; CC3_FOLLOW_ROOT; CC_NUM_THREADS; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; EOM_GUESS; EOM_REFERENCE; E_CONVERGENCE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; R_CONVERGENCE; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT. Expert; EXCITATION_RANGE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__cceom.html:7031,CACHE,CACHELEVEL,7031,psi4manual/1.9.x/autodir_options_c/module__cceom.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__cceom.html,2,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"ergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10--------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optking-1.html:15561,optimiz,optimizations,15561,psi4manual/1.2.1/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optking-1.html,6,['optimiz'],"['optimizations', 'optimize']"
Performance,"ergy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. select_omp3(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. select_omp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. check_iwl_file_from_scf_type(scf_type, wfn)[source]¶; Ensures that a IWL file has been written based on input SCF type. check_non_symmetric_jk_density(name)[source]¶; Ensure non-symmetric density matrices are supported for the selected JK routine. dft_set_reference_local(name)[source]¶; Figures out the correct DFT reference to set locally. oeprop_validator(prop_list)[source]¶; Validations a list of OEProp computations. Throws if not found. scf_set_reference_local(name)[source]¶; Figures out the correct SCF reference to set locally. run_roa(name, **kwargs)[source]¶; Main driver for managing Raman Optical activity computations with; CC response theory. Uses distributed finite differences approach –>. Sets up a database to keep track of running/finished/waiting; computations. Generates separate input files for displaced geometries. When all displacements are run, collects the necessary information; from ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:170732,perform,performance,170732,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"ergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceEr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:60260,optimiz,optimizer,60260,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,6,['optimiz'],['optimizer']
Performance,"ergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.OptimizationConvergenceError` if :",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:58486,optimiz,optimizer,58486,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['optimiz'],['optimizer']
Performance,"ergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceErro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:60237,optimiz,optimizer,60237,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizer']
Performance,"eria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10--------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Output. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:15172,optimiz,optimizations,15172,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],"['optimizations', 'optimize']"
Performance,"erial()¶; Converts serialized data to the correct Psi4 data type. Parameters:. self – Pointer to which class to be constructed.; json_data (Dict[str, Any]) – Serialization of class. See to_serial() for data layout. Return type:; Union[Matrix, Vector]. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html:5063,load,load,5063,psi4manual/1.7.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Vector.html,2,['load'],['load']
Performance,"erial()¶; Converts serialized data to the correct Psi4 data type. Parameters:. self – Pointer to which class to be constructed.; json_data (Dict[str, Any]) – Serialization of class. See to_serial() for data layout. Return type:; Union[Matrix, Vector]. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: psi4.core.Vector, sc: flo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html:5405,load,load,5405,psi4manual/1.8.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Vector.html,2,['load'],['load']
Performance,"erically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. [1]FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CASCI, in which a full CI is performed in some smaller; set of active orbitals; it is equivalent to CASSCF except without; any orbital optimization. It can be invoked via energy('fci'); with appropriate values selected for FROZEN_DOCC and; ACTIVE. For CI computations, there is no difference between; FROZEN_DOCC and RESTRICTED_DOCC, or between; FROZEN_UOCC and RESTRICTED_UOCC. There are; differences between these keywords for sec:mcscf. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:5952,perform,performed,5952,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,12,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"erion for SCF density, which is defined as the RMS value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indice",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html:5040,perform,performed,5040,psi4manual/4.0b5/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html,4,['perform'],['performed']
Performance,"erion for SCF density, which is defined as the RMS value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indice",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__scf-1.html:4916,perform,performed,4916,psi4manual/4.0b4/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__scf-1.html,4,['perform'],['performed']
Performance,"erminant-based string formalism; of Handy [Handy:1980]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. It can also perform approximate; CASSCF computations in which one uses RAS restrictions on the CI excitations,; rather than doing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in MCSCF: Multi-Configurational Self-Consistent-Field.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:3514,perform,perform,3514,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['perform'],['perform']
Performance,"erminant-based string formalism; of Handy [Handy:1980]. It can solve for restricted active space; configuration interaction (RAS CI) wavefunctions as described by Olsen,; Roos, Jorgensen, and Aa. Jensen [Olsen:1988]. Excitation-class; selected multi-reference CI wavefunctions, such as second-order CI,; can be formulated as RAS CI’s. A RAS CI selects determinants for the; model space as those which have no more than \(n\) holes in the lowest set; of orbitals (called RAS I) and no more than \(m\) electrons in the highest; set of orbitals (called RAS III). An intermediate set of orbitals, if; present (RAS II), has no restrictions placed upon it. All determinants; satisfying these rules are included in the RAS CI.; The DETCI module is also very efficient at computing full configuration; interaction; wavefunctions, and it is used in this capacity in the complete-active-space; self-consistent-field (CASSCF) code. It can also perform approximate; CASSCF computations in which one uses RAS restrictions on the CI excitations,; rather than doing a full CI in the active space. This is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in sec:mcscf.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:3324,perform,perform,3324,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['perform'],['perform']
Performance,"ernally for property and gradient computations. Type: boolean; Default: false. OPDM (DETCI)¶DETCI — Do compute one-particle density matrix if not otherwise required?. Type: boolean; Default: false. OPDM_ONLY (CCDENSITY)¶CCDENSITY (Expert) — For internal use only! Compute the one-particle density matrix, but not the two-particle density matrix. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY)¶CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2)¶DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING)¶OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. CUSTOM is not fully implemented yet - expected optking 0.3.1. Type: string; Possible Values: REDUNDANT, INTERNAL, CARTESIAN, BOTH, CUSTOM; Default: INTERNAL. OPT_METHOD (DFOCC)¶DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC)¶OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. OPT_RESTART (OPTKING)¶OPTKING — Restart the optimization from optking’s written history. Type: double; Default: 0. OPT_TYPE (OPTKING)¶OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC)¶DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC)¶O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:190300,optimiz,optimization,190300,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['optimiz'],['optimization']
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:16659,perform,perform,16659,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,8,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2007-2024, The P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.opt.html:16626,perform,perform,16626,psi4manual/master/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.opt.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2007-2023, The Psi4 Pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:16183,perform,perform,16183,psi4manual/1.8.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. opt; opt(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2007-2024, The Psi4 Pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.opt.html:16619,perform,perform,16619,psi4manual/1.9.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.opt.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.optimize.html:16654,perform,perform,16654,psi4manual/master/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.optimize.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2007-202",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html:16211,perform,perform,16211,psi4manual/1.8.x/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.optimize.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2007-202",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.optimize.html:16647,perform,perform,16647,psi4manual/1.9.x/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.optimize.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:15977,perform,perform,15977,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"eroatm. zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.optimize.html:16005,perform,perform,16005,psi4manual/1.7.x/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.optimize.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"erred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved. CDA threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:26661,optimiz,optimized,26661,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['optimiz'],['optimized']
Performance,"error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The interface; can use classic or mctc-gcp executables interchangeably and will prefer the latter.; A DFTD3 executable, classic or simple-dftd3,; must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/gcp.html:2680,optimiz,optimization,2680,psi4manual/1.7.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/gcp.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"ersion of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Theoretical Methods: SCF to FCI; CI: Configuration Interaction. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/detci.html:15219,perform,perform,15219,psi4manual/1.6.x/detci.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/detci.html,1,['perform'],['perform']
Performance,"ersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. wb88_x; B88 Short-Range GGA Exchange (HJS Model). wb97; Parameterized LRC B97 GGA XC Functional. wb97x; Parameterized Hybrid LRC B97 GGA XC Functional. wb97x-d; Parameterized Hybrid LRC B97 GGA XC Functional with Dispersion w/ Chai and Head-Gordon Dispersion Correction. wblyp; BLYP SR-XC Functional (HJS Model). wpbe; PBE SR-XC Functional (HJS Model). wpbe0; PBE0 SR-XC Functional (HJS Model). wpbe_x; PBE Short-Range GGA Exchange (HJS Model). wpbesol; PBEsol SR-XC Functional (HJS Model). wpbesol0; PBEsol0 SR-XC Functional (HJS Model). wpbesol_x; PBEsol Short-Range GGA Exchange (HJS Model). wsvwn; LSDA SR-XC Functional. ws_x; Slater Short-Range LSDA Exchange. Warning; For the present, file intco.dat is lodged in the submission; directory and defines the internal coordinates for an optimization.; Thus, it is unsafe to run multiple optimizations from a single; directory. Also, intco.dat can linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/opt-1.html:6641,optimiz,optimization,6641,psi4manual/4.0b3/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html,2,['optimiz'],['optimization']
Performance,"ertain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (CPHF); CPHF — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRITE (CCLAMBDA); CCLAMBDA — Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM); CCEOM — Do turn on root following for CC3. Type: boolean; Default: false. CC_A_RAS3_MAX (DETCI); DETCI — maximum number of alpha electrons in RAS III, for CC. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:11074,cache,cached,11074,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['cache'],['cached']
Performance,"erties('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old \(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cc-1.html:5266,optimiz,optimizations,5266,psi4manual/1.4.0/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cc-1.html,5,['optimiz'],['optimizations']
Performance,"es (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC;  . 2; CC(n-1)[n];  . 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a;  . 6; CC(n)-1b;  . 7; CCn;  . 8; CC(n)-3;  . table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/mrcc-1.html:3926,optimiz,optimize,3926,psi4manual/1.2.1/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/mrcc-1.html,4,['optimiz'],['optimize']
Performance,"es (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; complete_basis_set() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of PSI4 and Cfour computational methods and PSI4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; property() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Gradient methods available through P4C4 interface. name; calls method in Stanton a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:25824,optimiz,optimizations,25824,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,12,['optimiz'],['optimizations']
Performance,"es [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:2350,optimiz,optimized,2350,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,15,['optimiz'],['optimized']
Performance,"es are permitted: NR (=0) – Straightforward Newton-Raphson search for minimum; RFA (=1) – Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) – Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); 4 is currently unavailable; SINGLE_POINT (=5) is a single point calculation. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly OPT_TYPE and STEP_TYPE. Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT; Default: SINGLE_POINT. CFOUR_MRCC¶. Specifies the type of MRCC calculation. MK performs a MR-CC calculation based on Mukherjee’s ansatz. Type: boolean; Default: false. CFOUR_MULTIPLICITY¶. Specifies the spin multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING¶. Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL¶. Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:38156,perform,performs,38156,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,26,['perform'],['performs']
Performance,"es frequencies from gradients for H2O. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dft-jk; DFT JK on-disk test. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. serial-wfn; A simple hf/cc-pvdz water calculation. The resulting wavefunction is written to a file, and then a new wavefunction is generated from that file. The member variables of both wavefunctions should be identical in value. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. mp2-grad1; MP2 cc-pVDZ gr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:2300,optimiz,optimization,2300,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"es of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT) [manual] [details]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequency.html:2860,optimiz,optimize,2860,psi4manual/1.7.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequency.html,2,['optimiz'],['optimize']
Performance,"es the threshold value (given as an integer) for the treatment of CPHF coefficients in second derivative calculations using perturbed canonical orbitals. If a CPHF coefficient is above the threshold, the corresponding orbital rotation is treated (at the expense of additional CPU cost) using the standard non-canonical procedures, while orbital pairs corresponding to CPHF coefficients below the threshold are treated using perturbed canonical representation. Default: 25 (Default: 1 in the developer version). Type: integer; Default: 25. CFOUR_UNITS (CFOUR)¶CFOUR — Specifies the units used for molecular geometry input. ANGSTROM (= 0) uses Angstrom units, BOHR (= 1) specifies atomic units. Psi4 Interface: Keyword set from active molecule, always ANGSTROM. Type: string; Possible Values: ANGSTROM, BOHR; Default: ANGSTROM. CFOUR_UPDATE_HESSIAN (CFOUR)¶CFOUR — Specifies whether or not the Hessian update is carried out. OFF (= 0) uses the initial Hessian (however supplied, either the default guess or a FCMINT file), ON (= 1) updates it during subsequent optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR)¶CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF, EXACT; Default: NO. CFOUR_VTR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:83056,optimiz,optimization,83056,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['optimiz'],['optimization']
Performance,"es(), freq(). :returns: *float* |w--w| Total electronic energy in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:79777,perform,performed,79777,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['performed']
Performance,"es) at two frequencies on methyloxirane. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. cbs-xtpl-energy; Extrapolated water energies. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. omp2p5-2; OMP2 cc-pVDZ energy for the H2O molecule. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. ocepa2; OCEPA cc-pVDZ energy with B3LYP initial guess for the NO radical. soscf1; Second-order SCF convergnece: Benzene. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. cubeprop; RHF orbitals and density for water. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. dcft1; DC-06, DC-12, ODC-06 and ODC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:15980,optimiz,optimization,15980,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"es, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). table of contents. energy; energy(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.energy.html:38755,perform,perform,38755,psi4manual/master/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.energy.html,4,['perform'],['perform']
Performance,"es, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of Psi4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in Psi4 are; _nbody_gufunc(),; database(), and; complete_basis_set(); read their respective sections; for details, but an overview is provided here. _nbody_gufunc(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set basis aug-cc-pVDZ. for R in Rvals:; dimer.R = R; ecp = cp('c4-mp2'); print_stdout('R [A] = %.1f IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp)). yields; R [A] = 2.5 IE [kcal/mol] = 0.804; R [A] = 3.0 IE [kcal/mol] = 0.030; R [A] = 4.0 IE [kcal/mol] = -0.014. Next, the database() wrapper allows any computational; model chemistry to be applied a predefined collection of molecules. Thus; an input; set {; basis jun-cc-pvdz; d_convergence 9; }. database('c4-mp2','nbc10',cp='on',subset='MeMe'). yield",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:12539,optimiz,optimization,12539,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimization']
Performance,"es. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. fd-freq-gradient-large; SCF DZ finite difference frequencies by energies for C4NH4. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc36; CC2(RHF)/cc-pVDZ energy of H2O. cbs-delta-energy; Extrapolated energies with delta correction. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Sin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:11981,optimiz,optimizations,11981,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimizations']
Performance,"es: DETCI, CI, ZAPTN, DETCAS, CASSCF, RASSCF; Default: DETCI. WFN (GLOBALS)¶GLOBALS (Expert) — Wavefunction type. Type: string; Default: SCF. WFN (SCF)¶SCF (Expert) — Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. WFN_SYM (MCSCF)¶MCSCF — The symmetry of the SCF wavefunction. Type: string; Default: 1. WFN_SYM (PSIMRCC)¶PSIMRCC — The symmetry of the target wavefunction, specified either by Schönflies symbol, or irrep number (in Cotton ordering). Type: string; Default: 1. WFN_TYPE (DFOCC)¶DFOCC — Type of the wavefunction. Type: string; Default: DF-OMP2. WFN_TYPE (OCC)¶OCC — Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. WRITE_NOS (CCDENSITY)¶CCDENSITY — Do write natural orbitals (molden). Type: boolean; Default: false. WRITE_OPT_HISTORY (OPTKING)¶OPTKING — Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT (OPTKING)¶OPTKING — Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY (OPTKING)¶OPTKING — Write Optimization Trajectory. Type: boolean; Default: false. WRITER_FILE_LABEL (GLOBALS)¶GLOBALS — Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. XI (CCDENSITY)¶CCDENSITY — Do compute Xi?. Type: boolean; Default: false. XI_CONNECT (CCDENSITY)¶CCDENSITY (Expert) — Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. ZERO_INTERNAL_AMPS (PSIMRCC)¶PSIMRCC — Do zero the internal amplitudes, i.e., those that map reference determinants onto each other?. Type: boolean; Default: true. ZETA (CCDENSITY)¶CCDENSITY — Do use zeta?. Type: boolean; Default: false. ZETA (CCLAMBDA)¶CCLAMBDA — Do use zeta?. Type: boolean; Default: false. «; hide menu. menu; sidebar; »; . Navigation. Index",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:238331,optimiz,optimization,238331,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['optimiz'],['optimization']
Performance,"es: Enhancing PSI4 Capabilities ». Interface to MRCC by M. Kállay¶; Code author: Justin M. Turney and Andrew C. Simmonett; Section author: Justin M. Turney; Module: Keywords, PSI Variables, MRCC; PSI4 contains code to interface to the MRCC program of M. Kállay; and J. Gauss. The license and source code of the MRCC program must be; obtained from Mihály Kállay (http://www.mrcc.hu/). Installation¶; Follow the instructions provided with the source to build the MRCC programs.; To be used by PSI4, ensure that the program binary (dmrcc) can be; found in your PATH. If PSI4 is unable to execute the binary, an; error will be reported. Running MRCC¶; MRCC can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the CCSDT energy for water with cc-pVDZ using; MRCC simply provide the following:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 104.5; }; set {; basis cc-pVDZ; }; energy('mrccsdt'). 'mrccsdt' in the call to energy() instructs PSI4 to first; perform an RHF calculation and then call MRCC to compute the CCSDT energy.; For a CCSDT(Q) energy, simply use 'mrccsdt(q)' in the call to; energy(). MRCC can be used to perform geometry optimization and; frequency calculations for electronic ground states only.; At this time, PSI4 is only able to automatically generate the proper; input file for MRCC for the methods listed in table below.; To utilize any method described in the table, you must prefix; the method name with MR. For other methods, you will be required to; use the MRCC keywords described in Appendix MRCC. Methods available in automatic interface with MRCC. CCSD; CCSD(T) [1]; CCSD(T)_L [1]. CCSDT; CCSDT(Q) [1]; CCSDT(Q)_L [1]. CCSDTQ; CCSDTQ(P) [1]; CCSDTQ(P)_L [1]. CCSDTQP; CCSDTQP(H) [1]; CCSDTQP(H)_L [1]. CCSDTQPH;  ;  . CCSDT-1a; CCSDT-1b; CCSDT-3. CCSDTQ-1a; CCSDTQ-1b; CCSDTQ-3. CCSDTQP-1a; CCSDTQP-1b; CCSDTQP-3. CCSDTQPH-1a; CCSDTQPH-1b; CCSDTQPH-3. CC2;  ;  . CC3;  ;  . CC4;  ;  . CC5;  ;  . CC6;  ;  . [1](1, 2, 3, 4, 5, 6,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/mrcc-1.html:1147,perform,perform,1147,psi4manual/4.0b4/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/mrcc-1.html,4,['perform'],['perform']
Performance,es_from_fcidump; energies_from_fcidump; energy; energy; fchk; fchk; fcidump; fcidump; fcidump_from_file; fcidump_from_file; find_approximate_string_matches; find_approximate_string_matches; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; getFromDict; gradient; gradient; hessian; hessian; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; molden; molden; driver.molecule_from_arrays; driver.molecule_from_arrays; driver.molecule_from_schema; driver.molecule_from_schema; driver.molecule_from_string; driver.molecule_from_string; molecule_get_attr; molecule_get_attr; molecule_set_attr; molecule_set_attr; oeprop; oeprop; opt; opt; OptimizationConvergenceError; optimize; optimize; ParsingError; PastureRequiredError; pcm_helper; pcm_helper; print_stderr; print_stderr; print_stdout; print_stdout; process_input; process_input; prop; prop; properties; properties; PsiException; PsiImportError; QMMM; sanitize_name; sanitize_name; scf_helper; scf_helper; scf_wavefunction_factory; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_memory; set_module_options; set_module_options; set_options; set_options; success; success; Table; temp_circular_import_blocker; temp_circular_import_blocker; TestComparisonError; ValidationError; vibanal_wfn; vibanal_wfn; write_eigenvalues; write_eigenvalues; xml2dict; xml2dict. Appendices; Appendices. /autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no ti,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:509120,optimiz,optimize,509120,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['optimiz'],['optimize']
Performance,es_from_fcidump; energies_from_fcidump; energy; energy; fchk; fchk; fcidump; fcidump; fcidump_from_file; fcidump_from_file; find_approximate_string_matches; find_approximate_string_matches; freq; freq; frequencies; frequencies; frequency; frequency; gdma; gdma; geometry; geometry; get_memory; get_memory; getFromDict; gradient; gradient; hessian; hessian; join_path; join_path; levenshtein; levenshtein; ManagedMethodError; molden; molden; driver.molecule_from_arrays; driver.molecule_from_arrays; driver.molecule_from_schema; driver.molecule_from_schema; driver.molecule_from_string; driver.molecule_from_string; molecule_get_attr; molecule_get_attr; molecule_set_attr; molecule_set_attr; oeprop; oeprop; opt; opt; OptimizationConvergenceError; optimize; optimize; ParsingError; PastureRequiredError; pcm_helper; pcm_helper; print_stderr; print_stderr; print_stdout; print_stdout; process_input; process_input; prop; prop; properties; properties; PsiException; PsiImportError; QMMM; sanitize_name; sanitize_name; scf_helper; scf_helper; scf_wavefunction_factory; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_memory; set_module_options; set_module_options; set_options; set_options; success; success; Table; temp_circular_import_blocker; temp_circular_import_blocker; TestComparisonError; ValidationError; vibanal_wfn; vibanal_wfn; write_eigenvalues; write_eigenvalues; xml2dict; xml2dict. Appendices; Appendices. autodir_options_c; ; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no title>; <no tit,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:466094,optimiz,optimize,466094,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,2,['optimiz'],['optimize']
Performance,"escue the convergence of the SCF. MOM can; be used in concert with DIIS, though care should be taken to not turn MOM on; until the oscillatory behavior begins.; Damping [Off by Default]; In some cases, a static mixing of Fock Matrices from adjacent iterations can; quench oscillations. This mixing, known as “damping” can be activated by setting; the DAMPING_PERCENTAGE keyword to a nonzero percent. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An in-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; An in-core repeated integral evaluation algorithm using; exact ERIs. Symmetry is used to reduce the number of integrals, and no disk is; used. However, integral regeneration is quite costly, implying that this; algorithm should be used only if there is not enough disk space for the; OUT_OF_CORE algorithm.; DF; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT au",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:17358,bottleneck,bottleneck,17358,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,4,['bottleneck'],['bottleneck']
Performance,"esidual vector in SEM step. This option is only available for the built-in ADC backend. Type: conv double; Default: 1e-6. NUM_AMPS_PRINT¶. Number of components of transition amplitudes printed. This option is only available for the built-in ADC backend. Type: integer; Default: 5. NUM_CORE_ORBITALS¶. Number of orbitals to place in the core. This option is only available for the adcc backend. Type: integer; Default: 0. NUM_GUESSES¶. Number of guess vectors to generate and use. Negative values keep * the adcc default (currently 2 * ROOTS_PER_IRREP). This option is only available for the adcc backend. Type: integer; Default: -1. POLE_MAXITER¶. Maximum iteration number in pole searching. This option is only available for the built-in ADC backend. Type: integer; Default: 20. PR¶. Do use the partial renormalization scheme for the ground state wavefunction? * This option is only available for the built-in ADC backend. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF; Default: RHF. ROOTS_PER_IRREP¶. The number of poles / excited states to obtain per irrep vector. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. SEM_MAXITER¶. Maximum iteration number in simultaneous expansion method. This option is only available for the built-in ADC backend. Type: integer; Default: 30. table of contents. ADC; General; CACHELEVEL; CUTOFF_AMPS_PRINT; GAUGE; KIND; MAXITER; MAX_NUM_VECS; MEMORY; NEWTON_CONVERGENCE; NORM_TOLERANCE; NUM_AMPS_PRINT; NUM_CORE_ORBITALS; NUM_GUESSES; POLE_MAXITER; PR; REFERENCE; ROOTS_PER_IRREP; R_CONVERGENCE; SEM_MAXITER. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Appendices; Keywords by Module; ADC. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__adc.html:2975,CACHE,CACHELEVEL,2975,psi4manual/1.6.x/autodir_options_c/module__adc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__adc.html,1,['CACHE'],['CACHELEVEL']
Performance,"esky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:15007,perform,performing,15007,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['perform'],['performing']
Performance,"esky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in PSI4, with or without the; use of FNOs, through the FNOCC module. The implementation and accuracy of; the DF/CD-CCSD(T) method are described in Ref. [DePrince:2013:inpress].; The DF-CCSD(T) procedure uses two auxiliary basis sets. The first set is; that used in the SCF procedure, defined by the DF_BASIS_SCF; keyword. If this keyword is not specified, an appropriate -JKFIT set is; automatically selected. This auxiliary set defines the ERI’s used to; build the Fock matrix used in the DF-CCSD(T) procedure. The second; auxiliary set is used to approximate all other ERI’s in the DF-CCSD(T); procedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For example, if the primary basis is aug-cc-pVDZ, the default; DF_BASIS_CC will be aug-cc-pVDZ-RI.; Alternatively, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying; DF_BASIS_CC as “CHOLESKY”. CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as “CD”. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; df_basis_cc cholesky; basis aug-cc-pvdz; freeze_core true; }; energy('df-ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. ). Gn theory¶; The FNOC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/fnocc-1.html:8751,optimiz,optimized,8751,psi4manual/4.0b5/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/fnocc-1.html,2,['optimiz'],['optimized']
Performance,"esponse(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('SCF_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only scf. if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError(['select_scf_gradient', name, 'SCF_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:2307,perform,performance,2307,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,2,['perform'],['performance']
Performance,"ess. To expedite development, a; plugin system was developed. This plugin machinery allows developers to access; the classes defined in the innards of PSI4, with only the small plugin; code requiring recompilation during development. The resulting lightweight; code can be maintained and distributed independently of PSI4, making this; a good strategy for development, especially in cases where tighter integration; of the new code with existing PSI4 machinery is required than that; afforded by the Numpy based strategy outlined in the Rapid initial development using Psi4NumPy; section. For details about how to write these plugins, see the; Creating New Plugins section. Incorporating code into PSI4¶; For features to be incorporated fully into the PSI4 ecosystem, changes to; the core routines are inevitable. However, the programmer should think very; carefully about the most appropriate language for the task in hand. Let’s; consider a new feature that downloads some data from an external source and; then performs some kind of expensive matrix operation on those data. Because; Python has a rich set of tools for obtaining data from external sources,; writing this tool in the Python layer is a natural choice. If we know that the; matrix will always be small enough to fit in memory, we can simply rely on the; routines present in NumPy to do the heavy lifting and the code is easy to; implement entirely in the Python layer. In the case where the matrix operation; is non-standard and requires some specialized code to handle disk-based; storage, the decision to write in Python is less clear cut. It is certainly; possible to write these out-of-core routines using Numpy primitives, but there; are a number of tools in PSI4 already to perform tasks like these that are; required, e.g., for cluster. In this case, a good design would be to write a; simple piece of code in the C++ layer that performs the matrix operation on a; given input, using the I/O routines available in PSI4 and the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html:4036,perform,performs,4036,psi4manual/1.4.0/prog_ways_to_add-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_ways_to_add-1.html,9,['perform'],['performs']
Performance,"ess; import sys; import warnings; from typing import Dict, List, Union. import numpy as np; from qcelemental.util import parse_version, which. from psi4 import core, extras. from .. import p4util; from .. import psifiles as psif; from .. import qcdb; from ..constants import constants; from ..p4util.exceptions import (; ManagedMethodError,; PastureRequiredError,; UpgradeHelper,; ValidationError,; docs_table_link,; ). #from psi4.driver.molutil import *; from ..qcdb.basislist import corresponding_basis; from . import dft, empirical_dispersion, mcscf, proc_util, response, solvent; from .proc_data import method_algorithm_type; from .roa import run_roa. # never import driver, wrappers, or aliases into this file. # ADVICE on new additions:; # * two choices: basic `def run` or managed `def select`; # * consult http://psicode.org/psi4manual/master/proc_py.html --or-- <psi4-repo>/doc/sphinxman/source/proc_py.rst. def select_scf_gradient(name, **kwargs):; """"""Function selecting the algorithm for an SCF gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(""scf"") # `""scf""` instead of `name` avoids adding every functional to governing dict in proc_data.py; module = core.get_global_option('QC_MODULE'). if mtd_type == 'CD':; # manifestation of `""""""No analytic derivatives for SCF_TYPE CD.""""""`.; # here, only hits upon `gradient(""scf"")` so above message also present in driver.py to catch e.g., mp2 gradient atop a cd reference.; func = None; else:; func = run_scf_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html:2443,perform,performance,2443,psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"est atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a minimal set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default) or linear combinations of atomic positions; (automatic use of principal axes is under development).; These dimer coordinates can be directly specified through INTERFRAG_COORDS); See here <DimerSection_> for two examples of their use. Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphso",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:2695,optimiz,optimization,2695,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimization']
Performance,"est case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:20250,optimiz,optimization,20250,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"estlabel; Run tests excluding those by label: pytest -m ""not testlabel""; Run tests with complicated filtering by name: pytest -k ""cc and not cc4 and not stdsuite""; Run tests and see test names: pytest -v; Run tests and see test names and sometimes more verbose errors: pytest -vv. How to see CTest testing errors¶; >>> ctest; Test project /your/path/2/psi4/build/directory/tests; Start 248: tu1-h2o-energy; 1/2 Test #248: tu1-h2o-energy ................... Passed 1.73 sec; Start 6: cc1; 2/2 Test #6: cc1 ..............................***Failed 0.07 sec; ... When ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a supplementary test suite is available to be; run via pytest. Running a limited number of “smoke” tests is; generally sufficient to verify an installation. From the executable; # smoke tests only in serial; psi4 --test; # smoke tests only in parallel; psi4 --test -n`getconf _NPROCESSORS_ONLN`; # most tests; psi4 --test full. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.); # smoke tests only; python -c ""import psi4; psi4.test('smoke')""; # most tests; python -c ""import psi4; psi4.test()"". From pytest directly. If package pytest-xdist is installed, can run in parallel.; # smoke tests only; pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -m smoke -n auto; # all tests; pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -n auto. Output looks something like the below.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:54883,perform,performed,54883,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,5,['perform'],['performed']
Performance,"ests/plugin_mp2/plugin_mp2.cc.in; A plugin that uses LibTrans to generate open- and closed-shell MP2 energies.; psi4/tests/plugin_sointegrals/sointegrals.cc.in; An example that uses the LibMints library to generate and print SO basis (with symmetry) integrals. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. Makefile — Makefile for the directory. As long as you are the; only user of the plugin, this should not need editing. After any change to; the plugin C++ code, make must be run in the plugin directory to; recompile the myplugin.so executable, but recompiling the main; PSI4 code is not necessary. (PSI4 must have originally been; compiled with configure directive --with-plugins.). input.dat — Sample input file for the plugin (old style).; Modifications to a standard input file needed to run the plugin are (1); the line plugin_load(""./myplugin.so"") before any keyword setting to; load the plugin’s options into PSI4’s options data structure and (2); the final line plugin(""./myplugin.so"") to call the plugin code after; any necessary preparatory modules (here, scf) have been run. pymodule.py — Python component of the plugin. The procedure; for calling plugin code shown in input.dat sounds very simple, but it; can be made simpler still. By encoding the sequence of PSI4 module; calls needed to run the plugin in the run_myplugin() function in this; file, the plugin is hooked into the main PSI4 driver function; energy() and so can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file. __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/plugins-1.html:4799,load,load,4799,psi4manual/4.0b2/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/plugins-1.html,2,['load'],['load']
Performance,"et INCFOCK to TRUE). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. COSX Exchange¶; The semi-numerical COSX algorithm described in [Neese:2009:98] evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in DFT: Density Functional Theory.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; The SCF algorithm is first converged on a smaller grid, followed by a final SCF; iteration on a larger grid. This results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. The size of the initial grid is controlled by the; keywords COSX_RADIAL_POINTS_INITIAL and COSX_SPHERICAL_POINTS_INITIAL.; The final grid is controlled by COSX_RADIAL_POINTS_FINAL and; COSX_SPHERICAL_POINTS_FINAL. The defaults for both grids aim to balance; cost and accuracy.; Screening thresholds over integrals, densities, and basis extents are set; with the COSX_INTS_TOLERANCE, COSX_DENSITY_TOLERANCE, and; COSX_BASIS_TOLERANCE keywords, respectively. COSX_INTS_TOLERANCE; is the most consequential of the three thresholds in both cost and accuracy.; This keyword determines screening of negligible one-electron integrals.; COSX_DENSITY_TOLERANCE controls the threshold for significant; shell pairs in the density matrix. Lastly, COSX_BASIS_TOLERANCE is; a cutoff for the value of basis functions at grid points. This keyword is; used to determine the radial extent of the each basis shell, and it is the; COSX ana",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:36187,perform,performing,36187,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['perform'],['performing']
Performance,"et Perturbation Theories; PSIMRCC Implementation of Mk-MRCC Theory; CI: Configuration Interaction; SAPT: Symmetry-Adapted Perturbation Theory; ADC: Ab Initio Polarization Propagator; Scalar relativistic Hamiltonians; Geometry Optimization; oeprop() Evaluation of One-Electron Properties; Vibrational and Thermochemical Analysis. Interfaces: Enhancing Psi4 Capabilities; Interface to CFOUR by J. Stanton and J. Gauss; Interface to CheMPS2 by S. Wouters; Interface to DFTD3 by S. Grimme; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Interface to programs through FCHK files, fchk(); Interface to GDMA Distributed Multipole Analysis by A. J. Stone, gdma(); Interface to LIBEFP by I. Kaliman; Interface to PCMSolver; Interface to Molden, molden(); Interface to MRCC by M. Kállay. Psithon Functions: Invoking a Calculation; Notes on Options; Single-Point Energy, energy(); Property; Counterpoise Correct; Geometry Optimization, optimize() and gradient(); Harmonic Vibrational Analysis, frequency() and hessian(); Database, database(); Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; cubeprop() Generation of cube files; Orbital Visualization with VMD. Customization: Adding Simple Extensions; Defining a Method Alias; Creating a Database. Appendices; Keywords; Keywords by Alpha; Keywords by Module. Basis Sets; Basis Sets by Family; Basis Sets by Element; Auxiliary Basis Sets. PSI Variables; PSI Variables by Alpha; PSI Variables by Module. Miscellaneous; Test Suite and Sample Inputs; DFT Functionals; PSIOH Intermediate Files; Physical Constants; Bibliography. Programmers’ Manual¶. Contributions: Intro to Programming in Psi4; Plugins: Adding New Functionality to Psi4; Best Practices for Python Functions; Documentation; PsiPEP: Plans and Practices to Organize Psi4. Programming: Using the Core Libraries; LibOptions: globals, locals, has_changed and all that; Adding Methods to Driver; BasisSet. Python Driver; wrapper_database; d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/contents.html:2295,optimiz,optimize,2295,psi4manual/1.0.0/contents.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/contents.html,2,['optimiz'],['optimize']
Performance,"et basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:29488,perform,perform,29488,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['perform'],['perform']
Performance,"et basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variabl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:32539,perform,perform,32539,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"et basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI (MolSSI driver interface) if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). _filter_renamed_methods(""energy"", lowername). # * Avert pydantic anger at incomplete modelchem spec; userbas = core.get_glob",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:36315,perform,perform,36315,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['perform'],['perform']
Performance,"et basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody.nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CBS if ""method/basis"" name",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:33597,perform,perform,33597,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['perform'],['perform']
Performance,"et basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to MDI if mdi kwarg; use_mdi = kwargs.pop('mdi', False); if use_mdi:; return mdi_run(name, **kwargs). core.print_out(""\nScratch directory: %s\n"" % core.IOManager.shared_object().get_default_path()). basisstash = p4util.OptionsState(['BASIS']); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). ## Pre-planning interventions. # * Trip on function or alias as name; lowername = driver_util.upgrade_interventions(name). # * Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:29355,perform,perform,29355,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['perform'],['perform']
Performance,"et cubeprop_tasks ['orbitals']; set cubeprop_orbitals [5,6,-5,-6]. E, wfn = energy('scf', return_wfn=True); cubeprop(wfn). In this example, the cubeprop(); call after the energy('scf') command; executes the cubeprop code. The array CUBEPROP_TASKS specifies which; tasks should be executed. In this case the task 'orbitals' generates cube; files for orbitals. The CUBEPROP_ORBITALS option specifies that cube files; should be generated only for alpha orbitals 5 (HOMO) and 6 (LUMO) and; beta orbitals 5 (indicated as -5) and 6.; If the option CUBEPROP_ORBITALS is not provided, then cube files are; generated for all orbitals.; After running, the above input will generate four files: Psi_a_5.cube,; Psi_a_6.cube, Psi_b_5.cube, and Psi_b_6.cube. Note; If your cube plots are too coarse, try to decrease the grid spacing via; the option CUBIC_GRID_SPACING. If the edges of your plot are cut then; increase the size of the grid via the option CUBIC_GRID_OVERAGE. Cubeprop Tasks¶; The cubeprop utility can be provided a list of tasks to perform.; Tasks are specified by the CUBEPROP_TASKS option, which is a list of strings; that identify the tasks. Several tasks are available. These include:. ORBITALS [Default if CUBEPROP_TASKS is not specified]; Produces cube representations of the molecular orbitals; . Orbitals are sorted according to increasing; orbital energy ignoring symmetry.; DENSITY; This task can be used to obtain the alpha and beta electron densities,; and , together; with the total density; ,; and the spin density; .; BASIS_FUNCTIONS; This task is useful to produce cube files of the atomic orbital basis; functions .; ESP; Calculates the total (nuclear + electronic) electrostatic potential; . Note; The ESP task requires the user to specify a density-fitting basis; via the DF_BASIS_SCF keyword. Warning; It is important to specify the CUBEPROP_ORBITALS option when; dealing with large molecules to avoid running out of disk space.; For example, using the default grid spacing of; 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cubeprop-1.html:2553,perform,perform,2553,psi4manual/1.0.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cubeprop-1.html,2,['perform'],['perform']
Performance,"et cubeprop_tasks ['orbitals']; set cubeprop_orbitals [5,6,-5,-6]. E, wfn = energy('scf', return_wfn=True); cubeprop(wfn). In this example, the cubeprop(); call after the energy('scf') command; executes the cubeprop code. The array CUBEPROP_TASKS specifies which; tasks should be executed. In this case the task 'orbitals' generates cube; files for orbitals. The CUBEPROP_ORBITALS option specifies that cube files; should be generated only for alpha orbitals 5 (HOMO) and 6 (LUMO) and; beta orbitals 5 (indicated as -5) and 6.; If the option CUBEPROP_ORBITALS is not provided, then cube files are; generated for all orbitals.; After running, the above input will generate four files: Psi_a_5.cube,; Psi_a_6.cube, Psi_b_5.cube, and Psi_b_6.cube. Note; If your cube plots are too coarse, try to decrease the grid spacing via; the option CUBIC_GRID_SPACING. If the edges of your plot are cut then; increase the size of the grid via the option CUBIC_GRID_OVERAGE. Cubeprop Tasks¶; The cubeprop utility can be provided a list of tasks to perform.; Tasks are specified by the CUBEPROP_TASKS option, which is a list of strings; that identify the tasks. Several tasks are available. These include:. ORBITALS [Default if CUBEPROP_TASKS is not specified]; Produces cube representations of the molecular orbitals; \(\psi_q(\mathbf{r})\). Orbitals are sorted according to increasing; orbital energy ignoring symmetry.; DENSITY; This task can be used to obtain the alpha and beta electron densities,; \(\rho_\alpha(\mathbf{r})\) and \(\rho_\beta(\mathbf{r})\), together; with the total density; \(\rho(\mathbf{r}) = \rho_\alpha(\mathbf{r}) + \rho_\beta(\mathbf{r})\),; and the spin density; \(\rho(\mathbf{r}) = \rho_\alpha(\mathbf{r}) - \rho_\beta(\mathbf{r})\).; BASIS_FUNCTIONS; This task is useful to produce cube files of the atomic orbital basis; functions \(\chi_\mu(\mathbf{r})\).; ESP; Calculates the total (nuclear + electronic) electrostatic potential; \(V(\mathbf{r})\). Note; The ESP task requires th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cubeprop-1.html:2581,perform,perform,2581,psi4manual/1.1.0/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cubeprop-1.html,2,['perform'],['perform']
Performance,"et equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.symmetryoperation.html:1886,Perform,Performs,1886,psi4manual/1.4.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.symmetryoperation.html,5,['Perform'],['Performs']
Performance,"et, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import shutil; import subprocess. import numpy as np. from psi4 import extras; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import constants; from psi4.driver.p4util.exceptions import *; from psi4.driver.molutil import *; # never import driver, wrappers, or aliases into this file. from .roa import *; from . import proc_util; from . import empirical_dispersion; from . import dft_funcs; from . import mcscf; from . import response. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:2074,perform,performance,2074,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['perform'],['performance']
Performance,"et.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946      0.01008137      0.00594928  ~     3     -76.027032729374     -0.000010063363      0.00014019      0.00008488      0.00077463      0.00044738  ~ --------------------------------------------------------------------------------------------------------------- ~; To get harmonic vibrational frequencies, it’s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:7793,optimiz,optimizer,7793,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['optimiz'],['optimizer']
Performance,"et.zero_ao_basis_set()); return wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self, filenumber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_pu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:4728,load,load,4728,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,6,['load'],['load']
Performance,"et_active_molecule()); molecule.update_geometry(); kwargs['molecule'] = molecule. # Allow specification of methods to arbitrary order; lowername = args[0].lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. if ""/"" in lowername:; return driver_cbs._cbs_gufunc(properties, lowername, ptype='properties', **kwargs). return_wfn = kwargs.pop('return_wfn', False); props = kwargs.get('properties', ['dipole', 'quadrupole']). if len(args) > 1:; props += args[1:]. kwargs['properties'] = p4util.drop_duplicates(props); optstash = driver_util._set_convergence_criterion('properties', lowername, 6, 10, 6, 10, 8); wfn = procedures['properties'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type ret",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:47344,optimiz,optimized,47344,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimized']
Performance,"et_geometry(opt_geometry); molecule.update_geometry(); core.print_out(f'\n Final Energy : {return_energy} \n'); core.print_out('\n Final Geometry : \n'); molecule.print_in_input_format(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn:; wfn = engine.p4_wfn. if return_wfn and return_history:; return (return_energy, wfn, history); elif return_wfn and not return_history:; return (return_energy, wfn); elif return_history and not return_wfn:; return (return_energy, history); else:; return return_energy. [docs]; def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: :py:class:`psi4.driver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:61235,Optimiz,OptimizationConvergenceError,61235,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,3,['Optimiz'],['OptimizationConvergenceError']
Performance,"et_num_threads(nthread)[source]¶; Function to reset the number of threads to parallelize across. success(label)[source]¶; Function to print a ‘label...PASSED’ line to screen.; Used by util.compare_values() family when functions pass. basislistdunning¶; Module (auto-generated from make_dunning.pl script); with commands building BasisFamily objects that; encode the Dunning basis set orbital definitions in; psi4/lib/basis/NOTES and fitting bases designed for those; orbital bases. load_basfam_dunning()[source]¶. aliases¶; Module with functions that call upon those in modules; proc, driver, and wrappers. Place in this file quickly defined procedures such as. aliases for complex methods; simple modifications to existing methods. sherrillgroup_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> energy('sherrillgroup_gold_standard'). qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module to largely replicate in python the psi4 libmints; CoordValue and CoordEntry classes, which were developed by; Justin M. Turney, with incremental improvements by other; psi4 developers. class CartesianEntry(entry_number, Z, charge, mass, symbol, label, x, y, z)[source]¶; Class to hold all information about an atom, including its; coordinate specification as three Cartesians. clone()[source]¶; Returns new, independent CartesianEntry object. compute()[source]¶; Computes the values of the coordinates (in whichever units; were inputted), returning them in a Vector. everything()[source]¶. invalidate()[source]¶; Flags the current coordinates as being outdated. print_in_input_format()[source]¶; Prints the updated geometry, in the format provided by th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:36832,perform,performed,36832,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['perform'],['performed']
Performance,"eta2] » ; Appendices »; Keywords by Module ». CCDENSITY¶; Computes the coupled cluster density matrices. Called whenever CC properties and/or gradients are required. General¶. AO_BASIS¶. The algorithm to use for the terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. CACHELEVEL¶. The amount of cacheing of data to perform. Type: integer; Default: 2. GAUGE¶. The type of gauge to use for properties. Type: string; Default: LENGTH. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. ONEPDM¶. Do ?. Type: boolean; Default: false. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do ?. Type: boolean; Default: false. Expert¶. AEL¶. Do compute the approximate excitation level? See Stanton and Bartlett, JCP, 98, 1993, 7034. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require and to be connected?. Type: boolean; Default: false. Table Of Contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; GAUGE; INTS_TOLERANCE; ONEPDM; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; XI; ZETA. Expert; AEL; WFN; XI_CONNECT. Previous topic; SEM_MAXITER; Next topic; AEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Appendices »; Keywords by Module ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccdensity-1.html:1605,CACHE,CACHELEVEL,1605,psi4manual/4.0b2/autodir_options_c/module__ccdensity-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccdensity-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"etected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPYTHON_EXECUTABLE=/path/to/interp/python2.7. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPYTHON_EXECUTABLE=""${PFXC}/bin/python"" \; -DPYTHON_LIBRARY=""${PFXC}/lib/libpython3.5m.so"" \; -DPYTHON_INCLUDE_DIR=""${PFXC}/include/python3.5m"". What Python is Psi4 running¶; The Python detected at build-time is embedded into the PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/envs/p4deps/bin/python3.5, and that’s the Python; through which PSI4 is running, rather than the Python of which python.; To use a different Python with PSI4 in the short term, just; path/to/desired/python psi4 on the command line to override the; shebang line. To use a different Python with PSI4 in the long term,; edit the shebang line.; If you’re using PSI4 as a Python module, then PSI4 is running; the Python of which python. How to fix “undefined symbol: _Py_FalseStruct“¶; You’re probably loading a Py3-compiled Psi4 in Py2. Switch interpreters; and re-run. A python of proper Py2 or Py3-ness is baked into the PSI4; “executable”, so you’ll see this error only for Psi4 as Python module. How to use gdb and lldb with Psi4¶; Debugging PSI4 has gotten a little confusing now that it’s running through Python. Here’s the syntax; 1; 2; 3>>> cd {objdir}; >>> lldb -- python stage/{prefix}/bin/psi4 ../tests/tu1-h2o-energy/input.dat; >>> (lldb) run. 1; 2; 3>>> cd {objdir}; >>> gdb --args python stage/{prefix}/bin/psi4 ../tests/tu1-h2o-energy/input.dat; >>> (gdb) run. How to see the actual compiling commands (or errors) with cmake¶; CMake by default hides a lot of useful debugging information to make the; compilation cleaner. Issue make VERBOSE=1 to display the full; compilation commands and errors. How to highlight git merge conflicts in vi¶; Edit your ~/.vimrc file to include the lines below. Hitting the F7; key will toggle highlighting of git’s conflict markers.; >>> ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:35785,load,loading,35785,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['load'],['loading']
Performance,"etected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPYTHON_EXECUTABLE=/path/to/interp/python2.7. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPYTHON_EXECUTABLE=""${PFXC}/bin/python"" \; -DPYTHON_LIBRARY=""${PFXC}/lib/libpython3.5m.so"" \; -DPYTHON_INCLUDE_DIR=""${PFXC}/include/python3.5m"". What Python is Psi4 running¶; The Python detected at build-time is embedded into the PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/envs/p4deps/bin/python3.5, and that’s the Python; through which PSI4 is running, rather than the Python of which python.; To use a different Python with PSI4 in the short term, just; path/to/desired/python psi4 on the command line to override the; shebang line. To use a different Python with PSI4 in the long term,; edit the shebang line.; If you’re using PSI4 as a Python module, then PSI4 is running; the Python of which python. How to fix “undefined symbol: _Py_FalseStruct”¶; You’re probably loading a Py3-compiled Psi4 in Py2. Switch interpreters; and re-run. A python of proper Py2 or Py3-ness is baked into the PSI4; “executable”, so you’ll see this error only for Psi4 as Python module. How to use gdb and lldb with Psi4¶; Debugging PSI4 has gotten a little confusing now that it’s running through Python. Here’s the syntax; 1; 2; 3>>> cd {objdir}; >>> lldb -- python stage/{prefix}/bin/psi4 ../tests/tu1-h2o-energy/input.dat; >>> (lldb) run. 1; 2; 3>>> cd {objdir}; >>> gdb --args python stage/{prefix}/bin/psi4 ../tests/tu1-h2o-energy/input.dat; >>> (gdb) run. How to see the actual compiling commands (or errors) with cmake¶; CMake by default hides a lot of useful debugging information to make the; compilation cleaner. Issue make VERBOSE=1 to display the full; compilation commands and errors. How to highlight git merge conflicts in vi¶; Edit your ~/.vimrc file to include the lines below. Hitting the F7; key will toggle highlighting of git’s conflict markers.; >>> ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:42165,load,loading,42165,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['load'],['loading']
Performance,"etected Python from PATH. >>> cmake. Build with specific Python. >>> cmake -DPYTHON_EXECUTABLE=/path/to/interp/python3.6. Build with full Python specification to root directory ${PFXC}. >>> cmake -DPYTHON_EXECUTABLE=""${PFXC}/bin/python"" \; -DPYTHON_LIBRARY=""${PFXC}/lib/libpython3.5m.so"" \; -DPYTHON_INCLUDE_DIR=""${PFXC}/include/python3.5m"". What Python is Psi4 running¶; The Python detected at build-time is embedded into the PSI4; executable. That is, the top line of bin/psi4 is something like; #!/path/to/miniconda/envs/p4deps/bin/python3.5, and that’s the Python; through which PSI4 is running, rather than the Python of which python.; To use a different Python with PSI4 in the short term, just; path/to/desired/python psi4 on the command line to override the; shebang line. To use a different Python with PSI4 in the long term,; edit the shebang line.; If you’re using PSI4 as a Python module, then PSI4 is running; the Python of which python. How to fix “undefined symbol: _Py_FalseStruct”¶; You’re probably loading a Py3-compiled Psi4 in Py2. Switch interpreters; and re-run. A python of proper Py2 or Py3-ness is baked into the PSI4; “executable”, so you’ll see this error only for Psi4 as Python module. How to use gdb and lldb with Psi4¶; Debugging PSI4 has gotten a little confusing now that it’s running through Python. Here’s the syntax; 1; 2; 3>>> cd {objdir}; >>> lldb -- python stage/bin/psi4 ../tests/tu1-h2o-energy/input.dat; >>> (lldb) run. 1; 2; 3>>> cd {objdir}; >>> gdb --args python stage/bin/psi4 ../tests/tu1-h2o-energy/input.dat; >>> (gdb) run. How to see the actual compiling commands (or errors) with cmake¶; CMake by default hides a lot of useful debugging information to make the; compilation cleaner. Issue make VERBOSE=1 to display the full; compilation commands and errors. How to highlight git merge conflicts in vi¶; Edit your ~/.vimrc file to include the lines below. Hitting the F7; key will toggle highlighting of git’s conflict markers.; >>> cat ~/.vimrc; set ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:45132,load,loading,45132,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['load'],['loading']
Performance,"ether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS (CFOUR); CFOUR — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION (CFOUR); CFOUR — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE (CFOUR); CFOUR — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD (CFOUR); CFOUR — Specifies the strength of a Fermi-Contact pertubation as required for finite-field calculations of spin densities and the FC contributions to indirect spin-spin coupling constants. The value must be specified as an integer and the FC strength used by the program will be the value of the keyword . The atom for which the FC perturbation is switched on is specified in the ZMAT file after the CFOUR command line and potential basis set input, as follows %spin density N with N as the number of atom (in (X5,I3) format) in the order they are written by JODA to the MOL file. Be awar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:39316,perform,performed,39316,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS (CFOUR); CFOUR — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION (CFOUR); CFOUR — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE (CFOUR); CFOUR — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD (CFOUR); CFOUR — Specifies the strength of a Fermi-Contact perturbation as required for finite-field calculations of spin densities and the FC contributions to indirect spin-spin coupling constants. The value must be specified as an integer and the FC strength used by the program will be the value of the keyword \(\times 10^{-6}\). The atom for which the FC perturbation is switched on is specified in the ZMAT file after the CFOUR command line and potential basis set input, as follows %spin density N with N as the number of atom (in (X5,I3) format) in the order they are written by JODA to th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:39335,perform,performed,39335,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['perform'],['performed']
Performance,"ether to include the coupling terms in the DCT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS)¶GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, ADCC, CCT3, BUILTIN; Default: No Default. QC_TYPE (DCT)¶DCT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC)¶DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF)¶SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP)¶EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI)¶DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (ADC)¶ADC — Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:198677,perform,perform,198677,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['perform'],['perform']
Performance,"ether to include the coupling terms in the DCT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS)¶GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, CCT3, BUILTIN, MRCC; Default: No Default. QC_TYPE (DCT)¶DCT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC)¶DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF)¶SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP)¶EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI)¶DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (ADC)¶ADC — Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:199388,perform,perform,199388,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['perform'],['perform']
Performance,"ethod for H2O. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. remp-energy2; integral conventional unrestricted REMP/cc-pVDZ energies for the H2O+ molecule. results were independently verified against the initial wavels implementation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. fcidump; test FCIDUMP functionality for rhf/uhf. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. opt15; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; <no title>. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:48775,optimiz,optimization,48775,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],"['optimization', 'optimized']"
Performance,"ethod is to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (1990); MITRUSHENKOV, to use a 2x2 Olsen/Davidson method; and DAVIDSON (or SEM) to use Liu’s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, SEMTEST. The SEM method is the most robust, but it also requires \(2NM+1\) CI vectors on disk, where \(N\) is the maximum number of iterations and \(M\) is the number of roots. Type: string; Possible Values: RSP, DAVIDSON, SEM; Default: SEM. LSE¶. Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE¶. Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE¶. Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. PRECONDITIONER¶. This specifies the type of preconditioner to use in the selected diagonalization method. The valid options are: DAVIDSON which approximates the Hamiltonian matrix by the diagonal elements; H0BLOCK_INV which uses an exact Hamiltonian of H0_BLOCKSIZE and explicitly inverts it; GEN_DAVIDSON which does a spectral decomposition of H0BLOCK; ITER_INV using an iterative approach to obtain the correction vector of H0BLOCK. The H0BLOCK_INV, GEN_DAVIDSON, and ITER_INV approaches are all formally equivalent but the ITER_INV is less computationally expensive. Default is DAVIDSON. Type: string; Possible Values: LANCZOS, DAVIDSON, GEN_DAVIDSON, H0BLOCK, H0BLOCK_INV, ITER_INV, H0BLOCK_COUPLING, EVANGELISTI; Default: DAVIDSON. UPDATE¶. The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. Density Matrices¶. DIPMOM¶. Do compute th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html:4870,perform,performed,4870,psi4manual/1.1.0/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__detci-1.html,2,['perform'],['performed']
Performance,"ethod is to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditioned inverse subspace method (1990); MITRUSHENKOV, to use a 2x2 Olsen/Davidson method; and DAVIDSON (or SEM) to use Liu’s Simultaneous Expansion Method, which is identical to the Davidson method if only one root is to be found. There also exists a SEM debugging mode, SEMTEST. The SEM method is the most robust, but it also requires \(2NM+1\) CI vectors on disk, where \(N\) is the maximum number of iterations and \(M\) is the number of roots. Type: string; Possible Values: RSP, DAVIDSON, SEM; Default: SEM. LSE¶. Do use least-squares extrapolation in iterative solution of CI vector?. Type: boolean; Default: false. LSE_COLLAPSE¶. Number of iterations between least-squares extrapolations. Type: integer; Default: 3. LSE_TOLERANCE¶. Minimum converged energy for least-squares extrapolation to be performed. Type: conv double; Default: 3. PRECONDITIONER¶. This specifies the type of preconditioner to use in the selected diagonalization method. The valid options are: DAVIDSON which approximates the Hamiltonian matrix by the diagonal elements; H0BLOCK_INV which uses an exact Hamiltonian of H0_BLOCKSIZE and explicitly inverts it; GEN_DAVIDSON which does a spectral decomposition of H0BLOCK; ITER_INV using an iterative approach to obtain the correction vector of H0BLOCK. The H0BLOCK_INV, GEN_DAVIDSON, and ITER_INV approaches are all formally equivalent but the ITER_INV is less computationally expensive. Default is DAVIDSON. Type: string; Possible Values: LANCZOS, DAVIDSON, GEN_DAVIDSON, H0BLOCK, ITER_INV, EVANGELISTI; Default: DAVIDSON. UPDATE¶. The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. Density Matrices¶. DIPMOM¶. Do compute the dipole moment?. Type: boolean",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:4872,perform,performed,4872,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,14,['perform'],['performed']
Performance,"ethod. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number \(N\).; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:23941,tune,tuned,23941,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,4,['tune'],['tuned']
Performance,"etical list over i, j, …, k enumerates; molecular fragments included in the computation in 1-indexed,; input-file order, while the second enumerates list over a, b,; …, c enumerates which fragments contribute basis functions to the; computation. For example, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENERGY¶. SAPT EXCH ENERGY¶. SAPT IND ENERGY¶; Respectively, the dispersion, electrostatics, exchange, and induction; components of the total electronic interaction energy [H] for the the; requested SAPT level of theory. The sum of these four components yields; SAPT TOTAL ENERGY. SAPT TOTAL ENERGY¶; The total electronic interaction ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html:17392,optimiz,optimized,17392,psi4manual/1.2.1/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/glossary_psivariables-1.html,4,['optimiz'],['optimized']
Performance,"etical, algorithmic,; or implementation contributions specific to PSI4 (in addition to; appropriate references for the underlying theory, which are not necessarily; included in the list below). Density Cumulant Functional Theory (DCFT)¶. “Density Cumulant Functional Theory: First Implementation and; Benchmark Results for the DCFT-06 Model,” A. C. Simmonett,; J. J. Wilke, H. F. Schaefer, and W. Kutzelnigg, J. Chem. Phys.; 133, 174122 (2010).; (doi: 10.1063/1.3503657).; “Analytic gradients for density cumulant functional theory: The; DCFT-06 model,” A. Yu. Sokolov, J. J. Wilke, A. C. Simmonett,; and H. F. Schaefer, J. Chem. Phys. 137, 054105 (2012).; (doi: 10.1063/1.4739423).; “Density cumulant functional theory: The DC-12 method, an improved; description of the one-particle density matrix,” A. Yu. Sokolov,; A. C. Simmonett, and H. F. Schaefer, J. Chem. Phys. 138, 024107; (2013).; (doi: 10.1063/1.4773580). Configuration Interaction (CI)¶; PSI has a highly optimized code for full configuration interaction; and highly correlated configuration interaction, as described in. “The Configuration Interaction Method: Advances in Highly; Correlated Approaches,” C. D. Sherrill and H. F. Schaefer, in; Adv. Quantum Chem., vol. 34, P.-O. Löwdin, Ed.; (Academic Press, New York, 1999), pp. 143-269.; (doi: 10.1016/S0065-3276(08)60532-8). Coupled Cluster (CC)¶; A general discussion of coupled cluster theory is given in. “An Introduction to Coupled Cluster Theory for Computational; Chemists,” T. D. Crawford and H. F. Schaefer, Rev. Comp. Chem.; 14, 33-136 (2000).; (doi: 10.1002/9780470125915.ch2). Implementation of frozen natural orbital (FNO) coupled cluster theory; in PSI and its performance for non-covalent interactions is discussed; in. “Accurate Noncovalent Interaction Energies Using Truncated Basis Sets; Based on Frozen Natural Orbitals,” A. E. DePrince and C. D. Sherrill,; J. Chem. Theory Comput. 9, 293-299 (2013).; (doi: 10.1021/ct300780u). Implementation of density-fitted (DF) a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:3469,optimiz,optimized,3469,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,4,['optimiz'],['optimized']
Performance,"etries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:2803,optimiz,optimization,2803,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,12,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"etry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided information, se",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:312514,optimiz,optimize,312514,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,6,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,etry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA) w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3lyp-d3m; B3LYP Hybrid-GGA Exchange-Correlation Functional (,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:3619,optimiz,optimized,3619,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['optimiz'],['optimized']
Performance,"etry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:3761,optimiz,optimized,3761,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,4,['optimiz'],['optimized']
Performance,"etry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:3491,optimiz,optimized,3491,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,2,['optimiz'],['optimized']
Performance,etry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj;  . b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj;  . b3lyp-d3mbj;  . b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj;  . b3pw91; B3PW91 Hyb-GGA Exchange-Correlation Functional. b3pw91-d3bj;  . b3pw91-nl; B3PW91-nl Hyb-GGA Exchange-Correlation Functional. b5050lyp; B5050LYP Hyb-GGA Exchange-Correlation Functional. b86b95; B86B95 ,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:2865,optimiz,optimized,2865,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,8,['optimiz'],['optimized']
Performance,etry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional (VWN1-RPA). b3lyp-d;  . b3lyp-d3;  . b3lyp-d3bj;  . b3lyp-d3m;  . b3lyp-d3mbj;  . b3lyp5; B3LYP5 Hybrid-GGA Exchange-Correlation Functional (VWN5). b3_x; Becke88 GGA Exchange (B3LYP weighting). b86bpbe; B86BPBE GGA Exchange-Correlation Functional. b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation Functional. b97-1; B97-1 Hybrid-GGA Exchange-Correlation Functional. b97-2; B97-2 Hybrid-GGA Exchange-Correlation Functional. b97-d;  . b97-d3;  . b97-d3bj;  . b97-d3m;  . b97-d3mbj;  . blyp; BLYP GGA Exchange-Correlation Functional. blyp-d;  . blyp-d3;  . blyp-d3bj;  . blyp-d3m;  . blyp-d3mbj;  . bp86; BP86 GGA Exchange-Correlation,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:3115,optimiz,optimized,3115,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,2,['optimiz'],['optimized']
Performance,"eturns the Beta Eigenvalues. epsilon_b_subset(self: psi4.core.Wavefunction, basis: str, subset: str) → psi4.core.Vector¶; Returns the requested Beta orbital energies subset. Parameters. basis – {‘AO’, ‘SO’, ‘MO’}; MO or SO select for Pitzer-ordering the return vector in the full computational point group symmetry.; AO selects for Pitzer-ordering the return vector without point group symmetry.; subset – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘FROZEN_OCC’, ‘ACTIVE_OCC’, ‘ACTIVE_VIR’, ‘FROZEN_VIR’}; Which subspace of orbital energies should be returned?. Returns; A Pitzer-ordered vector of the orbitals. Return type; Vector. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. finalize(self: psi4.core.HF) → None¶; Cleans up the the Wavefunction’s temporary data. finalize_energy()¶; Performs stability analysis and calls back SCF with new guess; if needed, Returns the SCF energy. This function should be called; once orbitals are ready for energy/property computations, usually; after iterations() is called. find_occupation(self: psi4.core.HF) → None¶; docstring. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. form_C(self: psi4.core.HF, shift: float = 0.0) → None¶; Forms the Orbital Matrices from the current Fock Matrices. form_D(self: psi4.core.HF) → None¶; Forms the Density Matrices from the current Orbitals Matrices. form_F(self: psi4.core.HF) → No",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html:21982,Perform,Performs,21982,psi4manual/1.5.0/api/psi4.core.cuhf.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.cuhf.html,10,['Perform'],['Performs']
Performance,"eturns the current legacy_wavefunction object from the most recent computation. psi4.core.libfock(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs a CPHF calculation, using libfock. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:233131,optimiz,optimization,233131,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['optimiz'],['optimization']
Performance,"etwork/disk/for/scratch/files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to your input; file:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 12; contains information about the internal coordiantes of a geometry optimization.; The user may want to retain this in the working directory; (i.e., where PSI4 was launched from) to analyze the optimization. This is; accomplished by the commands below:; psi4_io.set_specific_path(12, './'); psi4_io.set_specific_retention(12, True). # equivalent to above; psi4_io.set_specific_path(PSIF_INTCO, './'); psi4_io.set_specific_retention(PSIF_INTCO, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/external-1.html:6112,queue,queue,6112,psi4manual/1.4.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/external-1.html,9,['queue'],['queue']
Performance,"evel for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA)¶CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE)¶CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT)¶CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCT)¶DCT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC)¶OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY)¶CCENERGY — Selects the priority type for maintaining the automatic memory cach",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:10442,cache,cache,10442,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['cache'],['cache']
Performance,"even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes [5] and [6]; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water molecule using GeomeTRIC, with one of the two OH bonds constrained to 2.0 au; and the HOH angle constrained to 104.5 degrees:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'set' : [{'type' : 'distance',; 'indices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:21898,optimiz,optimize,21898,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,4,['optimiz'],['optimize']
Performance,"ew BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies for H2O. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fci-h2o; 6-31G H2O Test FCI Energy Point. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. cepa1; cc-pvdz H2O Test CEPA(1) Energy. ao-casscf-sp; CASSCF/6-31G** energy point. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. tdscf-6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:12520,perform,performs,12520,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"ew features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Symmetry; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algorithms; Convergence and Algorithm Defaults; Recommendations. Previous topic; Notes on Options; Next topic; DFT: Density Functional Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/scf-1.html:21382,optimiz,optimized,21382,psi4manual/4.0b3/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/scf-1.html,2,['optimiz'],['optimized']
Performance,"ewton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algorithm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/occ-1.html:13598,optimiz,optimized-,13598,psi4manual/1.3.2/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/occ-1.html,2,['optimiz'],['optimized-']
Performance,"example). psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. stability3; Test LDA stability analysis against QChem. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf-level-shift-rks; SCF level shift on an RKS computation. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. cc36; CC2(RHF)/cc-pVDZ energy of H2O. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. fnocc3; Test FNO-QCISD(T) computation. frac-sym; Fractional occupation with symmetry. tdscf-7; TD-HF test variable access. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dft1-alt; DFT Functional Test. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). scf-upcast-custom-basis; test scf castup with custom basis sets. mints4; A demonstration of mixed Cartesian/ZMatrix ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:21734,optimiz,optimization,21734,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"exceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if p4util.yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:9675,load,loading,9675,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,14,['load'],['loading']
Performance,"exceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS']:; try:; database.isOS; except AttributeError:; pass; else:; if yes.match(str(database.isOS)):; openshell_override = 1; core.print_out('\nSome reagents in database %s require an open",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:9758,load,loading,9758,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,1,['load'],['loading']
Performance,"exch-disp20. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. tu1-h2o-energy; Sample HF/cc-pVDZ H2O computation. mbis-5; MBIS calculation on ZnO. mbis-2; MBIS calculation on OH- (Expanded Arrays). nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. dft-freq-analytic; Analytic SVWN frequencies, compared to finite difference values. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. casscf-sp; CASSCF/6-31G** energy point. extern3; External potential calculation with one Ghost atom and one point charge at the same position. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dct-grad1; Various DCT analytic gradients for the O2 molecule with 6-31G basis set. cbs-xtpl-dict; Extrapolated water energies. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user nee",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:7753,optimiz,optimization,7753,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_OOFP (OPTKING)¶OPTKING — Specify out-of-plane angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_UOCC (GLOBALS)¶GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING)¶OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM)¶CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. G_CONVERGENCE (OPTKING)¶OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. GAUGE (ADC)¶ADC — Specifies the choice of representation of the electric dipole operator. * Acceptable values are LENGTH (default) and VELOCITY. Type: string; Possible Values: LENGTH, VELOCITY; Default: LENGTH. GAUGE (CCDENSITY)¶CCDENSITY — The type of gauge to use for properties. Type: string; Default: LENGTH. GAUGE (CCRESPONSE)¶CCRESPONSE — Specifies the choice of representation of the electric dipole operator. For polarizability, this keyword is ignored and LENGTH gauge is computed. For optical rotation and raman optical activity, this keyword is active, and acceptable values are LENGTH for the usua",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:141387,optimiz,optimization,141387,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['optimiz'],['optimization']
Performance,"expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/opt-1.html:14594,optimiz,optimize,14594,psi4manual/1.4.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/opt-1.html,4,['optimiz'],['optimize']
Performance,"expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns; Matrix – Total electronic gradient in Hartrees/Bohr. Returns; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/opt-1.html:14594,optimiz,optimize,14594,psi4manual/1.5.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/opt-1.html,4,['optimiz'],['optimize']
Performance,"extra calls to addCharge to describe the full MM region.; To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; 1; 2; 3set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginnin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:33356,optimiz,optimization,33356,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['optimiz'],['optimization']
Performance,"ey needed to access benchmark, and; the Reaction object. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. load_qcdata_byproject(project, pythonpath=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; standard location for project :module dbse_project and function; load_project. Module search path can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_saptdata_frombfdb(sset='default', pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True)[source]¶; This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; For each component database, loads subsets from all functions; in module modname. Default modname usues standard generators. mcs = None¶; assembly pattern for transspecies modelchems; >>> print asdf.mcs.keys(); XXXX. plot_all_flats(modelchem=None, sset='default', xlimit=4.0, failoninc=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Generate pieces for inclusion into tables. Supply list of; modelchemistries to plot from modelchem, otherwise defaults to; all those available. Can modify subset sset and plotting; range xlimit.; >>> asdf.plot_all_flats(sset='tt-5min', xlimit=4.0). plot_axis(axis, modelchem, benchmark='default', sset='default', failoninc=True, verbose=False, color='sapt', view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶. plot_bars(modelchem, benchmark='default', sset=['default', 'hb', 'mx', 'dd'], failoninc=True, verbose=False, view=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Prepares ‘grey bars’ diagram for each mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:33745,load,loads,33745,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['load'],['loads']
Performance,"eyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:10352,optimiz,optimizations,10352,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['optimiz'],"['optimizations', 'optimize']"
Performance,"eyword FLEXIBLE_G_CONVERGENCE. Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Convergence Criteria; Output. Previous topic; ADC: Ab Initio Polarization Propagator; Next topic; Evaluation of One-Electron Properties; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/optking-1.html:10352,optimiz,optimizations,10352,psi4manual/4.0b5/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/optking-1.html,4,['optimiz'],"['optimizations', 'optimize']"
Performance,"eze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:7593,optimiz,optimize,7593,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimize']
Performance,"f 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Caching level for libdpd. Type: integer; Default: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:8300,cache,cache,8300,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,12,['cache'],['cache']
Performance,"f 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. DF_INTS_IO¶. IO caching for CP corrections, etc. Changing this selects Disk_DF over Mem_DF. Note that setting this forces DiskDFJK when SCF_TYPE=DF. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert COSX Algorithm¶. COSX_BASIS_TOLERANCE¶. Screening criteria for basis function values on COSX grids. Type: conv double; Default: 1.0e-10. COSX_DENSITY_TOLERANCE¶. Screening criteria for shell-pair densities in COSX. Type: conv double; Default: 1.0e-10. COSX_OVERLAP_FITTING¶. Do reduce numerical COSX errors with overlap fitting?. Type: boolean; Default: true. COSX_PRUNING_SCHEME¶. Pruning scheme for COSX grids. Type: string; Default: ROBUST. Expert snLinK Algorithm¶. SNLINK_BASIS_TOLERANCE¶. Screening criteria for basis function values on snLinK grids. Type: conv double; Default: 1.0e-10. SNLINK_DENSITY_TOLERANCE¶. Screening criteria for shell-pair densities in snLinK. Type: conv double; Default: 1.0e-10. SNLINK_FORCE_CARTESIAN¶. Force snLinK to use cartesian coordinates. Type: boolean; Default: false. SNLINK_GPU_MEM¶. Proportion (in %) of available GPU memory to allocate to snLinK. Type: boolean; Default: 90. SNLINK_GRID_BATCH_SIZE¶. Maximum numbe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__scf.html:21610,LOAD,LOAD,21610,psi4manual/master/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__scf.html,1,['LOAD'],['LOAD']
Performance,"f HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 1.00. HESS_UPDATE_LIMIT_SCALE (OPTKING)¶OPTKING — If HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST (OPTKING)¶OPTKING — Number of previous steps to use in Hessian update, 0 uses all. Type: integer; Default: 2. HESSIAN_WRITE (FINDIF)¶FINDIF — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ICORE (DETCI)¶DETCI — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. INCFOCK (SCF)¶SCF — Do Perform Incremental Fock Build?. Type: boolean; Default: false. INCFOCK_FULL_FOCK_EVERY (SCF)¶SCF — Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. INDUCED_CONVERGENCE (PE)¶PE — Threshold for induced moments convergence. Type: conv double; Default: 1e-8. INTCOS_GENERATE_EXIT (OPTKING)¶OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTEGRAL_CUTOFF (DFOCC)¶DFOCC — Cutoff value for DF integrals. Type: integer; Default: 9. INTEGRAL_PACKAGE (GLOBALS)¶GLOBALS — Integral package to us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:145331,perform,perform,145331,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"f HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 1.00. HESS_UPDATE_LIMIT_SCALE (OPTKING)¶OPTKING — If HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST (OPTKING)¶OPTKING — Number of previous steps to use in Hessian update, 0 uses all. Type: integer; Default: 2. HESSIAN_WRITE (FINDIF)¶FINDIF — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ICORE (DETCI)¶DETCI — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. INCFOCK (SCF)¶SCF — Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE (SCF)¶SCF — The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. INCFOCK_FULL_FOCK_EVERY (SCF)¶SCF — Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. INDUCED_CONVERGENCE (PE)¶PE — Threshold for induced moments convergence. Type: conv double; Default: 1e-8. INTCOS_GENERATE_EXIT (OPTKING)¶OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. IN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:147055,perform,perform,147055,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['perform'],['perform']
Performance,"f HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 1.00. HESS_UPDATE_LIMIT_SCALE (OPTKING)¶OPTKING — If HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST (OPTKING)¶OPTKING — Number of previous steps to use in Hessian update, 0 uses all. Type: integer; Default: 2. HESSIAN_WRITE (FINDIF)¶FINDIF — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ICORE (DETCI)¶DETCI — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. INDUCED_CONVERGENCE (PE)¶PE — Threshold for induced moments convergence. Type: conv double; Default: 1e-8. INTCOS_GENERATE_EXIT (OPTKING)¶OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. INTEGRAL_CUTOFF (DFOCC)¶DFOCC — Cutoff value for DF integrals. Type: integer; Default: 9. INTEGRAL_PACKAGE (GLOBALS)¶GLOBALS — Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT1, SIMINT, LIBINT2; Default: LIBINT2. INTERFRAG_DIST_INV (OPTKING)¶OPTKING — Do use \(\frac{1}{R_{AB}}\) for the stretching coordinate between fragments? Otherwise, use \(R_{AB}\",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:144931,perform,perform,144931,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"f HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 1.00. HESS_UPDATE_LIMIT_SCALE (OPTKING)¶OPTKING — If HESS_UPDATE_LIMIT is true, changes to the Hessian from the update are limited to the larger of HESS_UPDATE_LIMIT_SCALE * (the previous value) and HESS_UPDATE_LIMIT_MAX [au]. Type: double; Default: 0.50. HESS_UPDATE_USE_LAST (OPTKING)¶OPTKING — Number of previous steps to use in Hessian update, 0 uses all. Type: integer; Default: 4. HESSIAN_WRITE (FINDIF)¶FINDIF — Do write a hessian output file? If so, the filename will end in .hess, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. ICORE (DETCI)¶DETCI — Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. INCFOCK (SCF)¶SCF — Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE (SCF)¶SCF — The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. INCFOCK_FULL_FOCK_EVERY (SCF)¶SCF — Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. INDUCED_CONVERGENCE (PE)¶PE — Threshold for induced moments convergence. Type: conv double; Default: 1e-8. INTCOS_GENERATE_EXIT (OPTKING)¶OPTKING — Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. IN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:150206,perform,perform,150206,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['perform'],['perform']
Performance,"f a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. Presently, by default, separate fragments are bonded by the; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a minimal set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default) or linear combinations of atomic positions; (automatic use of principal axes is under development).; These dimer coordinates can be directly specified through INTERFRAG_COORDS); See here <DimerSection_> for two examples of their use. Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input.; molecul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:2424,optimiz,optimization,2424,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimization']
Performance,"f a Z-matrix input, and in particular the inclusion; of dummy atoms, has no effect on the behavior of the optimizer, which begins; from a Cartesian representation of the system. Presently, by default, separate fragments are bonded by the; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a minimal set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default) or linear combinations of atomic positions; (automatic use of principal axes is under development).; These dimer coordinates can be directly specified through INTERFRAG_COORDS); See here <DimerSection_> for two examples of their use. Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, RS_I_RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. Optimizing Minima¶; First, define the molecule and basis in the input",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:2433,optimiz,optimization,2433,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['optimiz'],['optimization']
Performance,"f any coupled cluster computation. General¶. ABCD¶. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do ?. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Type: double; Default: 1.27. CC_SS_SCALE¶. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and P. Pulay, J. Comp. Chem. 14, 736-740 (1993) and C. Hampel and H.-J. Werner, J. Chem. Phys. 104, 6286-6297 (1996). Type: double; Default: 0.02. LOCAL_METHOD¶. Type of local-CCSD scheme to be simulated. WERNER selects the method developed by H.-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html:1229,cache,cache,1229,psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__ccenergy-1.html,4,['cache'],['cache']
Performance,"f computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which Psi4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; SAPT: Symmetry-Adapted Perturbation Theory. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Cr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:11466,perform,perform,11466,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['perform'],['perform']
Performance,"f coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]In the simultaneous algorithm the DCT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultaneous algorithm is accelerated using the; DIIS extrapolation technique. TWOSTEPIn the two-step algorithm each macroiteration consists of two sets of; microiterations. In the first set, the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods. QCIn the quadratically-convergent algorithm, the; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:8805,perform,performed,8805,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['perform'],['performed']
Performance,"f greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUT_S2 (DFOCC); DFOCC — Do compute <S2> for DF-OMP2/DF-MP2?. Type: boolean; Default: false. COMPUTE_MP4_TRIPLES (FNOCC); FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC); FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that couple the reference determinants?. Type: boolean; Default: true. COVALENT_CONNECT (OPTKING); OPTKING — When determining connectivity, a bond is assigned if interatomic distance is less than (this number) * sum of covalent radii. Type: double; Default: 1.3. CPH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:88063,perform,perform,88063,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"f ketene, starting from bent structure. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. scf-uhf-grad-nobeta; UHF gradient for a one-electron system (no beta electrons). pywrap-align; apply linear fragmentation algorithm to a water cluster. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. fnocc6; Test method/basis with disk_df. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. cepa-module; routing check on lccd, lccsd, cepa(0). dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. ao-casscf-sp; CASSCF/6-31G** energy point. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with varia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:38033,optimiz,optimized,38033,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimized']
Performance,"f not (lowername in procedures[types[dertype]]):; print('Frequencies: dertype = %d for frequencies is not available, switching to automatic determination.' % dertype); dertype = -1. if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # By default, set func to the energy function; func = energy; func_existed = False; if 'func' in kwargs:; func = kwargs['func']; func_existed = True. if (not('dertype' in kwargs) or dertype == -1):; if lowername in procedures['hessian']:; dertype = 2; elif lowername in procedures['gradient']:; dertype = 1; else:; dertype = 0. # Does an analytic procedure exist for the requested method?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction().energy(); elif (dertype == 1 and func_existed == False):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print(info). func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""); sys.stdout.flush(). # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:48233,Perform,Performing,48233,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Perform'],['Performing']
Performance,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:83531,perform,performed,83531,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['perform'],['performed']
Performance,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or str; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+-----------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=================================================================================================================+; | scf | Hartree--Fock (HF) or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:84730,perform,performed,84730,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['perform'],['performed']
Performance,"f not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. .. _`table:freq_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | scf | Hartree--Fock (HF) :ref:`[manu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:70642,perform,performed,70642,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['performed']
Performance,"f path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise ValidationError(; ""Reactions pickle file for loading database data from file %s does not exist"" % (pklfile)). with open(pklfile, 'rb') as handle:; hrxns = pickle.load(handle); # no error checking for speed; for rxn, data in hrxns.iteritems():; self.hrxn[rxn].data.update(data). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""Loads qcdb.ReactionDatums from HDF5 file at path/dbse_project.h5 .; If path not given, looks in qcdb/data. This file is written by; reap-DB and so has been largely validated. """"""; if path is None:; path = os.path.dirname(__file__) + '/../data'; hdf5file = os.path.abspath(path) + os.sep + self.dbse + '_' + project + '.h5'; if not os.path.isfile(hdf5file):; raise ValidationError(""HDF5 file for loading database data from file %s does not exist"" % (hdf5file)); try:; import pandas as pd; except ImportError:; raise ValidationError(""Pandas data managment module must be available for import""). try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; intrxn = False; else:; intrxn = True. with pd.get_store(hdf5file) as handle:; for mc in handle['pdie'].keys():; lmc = mc.split('-') # TODO could be done better; method = lmc[0]; bsse = '_'.join(lmc[1:-1]); basis = lmc[-1]. df = handle['pdie'][mc]; for dbrxn in df.index[df.notnull()].values:; [dbse, rxn] = dbrxn.split('-', 1); if intrxn:; rxn = int(rxn); self.hrxn[rxn].data[mc] = ReactionDatum.library_modelchem(dbse=dbse, rxn=rxn,; method=method, mode=bsse, basis=basis,; value=df[dbrxn]). [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; try:; next(self.hrxn.iterkeys()) + 1; except TypeError:; return False; else:; return True. @staticmethod; [docs] def load_pickled(dbname, path=None):; """""". """"""; if path is None:; path = os.path.dirname(__file__",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:39949,load,loading,39949,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loading']
Performance,"f ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""); if not core.get_local_option(""DFOCC"", ""CHOLESKY""):; scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()). ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if core.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['mp2.5', 'omp2.5']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['mp3', 'omp3']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['lccd', 'olccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); elif name in ['ccd']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:45436,optimiz,optimized,45436,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimized']
Performance,"f the Molecule observes the basis assignment to atoms. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. adc1; ADC/6-31G** on H2O. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. scf6; Tests RHF/ROHF/UHF SCF gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:8734,optimiz,optimization,8734,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"f the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. As a reminder, only; SAPT0 can handle the interaction of both closed- and open-shell monomers.; Higher-order SAPT is only available for computation of interactions between; closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module.; As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }. set {; reference uhf; scf_type df; basis cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:9920,perform,perform,9920,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,6,['perform'],['perform']
Performance,"f two-electron integrals in the evaluation of CCD T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: true. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'); energy('sapt2+(ccd)-ct'); energy('sapt2+(3)(ccd)-ct'); energy('sapt2+3(ccd)-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; ------------------------------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 [mEh] -1.3159 [kcal/mol] -5.5057 [kJ/mol]; SAPT Induction (Monomer Basis) -1.1396 [mEh] -0.7151 [kcal/mol] -2.9920 [kJ/mol]; SAPT Charge Transfer -0.9574 [mEh] -0.6008 [kcal/mol] -2.5137 [kJ/mol]. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centere",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:17765,perform,perform,17765,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['perform']
Performance,"f' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:2448,optimiz,optimization,2448,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"f'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:5230,optimiz,optimize,5230,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimize']
Performance,"f; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). In PsiAPI mode of operation, this syntax, psi4.set_num_threads(nthread), is; the primary way to control threading.; (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; 1set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. PBS job file¶; To run a PSI4 job on a PBS queueing system, you need to properly set up; all necessary variables in the PBS job file. Below is a minimal example of; a PBS job file for a threaded job, and a short explanation for each section.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26#!/bin/tcsh; #PBS -j oe; #PBS -l pmem=2120mb; #PBS -N jobname; #PBS -V. cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}; /psi/install/directory/bin/psi4 -i input.in -o input.out -n 4. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. The top section features PBS-specific commands. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/external-1.html:12561,queue,queueing,12561,psi4manual/1.1.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/external-1.html,6,['queue'],['queueing']
Performance,"f_guess):; psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True); psi4.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:. psi4.set_global_option(""FRAC_OCC"", [LUMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; psi4.set_global_option(""GUESS"", old_guess); if (hf_guess):; psi4.set_global_option(""FRAC_START"", 0); psi4.set_global_option(""REFERENCE"",""UHF""); energy('scf'); psi4.set_global_option(""REFERENCE"",""UKS""); psi4.set_global_option(""GUESS"", ""READ""); psi4.set_global_option(""FRAC_LOAD"", False). psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(HOMO)-1]). occs.append(oc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:4912,LOAD,LOAD,4912,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['LOAD'],['LOAD']
Performance,"face can use classic or mctc-gcp executables but only the latter implements “B97-3c” and “r2SCAN-3c”.; The newest wB97X-3c method doesn’t use a gcp correction (it does use ECPs down to first row elements); but is listed here for completeness of the “3c” family.; A DFTD3 executable, classic or simple-dftd3, must also be available for; the HF-3c, PBEh-3c, or B97-3c methods to run.; A DFTD4 python module must also be available for; the r2SCAN-3c or wB97X-3c methods to run.; These method are defined with their own basis set and thus no basis set should be set by the user.; PSI4 will select the intended basis sets: HF-3c/MINIX, PBEh-3c/def2-mSVP, B97-3c/def2-mTZVP, r2SCAN-3c/def2-mTZVPP, wB97X-3c/vDZP.; If a basis has previously been set for another calculation, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). r2SCAN-3c with default basis after basis set; set basis cc-pvdz; energy('r2scan3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PBEh-3c method/basis; combinations, func. Returns energy if dert",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/gcp.html:3257,optimiz,optimization,3257,psi4manual/1.9.x/gcp.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/gcp.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"face to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; FROZEN_UOCC; MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; Interface to MRCC by M. Kállay; Next topic; Geometry Optimization; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Theoretical Methods: SCF to FCI ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/detci-1.html:10979,perform,perform,10979,psi4manual/4.0b3/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/detci-1.html,2,['perform'],['perform']
Performance,"faces: Enhancing PSI4 Capabilities; Introduction; Introduction; Interface to LIBEFP by I. Kaliman; Interface to LIBEFP by I. Kaliman; Interface to Libint by E. Valeev; Interface to Libint by E. Valeev; Interface to Libxc by M. A. L. Marques; Interface to Libxc by M. A. L. Marques; Adding Add-Ons; Adding Add-Ons; Git, Versioning; Git, Versioning; Managing: Git, Conda, CMake and all that; Managing: Git, Conda, CMake and all that; Theoretical Methods: SCF to FCI; Theoretical Methods: SCF to FCI; Interface to Molden — molden(); Interface to Molden — molden(); Interface to MRCC by M. Kállay; Interface to MRCC by M. Kállay; <no title>; <no title>; Basis Set Superposition Corrections; Basis Set Superposition Corrections; Notes on Options; Notes on Options; Notes on Options; Notes on Options; Interface to NumPy; Interface to NumPy; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Evaluation of One-Electron Properties — oeprop(); Evaluation of One-Electron Properties — oeprop(); Geometry Optimization — optimize() and gradient(); Geometry Optimization — optimize() and gradient(); LibOptions: globals, locals, has_changed and all that; LibOptions: globals, locals, has_changed and all that; Geometry Optimization; Geometry Optimization; Interface to PCMSolver by R. Di Remigio; Interface to PCMSolver by R. Di Remigio; PEP1: Proposing PsiPEP for PSI4; PEP1: Proposing PsiPEP for PSI4; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Plugin v2rdm_casscf by A. E. DePrince; Plugin v2rdm_casscf by A. E. DePrince; Creating New Plugins; Creating New Plugins; Adding Methods to Driver; Adding Methods to Driver; Linear Algebra in PSI4; Linear Algebra in PSI4; Community Code of Conduct; Community Code of Conduct; Programming with the Core Libraries; Programming with the Core Libraries; Debugging and Profiling; Debugging and Profiling;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:498566,optimiz,optimize,498566,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['optimiz'],['optimize']
Performance,"faces: Enhancing PSI4 Capabilities; Introduction; Introduction; Interface to LIBEFP by I. Kaliman; Interface to LIBEFP by I. Kaliman; Interface to Libint by E. Valeev; Interface to Libint by E. Valeev; Interface to Libxc by M. A. L. Marques; Interface to Libxc by M. A. L. Marques; Adding Add-Ons; Adding Add-Ons; Git, Versioning; Git, Versioning; Managing: Git, Conda, CMake and all that; Managing: Git, Conda, CMake and all that; Theoretical Methods: SCF to FCI; Theoretical Methods: SCF to FCI; Interface to Molden — molden(); Interface to Molden — molden(); Interface to MRCC by M. Kállay; Interface to MRCC by M. Kállay; <no title>; <no title>; Basis Set Superposition Corrections; Basis Set Superposition Corrections; Notes on Options; Notes on Options; Notes on Options; Notes on Options; Interface to NumPy; Interface to NumPy; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Evaluation of One-Electron Properties — oeprop(); Evaluation of One-Electron Properties — oeprop(); Geometry Optimization — optimize() and gradient(); Geometry Optimization — optimize() and gradient(); LibOptions: globals, locals, has_changed and all that; LibOptions: globals, locals, has_changed and all that; Geometry Optimization; Geometry Optimization; Interface to PCMSolver by R. Di Remigio; Interface to PCMSolver by R. Di Remigio; PEP1: Proposing PsiPEP for PSI4; PEP1: Proposing PsiPEP for PSI4; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Plugin v2rdm_casscf by A. E. DePrince; Plugin v2rdm_casscf by A. E. DePrince; Plugins: Adding New Functionality to PSI4; Plugins: Adding New Functionality to PSI4; Adding Methods to Driver; Adding Methods to Driver; Linear Algebra in PSI4; Linear Algebra in PSI4; Programmers FAQ; Programmers FAQ; Programming: Using the Core Libraries; Programming: Using the Core Libraries; Property; Property; PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:413533,optimiz,optimize,413533,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,4,['optimiz'],['optimize']
Performance,"false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING); OPTKING — Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN (OPTKING); OPTKING — Specify atom and X, XY, XYZ, … to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Defaul",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:134199,optimiz,optimized,134199,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimized']
Performance,"fault: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. RESTRICTED_DOCC¶. The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html:3446,perform,perform,3446,psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__psimrcc-1.html,12,['perform'],['perform']
Performance,"fault: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Will be removed in v1.7. Type: integer; Default: 2. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START¶. The minimum iteration to start storing DIIS vectors and performing ADIIS/EDIIS. Type: integer; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. INCFOCK¶. Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE¶. The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. INCFOCK_FULL_FOCK_EVERY¶. Frequency with which to compute the full Fock matrix if using INCFOCK . N means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. LINK_INTS_TOLERANCE¶. The screening tolerance used for ERI/Density sparsity in the LinK algorithm. Type: conv double; Default: 1.0e-12. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html:5944,perform,perform,5944,psi4manual/1.7.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html,8,['perform'],['perform']
Performance,"fault: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM —. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 —. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM —. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:6777,cache,cacheing,6777,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,4,"['cache', 'perform']","['cacheing', 'perform']"
Performance,"fault: 50. CHOLESKY¶. Do Cholesky decomposition of the ERI tensor. Type: boolean; Default: false. CHOLESKY_TOLERANCE¶. tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. COMPUT_S2¶. Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 8. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. EKT_IP¶. Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html:1555,perform,perform,1555,psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html,36,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"fault: 50. CHOLESKY¶. Do Cholesky decomposition of the ERI tensor. Type: boolean; Default: false. CHOLESKY_TOLERANCE¶. tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. COMPUT_S2¶. Do compute \(\langle \hat{S}^2 \rangle\) for DF-OMP2/DF-MP2?. Type: boolean; Default: false. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 8. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. EKT_IP¶. Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html:1550,perform,perform,1550,psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,12,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"fault: 50. SCF_MEM_SAFETY_FACTOR (SCF); SCF — Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE (CPHF); CPHF — SCF Type. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: DIRECT. SCF_TYPE (SCF); SCF — What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, FAST_DF, CD; Default: PK. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM); CCEOM — Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. SCHWARZ_CUTOFF (CPHF); CPHF — The schwarz cutoff value. Type: double; Default: 1.0e-12. SCREEN_INTS (CCENERGY); CCENERGY — Do screen integrals?. Type: boolean; Default: false. SCS (CCENERGY); CCENERGY — Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS (CPHF); CPHF — Do perform a spin component scaled MP2 computation?. Type: boolean; Default: false. SCS_CCSD (CCENERGY); CCENERGY — Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_CCSD (FNOCC); FNOCC — Do SCS-CCSD?. Type: boolean; Default: false. SCS_CEPA (FNOCC); FNOCC — Do SCS-CEPA? Note that the scaling factors will be identical to those for SCS-CCSD. Type: boolean; Default: false. SCS_MP2 (CCENERGY); CCENERGY — Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS_MP2 (FNOCC); FNOCC — Do SCS-MP2?. Type: boolean; Default: false. SCS_N (CCENERGY); CCENERGY — Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_N (CPHF); CPHF — Do perform a spin component scaled (N) MP2 computation?. Type: boolean; Default: false. SCS_TYPE (OCC); OCC — Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SCSN_MP2 (CCENERGY); CCENERGY — Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:116167,perform,perform,116167,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"fault: 6. DIIS_MAX_VECS (DETCI); DETCI — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (FNOCC); FNOCC — Desired number of DIIS vectors. Type: integer; Default: 8. DIIS_MAX_VECS (MCSCF); MCSCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (PSIMRCC); PSIMRCC — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (SCF); SCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS (DCFT); DCFT (Expert) — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. DIIS_MIN_VECS (DETCI); DETCI — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_MIN_VECS (SCF); SCF — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_START (PSIMRCC); PSIMRCC — The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. DIIS_START (SCF); SCF — The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. DIIS_START_CONVERGENCE (DCFT); DCFT — Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations. Type: conv double; Default: 1e-3. DIIS_START_ITER (CCENERGY); CCENERGY — Iteration at which to start DIIS extrapolation. Type: integer; Default: 3. DIIS_START_ITER (DETCI); DETCI — Iteration at which to start using DIIS. Type: integer; Default: 1. DIPMOM (DETCI); DETCI — Do compute the dipole moment?. Type: boolean; Default: false. DIPMOM (FNOCC); FNOCC — Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF); FINDIF — Displacement size in au for f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:33831,perform,performed,33831,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"fault: 6. DIIS_MAX_VECS (DETCI); DETCI — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 5. DIIS_MAX_VECS (FNOCC); FNOCC — Desired number of DIIS vectors. Type: integer; Default: 8. DIIS_MAX_VECS (MCSCF); MCSCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (PSIMRCC); PSIMRCC — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_MAX_VECS (SCF); SCF — Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS (DCFT); DCFT (Expert) — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. DIIS_MIN_VECS (DETCI); DETCI — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_MIN_VECS (SCF); SCF — Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 2. DIIS_START (PSIMRCC); PSIMRCC — The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. DIIS_START (SCF); SCF — The minimum iteration to start storing DIIS vectors. Type: integer; Default: 1. DIIS_START_CONVERGENCE (DCFT); DCFT — Value of RMS of the density cumulant residual and SCF error vector below which DIIS extrapolation starts. Same keyword controls the DIIS extrapolation for the solution of the response equations. Type: conv double; Default: 1e-3. DIIS_START_ITER (DETCI); DETCI — Iteration at which to start using DIIS. Type: integer; Default: 1. DIPMOM (DETCI); DETCI — Do compute the dipole moment?. Type: boolean; Default: false. DIPMOM (FNOCC); FNOCC — Compute the dipole moment? Note that dipole moments are only available in the FNOCC module for the ACPF, AQCC, CISD, and CEPA(0) methods. Type: boolean; Default: false. DISP_SIZE (FINDIF); FINDIF — Displacement size in au for finite-differences. Type: double; Default: 0.005. DISTRIBUTED_MATRIX (SCF); SCF (Expert) — The dimension sizes of t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:105152,perform,performed,105152,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,6,['perform'],['performed']
Performance,"fault: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through higher-order SAPT; computations. The SAPT module can perform density-fitted evaluations; of SAPT2, SAPT2+, SAPT2+(3), and SAPT2+3 energies. Publications resulting; from the use of the higher-order SAPT code should cite the following:; [Hohenstein:2010:014101].; For methods SAPT2+ and above, one can replace the many-body treatment of; dispersion by an improved method based on coupled-cluster doubles (CCD).; This approach tends to give good improvements when dispersion effects; are very large, as in the PCCP dimer (see [Hohenstein:2011:2842]).; As shown in [Parker:2014:094106], whether or not CCD dispersion offers; more accurate interaction energies tends to depend on the SAPT truncation; and basis set employed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code in Psi; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:11675,perform,perform,11675,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['perform']
Performance,"fault: PSIF_AO_OPDM. PITZER¶. Do ?. Type: boolean; Default: false. PRESORT_FILE¶. Type: integer; Default: PSIF_SO_PRESORT. PRINT_LVL¶. Type: integer; Default: 1. PRINT_MOS¶. Do ?. Type: boolean; Default: false. PRINT_OE_INTEGRALS¶. Do ?. Type: boolean; Default: false. PRINT_REORDER¶. Do ?. Type: boolean; Default: false. PRINT_SORTED_OE_INTS¶. Do ?. Type: boolean; Default: false. PRINT_SORTED_TE_INTS¶. Do ?. Type: boolean; Default: false. PRINT_TE_INTEGRALS¶. Do ?. Type: boolean; Default: false. PSIMRCC¶. Do ?. Type: boolean; Default: false. QRHF¶. Do ?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. REORDER¶. Do ?. Type: boolean; Default: false. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SORTED_TEI_FILE¶. Type: integer; Default: PSIF_MO_TEI. SO_S_FILE¶. Type: integer; Default: PSIF_OEI. SO_TEI_FILE¶. Type: integer; Default: PSIF_SO_TEI. SO_T_FILE¶. Type: integer; Default: PSIF_OEI. SO_V_FILE¶. Type: integer; Default: PSIF_OEI. TPDM_ADD_REF¶. Do ?. Type: boolean; Default: false. TPDM_FILE¶. Type: integer; Default: PSIF_MO_TPDM. Expert¶. RAS1¶. An array giving the number of orbitals per irrep for RAS1. Type: array; Default: No Default. RAS2¶. An array giving the number of orbitals per irrep for RAS2. Type: array; Default: No Default. RAS3¶. An array giving the number of orbitals per irrep for RAS3. Type: array; Default: No Default. RAS4¶. An array giving the number of orbitals per irrep for RAS4. Type: array; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: CCSD. Table Of Contents. TRANSQT; General; AA_M_FILE; AB_M_FILE; AO_BASIS; BB_M_FILE; CHE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__transqt-1.html:3047,optimiz,optimized,3047,psi4manual/4.0b2/autodir_options_c/module__transqt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__transqt-1.html,4,['optimiz'],['optimized']
Performance,"fault: RHF. EX_ALLOW (DETCI); DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI); DETCI — The CI excitation level. Type: integer; Default: 2. EXCITATION_RANGE (CCEOM); CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF); CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF); SCF — An ExternalPotential (built by Python or NULL/None). Type: python; Default: No Default. FAVG (MCSCF); MCSCF — Do use the average Fock matrix during the SCF optimization?. Type: boolean; Default: false. FAVG_CCSD_T (PSIMRCC); PSIMRCC — Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FAVG_START (MCSCF); MCSCF — Iteration at which to begin using the averaged Fock matrix. Type: integer; Default: 5. FCI (DETCI); DETCI — Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FCI_STRINGS (DETCI); DETCI (Expert) — Do store strings specifically for FCI? (Defaults to TRUE for FCI.). Type: boolean; Default: false. FILTER_GUESS (DETCI); DETCI (Expert) — Do invoke the FILTER_GUESS options that are used to filter out some trial vectors which may not have the appropriate phase convention between two determinants? This is useful to remove, e.g., delta states when a sigma state is desired. The user inputs two determinants (by giving the absolute alpha string number and beta string number for each), and also the desired phase between th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:30095,optimiz,optimization,30095,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"fchk(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. Added in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction); filename (str); debug (bool); strict_label (bool). >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.fchk.html:1249,optimiz,optimized,1249,psi4manual/master/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.fchk.html,2,['optimiz'],['optimized']
Performance,"fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis with A. geometry(geom[, name]); Function to create a molecule object of name name from the :rtype: Molecule. get_memory(); Return the total memory allocation in bytes. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:18303,optimiz,optimize,18303,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,1,['optimiz'],['optimize']
Performance,"fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Return the total memory allocation in bytes. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:18204,optimiz,optimize,18204,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['optimiz'],['optimize']
Performance,"fchk(wfn, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Return the total memory allocation in bytes. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geome",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:18256,optimiz,optimize,18256,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['optimiz'],['optimize']
Performance,"fective fragment potential (EFP) [manual]. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. hf3c; HF with dispersion, BSSE, and basis set corrections [manual]. pbeh3c; PBEh with dispersion, BSSE, and basis set corrections [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order Møller–Plesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. scs-omp2; spin-component scaled OMP2 [manual]. scs(n)-omp2; a special version of SCS-OMP2 for nucleobase interactions [manual]. scs-omp2-vdw; a special version of SCS-OMP2 (from ethene dimers) [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. sos-pi-omp2; A special version of SOS-OMP2 for pi systems [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. scs-omp3; spin-component scaled OMP3 [manual]. scs(n)-omp3; a special version of SCS-OMP3 for nucleobase interactions [manual]. scs-omp3-vdw; a special version of SCS-OMP3 (from ethene dimers) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/energy-1.html:2257,optimiz,optimized,2257,psi4manual/1.1.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/energy-1.html,11,['optimiz'],['optimized']
Performance,"fects up to the number of fragments. embedding_charges (dict) – {1: [-0.834, 0.417, 0.417], ..}; Dictionary of atom-centered point charges. keys: 1-based index of fragment, values: list of charges for each fragment.; Add atom-centered point charges for fragments whose basis sets are not included in the computation. The nbody function computes counterpoise-corrected (CP), non-CP (noCP), and Valiron-Mayer Function Counterpoise (VMFC) interaction energies for complexes composed of arbitrary numbers of monomers.; Examples :; set {; basis def2-svp; }. # Counterpoise corrected CCSD(T) energies for the Helium dimer; molecule mol {; He; --; He 1 3; }; # Calculate interaction energies only (skips monomers in monomer basis):; energy('CCSD(T)', bsse_type='cp'); # Calculate interaction and total energies, return interaction energies:; energy('CCSD(T)', bsse_type=['cp','nocp']); # Calculate and return counterpoise-corrected gradient; # Useful for e.g. CP-corrected geometry optimization; gradient('CCSD(T)', bsse_type='cp', return_total_data=True). # noCP, VMFC, and CP energy for a helium cluster, limited at 3 bodies; molecule mol {; He 0 0 0; --; He 0 0 4; --; He 0 4 0; --; He 4 0 0; }. # Returns the nocp energy as its first in the list; energy('CCSD(T)', bsse_type=['nocp', 'cp', 'vmfc'], max_nbody=3). API¶. class psi4.driver.driver_nbody.BsseEnum(value)[source]¶; Available basis-set superposition error (BSSE) treatments. cp = 'cp'¶. nocp = 'nocp'¶. vmfc = 'vmfc'¶. pydantic model psi4.driver.driver_nbody.ManyBodyComputer[source]¶. Show JSON schema{; ""title"": ""ManyBodyComputer"",; ""description"": ""Base class for \""computers\"" that plan, run, and process QC tasks."",; ""type"": ""object"",; ""properties"": {; ""molecule"": {; ""title"": ""Molecule"",; ""description"": ""The target molecule, if not the last molecule defined.""; },; ""basis"": {; ""title"": ""Basis"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""method"": {; ""title"": ""Method"",; ""default"": ""(auto)"",; ""type"": ""string""; },; ""driver"": {; ""descrip",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/nbody.html:3422,optimiz,optimization,3422,psi4manual/master/nbody.html,https://psicode.org,https://psicode.org/psi4manual/master/nbody.html,1,['optimiz'],['optimization']
Performance,"fee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/lib/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Indicates whether correction for deformation energy is; employed in computing interaction energies. Option available; (See Available Databases) onl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/db-1.html:1888,perform,performs,1888,psi4manual/4.0b5/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/db-1.html,8,"['optimiz', 'perform']","['optimization', 'optimize', 'performs']"
Performance,"ference computation, using the PubChem database to obtain the initial geometry, at the UHF an ROHF levels of theory. cc44; Test case for some of the PSI4 out-of-core codes. The code is given only 2.0 MB of memory, which is insufficient to hold either the A1 or B2 blocks of an ovvv quantity in-core, but is sufficient to hold at least two copies of an oovv quantity in-core. cc35; CC3(ROHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:19740,optimiz,optimization,19740,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"fference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. scf6; Tests RHF/ROHF/UHF SCF gradients. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. cbs-xtpl-alpha; Extrapolated water energies. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dft-custom; DFT custom functional test. dft2; DFT Functional Test. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cepa-module; routing check on lccd, lccsd, cepa(0). dct12; Spin-restricted DC-06 counterpart of dct1. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints12; test roundtrip-ness of dict repr for psi4.core.Molecule and qcdb.Molecule. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). omp2p5-2; OMP2.5 cc-pVDZ energy for the H2O molecule. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. ddd-function-kwargs; check distributed driver is correctly passing function kwargs. numpy-array-interface; Numpy interface testing. cc54; CCSD dipole with user-specified basis set. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dft-dens-cut; LibXC density screening te",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:15432,perform,performed,15432,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"ficient. Analytic gradients are not available for the three-particle energy; correction \((\lambda_3)\). Methods Summary¶; The table below summarizes current DCT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. \(\mbox{ODC-12$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. \(\mbox{ODC-13$(\lambda_3)$}\); SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE RHF is only available for; ALGORITHM SIMULTANEOUS. To compute \((\lambda_3)\) correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dct'). The energy('dct') call to energy() executes the DCT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dct'). The optimize('dct') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. Ho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:13311,perform,perform,13311,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['perform'],['perform']
Performance,"fied, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:10509,optimiz,optimize,10509,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,7,['optimiz'],['optimize']
Performance,"file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request – ask the forum; Why do you? – ask the forum; When will you? – ask the forum; I have an experience that can improve the build documentation – inform the forum or add to the documentation itself; Anything you want to share privately – crawdad@vt.edu or sherrill@gatech.edu. Footnotes. 1; Frozen natural orbital variant available. In particular, RHF available as CONV. 2(1,2); Frozen natural orbital variant available. In particular, RHF available as CONV/DF. 3(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21); threading through BLAS routines only. 4; DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. DH-DFT gradients not implemented. 5; Both EFP/EFP and QM/EFP energies are available. 6; Adapted from here. 7; DH-DFT only available with DF-MP2. 8(1,2,3,4); Not all combinations of reference and algorithm available. In particular, non-RHF references only available as CONV. For CCSD(T), gradients are not available with frozen core. 9; Orbital-optimized variant available. In particular, all references available as CONV/DF. 10(1,2,3,4,5,6,7,8,9,10); Capabilities breakdown in great detail can be found here. table of contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Theory (DCT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree–Fock Methods; Algebraic-Diagrammatic Construction methods (ADC); Density Matrix Renormalization Group (DMRG); Scalar Relativistic Corrections. Supported Systems; License; Capabilities; Technical Support. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Introduction. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:28052,optimiz,optimized,28052,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,2,['optimiz'],['optimized']
Performance,"file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request – ask the forum; Why do you? – ask the forum; When will you? – ask the forum; I have an experience that can improve the build documentation – inform the forum or add to the documentation itself; Anything you want to share privately – crawdad@vt.edu or sherrill@gatech.edu. Footnotes. 1; Frozen natural orbital variant available. In particular, RHF available as CONV. 2(1,2); Frozen natural orbital variant available. In particular, RHF available as CONV/DF. 3(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21); threading through BLAS routines only. 4; DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. DH-DFT gradients not implemented. 5; Both EFP/EFP and QM/EFP energies are available. 6; Adapted from here. 7; DH-DFT only available with DF-MP2. 8(1,2,3,4); Not all combinations of reference and algorithm available. In particular, non-RHF references only available as CONV. For CCSD(T), gradients are not available with frozen core. 9; Orbital-optimized variant available. In particular, all references available as CONV/DF. 10(1,2,3,4,5,6,7,8,9,10); Capabilities breakdown in great detail can be found here. table of contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Theory (DCT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree–Fock Methods; Algebraic-Diagrammatic Construction methods (ADC); Density Matrix Renormalization Group (DMRG); Scalar Relativistic Corrections. Supported Systems; License; Capabilities; Technical Support. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Introduction. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/introduction-1.html:28108,optimiz,optimized,28108,psi4manual/1.5.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/introduction-1.html,2,['optimiz'],['optimized']
Performance,"file auto-generated from the hessian() wrapper.\n\n'); fmaster.write(p4util.format_molecule_for_input(molecule)); fmaster.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (frequency.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(); psi4.print_out(instructionsM). for n, displacement in enumerate(displacements):; rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Energy Displacement %d ')\n"""""" % (n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if (freq_mode.lower() == 'continuous'):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; func(lowername, **kwargs). # Save the energy; energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif (freq_mode.lower() == 'sow'):; molecule.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nHESSIAN RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:68958,Load,Load,68958,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Load'],['Load']
Performance,"file for the plugin (new style).; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file. Then,; the plugin can be loaded as import myplugin and executed as; energy('myplugin'). Any other Python functions are also available from; the input file, e.g. myplugin.testfunction(), note the namespace; protection. doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile, myplugin.cc, and input.dat files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; inputalt.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/plugins-1.html:7378,load,loading,7378,psi4manual/4.0b3/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/plugins-1.html,4,['load'],['loading']
Performance,"file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Table Of Contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Output. Previous topic; Scalar relativistic Hamiltonians; Next topic; oeprop() Evaluation of One-Electron Properties. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:14033,optimiz,optimizations,14033,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,6,['optimiz'],"['optimizations', 'optimize']"
Performance,"file.\n#\n""""""; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n\n"""""" % ('FREQ-master.in', 'FREQ-master.out'). fmaster = open('FREQ-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the hessian() wrapper.\n\n'); fmaster.write(p4util.format_molecule_for_input(molecule)); fmaster.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (frequency.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(); psi4.print_out(instructionsM). for n, displacement in enumerate(displacements):; rfile = 'FREQ-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Hessian Computation: Energy Displacement %d ')\n"""""" % (n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if (freq_mode.lower() == 'continuous'):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; func(lowername, **kwargs). # Save the energy; energies.append(psi4.get_variable('CURRENT ENERGY')). # clean may be necessary when changing irreps of displacements; psi4.clean(). # S/R: Write each displaced geometry to an input file; elif (freq_mode.lower() == 'sow'):; molecule.set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:68776,Load,Loading,68776,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Load'],['Loading']
Performance,"fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number \(N\).; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # FRAC jobs will be be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do all kinds",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:25435,optimiz,optimized,25435,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['optimiz'],['optimized']
Performance,"fix to use for writing files for external programs. git_version(). Deprecated since version 1.4. has_array_variable(key); Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). has_global_option_changed(key); Whether keyword key value has been touched at global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. SCF). print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:6873,optimiz,optimized,6873,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,1,['optimiz'],['optimized']
Performance,"fix to use for writing files for external programs. git_version(). Deprecated since version 1.4. has_array_variable(key); Is the Matrix QCVariable key (case-insensitive) set? Prefer has_variable(). has_global_option_changed(key); Whether keyword key value has been touched at global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_srcdir(); Returns the location of the source code. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:6871,optimiz,optimized,6871,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,1,['optimiz'],['optimized']
Performance,"float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → None¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → float¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fcidump_tei_helper(nirrep: int, restricted: bool, DPD_info: Dict[str, int], ints_tolerance: float, fname: str='INTDUMP') → None¶; Write integrals to file in FCIDUMP format. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:226256,optimiz,optimized,226256,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['optimiz'],['optimized']
Performance,"float¶; Runs the coupled cluster response theory code. psi4.core.cctransort(arg0: psi::Wavefunction) → None¶; Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. psi4.core.cctriples(arg0: psi::Wavefunction) → float¶; Runs the coupled cluster (T) energy code. psi4.core.clean() → None¶; Function to remove scratch files. Call between independent jobs. psi4.core.clean_options() → None¶; Function to reset options to clean state. psi4.core.clean_variables() → None¶; Empties all PSI variables that have set internally. psi4.core.close_outfile() → None¶; Closes the output file. psi4.core.dcft(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density cumulant functional theory code. psi4.core.detci(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the determinant-based configuration interaction code. psi4.core.dfmp2(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DF-MP2 code. psi4.core.dfocc(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the density-fitted orbital optimized CC codes. psi4.core.displace_atom(arg0: psi::Matrix, arg1: int, arg2: int, arg3: int, arg4: float) → psi::Matrix¶; Displaces one coordinate of single atom. psi4.core.dmrg(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the DMRG code. psi4.core.efp_init() → psi4.core.EFP¶; Initializes the EFP library and returns an EFP object. psi4.core.efp_set_options() → None¶; Set EFP options from environment options object. psi4.core.fd_1_0(arg0: psi::Molecule, arg1: list) → psi::Matrix¶; Performs a finite difference gradient computation, from energy points. psi4.core.fd_freq_0(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from energy points, for a given irrep. psi4.core.fd_freq_1(arg0: psi::Molecule, arg1: list, arg2: int) → psi::Matrix¶; Performs a finite difference frequency computation, from gradients, for a given irrep. psi4.core.fd_geoms_1_0(arg0: psi::Molecule) → List[psi::Matrix]¶",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:147117,optimiz,optimized,147117,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['optimiz'],['optimized']
Performance,"fn = run_dct_property(name, **kwargs). derivobj = core.Deriv(dct_wfn); derivobj.set_tpdm_presorted(True); if core.get_option('DCT', 'DCT_TYPE') == 'CONV':; grad = derivobj.compute(); else:; grad = derivobj.compute_df('DF_BASIS_SCF', 'DF_BASIS_DCT'). dct_wfn.set_gradient(grad). optstash.restore(); return dct_wfn. def run_dct_property(name, **kwargs):; """""" Function encoding sequence of PSI module calls for; DCT property calculation. """"""; optstash = p4util.OptionsState(; ['DCT', 'OPDM']). core.set_local_option('DCT', 'OPDM', 'true');; dct_wfn = run_dct(name, **kwargs). # Run OEProp; oe = core.OEProp(dct_wfn); oe.set_title(""DCT""); for prop in kwargs.get(""properties"", []):; prop = prop.upper(); if prop in core.OEProp.valid_methods or ""MULTIPOLE("" in prop:; oe.add(prop); oe.compute(); dct_wfn.oeprop = oe. for k, v in dct_wfn.variables().items():; core.set_variable(k, v). optstash.restore(); return dct_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(corl_type):; if corl_type == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); proc_util.check_disk_df(name.upper(), optstash). elif corl_type == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_global_option_changed('SCF_TYPE'):; optstash.add_option(['SCF_TYPE']); core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_global_option('SCF_TYPE') != 'CD':; core.set_local_option('DFOCC', 'READ_SCF_3INDEX', 'FALSE'); else:; raise ValidationError(f""""""Invalid type '{corl_type}' for DFOCC""""""). if name in ['mp2', 'omp2']:; core.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:53909,optimiz,optimized,53909,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['optimiz'],['optimized']
Performance,"fn='mp2', corl_basis='cc-pv[dt]z'); energy(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": ""corl_xtpl_helgaker_2""}]). Caution; In PSI4 previous to Spring 2022 and v1.6, calling certain; cbs-related functions like the above looked like; energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z'). energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvtz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[dt]z"", ""scheme"": corl_xtpl_helgaker_2}]). The difference is that the main function; psi4.cbs() and extrapolation schemes like; psi4.driver.driver_cbs_helper.xtpl_highest_1() and; psi4.driver.driver_cbs_helper.scf_xtpl_helgaker_2() and composite; aliases like psi4.driver.aliases.sherrill_gold_standard(); and psi4.driver.aliases.allen_focal_point() in the old way; passed the Python function directly, whereas the new way uses the; string of the function name. A CCSD(T) DT coupled-cluster correction atop a TQ MP2 extrapolation; geometry optimization can also be accessed through the first item below more; conveniently than the equivalent second and third items. optimize('mp2/cc-pv[tq]z + D:ccsd(t)/cc-pvdz'); optimize(""cbs"", corl_wfn='mp2', corl_basis='cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='cc-pvdz'); optimize(""cbs"", cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pvqz""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvdz""}]). Many examples can be found at cbs-xtpl-energy,; cbs-xtpl-gradient, cbs-xtpl-opt,; cbs-xtpl-freq, cbs-xtpl-func,; cbs-xtpl-wrapper, cbs-xtpl-dict. psi4.cbs(name[, scf_basis, scf_scheme, corl_wfn, corl_basis, corl_scheme, delta_wfn, delta_wfn_lesser, delta_basis, delta_scheme, delta2_wfn, delta2_wfn_lesser, delta2_basis, delta2_scheme, cbs_metadata])[source]; Function to define a multistage energy method from combinations of; basis set extrapolations and delta corrections and condense the; components into a minimum number of calculations. Aliases; complete_basis_set(). Returns; (float) – Total el",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:1673,optimiz,optimization,1673,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,1,['optimiz'],['optimization']
Performance,"for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for local-coupled-perturbed-Hartree-Fock. Type: double; Default: 0.10. LOCAL_CUTOFF¶. Value (always between one and zero) for the Broughton-Pulay completeness check used to contruct orbital domains for local-CC calculations. See J. Broughton and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html:1549,cache,cache,1549,psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html,24,['cache'],['cache']
Performance,"for available; molecular systems (case insensitive). [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. This; is the only portion of database input that is case sensitive;; choices for this keyword must match the database python file. Examples:. 1; 2>>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). 1; 2; 3>>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). 1; 2>>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). 1; 2>>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). 1; 2>>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; 1; 2; 3; 4RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:5991,optimiz,optimize,5991,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,4,['optimiz'],['optimize']
Performance,"for dihedral angles between atoms. Type: string; Default: No Default. EXT_FORCE_DISTANCE¶. Specify formula for external forces for the distance between atoms. Type: string; Default: No Default. EXT_FORCE_OOFP¶. Specify formula for external forces for out-of-plane angles between atoms. Type: string; Default: No Default. FREEZE_ALL_DIHEDRALS¶. Freeze ALL dihedral angles. Type: boolean; Default: false. FROZEN_BEND¶. Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN¶. Specify atom and X, XY, XYZ, … to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL¶. Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE¶. Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_OOFP¶. Specify out-of-plane angles between atoms to be frozen (unchanged). Type: string; Default: No Default. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. H_UPDATE_DEN_TOL¶. Denominator check for hessian update. Type: conv double; Default: 1e-7. INTERFRAG_STEP_LIMIT¶. Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT¶. Initial maximum step size in bohr or radian along an internal coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT_MAX¶. Upper bound for dynamic trust radius [au]. Type: double; Default: 1.0. INTRAFRAG_STEP_LIMIT_MIN¶. Lower bound for dynamic trust radius [au]. Type: double; Default: 0.001. IRC_DIRECTION¶. IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_POINTS¶. Maximum number of IRC points to collect before stopping. Type: integer; Default: 20. IRC_STEP_SIZE¶. IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. OPT_COORDINATES¶. Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. CARTESIAN us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html:2295,optimiz,optimization,2295,psi4manual/master/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html,2,['optimiz'],['optimization']
Performance,"for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SCALE (OCC)¶OCC — A custom scaling parameter for same-spin terms in OCC. The result goes to a CUSTOM SCS variable, exact name method-dependent. Type: double; Default: 1. SS_SKIP_DIAG (CCEOM)¶CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM)¶CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT)¶FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCT)¶DCT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF)¶SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCT)¶DCT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCT)¶DCT (Expert) — Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCT)¶DCT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCT)¶DCT (Expert) — The maximum size of the sub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:220127,perform,perform,220127,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['perform'],['perform']
Performance,"for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CC_MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting to aid convergence. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift parameter. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orb",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html:1204,perform,perform,1204,psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,8,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"for mc, dbdat in dbdatdict.iteritems():; # print mc; # for d in dbdat:; # print '{:20s} {:8.2f} {:8.2f} {:8.2f}'.format(d['sys'], d['axis'],; # 0.0 if d['bmdata'] is None else d['bmdata'],; # 0.0 if d['mcdata'] is None else d['mcdata']); # generate matplotlib instructions and call or print; try:; from . import mpl; import matplotlib.pyplot as plt; except ImportError:; # if not running from Canopy, print line to execute from Canopy; print(""""""filedict = mpl.valerr(%s,\n color='%s',\n title='%s',\n xtitle='%s',\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, axis, view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.valerr(dbdatdict, color=color, title=title, xtitle=axis,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def load_saptdata_frombfdb(self, sset='default',; pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True): # pythonpath=None; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. """"""; saptpackage = OrderedDict(); for db, odb in self.dbdict.items():; modname = 'sapt_' + odb.dbse; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). try:; saptdata = getattr(datamodule, 'DATA'); except AttributeError:; raise ValidationError(""SAPT punt module does not contain DATA"" + str(modname)); saptmc = saptdata['SAPT MODELCHEM']. dbix = self.dbdict.keys().index(db); for rxn, orxn in odb.hrxn.iteritems():; lss = self.sset[sset][dbix]; if lss is not None:; if rxn in odb.s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:64770,load,loads,64770,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loads']
Performance,"for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:25639,perform,performed,25639,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['perform'],['performed']
Performance,"for the NO molecule. cepa-module; routing check on lccd, lccsd, cepa(0). pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cc17; Single point energies of multiple excited states with EOM-CCSD. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:28605,perform,performed,28605,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimiz",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:47396,optimiz,optimization,47396,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:47524,optimiz,optimization,47524,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"forces. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. mbis-5; MBIS calculation on ZnO. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cbs-parser; mtd/basis syntax examples. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. fci-dipole; 6-31G H2O Test FCI Energy Point. scf-response3; UHF Dipole Polarizability Test. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cbs-xtpl-alpha; Extrapolated water energies. extern3; External potential calculation with one Ghost atom and one point charge at the same position. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. cbs-delta-energy; Extrapolated energies with delta correction. dft1; DFT Functional Test all values update for new BraggSlater radii. scf-coverage; Lithium test for coverage. s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:35306,optimiz,optimization,35306,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft1-alt; DFT Functional Test. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. scf6; Tests RHF/ROHF/UHF SCF gradients. numpy-array-interface; Numpy interface testing. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. casscf-fzc-sp; CASSCF/6-31G** energy point. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer intera",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:13703,optimiz,optimization,13703,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"forming a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available. PSIthonPsiAPIe_mp2 = variable('MP2 TOTAL ENERGY'); e_scs_mp2 = variable('SCS-MP2 TOTAL ENERGY'). e_mp2 = psi4.variable('MP2 TOTAL ENERGY'); e_scs_mp2 = psi4.variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=Tru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:9965,optimiz,optimize,9965,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['optimiz'],['optimize']
Performance,"four and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html:3085,optimiz,optimization,3085,psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,6,['optimiz'],['optimization']
Performance,"frag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). import optking. Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """""";",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:4972,optimiz,optimize,4972,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimize']
Performance,"fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/kw-1; testing best practices options, part i. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:3719,optimiz,optimization,3719,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"freq. freq¶. psi4.driver.freq(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html:1119,perform,performs,1119,psi4manual/1.7.x/api/psi4.driver.freq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.freq.html,8,['perform'],['performs']
Performance,"freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. freq-isotope; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:27205,optimiz,optimization,27205,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"frequencies. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html:1049,perform,performed,1049,psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,4,['perform'],['performed']
Performance,"frequencies. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequencies-1.html:1049,perform,performed,1049,psi4manual/1.5.0/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequencies-1.html,4,['perform'],['performed']
Performance,"frequencies. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequencies.html:1049,perform,performed,1049,psi4manual/1.6.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequencies.html,2,['perform'],['performed']
Performance,"frequency. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequency-1.html:1049,perform,performed,1049,psi4manual/1.4.0/api/psi4.driver.frequency-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequency-1.html,4,['perform'],['performed']
Performance,"frequency. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequency-1.html:1049,perform,performed,1049,psi4manual/1.5.0/api/psi4.driver.frequency-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequency-1.html,4,['perform'],['performed']
Performance,"frequency. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases; frequencies(), freq(). Returns; float – Total electronic energy in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequency.html:1049,perform,performed,1049,psi4manual/1.6.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.frequency.html,2,['perform'],['performed']
Performance,"from a module specification and input dictionary. set_options(options_dict[, verbose]); Sets Psi4 options from an input dictionary. tdscf(wfn, **kwargs). temp_circular_import_blocker(). vibanal_wfn(wfn[, hess, irrep, molecule, ...]); Function to perform analysis of a hessian or hessian block, specifically. Classes¶. AtomicComputer; Computer for analytic single-geometry computations. ConvergenceError(eqn_description, iteration); Error called for problems with converging an iterative method. EmpiricalDispersion(*[, name_hint, ...]); Lightweight unification of empirical dispersion calculation modes. ManagedMethodError(circs); Error called when a requested level of theory and derivative level are nominally available but not for the particular conditions (e.g., reference, algorithm, active orbitals, QC module, etc.) requested. MissingMethodError(msg); Error called when requested level or theory or derivative level are not available. OptimizationConvergenceError(...); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for PSI4. QMMM(); Hold charges and psi4.core.ExternalPotential. QMMMbohr(); Hold charges and psi4.core.ExternalPotential. SCFConvergenceError(eqn_description, ...); Error called for problems with SCF iterations. TDSCFConvergenceError(iteration, wfn, what, ...); Error called for problems with TDSCF iterations. TestComparisonError(msg); Error called when a compare_values() or other comparison function fails. UpgradeHelper(old, new, version, elaboration); Error called on previously valid syntax that now isn't and a simple syntax transition is possible. ValidationError(msg); Input specification has problems. Class Inheritance Diagram¶. psi4.driver.p4util Package¶; Miscellaneous tools for driver and users. Functions¶. OptionsStat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:21521,optimiz,optimizer,21521,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,2,['optimiz'],['optimizer']
Performance,"from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. INTS_TOLERANCE (SCF)¶SCF — Screening threshold for the chosen screening method (SCHWARZ, CSAM, DENSITY) Absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. IP_POLES (OCC)¶OCC — Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. IRC_DIRECTION (OPTKING)¶OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING)¶OPTKING — IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. IRC_STOP (OPTKING)¶OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISOTROPIC_POL (PE)¶PE — Make polarizabilities isotropic. Type: boolean; Default: false. ISTOP (DETCI)¶DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. JOBTYPE (CCLAMBDA)¶CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. KEEP_INTCOS (OPTKING)¶OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. KIND (ADC)¶ADC — The kind of states to compute. Type: string; Possible Values: SINGLET, TRIPLET, SPIN_FLIP, ANY; Default: SINGLET. LEVEL_SHIFT (DFOCC)¶DFOCC — Level shift to aid convergence. Type: double; Default: 0.02. LEVEL_SHIFT (MCSCF)¶MCSCF — Level shift to aid convergence. Type: double; Default: 0.0. LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. LEVEL_SHIFT (SCF)¶SCF — Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF (SCF)¶SCF — DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. LINEAR (CCRESPONSE)¶CCRESPONSE — Do Bartlett size-extensive linear model?. Type: boolean; Default: false. LINEQ_SOLVER (DFOCC)¶DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:150271,perform,performed,150271,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,3,['perform'],['performed']
Performance,from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp2-vdw; A special version of SCS-OMP2 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp2; A special version of SOS-OMP2 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP3 methods currently supported in PSI4 are outlined in Table OMP3 Methods. Name; Calls Method; Energy; Gradient; Reference. mp3; MP3; Y; Y; RHF/UHF. omp3; Orbital-Optimized MP3; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp3; Spin-Component Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp3; Spin-Opposite Scaled Orbital-Optimized MP3; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp3; A special version of SCS-OMP3 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. scs-omp3-vdw; A special version of SCS-OMP3 (from ethene dimers); Y; N; RHF/ROHF/UHF/RKS/UKS. sos-pi-omp3; A special version of SOS-OMP3 for -systems; Y; N; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized MP2.5 methods currently supported in PSI4 are outlined in Table OMP2.5 Methods. Name; Calls Method; Energy; Gradient; Reference. mp2.5; MP2.5; Y; Y; RHF/UHF. omp2.5; Orbital-Optimized MP2.5; Y; Y; RHF/ROHF/UHF/RKS/UKS. The conventional and orbital-optimized CEPA methods currently supported in PSI4 are outlined in Table OCEPA Met,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:5905,optimiz,optimized,5905,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['optimiz'],['optimized']
Performance,"ft matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None; Loads a matrix from an ASCII file in MPQC format. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; Returns the number of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:21333,load,load,21333,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"ftware package; #; # Copyright (c) 2007-2017 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; from __future__ import print_function; from __future__ import absolute_import; import sys; import re; import math; import os; import shutil. # Import driver helpers; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import p4util; # from psi4.driver.inputparser import parse_options_block. from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:1260,optimiz,optimizations,1260,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['optimiz'],['optimizations']
Performance,"ftware package; #; # Copyright (c) 2007-2018 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; from __future__ import print_function; from __future__ import absolute_import; import os; import re; import sys; import json; import shutil. import numpy as np. from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:1262,optimiz,optimizations,1262,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimizations']
Performance,"full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; 1; 2; 3; 4; 5; 6; 7molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; 1optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; 1; 2set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; 1optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; 1; 2set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; 1; 2; 3; 4; 5; 6; 7set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:4828,optimiz,optimize,4828,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimize']
Performance,"func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). # [Aug 2022] DF CCSD t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:21435,perform,performance,21435,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['perform'],['performance']
Performance,"function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). full_hess_every = PsiMod.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. PsiMod.get_active_molecule().update_geometry(); mol = PsiMod.get_active_molecule(); mol.update_geometry(); initial_sy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:50119,optimiz,optimization,50119,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp5 optimization; >>> opt('mp5'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). full_hess_every = psi4.get_local_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. # are we in sow/reap mode?; isSowReap = False; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'sow'):; isSowReap = True; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; isSowReap = True; optstash = p4util.OptionsState(; ['SCF', 'GUESS']). n = 1; if ('opt_iter' in kwargs):; n = kwargs['opt_iter']. psi4.get_active_molecule().update_geometry(); mol = psi4.get_active_molecule(); mol.update_geometry(); in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:50362,optimiz,optimization,50362,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"function when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:49045,perform,performs,49045,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['performs']
Performance,"function_build. def _core_wavefunction_get_scratch_filename(self, filenumber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data):; """"""Summary. Parameters; ----------; wfn_data : str or dict; If a str reads a Wavefunction from a disk otherwise, assumes the data; is passed in. Returns; -------; Wavefunction; A deserialized Wavefunction object; """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmonics boolean; basis_name = wfn_string['basisname']; if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). basis_puream = wfn_boolean['basispuream']; basisset = core.BasisSet.build(molecule, 'ORBITAL', basis_name, puream=basis_puream). # change some variables",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html:4620,load,load,4620,psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/python_helpers.html,1,['load'],['load']
Performance,"functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses cbs() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; cbs() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:26923,optimiz,optimization,26923,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,"fuse charges to; resulting density. """"""; basisChanged = psi4.has_option_changed(""BASIS""); ribasisChanged = psi4.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = psi4.has_option_changed(""SCF_TYPE""). basis = psi4.get_option(""BASIS""); ribasis = psi4.get_option(""DF_BASIS_SCF""); scftype = psi4.get_option(""SCF_TYPE""). psi4.print_out("" => Diffuse SCF (Determines Da) <=\n\n""); activate(self.molecule). psi4.set_global_option(""BASIS"", self.basisname); psi4.set_global_option(""DF_BASIS_SCF"", self.ribasisname); psi4.set_global_option(""SCF_TYPE"", ""DF""); energy('scf'); psi4.print_out(""\n""). self.fitGeneral(). psi4.clean(). psi4.set_global_option(""BASIS"", basis); psi4.set_global_option(""DF_BASIS_SCF"", ribasis); psi4.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; psi4.revoke_option_changed(""BASIS""); if not ribasisChanged:; psi4.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; psi4.revoke_option_changed(""SCF_TYPE""). [docs] def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; psi4.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.wfn = psi4.wavefunction(); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = psi4.Gaussian94BasisSetParser(); self.ribasis = psi4.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = psi4.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). [docs] def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = psi4.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuse",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html:2647,perform,perform,2647,psi4manual/4.0b5/_modules/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/qmmm.html,2,['perform'],['perform']
Performance,"g JK. Type: double; Default: 0.75. SCF_PROPERTIES¶. SCF Properties to calculate after an energy evaluation. Note, this keyword is not used for property evaluations. Type: array; Default: No Default. S_CHOLESKY_TOLERANCE¶. Tolerance for partial Cholesky decomposition of overlap matrix. Type: conv double; Default: 1e-8. S_ORTHOGONALIZATION¶. SO orthogonalization: automatic, symmetric, or canonical?. Type: string; Possible Values: AUTO, SYMMETRIC, CANONICAL, PARTIALCHOLESKY; Default: AUTO. S_TOLERANCE¶. Minimum S matrix eigenvalue to allow before linear dependencies are removed. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary SCF with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the Defaults small basis set 3-21G, pcseg-0, or def2-SV(P). Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html:3847,perform,performed,3847,psi4manual/1.4.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html,18,['perform'],['performed']
Performance,"g and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dft1; DFT Functional Test all values update for new BraggSlater radii. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. nbody-multi-level-2; many-body different levels of theory on each body of helium tetramer. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. dfccdl1; DF-CCDL cc-pVDZ energy for the H2O molecule. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-smoke; DFT Functional Smoke Test.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:38144,optimiz,optimize,38144,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimize']
Performance,"g each iteration of the SCF) and; the product will be considered during screening. If only coulomb-like terms; are to be computed, the needs_exchange argument to the integral object; constructor should be set to false, otherwise it should be true to correcly; account for products of the density and integrals that contribute to; exchange-like terms. Shell blocking¶; Each underlying integral engine knows whether it will use blocks, and will set up; the metadata automatically. Instead of looping over individual shells, the; user should loop over blocks supplied by the integral object; these blocks will; be just a single shell quartet combination for the case where blocking is not; used. It is simple to loop over pairs within each block using C++11 syntax, as; demonstrated in the code snippet above. Only shell pairs with significant; overlap are included in the shell block information, making this an efficient; way to loop over non-negligible terms. Permutational symmetry¶; The pairs within each block are optimized for efficiency. First, they are; screened during the integral object’s creation to ensure that only terms with; appreciable overlap are stored. Second, only P,Q combinations that are; permutationally unique are stored, ordered with the higher angular momentum; first. Therefore care must be taken to ensure that the missing permutations; are correctly accounted for when processing the integrals within the loop. See; the DirectJK code in libfock for an example of using this scheme for a Fock; matrix build. Using bra-ket symmetry¶; In cases where there is no batching performed, bra-ket symmetry can be; trivially enforced by ensuring that one of the block indices is greater than or; equal to the other. When batching is used, the situation is trickier; some ket; batches may contain a mixture of integrals that are bra-ket unique and those; that are not. To handle this we must do a coarse check at the top of the loop; to see if any integrals in the batch are needed, w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html:7610,optimiz,optimized,7610,psi4manual/1.4.0/prog_integrals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/prog_integrals-1.html,9,['optimiz'],['optimized']
Performance,"g is most useful in the initial phase of the; calculation to reduce the orbital error enough for DIIS to work; well. The level shift is controlled by the parameter; LEVEL_SHIFT, and it is turned off when the DIIS error is; smaller than LEVEL_SHIFT_CUTOFF. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively. SOSCF [Off by Default]See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:24756,bottleneck,bottleneck,24756,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,6,['bottleneck'],['bottleneck']
Performance,"g on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitud",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:7743,cache,cache,7743,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,12,['cache'],['cache']
Performance,"g ranged_dihedral = $my_string; E = optimize('scf'); PES.append((upper, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). To scan the potential energy surface without the RANGED_DIHEDRAL keyword, a zmatrix; can be used. Warning; Rotating dihedrals in large increments without allowing the molecule to relax; in between increments can lead to unphysical geometries with overlapping functional groups in larger molecules,; which may prevent successful constrained optimzations. Furthermore, such a relaxed scan of the PES does; not always procude a result close to an IRC, or even a reaction path along which the energy changes in a; continuous way. molecule hooh {; 0 1; H; O 1 0.95; O 2 1.39 1 103; H 3 0.95 2 103 1 D. D = 99. units ang; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; frozen_dihedral ("" 1 2 3 4 ""); }. dihedrals = [100, 110, 120, 130, 140, 150]; PES = []. for phi in dihedrals:; hooh.D = phi; E = optimize('scf'); PES.append((phi, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). Multi-Fragment Optimizations¶; In previous versions of optking, the metric for connecting atoms was increased until all atoms; were connected. This is the current behavior for FRAG_MODE single.; Setting FRAG_MODE to multi will now add a special; set of intermolecular coordinates between fragments - internally referred to as DimerFrag; coordinates (see here <DimerIntro_> for the brief description).; For each pair of molecular fragments, a set of up to 3 reference points; are chosen on each fragment. Each reference point will be either an atom or a linear combination; of positions of atoms within that fragment. Stretches, bends, and dihedral angles between the two; fragments will be created using these reference points. See; Dimer coordinate table for how reference points are created.; For a set of three dimers A, B, and C, sets of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:8477,optimiz,optimize,8477,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,4,['optimiz'],['optimize']
Performance,"g the Ms = 0 component of the singlet. Uses TCSCF orbitals. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. freq-masses; check nonphysical masses possible. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. cc17; Single point energies of multiple excited states with EOM-CCSD. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. casscf-sp; CASSCF/6-31G** energy point. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfccsdt2; DF-CCSD(T) cc-pVDZ energy for the NH molecule. dft-reference; MP2 with a PBE0 reference computation. options1; check all variety of options parsing. ghosts; Density fitted MP2 c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:31461,perform,performs,31461,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"g the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:169387,perform,performance,169387,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"g-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf3; are specified explicitly. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. omp2-2; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc12; Single point energies of multiple excited states with EOM-CCSD. cisd-sp; 6-31G** H2O Test CISD Energy Point. mrcc4; CCSDT cc-pVDZ optimization and frequencies for the H2O molecule using MRCC. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). fci-dipole; 6-31G H2O Test FCI Energy Point. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and ci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:11416,optimiz,optimization,11416,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"g.,; --with-lapack='-llapack -lcblas -latlas'. --with-max-am-eri=integer — Specifies the maximum angular momentum; level for the primitive Gaussian basis functions when computing; electron repulsion integrals. This is set to h-type functions (AM=5); by default. --with-max-am-deriv1=integer — Specifies the maximum angular; momentum level for first derivatives of the primitive Gaussian; basis functions. This is set to g-type functions (AM=4) by default. --with-max-am-deriv2=integer — Specifies the maximum angular; momentum level for second derivatives of the primitive Gaussian; basis functions. This is set to f-type functions (AM=3) by default. --with-max-am-r12=integer — Specifies the maximum angular momentum; level for primitive Gaussian basis functions used in r_12 explicitly; correlated methods. This is set to f-type functions (AM=3) by default.; Not yet active. --with-debug=yes/no — Turns on debugging flags (-g) if yes. This is; set to no by default. --with-opt=yes/no — Turns off compiler optimizations (-OX) if no.; This is set to yes by default. --with-strict=yes — Turns on strict compiler warnings. Python interpreter; Usually Python will be detected automatically. If this fails, or if; you have multiple versions installed and want to specify a particular; one, set the PYTHON environmental variable to the full path name; of the Python interpreter you want to use. This defaults to the; python in your path. For example, if you want to use; python2.6 located in /usr/bin set the environmental variable to be:; PYTHON=/usr/bin/python2.6. Note; If the variable PYTHON is set, the config program must be; present with a similar name. For instance, in the above example; the following must exist:; /usr/bin/python2.6-config. You either set the environmental variable before you call configure, or; tell configure about it:; ../configure PYTHON=/usr/bin/python2.6. Boost Libraries; PSI4 can use a user-provided boost C++ library, or, alternatively,; build the boost version 1.48.0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:13850,optimiz,optimizations,13850,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,2,['optimiz'],['optimizations']
Performance,"g4, arg5, …); docstring. DTBMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTBSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRMV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSM(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. DTRSV(arg0, arg1, arg2, arg3, arg4, arg5, …); docstring. IDAMAX(arg0, arg1, arg2, arg3); docstring. adc(ref_wfn); Runs the ADC propagator code, for excited states. array_variable(key); Returns copy of the Matrix QCVariable key (case-insensitive); prefer variable(). array_variables(); Returns dictionary of all Matrix QCVariables; prefer variables(). be_quiet(); Redirects output to /dev/null. benchmark_blas1(max_dim, min_time); Perform benchmark traverse of BLAS 1 routines. benchmark_blas2(max_dim, min_time); Perform benchmark traverse of BLAS 2 routines. benchmark_blas3(max_dim, min_time, nthread); Perform benchmark traverse of BLAS 3 routines. benchmark_disk(max_dim, min_time); Perform benchmark of PSIO disk performance. benchmark_integrals(max_am, min_time); Perform benchmark of psi integrals (of libmints type). benchmark_math(min_time); Perform benchmark of common double floating point operations including most of cmath. ccdensity(ref_wfn); Runs the code to compute coupled cluster density matrices. ccenergy(ref_wfn); Runs the coupled cluster energy code. cceom(ref_wfn); Runs the equation of motion coupled cluster code for excited states. cchbar(ref_wfn); Runs the code to generate the similarity transformed Hamiltonian. cclambda(ref_wfn); Runs the coupled cluster lambda equations code. ccresponse(ref_wfn); Runs the coupled cluster response theory code. cctransort(ref_wfn); Runs cctransort that transforms and reorders integrals for use in the coupled cluster codes. cctriples(ref_wfn); Runs the coupled cluster (T) energy code. clean(); Remove scratch files. clean_options(); Reset options to clean state. clean_timers(); Reinitialize timers for independent timer.dat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:2796,perform,performance,2796,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['perform'],['performance']
Performance,"g; Default: WERNER. LOCAL_PAIRDEF¶. Definition of local pair domains. Type: string; Default: No Default. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old \(\lambda_1\) and \(\lambda_2\) amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Keywords by Module. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cclambda-1.html:3258,perform,performed,3258,psi4manual/1.2.1/autodir_options_c/module__cclambda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__cclambda-1.html,2,['perform'],['performed']
Performance,"g; Possible Values: LANCZOS, DAVIDSON, GEN_DAVIDSON, H0BLOCK, ITER_INV, EVANGELISTI; Default: DAVIDSON. UPDATE¶. The update or correction vector formula, either DAVIDSON (default) or OLSEN. Type: string; Possible Values: DAVIDSON, OLSEN; Default: DAVIDSON. Density Matrices¶. DIPMOM¶. Do compute the dipole moment?. Type: boolean; Default: false. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OPDM¶. Do compute one-particle density matrix if not otherwise required?. Type: boolean; Default: false. TDM¶. Do compute the transition density? Note: only transition densities between roots of the same symmetry will be evaluated. DETCI does not compute states of different irreps within the same computation; to do this, lower the symmetry of the computation. Type: boolean; Default: false. Root Following¶. FOLLOW_ROOT¶. The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 0. Guess Vectors¶. RESTART¶. Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk. Type: boolean; Default: false. File Handling¶. COLLAPSE_SIZE¶. Gives the number of vectors to retain when the Davidson subspace is collapsed (see MAX_NUM_VECS . If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. MAX_NUM_VECS¶. Maximum number of Davidson subspace vectors which can be held on disk for the CI coefficient and sigma vectors. (There is one H(diag) vector and the number of D vectors is equal to the number of roots). When the number of vectors on disk reaches the value of MAX_NUM_VECS, the Davidson subspace will be collapsed to COLLAPSE_SIZE vectors for each root. This is very helpful for saving disk space. Defaults to CI_MAXITER * NUM_ROOTS + NUM_INIT_VECS. Type: intege",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:6521,optimiz,optimization,6521,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,22,['optimiz'],['optimization']
Performance,"g; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maximum number of CPHF iterations. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors used in CCD-DIIS. Type: inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__sapt-1.html:2123,perform,performs,2123,psi4manual/1.1.0/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__sapt-1.html,4,['perform'],['performs']
Performance,"g; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) evaluation. Type: double; Default: 1.0e-6. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are involved. Defaults to DF_BASIS_SAPT. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. D_CONVERGENCE¶. Convergence criterion for residual of the CPHF coefficients in the SAPT \(E_{ind,resp}^{(20)}\) term. Type: conv double; Default: 1e-8. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. E_CONVERGENCE¶. Convergence criterion for energy (change) in the SAPT \(E_{ind,resp}^{(20)}\) term during solution of the CPHF equations. Type: conv double; Default: 1e-10. FREEZE_CORE¶. The scope of core orbitals to freeze in evaluation of SAPT \(E_{disp}^{(20)}\) and \(E_{exch-disp}^{(20)}\) terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. INTS_TOLERANCE¶. Schwarz screening threshold. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. MAXITER¶. Maximum number of CPHF iterations. Type: integer; Default: 50. MAX_CCD_DIISVECS¶. Maximum number of vectors",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html:2126,perform,performs,2126,psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__sapt-1.html,10,['perform'],['performs']
Performance,"g; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; cbs() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of PSI4 and Cfour computational methods and PSI4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; properties() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Gradient methods available through P4C4 interface. name; calls method in Stanton",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cfour.html:26984,optimiz,optimizations,26984,psi4manual/1.7.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cfour.html,8,['optimiz'],['optimizations']
Performance,"gaker_2(functionname, zLO, valueLO, zHI, valueHI, verbose=True)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by cbs().; Halkier, Helgaker, Jorgensen, Klopper, Koch, Olsen, & Wilson, Chem. Phys. Lett. 286 (1998) 243-252. \[E_{corl}^X = E_{corl}^{\infty} + \beta X^{-3}\]. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). 1; 2>>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). 1; 2>>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/cbs-1.html:18432,perform,performed,18432,psi4manual/1.1.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/cbs-1.html,2,['perform'],['performed']
Performance,"gation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Compiling and Installing from Source. Compiling and Installing from Source¶. Warning; As of v1.8, primary binary distribution has moved from; the psi4 channel to the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psi4/conda/psi4-path-advisor.py; (extensive help menu at conda/psi4-path-advisor.py -h); or psicode downloads; page for the latest guides. This section fulfills the duty of every Linux project to have an INSTALL; file detailing how to build it from source. Few (mostly packagers and; sysadmins) are expected to read this file as it is a broad guide to the; many choices in building this project. For a specific, well-tested,; and performance-tuned build path, see psicode.org/installs/latest; (select “source”). For pre-built binaries again well-tested,; performance-tuned, and available for all common operating systems,; see psicode.org/installs/latest (select “conda”).; To see working builds for Linux, Mac, and Windows, see :src:; [this GHA]. Planning: how to configure Psi4 and invoke CMake¶; PSI4 is built through CMake. An abbreviated build guide can be found; within the source itself .; CMake does a good job scanning your computer to locate libraries, header; files, and executables needed for compilation. So it’s very possible that; from top-level-psi4-dir source directory, you can call cmake -S.; -Bobjdir without any further arguments, and it will invoke cmake,; detect some appropriate defaults, configure the build, create a build; directory objdir, and complete, leaving you to only invoke; make or Ninja in the new build directory.; Should this happy scenario not come to pass, or if the default build; options are not to your taste, use the links within core; dependencies and add-on dependencies to plan a set of arguments to cmake tailored to; your c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_planning.html:1027,perform,performance-tuned,1027,psi4manual/master/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/master/build_planning.html,1,['perform'],['performance-tuned']
Performance,"gative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for interacting with options in the python driver. Preserving User Options (Enforcing definition [a] of has_changed); The first, less-interesting, use of retrieving user option values has; been to preserve them so that they may be restored at the end after the; procedure itself has clobbered them. By decoupling global_option and; local_option commands, this can now be performed neatly by saving at the; beginning the global and local values and the global and local; has_changed values, then restoring them at the end. Below is an example; of this procedure; don’t actually do this.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27g_user_scftype = psi4.get_global_option('SCF_TYPE'); l_user_scftype_scf = psi4.get_local_option('SCF', 'SCF_TYPE'); bg_user_scftype = psi4.has_global_option_changed('SCF_TYPE'); bl_user_scftype_scf = psi4.has_local_option_changed('SCF', 'SCF_TYPE'). g_user_wfn = psi4.get_global_option('WFN'); l_user_wfn = psi4.get_local_option('MP2', 'WFN'); bg_user_wfn = psi4.has_global_option_changed('WFN'); bl_user_wfn = psi4.has_local_option_changed('MP2', 'WFN'). # body of function; # scf_type and wfn are freely changed, LOCALLY; # psi4.scf() and psi4.mp2() are run. psi4.set_global_option('SCF_TYPE', g_user_scftype); if not bg_user_scftype:; psi4.revoke_global_option_changed('SCF_TYPE'); psi4.set_local_option('SCF', 'SCF_TYPE', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html:7774,perform,performed,7774,psi4manual/1.1.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optionshandling-1.html,6,['perform'],['performed']
Performance,"gative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for interacting with options in the python driver. Preserving User Options (Enforcing definition [a] of has_changed); The first, less-interesting, use of retrieving user option values has; been to preserve them so that they may be restored at the end after the; procedure itself has clobbered them. By decoupling global_option and; local_option commands, this can now be performed neatly by saving at the; beginning the global and local values and the global and local; has_changed values, then restoring them at the end. Below is an example; of this procedure; don’t actually do this.; g_user_scftype = PsiMod.get_global_option('SCF_TYPE'); l_user_scftype_scf = PsiMod.get_local_option('SCF', 'SCF_TYPE'); bg_user_scftype = PsiMod.has_global_option_changed('SCF_TYPE'); bl_user_scftype_scf = PsiMod.has_local_option_changed('SCF', 'SCF_TYPE'). g_user_wfn = PsiMod.get_global_option('WFN'); l_user_wfn = PsiMod.get_local_option('MP2', 'WFN'); bg_user_wfn = PsiMod.has_global_option_changed('WFN'); bl_user_wfn = PsiMod.has_local_option_changed('MP2', 'WFN'). # body of function; # scf_type and wfn are freely changed, LOCALLY; # PsiMod.scf() and PsiMod.mp2() are run. PsiMod.set_global_option('SCF_TYPE', g_user_scftype); if not bg_user_scftype:; PsiMod.revoke_global_option_changed('SCF_TYPE'); PsiMod.set_local_option('SCF', 'SCF_TYPE', l_user_scftype_scf); if not bl_user_scftype_scf:; PsiMod.revoke_local_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html:7755,perform,performed,7755,psi4manual/4.0b3/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optionshandling-1.html,4,['perform'],['performed']
Performance,"gative changed status (revoke_changed), can only be done for a specific; scope, either global or local to the specified module. Querying, either a; value (get) or a changed status (has_changed), can be done in the global; scope, in a specified local scope, or in the context of “What will the; specified module use?”. Note; “Global” in the sense of the discussion has nothing; to do with the globals section at the top of read_options.cc . That; section is just a convenient place for options and associated values; that are used by most, if not all, modules. There are two primary purposes for interacting with options in the python driver. Preserving User Options (Enforcing definition [a] of has_changed); The first, less-interesting, use of retrieving user option values has; been to preserve them so that they may be restored at the end after the; procedure itself has clobbered them. By decoupling global_option and; local_option commands, this can now be performed neatly by saving at the; beginning the global and local values and the global and local; has_changed values, then restoring them at the end. Below is an example; of this procedure; don’t actually do this.; g_user_scftype = psi4.get_global_option('SCF_TYPE'); l_user_scftype_scf = psi4.get_local_option('SCF', 'SCF_TYPE'); bg_user_scftype = psi4.has_global_option_changed('SCF_TYPE'); bl_user_scftype_scf = psi4.has_local_option_changed('SCF', 'SCF_TYPE'). g_user_wfn = psi4.get_global_option('WFN'); l_user_wfn = psi4.get_local_option('MP2', 'WFN'); bg_user_wfn = psi4.has_global_option_changed('WFN'); bl_user_wfn = psi4.has_local_option_changed('MP2', 'WFN'). # body of function; # scf_type and wfn are freely changed, LOCALLY; # psi4.scf() and psi4.mp2() are run. psi4.set_global_option('SCF_TYPE', g_user_scftype); if not bg_user_scftype:; psi4.revoke_global_option_changed('SCF_TYPE'); psi4.set_local_option('SCF', 'SCF_TYPE', l_user_scftype_scf); if not bl_user_scftype_scf:; psi4.revoke_local_option_changed('SCF', 'SCF_TY",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optionshandling-1.html:7760,perform,performed,7760,psi4manual/1.0.0/optionshandling-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optionshandling-1.html,4,['perform'],['performed']
Performance,"ge fitting basis of last; resort will be used.; To avoid this, either set DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or set DF_SCF_GUESS; to false, which disables this acceleration entirely. Integral-Direct Density-Fitted Coulomb Construction¶; The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285],; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside; Psi4’s separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction; algorithm when specifying SCF_TYPE to use a composite algorithm combination (DFDIRJ+K_alg in general,; or DFDIRJ for DFT with non-hybrid functionals).; DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI; screening (set SCREENING to DENSITY) and incremental Fock matrix construction (set INCFOCK to TRUE). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. COS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/scf.html:34929,bottleneck,bottlenecks,34929,psi4manual/1.9.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/scf.html,2,['bottleneck'],['bottlenecks']
Performance,"ge fitting basis of last; resort will be used.; To avoid this, either set DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or set DF_SCF_GUESS; to false, which disables this acceleration entirely. Integral-Direct Density-Fitted Coulomb Construction¶; The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285],; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside; Psi4’s separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction; algorithm when specifying SCF_TYPE to use a composite algorithm combination (DFDIRJ+K_alg).; DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI; screening (set SCREENING to DENSITY) and incremental Fock matrix construction (set INCFOCK to TRUE). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. COSX Exchange¶; The semi-numerical COSX algorithm described in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:34482,bottleneck,bottlenecks,34482,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['bottleneck'],['bottlenecks']
Performance,"ge for the dihedral angles between atoms to be constrained to (eq. value specified) analogous to the previous FIXED_DIHEDRAL. Type: string; Default: No Default. RANGED_DISTANCE¶. Specify range for distances between atoms to be constrained to (eq. value specified) analogous to the previous FIXED_DISTANCE. Type: string; Default: No Default. RANGED_OOFP¶. Specify range for the out-of-plane angles between atoms to be constrained to (eq. value specified) analogous to the old FIXED_<COORD> keyword. Type: string; Default: No Default. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX¶. Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RSRFO_ALPHA_MAX¶. Absolute maximum value of RS-RFO. Type: double; Default: 1e8. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html:4531,optimiz,optimization,4531,psi4manual/1.7.x/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html,9,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"ge for the dihedral angles between atoms to be constrained to (eq. value specified) analogous to the previous FIXED_DIHEDRAL. Type: string; Default: No Default. RANGED_DISTANCE¶. Specify range for distances between atoms to be constrained to (eq. value specified) analogous to the previous FIXED_DISTANCE. Type: string; Default: No Default. RANGED_OOFP¶. Specify range for the out-of-plane angles between atoms to be constrained to (eq. value specified) analogous to the old FIXED_<COORD> keyword. Type: string; Default: No Default. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX¶. Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RSRFO_ALPHA_MAX¶. Absolute maximum value of RS-RFO. Type: double; Default: 1e8. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, RS_I_RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. UNFREEZE_DIHEDRALS¶. Unfreeze a subset of dihedrals - meant for use with freeze_all_dihedrals. Type: string; Default: No Default. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html:4914,optimiz,optimization,4914,psi4manual/master/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html,3,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"ge-Correlation Functional. x3lyp-d3bj;  . xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj;  . zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:11968,optimiz,optimization,11968,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,4,['optimiz'],['optimization']
Performance,"gedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:7070,perform,performance,7070,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"gedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'R",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:7665,perform,performance,7665,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['perform'],['performance']
Performance,"gence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(); core.clean(); optstash.restore(). opt_data = opt_object.to_dict(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). core.print_out('\n Structure for next step:\n');",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:76386,optimiz,optimize,76386,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimize']
Performance,"ger; Default: 0. CFOUR_FD_CALCTYPE (CFOUR); CFOUR — Specifies the algorithm used to compute the harmonic force constants in finite-difference calculations.GRADONLY (=0) evaluates the force constants and dipole moment derivatives by numerical differentiation of analytic gradients; ENERONLY (=1) evaluates the force constants by second differences of energies (dipole moment derivatives are not evaluated); while MIXED (=2) evaluates 1x1 blocks of symmetry-blocked force constants by second differences pf energies and all other elements by first differences of gradients. the GRADONLY and MIXED approaches may, of course, only be used hwen using computational methods for which analytic gradients are available. Type: string; Possible Values: GRADONLY, ENERONLY, MIXED; Default: GRADONLY. CFOUR_FD_IRREPS (CFOUR); CFOUR — Requests that only vibrational frequencies of certain symmetry types are evaluated in a VIBRATION=FINDIF calculation. The numbers of the irreducible representations for which vibrational analysis is to be performed are separated by slashes. For example, FD_IRREP=1/3/4 means compute the frequencies of modes transforming as the first, third, and fourth irreducible representations. If a symmetry is specified for which there are no vibrational modes, the program will terminate. The labels of the irreducible representations for this keyword are not usually the same as those used in the rest of the calculation. Moreover, for some point groups, for example, those of linear molecules, the two sets of labels refer to different subgroups. There is as yet no straightforward way to determine what they will be without starting a calculation. If one runs the xjoda and then the xsymcor executables, the relevant irreducible representations will be listed. If all vibrational frequencies are desired, this keyword need not be included. Default : compute vibrational frequencies for all irreducible representations. Type: array; Default: No Default. CFOUR_FD_PROJECT (CFOUR); CFOUR —",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:41429,perform,performed,41429,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['perform'],['performed']
Performance,"ger; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density, which is defined as the RMS value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html:4965,perform,perform,4965,psi4manual/4.0b5/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"ger; Default: 1. D_CONVERGENCE¶. Convergence criterion for SCF density, which is defined as the RMS value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__scf-1.html:4841,perform,perform,4841,psi4manual/4.0b4/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"ger; Default: PSIF_MO_OPDM. OPDM_KE (DETCI); DETCI (Expert) — Do compute the kinetic energy contribution from the correlated part of the one-particle density matrix?. Type: boolean; Default: false. OPDM_OUT_FILE (TRANSQT); TRANSQT — AO-basis one-particle density matrix file. Type: integer; Default: PSIF_AO_OPDM. OPDM_PRINT (DETCI); DETCI — Do print the one-particle density matrix for each root?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2); DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (OCC); OCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE (OCC); OCC — The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. P (THERMO); THERMO — Pressure in Pascal for thermodynamic analysis. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:93241,perform,performed,93241,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"gers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:6807,optimiz,optimizations,6807,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,12,['optimiz'],"['optimizations', 'optimizer']"
Performance,"gers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:6709,optimiz,optimizations,6709,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,18,['optimiz'],"['optimizations', 'optimizer']"
Performance,"gers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into Psi4 format. Note; Psi4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in Psi4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; Psi4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:6722,optimiz,optimizations,6722,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['optimiz'],"['optimizations', 'optimizer']"
Performance,"gether with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; by one or two orders of magnitude (e.g. or; ). This can be particularly useful for computions using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. Table Of Contents. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. Previous topic; DFT: Density Functional Theory; Next topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation Theory. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Theoretical Methods: SCF to FCI ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:14827,perform,performing,14827,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['perform'],['performing']
Performance,"gh for DIIS to work; well. The level shift is controlled by the parameter; LEVEL_SHIFT, and it is turned off when the DIIS error is; smaller than LEVEL_SHIFT_CUTOFF. Reasonable values for; the shift and convergence threshold are 5.0 and 1e-2,; respectively. SOSCF [Off by Default]See Second-order Convergence. ERI Algorithms¶; The key difficulty in the SCF procedure is treatment of the four-index ERI; contributions to the Fock Matrix. A number of algorithms are available in; PSI4 for these terms. The algorithm is selected by the SCF_TYPE; keyword. Most consist of a single algorithm applied to; the construction of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:26005,bottleneck,bottleneck,26005,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['bottleneck'],['bottleneck']
Performance,"gher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; SAPT(DFT); Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT Results; Spin-Flip SAPT; Second-Order Exchange Terms without Single-Exchange Approximation. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; Adding Point Charges to F/I-SAPT Computations; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; Interface to adcc; Built-in ADC(2) code. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stockholder. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. TDSCF: Time-dependent Hartree–Fock and density-functional theory; Introduction; Known limitations; Theory; Psithon keywords; PsiAPI usage; Plotting one-photon absorption and electronic circular dichroism spectra. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/methods-1.html:3686,optimiz,optimizations,3686,psi4manual/1.4.0/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/methods-1.html,2,['optimiz'],['optimizations']
Performance,"gher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. MCSCF: Multi-Configurational Self-Consistent-Field; Basic MCSCF Keywords. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; SAPT(DFT); Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT Results; Spin-Flip SAPT; Second-Order Exchange Terms without Single-Exchange Approximation. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; Adding Point Charges to F/I-SAPT Computations; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Available ADC methods; Running ADC calculations; Interface to adcc; Built-in ADC(2) code. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid; Minimal Basis Iterative Stockholder. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. TDSCF: Time-dependent Hartree–Fock and density-functional theory; Introduction; Known limitations; Theory; Psithon keywords; PsiAPI usage; Plotting one-photon absorption and electronic circular dichroism spectra. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/methods-1.html:3781,optimiz,optimizations,3781,psi4manual/1.5.0/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/methods-1.html,2,['optimiz'],['optimizations']
Performance,"gine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:17411,optimiz,optimizations,17411,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,6,['optimiz'],"['optimizations', 'optimize']"
Performance,"gine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY; INTCOS_GENERATE_EXIT. Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Interface to GeomeTRIC; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/optking-1.html:17411,optimiz,optimizations,17411,psi4manual/1.5.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/optking-1.html,6,['optimiz'],"['optimizations', 'optimize']"
Performance,"gle point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). fcidump; test FCIDUMP functionality for rhf/uhf. fnocc5; Test FNO-DF-CCSD(T) energy. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc12; Single point energies of multiple excited states with EOM-CCSD. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. fnocc4; Test FNO-DF-CCSD(T) energy. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc54; CCSD dipole with user-specified basis set. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-pt2; Mk-MRP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:8225,perform,performed,8225,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"gle-point electronic energy. Returns:(float) Total electronic energy in Hartrees. SAPT returns interaction energy. Psi variables:. CURRENT ENERGY; CURRENT REFERENCE ENERGY; CURRENT CORRELATION ENERGY. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mcscf; multiconfigurational self consistent field (SCF). mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual]. mp2.5; average of MP2 and MP3 [manual]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. mp4; full MP4 [manual]. mpn; nth-order Moller–Plesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation, equiv. linear. CCD [manual]. cepa(0); coupled electron pair approximation variant 0 [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. acpf; averaged coupled-pair functional [manual]. aqcc; averaged quadratic coupled cluster [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual]. cc2; approximate coupled cluster singles and doubles (CC2) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. bccd; Brueckner coupled cluster doubles (BCCD) [manual]. qcisd(t); QCISD with perturbative triples [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. fno-df-ccsd(t); CCSD(T) with density fitting and frozen natural orbitals [manual]. bccd(t); BCCD with perturbative triples [manual]. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/energy-1.html:1231,optimiz,optimized,1231,psi4manual/4.0b4/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/energy-1.html,4,['optimiz'],['optimized']
Performance,"global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; 1; 2; 3; 4; 5procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/proc_py-1.html:5380,perform,performance,5380,psi4manual/1.1.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/proc_py-1.html,6,['perform'],['performance']
Performance,"good to 1-4 more than this number of digits. (This means that D_CONVERGENCE = 11 is overkill and will approach machine precision.) See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. MAXITER¶. Maximum number of iterations. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html:4586,perform,perform,4586,psi4manual/4.0b3/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"gorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:169225,perform,performance,169225,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"gorithm to use. For debug purposes, selection will be automated later. Type: string; Possible Values: REORDER, YOSHIMINE; Default: REORDER. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. PK_NO_INCORE¶. Deactivate in core algorithm. For debug purposes. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. Expert Convergence Control/Stabilization¶. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS FOLLOW, how much to scale the step along the eigenvector by. A full step of \(pi/2\) corresponds to a value of 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert COSX Algorithm¶. COSX_BASIS_TOLERANCE¶. Screening criteria for basis function values on COSX grids. Type: conv double; Default: 1.0e-10. COSX_DENSITY_TOLERANCE¶. Screeni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html:18783,optimiz,optimization,18783,psi4manual/1.6.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html,4,['optimiz'],['optimization']
Performance,"gorithm to use. For debug purposes, selection will be automated later. Type: string; Possible Values: REORDER, YOSHIMINE; Default: REORDER. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. PK_NO_INCORE¶. Deactivate in core algorithm. For debug purposes. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. Expert Convergence Control/Stabilization¶. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS FOLLOW, how much to scale the step along the eigenvector by. A full step of \(pi/2\) corresponds to a value of 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert SAD Guess Algorithm¶. DF_BASIS_SAD¶. Density fitting basis used in SAD. Type: string; Possible Values: basis string; Default: SAD-FIT. SAD_CHOL_TOLERANCE¶. SAD guess den",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html:13779,optimiz,optimization,13779,psi4manual/1.3.2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html,10,['optimiz'],['optimization']
Performance,"gorithm to use. For debug purposes, selection will be automated later. Type: string; Possible Values: REORDER, YOSHIMINE; Default: REORDER. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. PK_NO_INCORE¶. Deactivate in core algorithm. For debug purposes. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. Expert Convergence Control/Stabilization¶. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS FOLLOW, how much to scale the step along the eigenvector by. A full step of \(pi/2\) corresponds to a value of 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert SAD Guess Algorithm¶. DF_BASIS_SAD¶. Fitting SAD basis. Type: string; Possible Values: basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html:12888,optimiz,optimization,12888,psi4manual/1.1.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html,4,['optimiz'],['optimization']
Performance,"grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. cbs-xtpl-dict; Extrapolated water energies. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the diffe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:31601,optimiz,optimization,31601,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"grad].; Publications resulting from the use of the OMP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OMP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the OCEPA code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP2 code should cite the following publication(s):; [Bozkaya:2011:omp2].; Publications resulting from the use of the MP3 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the MP2.5 code should cite the following publications:; [Bozkaya:2011:omp3] and [Bozkaya:2013:omp3].; Publications resulting from the use of the CEPA0 code should cite the following publication(s):; [Bozkaya:2011:omp2]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals generally provide much better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simply use “reference rohf” option. For DFT orbitals one should use “reference uks” and “dft_functional b3lyp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The conventional and orbital-optimized MP2 methods currently supported in PSI4 are outlined in Table OMP2 Methods. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. omp2; Orbital-Optimized MP2; Y; Y; RHF/ROHF/UHF/RKS/UKS. scs-omp2; Spin-Component Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. sos-omp2; Spin-Opposite Scaled Orbital-Optimized MP2; Y; N; RHF/ROHF/UHF/RKS/UKS. scsn-omp2; A special version of SCS-OMP2 for nucleobase interactions; Y; N; RHF/ROHF/UHF/RKS/UKS. sc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:5355,optimiz,optimized,5355,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['optimiz'],['optimized']
Performance,"gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. mbis-4; MBIS calculation on NaCl. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct10; The multiple guesses for DCT amplitudes for ODC-12. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. mom-h2o-4; MOM excitation from LUMO HOMO+4. fci-h2o; 6-31G H2O Test FCI Energy Point. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:40162,optimiz,optimization,40162,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. omp3-grad1; OMP3 cc-pVDZ gradient for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:6846,perform,performs,6846,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc48; reproduces dipole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:6260,perform,performs,6260,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['perform'],['performs']
Performance,"gradient for the H2O molecule. nbody-he-cluster; MP2/aug-cc-pv[DT]Z many body energies of an arbitrary Helium complex Size vs cost tradeoff is rough here. cc13d; Tests analytic CC2 gradients. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. omp2-3; OMP2 cc-pVDZ energy for the NO radical. scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cc36; CC2(RHF)/cc-pVDZ energy of H2O. mints3; Test individual integral objects for correctness. options1; check all variety of options parsing. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc19; CCSD/cc-pVDZ dipole polarizability at two frequencies. ocepa-grad1; OCEPA cc-pVDZ gradient for the H2O molecule. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. dcft4; DCFT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. dft-bench-interaction; functionals + DFTD3 interaction energies vs. other programs. dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dcft6; DCFT calculation for the triplet O2 using DC-06, DC-12 and CEPA0 functionals. Only two-step algorithm is tested. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. pywrap-bfs; apply linea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:6221,perform,performs,6221,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset vari",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:42748,Perform,Perform,42748,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Perform'],['Perform']
Performance,gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory :ref:`[manual] <sec:dcft>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <tlmp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+------------------------------------------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:50065,optimiz,optimizations,50065,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,3,['optimiz'],['optimizations']
Performance,gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | hf | HF self consistent field (SCF) :ref:`[manual] <sec:scf>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | dct | density cumulant (functional) theory :ref:`[manual] <sec:dct>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2 | 2nd-order |MollerPlesset| perturbation theory (MP2) :ref:`[manual] <sec:dfmp2>` :ref:`[details] <tlmp2>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp3 | 3rd-order |MollerPlesset| perturbation theory (MP3) :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | mp2.5 | average of MP2 and MP3 :ref:`[manual] <sec:occ_nonoo>` :ref:`[details] <tlmp25>` |; +-------------------------+------------------------------------------------------,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:62414,optimiz,optimizations,62414,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['optimiz'],['optimizations']
Performance,"gralTransform(wfn, spaces, trans_type); ints.transform_tei(core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all()); core.print_out('Integral transformation complete!\n'). DPD_info = {'instance_id': ints.get_dpd_id(), 'alpha_MO': ints.DPD_ID('[A>=A]+'), 'beta_MO': 0}; if not wfn.same_a_b_orbs():; DPD_info['beta_MO'] = ints.DPD_ID(""[a>=a]+""); # Write TEI to fname in FCIDUMP format; core.fcidump_tei_helper(nirrep, wfn.same_a_b_orbs(), DPD_info, ints_tolerance, fname). # Read-in OEI and write them to fname in FCIDUMP format; # Indexing functions to translate from zero-based (C and Python) to; # one-based (Fortran); mo_idx = lambda x: x + 1; alpha_mo_idx = lambda x: 2 * x + 1; beta_mo_idx = lambda x: 2 * (x + 1). with open(fname, 'a') as intdump:; core.print_out('Writing frozen core operator in FCIDUMP format to ' + fname + '\n'); if reference == 'RHF':; PSIF_MO_FZC = 'MO-basis Frozen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), constants.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), constants.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:5079,load,load,5079,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['load'],['load']
Performance,"gralTransform(wfn, spaces, trans_type); ints.transform_tei(core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all()); core.print_out('Integral transformation complete!\n'). DPD_info = {'instance_id': ints.get_dpd_id(), 'alpha_MO': ints.DPD_ID('[A>=A]+'), 'beta_MO': 0}; if not wfn.same_a_b_orbs():; DPD_info['beta_MO'] = ints.DPD_ID(""[a>=a]+""); # Write TEI to fname in FCIDUMP format; core.fcidump_tei_helper(nirrep, wfn.same_a_b_orbs(), DPD_info, ints_tolerance, fname). # Read-in OEI and write them to fname in FCIDUMP format; # Indexing functions to translate from zero-based (C and Python) to; # one-based (Fortran); mo_idx = lambda x: x + 1; alpha_mo_idx = lambda x: 2 * x + 1; beta_mo_idx = lambda x: 2 * (x + 1). with open(fname, 'a') as intdump:; core.print_out('Writing frozen core operator in FCIDUMP format to ' + fname + '\n'); if reference == 'RHF':; PSIF_MO_FZC = 'MO-basis Frozen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html:5303,load,load,5303,psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/p4util/fcidump.html,3,['load'],['load']
Performance,"gralTransform(wfn, spaces, trans_type); ints.transform_tei(core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all()); core.print_out('Integral transformation complete!\n'). DPD_info = {'instance_id': ints.get_dpd_id(), 'alpha_MO': ints.DPD_ID('[A>=A]+'), 'beta_MO': 0}; if not wfn.same_a_b_orbs():; DPD_info['beta_MO'] = ints.DPD_ID(""[a>=a]+""); # Write TEI to fname in FCIDUMP format; core.fcidump_tei_helper(nirrep, wfn.same_a_b_orbs(), DPD_info, ints_tolerance, fname). # Read-in OEI and write them to fname in FCIDUMP format; # Indexing functions to translate from zero-based (C and Python) to; # one-based (Fortran); mo_idx = lambda x: x + 1; alpha_mo_idx = lambda x: 2 * x + 1; beta_mo_idx = lambda x: 2 * (x + 1). with open(fname, 'a') as intdump:; core.print_out('Writing frozen core operator in FCIDUMP format to ' + fname + '\n'); if reference == 'RHF':; PSIF_MO_FZC = 'MO-basis Frozen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html:5328,load,load,5328,psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/p4util/fcidump.html,2,['load'],['load']
Performance,"gralTransform(wfn, spaces, trans_type); ints.transform_tei(core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all(), core.MOSpace.all()); core.print_out('Integral transformation complete!\n'). DPD_info = {'instance_id': ints.get_dpd_id(), 'alpha_MO': ints.DPD_ID('[A>=A]+'), 'beta_MO': 0}; if not wfn.same_a_b_orbs():; DPD_info['beta_MO'] = ints.DPD_ID(""[a>=a]+""); # Write TEI to fname in FCIDUMP format; core.fcidump_tei_helper(nirrep, wfn.same_a_b_orbs(), DPD_info, ints_tolerance, fname). # Read-in OEI and write them to fname in FCIDUMP format; # Indexing functions to translate from zero-based (C and Python) to; # one-based (Fortran); mo_idx = lambda x: x + 1; alpha_mo_idx = lambda x: 2 * x + 1; beta_mo_idx = lambda x: 2 * (x + 1). with open(fname, 'a') as intdump:; core.print_out('Writing frozen core operator in FCIDUMP format to ' + fname + '\n'); if reference == 'RHF':; PSIF_MO_FZC = 'MO-basis Frozen-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, frzcpi+active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:28.20E}{:4d}{:4d}{:4d}{:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), psif.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html:5328,load,load,5328,psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fcidump.html,10,['load'],['load']
Performance,"grals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. pywrap_alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. cc3; cc3: RHF-CCSD/6-31",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:10836,perform,performed,10836,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance,"group having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Type: array; Default: No Default. CFOUR_ESTATE_TRANS (CFOUR); CFOUR — Specifies whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS (CFOUR); CFOUR — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION (CFOUR); CFOUR — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE (CFOUR); CFOUR — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD (CFOUR); CFOUR — Specifies the strength of a Fermi-Contact pertubation as required for finite-field calculations of spin densities and the FC contributions to indirect spin-spin coupling constants. The val",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:38846,optimiz,optimizations,38846,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['optimiz'],"['optimizations', 'optimizer']"
Performance,"group having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Type: array; Default: No Default. CFOUR_ESTATE_TRANS (CFOUR); CFOUR — Specifies whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS (CFOUR); CFOUR — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION (CFOUR); CFOUR — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE (CFOUR); CFOUR — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD (CFOUR); CFOUR — Specifies the strength of a Fermi-Contact perturbation as required for finite-field calculations of spin densities and the FC contributions to indirect spin-spin coupling constants. The va",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html:38646,optimiz,optimizations,38646,psi4manual/1.1.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodoc_glossary_options_c-1.html,4,['optimiz'],"['optimizations', 'optimizer']"
Performance,"gstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. ONEPOT_GRID_READ (SCF); SCF — Read an external potential from the .dx file?. Type: boolean; Default: false. OO_SCALE (DFOCC); DFOCC — OO scaling factor used in MSD. Type: double; Default: 0.01. OPDM (DETCI); DETCI — Do compute one-particle density matrix if not otherwise required?. Type: boolean; Default: false. OPDM_AVG (DETCI); DETCI — Do average the OPDM over several roots in order to obtain a state-average one-particle density matrix? This density matrix can be diagonalized to obtain the CI natural orbitals. Type: boolean; Default: false. OPDM_PRINT (DETCI); DETCI — Do print the one-particle density matrix for each root?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2); DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING); OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC); DFOCC — The orbital optimization algorithm. Presently Quasy Newton-Raphson algorithm avaliable with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:176138,optimiz,optimization,176138,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"gy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:15817,optimiz,optimization,15817,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"gy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimization",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:17256,optimiz,optimization,17256,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"gy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM wa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:18005,optimiz,optimization,18005,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"gy or Max Disp are fulfilled. 6(1,2,3,4,5); Normal convergence achieved when all four criteria (Max Force, RMS Force,; Max Disp, and RMS Disp) are fulfilled. To help with flat; potential surfaces, alternate convergence achieved when 100\(\times\)rms force is less; than RMS Force criterion. 7; Compensates for difficulties in converging geometry optmizations of supermolecular complexes; tightly, where large rms disp and max disp may result from flat potential surfaces even when; max force and/or rms force are small. For ultimate control, specifying a value for any of the five monitored options activates that; criterium and overwrites/appends it to the criteria set by G_CONVERGENCE.; Note that this revokes the special convergence arrangements detailed in notes 5 and 6; and instead requires all active criteria to be fulfilled to; achieve convergence. To avoid this revokation, turn on keyword FLEXIBLE_G_CONVERGENCE. Interface to GeomeTRIC¶; The GeomeTRIC optimizer developed by Wang and Song [Wang:2016:214108] may be used in place of; Psi4’s native Optking optimizer. GeomeTRIC uses a translation-rotation-internal coordinate (TRIC); system that works well for optimizing geometries of systems containing noncovalent interactions.; Use of the GeomeTRIC optimizer is specified with the engine argument to; optimize(). The optimization will respect the keywords G_CONVERGENCE; and GEOM_MAXITER. Any other GeomeTRIC-specific options (including constraints); may be specified with the optimizer_keywords argument to optimize().; Constraints may be placed on cartesian coordinates, bonds, angles, and dihedrals, and they can be; used to either freeze a coordinate or set it to a specific value. See the GeomeTRIC github; for more information on keywords and JSON specification of constraints. Optimize the water molecule using GeomeTRIC:; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; maxiter 100; g_convergence gau; }. optimize('hf/cc-pvdz', engine='geometric'). Optimize the water mole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:13887,optimiz,optimizer,13887,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,10,['optimiz'],['optimizer']
Performance,"gy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local intern",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:8308,optimiz,optimizer,8308,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimizer']
Performance,"gy'). Optimize while limiting the initial step size to 0.1 au:; 1; 2set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; 1; 2; 3; 4; 5; 6; 7set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:5438,optimiz,optimization,5438,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimization']
Performance,"gy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. tdscf-6; td-camb3lyp with DiskDF and method/basis specification. dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. cubeprop; RHF orbitals and density for water. dft-smoke; DFT Functional Smoke Test. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-ecp; Water-Argon complex with ECP present; check of energies and forces. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-grad2; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN updated ref gradient due to new BraggSlater radii. fci-h2o; 6-31G H2O Test FCI Energy Point. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-level-shift-uhf; SCF level shift on a UHF computation. linK-2; RKS Linear Exchange Algorithm test for benzene. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. sapt11; sapt example with orbital freezing with alkali metal and dMP2. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:7056,perform,performed,7056,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"gy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if opt_mode == 'reap':; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Hessian: Canno",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:66272,optimiz,optimization,66272,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimization']
Performance,"h EOM-CCSD. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc54; CCSD dipole with user-specified basis set. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium dimer and water molecule. scf-coverage; Lithium test for coverage. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. tdscf-1; td-uhf test on triplet states of methylene (rpa). dfccd1; DF-CCD cc-pVDZ energy for the H2O molecule. soscf-large; Second-order SCF convergnece: Benzene. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. mp2-grad2; MP2 cc-pVDZ gradient for the N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:11478,perform,performed,11478,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"h as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-representability problem by disregarding orbital response contribution of one-particle; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections.; A lot of the functionality in OCC has been enabled with Density Fitting (DF) and Cholesky; Decomposition (CD) techniques, which can greatly speed up calculations and reduce memory; requirements for typically negligible losses in accuracy.; NOTE: As will be discussed later, all methods with orbital-optimization functionality have non-orbital; optimized counterparts. Consequently, there arise two possible ways to call density-fitted MP2. In most; cases, users should prefer the DF-MP2 code described in the DF-MP2 section because it is; faster. If gradients are needed (like in a geometry optimization), then the procedures outlined hereafter; should be ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:2512,perform,performance,2512,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,30,"['optimiz', 'perform']","['optimized', 'performance']"
Performance,"h cfour {...} block. Type: string; Default: No Default. MAX_RADIAL_MOMENT¶. Maximum Radial Moment to Calculate. Type: integer; Default: 4. MBIS_D_CONVERGENCE¶. MBIS Convergence Criteria. Type: conv double; Default: 1.0e-8. MBIS_MAXITER¶. Maximum Number of MBIS Iterations. Type: integer; Default: 500. MBIS_PRUNING_SCHEME¶. Pruning scheme for MBIS Grid. Type: string; Default: ROBUST. MBIS_RADIAL_POINTS¶. MBIS Number of Radial Points. Type: integer; Default: 75. MBIS_SPHERICAL_POINTS¶. MBIS Number of Spherical Points. Type: integer; Default: 302. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MP2_TYPE¶. Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE¶. Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Since v1.4, default for non-orbital-optimized MP2.5 and MP3 is DF. Type: string; Possible Values: DF, CONV, CD; Default: CONV. NUM_FROZEN_DOCC¶. The number of core orbitals to freeze in later correlated computations. This trumps FREEZE_CORE. Type: integer; Default: 0. NUM_FROZEN_UOCC¶. The number of virtual orbitals to freeze in later correlated computations. Type: integer; Default: 0. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PE¶. PE boolean for polarizable embedding module. Type: boolean; Default: false. PRINT¶. The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PRINT_NOONS¶. How many NOONS to print – used in libscf_solver/uhf.cc and libmints/oeprop.cc. Type: string; Default: 3. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html:5368,optimiz,optimized,5368,psi4manual/1.4.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html,16,['optimiz'],['optimized']
Performance,"h dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:16540,optimiz,optimization,16540,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"h dummy atoms, just for demo and testing purposes. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:17289,optimiz,optimization,17289,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"h is activated by its; stage_wfn keyword, or as a field in the `cbs_metadata` list, and is only; allowed if all preceding stages are active. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; hf; mp2; mp2.5; mp3; mp4(sdq); mp4; mpn. omp2; omp2.5; omp3; olccd; lccd; lccsd; cepa(0); cepa(1). cepa(3); acpf; aqcc; qcisd; cc2; ccsd; fno-ccsd; bccd. cc3; qcisd(t); ccsd(t); fno-ccsd(t); bccd(t); cisd; cisdt. cisdtq; cin; fci; mrccsd; mrccsd(t); mrccsdt; mrccsdt(q). Parameters:; name (str) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. scf_wfn (str) – \(\Rightarrow\) 'scf' \(\Leftarrow\) || 'c4-scf' || etc.; Indicates the energy method for which the reference energy is to be; obtained. Generally unnecessary, as ‘scf’ is the scf in PSI4 but; can be used to direct lone scf components to run in PSI4 or Cfour; in a mixed-program composite method. corl_wfn (str) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (str) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (str) – \(\Rightarrow\) corl_wfn \(\Leftarrow\) || 'mp2' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:3599,perform,performed,3599,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['perform'],['performed']
Performance,"h it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object()",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:59355,optimiz,optimized,59355,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimized']
Performance,"h oeprop. scf_helper(name, **kwargs)[source]¶; Function serving as helper to SCF, choosing whether to cast; up or just run SCF with a standard guess. This preserves; previous SCF options set by other procedures (e.g., SAPT; output file types for SCF). select_ccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. select_ccsd_at_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. select_ccsd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. select_ccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. select_ccsd_t__gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. select_cisd(name, **kwargs)[source]¶; Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. select_lccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. select_mp2(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:167091,perform,performance,167091,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"h respect to nuclear displacements. From this, it can obtain the harmonic vibrational frequencies, given below (roundoff errors of around \(0.1\) cm\(^{-1}\) may exist):; Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6478; A1 4113.3795; B2 4212.1814; -----------------------------------------------. Notice the symmetry type of the normal modes is specified (A1, A1, B2). The program also print out the normal modes in terms of Cartesian coordinates of each atom. For example, the normal mode at \(1776\) cm\(^{-1}\) is:; Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.068 15.994915; H 0.000 0.416 0.536 1.007825; H 0.000 -0.416 0.536 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for each atom along the normal mode coordinate. (This information could be used to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics analysis is automatically performed at the end of the computation. You can see this in the next section of the output file output.dat. The vibrational frequencies are sufficient to obtain vibrational contributions to enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the molecular geometry is used to obtain rotational constants, which are then used to obtain rotational contributions to H, S, and G.; Note: Psi4 has several synonyms for the functions called in this example. For instance, psi4.frequency() API will compute molecular vibrational frequencies, and psi4.optimize() API will perform a geometry optimization. IV. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. Psi4 contains code to analyze the nature of intermolecular interactions between two molecules, via symmetry-adapted perturbation theory (SAPT) (Jeziorski:1994:1887). This kind of analysis gives a lot of insight into the nature of intermolecular interactions, a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:10694,perform,performed,10694,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,11,['perform'],['performed']
Performance,"h those from psi4. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:3008,optimiz,optimization,3008,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"h; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # used by optimize(); H, wfn = psi4.hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:10862,optimiz,optimize,10862,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['optimiz'],['optimize']
Performance,"handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. fci-coverage; 6-31G H2O Test for coverage. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_.. tuple. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. cepa4; cc-pvdz H2O Test coupled-pair LCCD against DCFT CEPA0. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. cc51; EOM-CC3/cc-pVTZ on H2O. opt12; SCF cc-pVDZ geometry optimzation of ketene, starting from bent structure.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:36997,optimiz,optimization,36997,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['optimiz'],['optimization']
Performance,"handling of scratch files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are written to the; designated scratch numbered by content and labeled; with the process id, then are deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to the ~/.psi4rc; file.:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running sim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/external-1.html:3146,queue,queue,3146,psi4manual/4.0b4/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/external-1.html,4,['queue'],['queue']
Performance,"hannel psi4. Initially install PSI4 stable release with non-current python. >>> conda install psi4 python=3.6 -c psi4. Update to latest PSI4 stable release. >>> conda update psi4 -c psi4. Initially install stable release into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=0.1.12 -c psi4. Uninstall PSI4 from current environment. >>> conda remove psi4. Initially install PSI4 nightly build. # equivalent; >>> conda install psi4 -c psi4/label/dev; >>> conda install psi4 –channel psi4/label/dev. Initially install PSI4 nightly build with non-current python. >>> conda install psi4 python=3.6 -c psi4/label/dev. Update to latest PSI4 nightly build. >>> conda update psi4 -c psi4/label/dev. Initially install nightly build into a conda environment “p4env” instead of “root”. This creates a sandbox with PSI4 and python (loaded as dependency). >>> conda create -y -n p4env psi4 -c psi4/label/dev; >>> conda activate p4env. Install a particular PSI4 version. >>> conda install psi4=0.1.12 -c psi4/label/dev. Troubleshooting¶. If the target computer doesn’t have libc >= 2.7 (released c.2007; for reference, 2.10 is newer than 2.7; unlike most libraries, libc generally not available in multiple versions on a computer), the PSI4 conda package won’t work.; 1; 2; 3; 4; 5; 6# unsuitable computer; >>> ldd --version; ldd (GNU libc) 2.5; # suitable computer; >>> ldd --version; ldd (GNU libc) 2.17. It is of greatest importance that the PSI4 executable be linked against conda libpython.so not against any system libpython.so. This is arranged by setting RPATH to seek libraries relative to executable (thanks, conda binary relocation routine!). The conda PSI4 executable is not vulnerable to interference from your LD_LIBRARY_PATH settings. Below shows a well-linked executable. no libraries “not found”; fundamen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/conda-1.html:21745,load,loaded,21745,psi4manual/1.3.2/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/conda-1.html,2,['load'],['loaded']
Performance,"has mol, G, H general to freq calc; H = driver_findif.assemble_hessian_from_gradients(findif_meta_dict, irrep); wfn.set_hessian(core.Matrix.from_array(H)); wfn.set_gradient(G0). # Explicitly set the current energy..; if isinstance(lowername, str) and lowername in procedures['energy']:; # this correctly filters out cbs fn and ""hf/cc-pvtz""; # it probably incorrectly filters out mp5, but reconsider in DDD; core.set_variable(f""CURRENT HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); core.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); wfn.set_variable(f""{lowername.upper()} TOTAL HESSIAN"", H); wfn.set_variable(f""{lowername.upper()} TOTAL GRADIENT"", G0); core.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]); wfn.set_variable('CURRENT ENERGY', findif_meta_dict[""reference""][""energy""]). core.set_global_option(""PARENT_SYMMETRY"", """"); optstash.restore(); optstash_conv.restore(). else:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic energies.\n""""""). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash.restore(); optstash_conv.restore(); optstash_conv = driver_util._set_convergence_criterion('energy', lowername, 10, 11, 10, 11, 10). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_energies_geometries(molecule, irrep). # Record undisplaced symmetry for projection of diplaced point groups; core.set_global_option(""PARENT_SYMMETRY"", molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print(' %d displacements needed.' % ndisp). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html:80911,perform,perform,80911,psi4manual/1.5.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/driver.html,2,['perform'],['perform']
Performance,"has_array_variable(arg0); Is the Matrix QC variable (case-insensitive) set?. has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_scalar_variable(arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have bee",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:297157,optimiz,optimized,297157,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['optimiz'],['optimized']
Performance,"has_global_option_changed(arg0); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed(arg0, arg1); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable(arg0); Returns true if the PSI variable exists/is set. initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. libfock(arg0); Runs a CPHF calculation, using libfock. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the loc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:246785,optimiz,optimizer,246785,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['optimiz'],['optimizer']
Performance,"hat PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. scf3; File retention, docc, socc, and bond distances specified explicitly. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft1; DFT Functional Test. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. Previous topic; CFOUR; Next topic; DFTD3. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » ; Appendices ». © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/testsuite-1.html:32628,perform,performs,32628,psi4manual/1.0.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/testsuite-1.html,2,['perform'],['performs']
Performance,"hat do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:42700,perform,perform,42700,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['perform'],['perform']
Performance,"hat do not have associated gradients; if lowername in energy_only_methods:; raise ValidationError(""gradient('%s') does not have an associated gradient"" % name). dertype = _find_derivative_type('gradient', lowername, user_dertype). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); optstash = driver_util._set_convergence_criterion('energy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energy_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:40687,perform,perform,40687,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"hat have at; least one “large” dimension. See SolverEngine for requirements; guess (List) – list {engine dependent}; At least nroot initial expansion vectors; nroot (int) – Number of roots desired; r_convergence (float) – Convergence tolerance for residual vectors; max_ss_size (int) – The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter (int) – The maximum number of iterations; verbose (int) – The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only (bool) – Should eigenpairs with eigenvalue < 0 be ignored?. Return type:; Dict[str, Any]. Returns:. best_values (numpy.ndarray) – (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors (List[vector]) – (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats (List[Dict]) – Statistics collected on each iteration. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged. Notes; The solution vector is normalized to 1/2; The solver will return even when maxiter iterations are performed without convergence.; The caller must check stats[-1]['done'] for failure and handle each case accordingly. table of contents. davidson_solver; davidson_solver(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; davidson_solver. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.davidson_solver.html:2316,perform,performed,2316,psi4manual/1.8.x/api/psi4.driver.p4util.davidson_solver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.davidson_solver.html,6,['perform'],['performed']
Performance,"hat have at; least one “large” dimension. See SolverEngine for requirements; guess (List) – list {engine dependent}; At least nroot initial expansion vectors; nroot (int) – Number of roots desired; r_convergence (float) – Convergence tolerance for residual vectors; max_ss_size (int) – The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter (int) – The maximum number of iterations; verbose (int) – The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only (bool) – Should eigenpairs with eigenvalue < 0 be ignored?. Return type:; Dict[str, Any]. Returns:. best_values (numpy.ndarray) – (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors (List[vector]) – (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats (List[Dict]) – Statistics collected on each iteration. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged. Notes; The solution vector is normalized to 1/2; The solver will return even when maxiter iterations are performed without convergence.; The caller must check stats[-1]['done'] for failure and handle each case accordingly. table of contents. davidson_solver; davidson_solver(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; davidson_solver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.davidson_solver.html:2316,perform,performed,2316,psi4manual/1.9.x/api/psi4.driver.p4util.davidson_solver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.davidson_solver.html,6,['perform'],['performed']
Performance,"hat this option might be not available for all type of calculations. Type: string; Possible Values: DISK, DIRECT; Default: DISK. CFOUR_GENBAS_1 (CFOUR); CFOUR — This keyword applies only to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:46984,perform,performs,46984,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performs']
Performance,"hat this option might be not available for all type of calculations. Type: string; Possible Values: DISK, DIRECT; Default: DISK. CFOUR_GENBAS_1 (CFOUR); CFOUR — This keyword applies only to Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:47112,perform,performs,47112,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['perform'],['performs']
Performance,"have an idea/request and a plan – file a GitHub issue; I have an idea/request – ask the forum; Why do you? – ask the forum; When will you? – ask the forum; I have an experience that can improve the build documentation – inform the forum or post on the wiki itself; Anything you want to share privately – crawdad@vt.edu or sherrill@gatech.edu. Footnotes. [1]Frozen natural orbital variant available. In particular, RHF available as CONV. [2](1, 2) Frozen natural orbital variant available. In particular, RHF available as CONV/DF. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) threading through BLAS routines only. [4]DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. DH-DFT gradients not implemented. [5]Both EFP/EFP and QM/EFP energies are available. [6]Adapted from here. [7]DH-DFT only available with DF-MP2. [8](1, 2, 3) Not all combinations of reference and algorithm available. In particular, non-RHF references only available as CONV. [9]Orbital-optimized variant available. In particular, all references available as CONV/DF. Table Of Contents. Introduction; Overview; Citing Psi4; Overall Psi4 Package; Density Cumulant Functional Theory (DCFT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree–Fock Methods; Second-Order Algebraic-Diagrammatic Construction [ADC(2)]; Density Matrix Renormalization Group (DMRG); Scalar Relativistic Corrections. Supported Architectures; Capabilities; Technical Support. Previous topic; Programmers’ Manual; Next topic; <no title>. This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; Psi4 [1.0.0 6a9a71b] » . © Copyright 2016, The Psi4 Project.; Last updated on Tuesday, 05 July 2016 02:54AM.; Created using Sphinx 1.3.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/introduction-1.html:21386,optimiz,optimized,21386,psi4manual/1.0.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/introduction-1.html,2,['optimiz'],['optimized']
Performance,"have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number .; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:19423,tune,tuned,19423,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,8,['tune'],['tuned']
Performance,"he DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; FROZEN_UOCC; MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; SAPT: Symmetry-Adapted Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/detci-1.html:11053,perform,perform,11053,psi4manual/4.0b4/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/detci-1.html,2,['perform'],['perform']
Performance,"he DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. Table Of Contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; FROZEN_UOCC; MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Previous topic; PSIMRCC Implementation of Mk-MRCC Theory; Next topic; SAPT: Symmetry-Adapted Perturbation Theory; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Theoretical Methods: SCF to FCI ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/detci-1.html:11053,perform,perform,11053,psi4manual/4.0b5/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/detci-1.html,2,['perform'],['perform']
Performance,"he DF phase reaching convergence in eight true; iterations. When used together, SAD and DIIS are usually sufficient to converge; the SCF for all but the most difficult systems. Additional convergence; techniques are available for more difficult cases, and are detailed below. At; this point, the code switches on the requested Direct integrals technology, which; requires only four full iterations to reach convergence, starting from the DF; guess. This hybrid DF/Direct procedure can significantly accelerate SCF; computations requiring exact integrals.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree–Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) \(\{\psi_i\}\),. \[\psi_i(\vec x_1) = C_{\mu i} \phi_{\mu} (\vec x_1).\]; Here, \(\{\phi_{\mu}\}\) are the basis functions, which, in PSI4 are; contracted Cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix \(C_{\mu i}\) contains the MO coefficients, which are the; constrained variational parameters in Hartree–Fock. The molecular orbitals are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. \[\begin{split}| \Psi_0 \rangle =; \frac{1}{\sqrt{N!}} \left | \begin{array}{cccc}; \psi_1 (\vec x_1) & \psi_2(\vec x_1) & \ldots & \psi_N (\vec x_1) \\; \psi_1 (\vec x_2) & \psi_2(\vec x_2) & \ldots & \psi_N (\vec x_2) \\; \vdots & \vdots & \ddots & \vdots \\; \psi_1 (\vec x_N) & \psi_2(\vec x_N) & \ldots & \psi_N (\vec x_N) \\; \end{array}\right |\end{split}\]; This form for the Hartree–Fock wavefunction is actually entirely equivalent to; treating the electron correlation a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:4054,optimiz,optimized,4054,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,15,['optimiz'],['optimized']
Performance,"he GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:2394,Optimiz,Optimizations,2394,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,8,['Optimiz'],['Optimizations']
Performance,"he algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. select_omp3(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. select_omp3_gradient(name, **kwargs)[source]¶; Function selecting the algorith",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:169720,perform,performance,169720,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"he algorithm is selected by the SCF_TYPE; keyword, which may be one of the following. PK [Default]; An out-of-core, presorted algorithm using exact ERIs. Quite fast; for a zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; OUT_OF_CORE; An out-of-core, unsorted algorithm using exact; ERIs. Overcomes the memory bottleneck of the current PK algorithm. Integrals are; generated only once, and symmetry is utilized to reduce number of integrals.; DIRECT; A threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast up to; 1500 basis function, uses zero disk, and can obtain significant speedups with; negligible error loss if the INTS_TOLERANCE value is set to 1.0E-8 or so.; DF [Default]; A density-fitted algorithm designed for computations with thousands of basis; functions. This algorithm is highly optimized, and is threaded with a mixture of; parallel BLAS and OpenMP. Note that this algorithm should use the -JKFIT series; of auxiliary bases, not the -RI or -MP2FIT bases. The default guess for; auxiliary basis set should work for all Dunning bases, otherwise the; DF_BASIS_SCF keyword can be used to manually specify the auxiliary basis.; This algorithm is preferred unless either absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications).; Recently, we have added the automatic capability to use the extremely fast DF; code for intermediate convergence of the orbitals, for SCF_TYPE other; than DF. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the u",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:19512,optimiz,optimized,19512,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,2,['optimiz'],['optimized']
Performance,"he calculation.; The successor to the psi4.driver.QMMM class,; psi4.driver.QMMMbohr, is operable, but it is discouraged; from being used directly. To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type 1¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency 7; 8; 8. SCF of post-HF; energy; 8; 8; PK 3. optimization; 10; 10. frequency 7; 10; 10. CC property 2; 10; 10. Post-SCF convergence criteria defaults by calculation type 4¶. Ab Initio Method; Calculation Type; E_CONVERGENCE 5; R_CONVERGENCE 6. post-HF of post-HF; energy; 6. optimization; 8. frequency 7; 8. CC property 2; 8. Footnotes. 1; Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. 2(1,2); This applies to properties computed through the properties() function. 3; Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. 4; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. 5; The E_CONVERGENCE keyword is implement",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:46730,optimiz,optimization,46730,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['optimiz'],['optimization']
Performance,"he cbs() wrapper,; which automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; 1; 2; 3; 4; 5# all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; 1database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:17055,perform,perform,17055,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,2,['perform'],['perform']
Performance,"he common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; ---------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:7257,optimiz,optimize,7257,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,12,['optimiz'],"['optimization', 'optimize']"
Performance,"he computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational metho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:62576,optimiz,optimizers,62576,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimizers']
Performance,"he contents of the cfour {...} block are; blindly appended to any input interpreted from PSI4 format, mixing; of PSI4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL). Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; 1; 2set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; 1; 2; 3set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:30339,optimiz,optimization,30339,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,12,['optimiz'],['optimization']
Performance,"he contents of the cfour {...} block are; blindly appended to any input interpreted from Psi4 format, mixing; of Psi4 and Cfour input formats likely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route. Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between Psi4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL). Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. Psi4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles. Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; qcdb.cfour.muster_modelchem() for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:31361,optimiz,optimization,31361,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['optimiz'],['optimization']
Performance,"he cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in Hartrees. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cp-1.html:1216,perform,performs,1216,psi4manual/4.0b3/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cp-1.html,8,"['optimiz', 'perform']","['optimization', 'optimize', 'performs']"
Performance,"he cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in Hartrees. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/cp-1.html:1216,perform,performs,1216,psi4manual/4.0b4/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/cp-1.html,8,"['optimiz', 'perform']","['optimization', 'optimize', 'performs']"
Performance,"he cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in Hartrees. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('df-mp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cp-1.html:1216,perform,performs,1216,psi4manual/4.0b5/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cp-1.html,8,"['optimiz', 'perform']","['optimization', 'optimize', 'performs']"
Performance,"he cp function computes counterpoise-corrected two-body interaction energies; for complexes composed of arbitrary numbers of monomers. Aliases :counterpoise_correct(), counterpoise_correction(). Returns:(float) Counterpoise-corrected interaction energy in kcal/mol. Psi variables:. CP-CORRECTED 2-BODY INTERACTION ENERGY; UNCP-CORRECTED 2-BODY INTERACTION ENERGY. Caution; Some features are not yet implemented. Buy a developer a coffee. No values of func besides energy have been tested.; Table print-out needs improving. Add some PSI variables. Parameters:; name (string) – 'scf' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the molecule. May be any valid argument to; energy(); however, SAPT is not appropriate. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on the molecule; and each of its monomers. The default performs a single-point; energy('name'), while optimize perfoms a geometry optimization; on each system, and cbs performs a compound single-point energy.; If a nested series of python functions is intended; (see Function Intercalls), use keyword cp_func instead of func. check_bsse (boolean) – 'on' || 'off' ; Indicates whether to additionally compute un-counterpoise corrected; monomers and thus obtain an estimate for the basis set superposition error. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] counterpoise-corrected mp2 interaction energy; >>> cp('dfmp2'). n_body(name[, func, bsse, max_n_body, do_total, external, external_monomers, molecule])[source]¶. Previous topic; Property; Next topic; Optimize; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cp-1.html:1201,perform,performs,1201,psi4manual/4.0b2/cp-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cp-1.html,8,"['optimiz', 'perform']","['optimization', 'optimize', 'performs']"
Performance,"he engine drive all operations involving data structures that have at; least one “large” dimension. See SolverEngine for requirements; guess (List) – list {engine dependent}; At least nroot initial expansion vectors; nroot (int) – Number of roots desired; r_convergence (float) – Convergence tolerance for residual vectors; max_ss_size (int) – The maximum number of trial vectors in the iterative subspace that will; be stored before a collapse is done.; maxiter (int) – The maximum number of iterations; verbose (int) – The amount of logging info to print (0 -> none, 1 -> some, >1 -> everything); nonneg_only (bool) – Should eigenpairs with eigenvalue < 0 be ignored?. Return type:; Dict[str, Any]. Returns:. best_values (numpy.ndarray) – (nroots, ) The best approximation of the eigenvalues of A, computed on the last iteration of the solver; best_vectors (List[vector]) – (nroots) The best approximation of the eigenvectors of A, computed on the last iteration of the solver; stats (List[Dict]) – Statistics collected on each iteration. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged. Notes; The solution vector is normalized to 1/2; The solver will return even when maxiter iterations are performed without convergence.; The caller must check stats[-1]['done'] for failure and handle each case accordingly. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; davidson_solver. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.davidson_solver.html:2314,perform,performed,2314,psi4manual/1.7.x/api/psi4.driver.p4util.davidson_solver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.p4util.davidson_solver.html,6,['perform'],['performed']
Performance,"he gradient isn't needed; opt_calcs = opt_object.calculations_needed() # tuple of strings ('energy', 'gradient', etc). # Compute the gradient - no longer need to worry about opt_data being wiped; G, wfn = gradient(lowername, return_wfn=True, molecule=molecule, **kwargs); thisenergy = core.variable('CURRENT ENERGY'); opt_object.E = thisenergy; opt_object.gX = G.np. if core.get_option('OPTKING', 'CART_HESS_READ') and (n == 1):; opt_object.params.cart_hess_read = True; opt_object.params.hessian_file = f""{core.get_writer_file_prefix(molecule.name())}.hess""; # compute Hessian as requested; frequency wipes out gradient so stash it; elif 'hessian' in opt_calcs:; # compute hessian as requested. # procedures proctable analytic hessians; _, hess_wfn = frequencies(hessian_with_method,; molecule=molecule,; ref_gradient=G,; return_wfn=True,; **kwargs); opt_object.HX = hess_wfn.hessian().np. # force optking to update its molecule to psi4's.; # This allows for psi4 to rotate as desired. If optimizing in cartesians. rotation is not allowed; # Process gradient / hessian. Take step. Print summary to output for user; opt_object.molsys.geom = molecule.geometry().np; core.print_out(opt_object.pre_step_str()) # print optking's molecule; opt_object.compute() # process E, gX, H; try:; opt_object.take_step(); except optking.exceptions.AlgError:; # Optking encountered an algorithm error and reset.; if not opt_object.HX:; n += 1; continue; else:; raise ConvergenceError(; ""Psi4 caught an AlgError. This should only happen after optking resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:74480,optimiz,optimizing,74480,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimizing']
Performance,"he internal data. soFeff(self); Returns the effective Fock matrix in the orthogonalized SO basis. sobasisset(self); Returns the symmetry orbitals basis. soccpi(self); Returns the number of singly occupied orbitals per irrep. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. to_file([filename]); Converts a Wavefunction object to a base class. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. variable(key); Return copy of scalar or array QCVariable key from self psi4.core.Wavefunction. variables([include_deprecated_keys]); Return all scalar or array QCVariables from cls. write_molden([filename, do_virtual, use_natural]); Function to write wavefunction information in wfn to filename in molden format. write_nbo(name). Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. Ca(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Orbitals. Ca_subset(self: psi4.core.Wavefunction, arg0: str, arg1: str) → psi4.core.Matrix¶; Returns the requested Alpha orbital subset. Parameters. basis (str) – {‘SO’, AO’}; Should the subset be of symmetry orbitals or atomic orbitals?; subset (str) – {‘ALL’, ‘ACTIVE’, ‘FROZEN’, ‘OCC’, ‘VIR’, ‘",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html:12666,perform,performed,12666,psi4manual/1.6.x/api/psi4.core.ROHF.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.ROHF.html,2,['perform'],['performed']
Performance,"he moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last; resort will be used.; To avoid this, either set DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or set DF_SCF_GUESS; to false, which disables this acceleration entirely. Integral-Direct Density-Fitted Coulomb Construction¶; The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285],; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside; Psi4’s separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction; algorithm when specifying SCF_TYPE to use a composite algorithm combination (DFDIRJ+K_alg in general,; or DFDIRJ for DFT with non-hybrid functionals).; DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI; screening (set SCREENING to DENSITY) and incremental Fock matrix c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/scf.html:34692,bottleneck,bottleneck,34692,psi4manual/1.9.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/scf.html,4,"['bottleneck', 'perform']","['bottleneck', 'performing']"
Performance,"he moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so a very large fitting basis of last; resort will be used.; To avoid this, either set DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or set DF_SCF_GUESS; to false, which disables this acceleration entirely. Integral-Direct Density-Fitted Coulomb Construction¶; The Resolution of the Identity (RI) can be used to decompose the normally 4-center ERI tensor into a combination of 3-center and 2-center components.; By reducing the dimensionality of the ERI tensor, application of the RI (often referred to as density-fitting, or DF) can be used to greatly speed up; SCF calculations. The reduction in ERI tensor rank also makes DF an appealing option for conventional SCF calculations, where the ERIs are stored; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285],; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside; Psi4’s separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction; algorithm when specifying SCF_TYPE to use a composite algorithm combination (DFDIRJ+K_alg).; DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI; screening (set SCREENING to DENSITY) and incremental Fock matrix construction (set INCFOCK to TRUE). These two, when combined",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:34245,bottleneck,bottleneck,34245,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,2,"['bottleneck', 'perform']","['bottleneck', 'performing']"
Performance,"he most popular tuned-LRC; approach is IP-fitting, in which the \(\omega\) is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between \(N-1\)-electron and \(N\)-electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{tuned-LRC}} (r) = -; \frac{1}{r} + I_{\mathrm{IP}} +; \epsilon_{\mathrm{HOMO}}\]; Note that LRC functionals with default \(\omega\) only capture the; \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{LRC}} (r) = -; \frac{1}{r},\]; hybrid functionals only capture part of the \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -; \frac{\alpha}{r},\]; and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0\]; IP-tuned LRC functionals effectively pin the chemical potential at \(N\); electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” and more modern “-D3” approaches are a de facto industry standards. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; 1; 2; 3; 4; 5; 6; 7molecule {;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:11484,tune,tuned,11484,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,6,['tune'],['tuned']
Performance,"he most popular tuned-LRC; approach is IP-fitting, in which the \(\omega\) is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between \(N-1\)-electron and \(N\)-electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{tuned-LRC}} (r) = -; \frac{1}{r} + I_{\mathrm{IP}} +; \epsilon_{\mathrm{HOMO}}\]; Note that LRC functionals with default \(\omega\) only capture the; \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{LRC}} (r) = -; \frac{1}{r},\]; hybrid functionals only capture part of the \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -; \frac{\alpha}{r},\]; and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0\]; IP-tuned LRC functionals effectively pin the chemical potential at \(N\); electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of excited state ordering in many low band-gap systems.; For dispersion-bound complexes, a very simple additive empirical dispersion; potential, based on a damped Lennard-Jones potential can often produce; remarkably accurate results with KS-DFT. This approach was championed by Grimme,; whose “-D2” and more modern “-D3” approaches are a de facto industry standards. Minimal Input¶; Minimal input for a KS-DFT computation is a molecule block, basis set; option, and a call to energy('b3lyp') (or other valid functional name):; molecule {; He; }. set basis s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:12005,tune,tuned,12005,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['tune'],['tuned']
Performance,"he one-particle density matrix?. Type: boolean; Default: false. OPDM_OUT_FILE (TRANSQT); TRANSQT — AO-basis one-particle density matrix file. Type: integer; Default: PSIF_AO_OPDM. OPDM_PRINT (DETCI); DETCI — Do print the one-particle density matrix for each root?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (CPHF); CPHF — Do add relaxation terms to the one particle density matrix, for properties?. Type: boolean; Default: false. OPDM_RELAX (DFMP2); DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_METHOD (OCC); OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (OCC); OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (OCC); OCC — The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE (OCC); OCC — The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. P (THERMO); THERMO — Pressure in Pascal for thermodynamic analysis. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:92024,perform,performed,92024,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"he program binary (gcp) must be; found in your PSIPATH or PATH (in that order). If; PSI4 is unable to execute the binary, an error will be reported.; To preferentially use a particular gcp compilation, simply adjust its; position in the path environment variables. Running gCP¶; At present there is a limited interface to gCP that is used; only to implement the “HF-3c” [Sure:2013:1672] and “PBEh-3c”; [Grimme:2015:054107] methods (both energy and gradient). The DFTD3 executable must also be available for these methods to; run. Unlike every other method in PSI4, if a basis set has not been; set, these will default to their intended basis sets: MINIX for HF-3c; and def2-mSVP for PBEh-3c. If a basis has previously been set, but you; want to use the default basis, use the slash syntax to “empty” the basis; option for the scope of the current calculation, energy(""hf3c/"").; A few practical examples:. HF-3c single point with default minix basis; energy('hf3c'). PBEh-3c optimization with default def2-mSVP basis; optimize('pbeh3c'). HF-3c with non-standard basis; set basis cc-pvdz; energy('hf3c'). PBEh-3c with default basis after basis set; set basis cc-pvdz; energy('pbeh3c/'). If only BSSE/basis set corrections (rather than total energies) are of; interest, the gcp program can be run independently of the scf; through the python function run_gcp(). (This function; is the same PSI4/gcp interface that is called during an scf job.); This route is much faster than running a HF or DFT energy.; molecule nene {; Ne; Ne 1 2.0; }. nene.update_geometry(). >>> E, G = nene.run_gcp('hf3c'). >>> E, G = nene.run_gcp(func='HF3c', verbose=True). qcdb.Molecule.run_gcp(self, func=None, dertype=None, verbose=1)¶; Compute geometrical BSSE correction via Grimme’s GCP program.; Function to call Grimme’s GCP program; https://www.chemie.uni-bonn.de/pctc/mulliken-center/software/gcp/gcp; to compute an a posteriori geometrical BSSE correction to self for; several HF, generic DFT, and specific HF-3c and PB",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/gcp-1.html:2140,optimiz,optimization,2140,psi4manual/1.4.0/gcp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/gcp-1.html,10,['optimiz'],"['optimization', 'optimize']"
Performance,"he right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None; Average off-diagonal element in-place. identity(self: psi4.core.Matrix) → None; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None; Loads a matrix from an ASCII file in MPQC format. name; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int; Returns the number of irreps. np; View without only one irrep. classmethod np_read(filename, prefix=''); Reads the data from a NumPy compress file. np_write(filename=None, prefix=''); Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html:21470,load,load,21470,psi4manual/1.2.1/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"he split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. fci-coverage; 6-31G H2O Test for coverage. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. dft-grad-lr2; Tests CAM gradients with and without XC pieces to narrow grid error. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_.. tuple. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dft-custom-hybrid; DFT (hybrids) test of implementations in: hybrid_superfuncs.py. cepa4; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:36450,optimiz,optimize,36450,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,8,['optimiz'],['optimize']
Performance,"he target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Extra options passed to the GeomeTRIC or optking optimizers; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:1821,perform,performed,1821,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,20,['perform'],['performed']
Performance,"he y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; 1; 2; 3set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]¶. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CONVERGENCE keyword is implemented for most post-SCF modules.; See a list beginning at E_CONVERGENCE. [6]The R_CONVERGENCE keyword places a convergence check on an internal; residual error measure and is implemented for several post-SCF; modules (see list beginning at R_CONVERGENCE). It is defined; according to the quantum",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:33599,optimiz,optimization,33599,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['optimiz'],['optimization']
Performance,"he, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (CPHF); CPHF — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRITE (CCLAMBDA); CCLAMBDA — Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM); CCEOM — Do turn on root foll",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:10944,cache,cached,10944,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['cache'],['cached']
Performance,"he, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRITE (CLAG); CLAG — Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM); CCEOM — Do turn on root following for ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:11012,cache,cached,11012,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['cache'],['cached']
Performance,"he, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRITE (CLAG); CLAG — Do write the OEI, TEI, OPDM, TPDM, and Lagrangian files in canonical form, Pitzer order?. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM); CCEOM — Do turn on root following for CC3. Type: boolean; Default: false. CC_A_RAS3_MAX (DETCI); DETCI — maximum number of alpha electrons in RAS III, for CC. Type: i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:11043,cache,cached,11043,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['cache'],['cached']
Performance,"he; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/optking-1.html:6014,optimiz,optimize,6014,psi4manual/4.0b2/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html,4,['optimiz'],['optimize']
Performance,"he; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to eva",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:6220,optimiz,optimize,6220,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['optimiz'],['optimize']
Performance,"he; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * 1.00e-06 * 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -76.33224285 -7.63e+01 2.41e-03 1.60e-03 1.51e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:7459,optimiz,optimizations,7459,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['optimiz'],['optimizations']
Performance,"he; Psi4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * 1.00e-06 * 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -76.33224285 -7.63e+01 2.41e-03 1.60e-03 1.51e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:7472,optimiz,optimizations,7472,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimizations']
Performance,"he; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call PSI4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of PSI4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in PSI4 are; nbody(),; database(), and; cbs(); read their respective sections; for details, but an overview is provided here. nbody(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cfour.html:11926,optimiz,optimize,11926,psi4manual/1.6.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cfour.html,5,['optimiz'],['optimize']
Performance,"he; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call PSI4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of PSI4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in PSI4 are; nbody_gufunc(),; database(), and; cbs(); read their respective sections; for details, but an overview is provided here. nbody_gufunc(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:11926,optimiz,optimize,11926,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,4,['optimiz'],['optimize']
Performance,"he; generic 'cfour', the computational method is specified as the first; argument to the optimize() call. In the computational; command below, the string argument 'c4-ccsd(t)' directs that a CCSD(T); computation be run using Cfour (as opposed to 'ccsd(t)' which would; call Psi4 CC code). Specifying computational method in this manner; sets CFOUR_CALC_LEVEL from the argument and; CFOUR_DERIV_LEVEL as appropriate from the function call:; energy(), gradient(), or; optimize(). If those keywords are also set explicitly to; contradictory values, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of Psi4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in Psi4 are; _nbody_gufunc(),; database(), and; complete_basis_set(); read their respective sections; for details, but an overview is provided here. _nbody_gufunc(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:11939,optimiz,optimize,11939,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimize']
Performance,"he; run_cfour() function documented below. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; complete_basis_set() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of PSI4 and Cfour computational methods and PSI4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; property() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gaus",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:25190,optimiz,optimize,25190,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,6,['optimiz'],['optimize']
Performance,"hecks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. dft2; DFT Functional Test. soscf-large; Second-order SCF convergnece: Benzene. cbs-xtpl-alpha; Extrapolated water energies. cc17; Single point energies of multiple excited states with EOM-CCSD. fd-gradient; SCF STO-3G finite-difference tests. mbis-6; MBIS calculation on H2O. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. cbs-delta-energy; Extrapolated energies with delta correction. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. frac-sym; Fractional occupation with symmetry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. sapt-ecp; sapt0 of charged system in ECP basis set. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:32907,optimiz,optimization,32907,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"help to solve problems with oscillatory convergence. Type: double; Default: 0.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_MAX_VECS¶. Maximum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 10. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Will be removed in v1.7. Type: integer; Default: 2. DIIS_RMS_ERROR¶. Use RMS error instead of the more robust absolute error?. Type: boolean; Default: true. DIIS_START¶. The minimum iteration to start storing DIIS vectors and performing ADIIS/EDIIS. Type: integer; Default: 1. DO_LINK¶. Perform the linear scaling exchange (LinK) algorithm, as described in [Ochsenfeld:1998:1663]. Only applies to Direct SCF. Type: boolean; Default: false. D_CONVERGENCE¶. Convergence criterion for SCF density, defined as the RMS or maximum absolute value of the orbital gradient. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Cfour Interface: Keyword translates into CFOUR_SCF_CONV. Type: conv double; Default: 1e-6. E_CONVERGENCE¶. Convergence criterion for SCF energy. See Table SCF Convergence & Algorithm for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAIL_ON_MAXITER¶. Fail if we reach maxiter without converging?. Type: boolean; Default: true. INCFOCK¶. Do perform incremental Fock build?. Type: boolean; Default: false. INCFOCK_CONVERGENCE¶. The density threshold at which to stop building the Fock matrix incrementally. Type: conv double; Default: 1.0e-5. INCFOCK_FULL_FOCK_EVERY¶. Frequency with which to compute the full Fock m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html:5335,Perform,Perform,5335,psi4manual/1.6.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__scf.html,1,['Perform'],['Perform']
Performance,"hemistry software package; #; # Copyright (c) 2007-2016 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This program is free software; you can redistribute it and/or modify; # it under the terms of the GNU General Public License as published by; # the Free Software Foundation; either version 2 of the License, or; # (at your option) any later version.; #; # This program is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU General Public License for more details.; #; # You should have received a copy of the GNU General Public License along; # with this program; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions that encode the sequence of PSI module; calls for each of the *name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; from __future__ import print_function; from __future__ import absolute_import; import shutil; import os; import subprocess; import re. # Relative hack for now; import sys, inspect; path_dir = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],""../""))); sys.path.append(path_dir); import p4util; from p4util.exceptions import *; from molutil import *. from .functional import *; from .roa import *; from . import proc_util. # never import driver, wrappers, or aliases into this file. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. [docs]def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:1253,optimiz,optimize,1253,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['optimiz'],['optimize']
Performance,"hemistry software package; #; # Copyright (c) 2007-2019 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import os; import re; import sys; import json; import shutil. import numpy as np. from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". if ptype not in ['gradient', 'hessian']:; raise ValidationError(""_find_derivative_type: ptype must either be gradient or hessian.""). dertype = ""(auto)"". # If user type is None, try to fi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:1262,optimiz,optimizations,1262,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimizations']
Performance,"hemistry software package; #; # Copyright (c) 2007-2021 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import json; import os; import re; import shutil; import sys; from typing import Union. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver.procrouting import *; from psi4.driver.p4util.exceptions import *; from psi4.driver.mdi_engine import mdi_run. # never import wrappers or aliases into this file. def _find_derivative_type(ptype, method_name, user_dertype):; r""""""; Figures out the derivative type (0, 1, 2) for a given method_name. Will; first use user default and then the highest available derivative type for; a given method.; """""". derivatives = {""gradient"": 1, ""hessian"": 2}. if ptype not in derivatives:; raise",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:1280,optimiz,optimizations,1280,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['optimiz'],['optimizations']
Performance,"hemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Module with a *procedures* dictionary specifying available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:1280,optimiz,optimizations,1280,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizations']
Performance,"hen repeated using the DC-12 functional with the same algorithms. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. dct6; DCT calculation for the triplet O2 using DC-06 and DC-12. Only two-step algorithm is tested. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/cc-pVTZ on H2O. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbo; Generation of NBO file. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. scf-guess-read3; Test if the the guess read in the same basis converges. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cubeprop; RHF orbitals and density for water. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt11; Transition-s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:36753,optimiz,optimization,36753,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"henstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012).; (doi: 10.1002/wcms.84).; “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; (doi: 10.1063/1.3451077). F/I-SAPT. “Chemical Assignment of Symmetry-Adapted Perturbation Theory Interaction; Energy Components: The Functional-Group SAPT Partition,”; R. M. Parrish, T. M. Parker, and C. D. Sherrill,; J. Chem. Theory Comput. 10, 4417 (2014).; (doi: 10.1021/ct500724p).; “Communication: Practical Intramolecular Symmetry Adapted Perturbation Theory; via Hartree-Fock Embedding,”; R. M. Parrish, J. F. Gonthier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:12986,optimiz,optimization,12986,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,18,['optimiz'],"['optimization', 'optimized']"
Performance,"her. pubchem2; Superficial test of PubChem interface. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. casscf-fzc-sp; CASSCF/6-31G** energy point. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. fci-h2o-2; 6-31G H2O Test FCI Energy Point. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. mom-h2o-4; MOM excitation from LUMO HOMO+4. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mp2-1; All-electron MP2 6-31G** geometry optimization of water. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radica",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:4055,perform,performs,4055,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:4359,optimiz,optimize,4359,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimize']
Performance,"hers'][mc] = mc; # fmcs['Basis Treatment']['Others'][mc] = mc; # else:; # fancyrepr = """"""%20s / %-20s %s"""""" % (methods[mtd].latex, bases[bas].latex, mod); # fmcs['All']['All'][mc] = fancyrepr; # fmcs['Method'][methods[mtd].latex][mc] = fancyrepr; # fmcs['Options'][mod][mc] = fancyrepr; # fmcs['Basis Treatment'][bases[bas].latex][mc] = fancyrepr; # return fmcs. [docs] def integer_reactions(self):; """"""Returns boolean of whether reaction names need to be cast to integer""""""; return {db: odb.integer_reactions() for db, odb in self.dbdict.items()}. [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""For each component database, loads qcdb.ReactionDatums from; standard location for *project* :module dbse_project and function; load_project. Module search path can be prepended with *pythonpath*. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_byproject(project, pythonpath=pythonpath); self._intersect_modelchems(). [docs] def load_qcdata_hdf5_trusted(self, project, path=None):; """"""For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_hdf5_trusted(project, path=path); self._intersect_modelchems(). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; for db, odb in self.dbdict.items():; odb.load_qcdata_hrxn_byproject(project, path=path); self._intersect_modelchems(). [docs] def available_projects(self, path=None):; """"""""""""; import glob. if path is None:; path = os.path.dirname(__file__) + '/../data'. projects = []; for pjfn in glob.glob(path + '/*_hrxn_*.pickle'):; pj = pjfn[:-7].split('_')[-1]; projects.append(pj). complete_projects = []; for pj in set(projects):; if all([os.path.isfile(path + '/' + db + '_hrxn_' + pj + '.pickle') for db in self.dbdict.keys()]):; complete_projects.append(pj). return complete_projects. [docs] def loa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:51485,load,loads,51485,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loads']
Performance,"hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = core.get_legacy_gradient() # TODO; core.IOManager.shared_object().set_specific_retention(1, True); core.IOManager.shared_object().set_specific_path(1, './'); frequencies(hessian_with_method, molecule=moleculeclone, ref_gradient=G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if not core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT'):; if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_speci",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:67269,optimiz,optimized,67269,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimized']
Performance,"hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor (both as-is) or HTML table link (replace underscore in returned string by dash). sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psi4api.html:19217,perform,perform,19217,psi4manual/1.8.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psi4api.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). rtype:; None. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor :rtype: str. sanitize_name(name); Function to return name in coded form, stripped of :rtype: str. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_wfn, ...); Builds the correct (R/U/RO/CU HF/KS) wavefunction from the provided informatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psi4api.html:19316,perform,perform,19316,psi4manual/1.9.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psi4api.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"hest_1() in module wrappers. HSG module, [1]. HTBH module, [1]. I. ICORE (DETCI). IGNORE_TAU (DCFT). import_ignorecase() in module procutil. IncompleteAtomError. inertia_tensor() LibmintsMolecule method. init_with_checkpoint() LibmintsMolecule method. init_with_io() LibmintsMolecule method. init_with_xyz() qcdb.libmintsmolecule.LibmintsMolecule class method. qcdb.molecule.Molecule class method. input module. installing. INTCO_FIXED_EQ_FORCE_CONSTANT (OPTKING). INTCOS_GENERATE_EXIT (OPTKING). INTERFRAG_DIST_INV (OPTKING). INTERFRAG_HESS (OPTKING). INTERFRAG_MODE (OPTKING). INTERFRAG_STEP_LIMIT (OPTKING). INTERNAL_ROTATIONS (MCSCF). INTRAFRAG_HESS (OPTKING). INTRAFRAG_STEP_LIMIT (OPTKING). INTRAFRAG_STEP_LIMIT_MAX (OPTKING). INTRAFRAG_STEP_LIMIT_MIN (OPTKING). INTS_TOLERANCE (CCDENSITY). (CCSORT). (DCFT). (DFMP2). (LMP2). (MRCC). (SAPT). (SCF). (TRANSQT). (TRANSQT2). invalidate() CartesianEntry method. CoordValue method. ZMatrixEntry method. ip_fitting() in module frac. IRC; . geometry optimization. IRC_DIRECTION (OPTKING). IRC_STEP_SIZE (OPTKING). IRC_STOP (OPTKING). irrep_labels() LibmintsMolecule method. is_axis() LibmintsMolecule method. is_computed() CoordEntry method. is_equivalent_to() CoordEntry method. is_ghosted() CoordEntry method. is_linear_planar() LibmintsMolecule method. is_plane() LibmintsMolecule method. is_variable() LibmintsMolecule method. ISTOP (DETCI). IVO (TRANSQT). J. J_FILE (TRANSQT). JOBTYPE (CCLAMBDA). (MP2). JSCH module, [1]. K. KEEP_INTCOS (OPTKING). KEEP_J (TRANSQT). KEEP_OEIFILE (CCSORT). KEEP_PRESORT (TRANSQT). KEEP_TEIFILE (CCSORT). keywords; . C-side, setting. cbs(), setting. cp(), setting. database(), setting. diatomic_anharmonicity(), setting. energy(), setting. molecule, setting. optimize(), setting. property(), setting. kwargs_lower() in module procutil. L. label() CoordEntry method. LibmintsMolecule method. LAG_IN_FILE (TRANSQT). LAGRAN_DOUBLE (TRANSQT). LAGRAN_HALVE (TRANSQT). LAMBDA_MAXITER (DCFT). LCC2(+LMP2)TOTALENERGY. LCCSD(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/genindex.html:23530,optimiz,optimization,23530,psi4manual/4.0b3/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/genindex.html,1,['optimiz'],['optimization']
Performance,"hf-scf; single-point HF/qz2p on water. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/kw-1; testing best practices options, part i. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html:4701,optimiz,optimization,4701,psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"hf; scf_type df; basis aug-cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }. dimer = psi4.get_active_molecule(). set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True). monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True). psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'). aux_basis = psi4.core.BasisSet.build(wfn_dimer.molecule(), ""DF_BASIS_SAPT"",; psi4.core.get_global_option(""DF_BASIS_SAPT""),; ""RIFIT"", psi4.core.get_global_option(""BASIS"")); wfn_dimer.set_basisset(""DF_BASIS_SAPT"", aux_basis); wfn_dimer.set_basisset(""DF_BASIS_ELST"", aux_basis). psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:14391,load,load,14391,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['load'],['load']
Performance,"hgdoptval = psi4.get_global_option(chgdopt); if isinstance(chgdoptval, basestring):; commands += """"""psi4.set_global_option('%s', '%s')\n"""""" % (chgdopt, chgdoptval); elif isinstance(chgdoptval, int) or isinstance(chgdoptval, float):; commands += """"""psi4.set_global_option('%s', %s)\n"""""" % (chgdopt, chgdoptval); else:; raise ValidationError('Option \'%s\' is not of a type (string, int, float, bool) that can be processed.' % (chgdopt)); return commands. [docs]def format_kwargs_for_input(filename, lmode=1, **kwargs):; """"""Function to pickle to file *filename* the options dictionary; *kwargs*. Mode *lmode* =2 pickles appropriate settings for; reap mode. Used to capture Python options information for; distributed (sow/reap) input files. """"""; if lmode == 2:; kwargs['mode'] = 'reap'; kwargs['linkage'] = os.getpid(); filename.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, filename); filename.write('''"""""")\n'''); filename.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); if lmode == 2:; kwargs['mode'] = 'sow'; del kwargs['linkage']. [docs]def drop_duplicates(seq):; """"""Function that given an array *seq*, returns an array without any duplicate; entries. There is no guarantee of which duplicate entry is dropped. """"""; noDupes = []; [noDupes.append(i) for i in seq if not noDupes.count(i)]; return noDupes. [docs]def all_casings(input_string):; """"""Function to return a generator of all lettercase permutations; of *input_string*. """"""; if not input_string:; yield """"; else:; first = input_string[:1]; if first.lower() == first.upper():; for sub_casing in all_casings(input_string[1:]):; yield first + sub_casing; else:; for sub_casing in all_casings(input_string[1:]):; yield first.lower() + sub_casing; yield first.upper() + sub_casing. [docs]def getattr_ignorecase(module, attr):; """"""Function to extract attribute *attr* from *module* if *attr*; is available in any possible lettercase permutation. Returns; attribute if available, None if not. """"""; array = None; for per in list(all_casin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html:4849,load,loads,4849,psi4manual/4.0b5/_modules/p4util/procutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/p4util/procutil.html,2,['load'],['loads']
Performance,"hich is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCT)¶DCT (Expert) — Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCT)¶DCT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCT)¶DCT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCT)¶DCT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCT)¶DCT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING)¶OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. SUMMATION_FIELDS (PE)¶PE — Summation scheme for field computations, can be direct or fmm. Type: string; Possible Values: DIRECT, FMM; Default: DIRECT. SYMM_TOL (OPTKING)¶OPTKING — Symmetry tolerance for testing whether a mode is symmetric. Type: conv double; Default: 0.05. SYMMETRIZE (OCC)¶OCC — Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. T (THERMO)¶THERMO — Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. T2_COUPLED (CCENERGY)¶CCENERGY —. Type: boolean; Default: false. T3_WS_INCORE (CCENERGY)¶CCENERGY — Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. T3_WS_INCORE (CCEOM)¶CCEOM — Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. T_AMPS (CCHBAR)¶CCH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:221648,optimiz,optimization,221648,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['optimiz'],['optimization']
Performance,"hich is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCT)¶DCT (Expert) — Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCT)¶DCT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCT)¶DCT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCT)¶DCT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCT)¶DCT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING)¶OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. SUMMATION_FIELDS (PE)¶PE — Summation scheme for field computations, can be direct or fmm. Type: string; Possible Values: DIRECT, FMM; Default: DIRECT. SYMMETRIZE (OCC)¶OCC — Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. T (THERMO)¶THERMO — Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. T2_COUPLED (CCENERGY)¶CCENERGY —. Type: boolean; Default: false. T3_WS_INCORE (CCENERGY)¶CCENERGY — Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. T3_WS_INCORE (CCEOM)¶CCEOM — Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. T_AMPS (CCHBAR)¶CCHBAR — Do compute the T amplitude equation matrix elements?. Type: boolean; Default: false. T_CUT_CLMO (DLPNO)¶DLPNO (Expert",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:227680,optimiz,optimization,227680,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,3,['optimiz'],['optimization']
Performance,"hich is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCT)¶DCT (Expert) — Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCT)¶DCT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCT)¶DCT (Expert) — The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES (DCT)¶DCT (Expert) — The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS (DCT)¶DCT (Expert) — The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STEP_TYPE (OPTKING)¶OPTKING — Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, RS_I_RFO, P_RFO, NR, SD, LINESEARCH; Default: RFO. SUMMATION_FIELDS (PE)¶PE — Summation scheme for field computations, can be direct or fmm. Type: string; Possible Values: DIRECT, FMM; Default: DIRECT. SYMMETRIZE (OCC)¶OCC — Do symmetrize the GFM and OPDM in the EKT computations?. Type: boolean; Default: true. T (THERMO)¶THERMO — Temperature in Kelvin for thermodynamic analysis. Note that 273.15 is the value for IUPAC STP. Type: double; Default: 298.15. T2_COUPLED (CCENERGY)¶CCENERGY —. Type: boolean; Default: false. T3_WS_INCORE (CCENERGY)¶CCENERGY — Do build W intermediates required for cc3 in core memory?. Type: boolean; Default: false. T3_WS_INCORE (CCEOM)¶CCEOM — Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. T_AMPS (CCHBAR)¶CCHBAR — Do compute the T amplitude equation matrix elements?. Type: boolean; Default: false. T_CUT_CLMO (DLPNO)¶DLP",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html:234682,optimiz,optimization,234682,psi4manual/master/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_glossary_options_c.html,1,['optimiz'],['optimization']
Performance,"hich states to save AO transition OPDMs for? * Positive - Singlets * Negative - Triplets *. Type: array; Default: No Default. COLLAPSE_SIZE (DETCI); DETCI — Gives the number of vectors to retain when the Davidson subspace is collapsed (see MAX_NUM_VECS). If greater than one, the collapsed subspace retains the best estimate of the CI vector for the previous n iterations. Defaults to 1. Type: integer; Default: 1. COLLAPSE_WITH_LAST (CCEOM); CCEOM — Do collapse with last vector?. Type: boolean; Default: true. COMPLEX_TOLERANCE (CCEOM); CCEOM — Complex tolerance applied in CCEOM computations. Type: conv double; Default: 1e-12. COMPUT_S2 (DFOCC); DFOCC — Do compute <S2> for DF-OMP2/DF-MP2?. Type: boolean; Default: false. COMPUTE_MP4_TRIPLES (FNOCC); FNOCC (Expert) — Do compute MP4 triples contribution?. Type: boolean; Default: false. COMPUTE_TRIPLES (FNOCC); FNOCC (Expert) — Do compute triples contribution?. Type: boolean; Default: true. CONSECUTIVE_BACKSTEPS (OPTKING); OPTKING — Set number of consecutive backward steps allowed in optimization. Type: integer; Default: 0. CORR_ANSATZ (PSIMRCC); PSIMRCC — The ansatz to use for MRCC computations. Type: string; Possible Values: SR, MK, BW, APBW; Default: MK. CORR_CCSD_T (PSIMRCC); PSIMRCC — The type of CCSD(T) computation to perform. Type: string; Possible Values: STANDARD, PITTNER; Default: STANDARD. CORR_CHARGE (PSIMRCC); PSIMRCC — The molecular charge of the target state. Type: integer; Default: 0. CORR_MULTP (PSIMRCC); PSIMRCC — The multiplicity, , of the target state. Must be specified if different from the reference . Type: integer; Default: 1. CORR_WFN (PSIMRCC); PSIMRCC — The type of correlated wavefunction. Type: string; Possible Values: PT2, CCSD, MP2-CCSD, CCSD_T; Default: CCSD. COUPLING (PSIMRCC); PSIMRCC — The order of coupling terms to include in MRCCSDT computations. Type: string; Possible Values: NONE, LINEAR, QUADRATIC, CUBIC; Default: CUBIC. COUPLING_TERMS (PSIMRCC); PSIMRCC — Do include the terms that coupl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:87818,optimiz,optimization,87818,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"hier, C. Corminboeuf, and C. D. Sherrill,; J. Chem. Phys. 143, 051103 (2015).; (doi: 10.1063/1.4927575). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:13708,optimiz,optimized,13708,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,6,['optimiz'],['optimized']
Performance,"hift can improve convergence, it does change the DCT energy. Type: double; Default: 0.0. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-14. ORBITAL_LEVEL_SHIFT¶. The shift applied to the denominator in the orbital update iterations. Type: double; Default: 0.0. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. table of contents. DCT; General; ALGORITHM; AO_BASIS; DCT_FUNCTIONAL; DCT_TYPE; DF_BASIS_DCT; DIIS_START_CONVERGENCE; E_CONVERGENCE; GUESS_R_CONVERGENCE; MAXITER; ODC_GUESS; OPDM; QC_COU",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html:5978,Perform,Performs,5978,psi4manual/1.4.0/autodir_options_c/module__dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dct-1.html,9,['Perform'],['Performs']
Performance,"hing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR)¶CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA)¶CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:9337,cache,cache,9337,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['cache'],['cache']
Performance,"hirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or 12.1 (we have had; trouble with version 12.0). See Sec. Compiling and Installing for details. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DF-SCF (HF and DFT); Y; Y [4]; RHF/ROHF/UHF/RKS/UKS; threaded. DCFT; Y; Y; UHF; partially threaded. MP2; Y; Y; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y [2]; RHF/ROHF/UHF; threaded. MP3; Y; Y; RHF/UHF; threaded [3]. MP2.5; Y; Y; RHF/UHF; threaded [3]. MP4; Y; —; RHF; threaded [3]. MP(n); Y; —; RHF/ROHF; partially threaded. ZAPT(n); Y; —; RHF/ROHF; partially threaded. OMP2; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP3; Y; Y; RHF/ROHF/UHF/RKS/UKS; partially threaded. OMP2.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:11417,perform,perform,11417,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,4,['perform'],['perform']
Performance,"his density matrix can be diagonalized to obtain the CI natural orbitals. Type: boolean; Default: false. OPDM_IN_FILE (TRANSQT); TRANSQT — MO-basis one-particle density matrix file. Type: integer; Default: PSIF_MO_OPDM. OPDM_KE (DETCI); DETCI (Expert) — Do compute the kinetic energy contribution from the correlated part of the one-particle density matrix?. Type: boolean; Default: false. OPDM_OUT_FILE (TRANSQT); TRANSQT — AO-basis one-particle density matrix file. Type: integer; Default: PSIF_AO_OPDM. OPDM_PRINT (DETCI); DETCI — Do print the one-particle density matrix for each root?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY); CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (MP2); MP2 — Do add relaxation terms to the one particle density matrix, for properties?. Type: boolean; Default: false. OPT_METHOD (OMP2); OMP2 — The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. OPT_METHOD (OMP3); OMP3 — The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. OPT_TYPE (OPTKING); OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORTH_TYPE (OMP2); OMP2 — The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. ORTH_TYPE (OMP3); OMP3 — The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. P (THERMO); THERMO — Pressure in Pascal for thermodynamic analysis. Type: double; Default: 101325. PAIR_ENERGIES_PRINT (CCENERGY); CCENERGY — Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. PARALLEL (SCF); SCF (Expert) — Do run in parallel?. Type: boolean; Default: false. PERTURB_CBS (PSIMRCC); PSIMRCC (Expert) — Do compute the perturbative corrections for basis set incompleteness?. Type: boolean; Default: false. PERTURB_CBS_COUPLING (PSIMRCC); PSIMRCC (Expert) — Do i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:88624,optimiz,optimization,88624,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"his file. # ATTN NEW ADDITIONS!; # consult http://sirius.chem.vt.edu/psi4manual/master/proc_py.html. [docs]def run_dcft(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density cumulant functional theory calculation. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['DCFT', 'REFERENCE']). psi4.set_local_option('SCF', 'REFERENCE', 'UHF'); psi4.set_local_option('DCFT', 'REFERENCE', 'UHF'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs); psi4.dcft(). optstash.restore(). [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); run_dcft(name, **kwargs); psi4.deriv(). optstash.restore(). [docs]def run_omp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. """"""; # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). return psi4.occ(). [docs]def run_omp2_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; OMP2 gradient calculation. """"""; optstash = p4util.OptionsState(; ['REFERENCE'],; ['GLOBALS', 'DERTYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); run_omp2(name, **kwargs); psi4.deriv(). optstash.restore(). [docs]def run_mp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a MP2 calculation. """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT']). # If the scf type is DF/CD, then the AO integrals were never written to disk; if psi4.get_option('SCF', 'SCF_TYPE') == 'DF' or psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; mints = psi4.MintsHelper(); mints.integrals(). psi4.set_local_option('OCC', 'OR",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:2459,optimiz,optimized,2459,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,2,['optimiz'],['optimized']
Performance,"his test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. omp2-3; OMP2 cc-pVDZ energy for the NO radical. omp2p5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). sapt11; sapt example with orbital freezing with alkali metal and dMP2. fci-h2o; 6-31G H2O Test FCI Energy Point. psimrcc-sp1; Mk-MRCCSD single point. \(^3 \Sigma ^-\) O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfccsd-t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:5989,perform,performs,5989,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"his ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf; mp2. df-mp2; cc2; ccsd. bccd; cc3; ccsd(t). cisd; cisdt; cisdtq. cin; fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtain",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/cbs-1.html:2938,perform,performed,2938,psi4manual/4.0b3/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/cbs-1.html,2,['perform'],['performed']
Performance,"hm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). To choose the type of sieving, set; the SCREENING keyword to your desired option. For Schwarz screening, set it; to SCHWARZ, for CSAM, CSAM, and for density matrix-based screening, DENSITY. SCHWARZUses the Cauchy-Schwarz inequality to calculate an upper bounded value of a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/scf-1.html:27092,perform,performance,27092,psi4manual/1.5.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/scf-1.html,2,['perform'],['performance']
Performance,"hm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications).; We have added the automatic capability to use the extremely fast DF; code for intermediate convergence of the orbitals, for SCF_TYPE; DIRECT. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:27092,perform,performance,27092,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,2,['perform'],['performance']
Performance,"hm. The COSX algorithm uses no I/O, scales; well with system size, and requires minimal memory, making it ideal for; large systems and multi-core CPUs. See the COSX section below for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). To choose the type of sieving, set; the SCREENING keyword to your desired option. For Schwarz screening, set it; to SCHWARZ, for CSAM, CSAM, and for density matrix-based screening, DENSITY. SCHWARZUses the Cauchy-Schwarz inequality to calculate an upper bounded value of a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:27956,perform,performance,27956,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['perform'],['performance']
Performance,"hmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retain",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:6575,cache,cache,6575,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance,"hmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM —. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:5966,cache,cache,5966,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance,"hod. fy() LibmintsMolecule method. fZ() LibmintsMolecule method. fz() LibmintsMolecule method. G. G_CONVERGENCE (OPTKING). gamma() CharacterTable method. GAUGE (CCDENSITY). (CCRESPONSE). Gaussian Formatted Checkpoint. Gaussian94BasisSetParser class in qcdb.libmintsbasissetparser. gaussian_n module. GaussianShell class in qcdb.libmintsgshell. GDMA. gdma() in module driver. GDMA_LIMIT (GDMA). GDMA_MULTIPOLE_UNITS (GDMA). GDMA_ORIGIN (GDMA). GDMA_RADIUS (GDMA). GDMA_SWITCH (GDMA). general; . setting keywords. genset_allneutral() in module qcdb.subsetgenerator. genset_anyanion() in module qcdb.subsetgenerator. genset_anycation() in module qcdb.subsetgenerator. genset_DDn5min() in module qcdb.subsetgenerator. genset_HBn5min() in module qcdb.subsetgenerator. genset_MXDDNPn5min() in module qcdb.subsetgenerator. genset_MXDDPPn5min() in module qcdb.subsetgenerator. genset_MXn5min() in module qcdb.subsetgenerator. genset_MXuDD() in module qcdb.subsetgenerator. GEOM_MAXITER (OPTKING). geometry optimization; . IRC. constrained. convergence criteria. function call. minima. output. transition state. geometry optimization, optimization. geometry() in module molutil. LibmintsMolecule method. get_anchor_atom() LibmintsMolecule method. get_ao_sorted_list() BasisSet method. get_ao_sorted_shell() BasisSet method. get_coord_value() LibmintsMolecule method. get_full_point_group() LibmintsMolecule method. get_hrgt() Database method. get_hrxn() Database method. get_memory() in module p4util.util. get_missing_reactions() Database method. get_num_threads() in module p4util.util. get_pec_weightinfo() WrappedDatabase method. get_psifile() in module p4util.procutil. get_reactions() Database method. get_variable() LibmintsMolecule method. getattr_ignorecase() in module p4util.procutil. in module qcdb.psiutil. getCartesian() PubChemObj method. getFromDict() in module p4util.util. getMoleculeString() PubChemObj method. getPubChemResults() in module pubchem. getrec() in module qcdb.jajo. getSDF() Pu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:39024,optimiz,optimization,39024,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['optimiz'],['optimization']
Performance,"hod. is_pure() psi4.core.GaussianShell method. is_variable() psi4.core.Molecule method. is_x_hybrid() psi4.core.SuperFunctional method. is_x_lrc() psi4.core.SuperFunctional method. ISA. ; MBIS. Isotopes. ISOTROPIC_POL (PE). ISTOP (DETCI). iteration_ psi4.core.CUHF attribute. psi4.core.HF attribute. psi4.core.RHF attribute. psi4.core.ROHF attribute. psi4.core.UHF attribute. iterations() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. J. J() psi4.core.JK method. psi4.core.MemDFJK method. JK class in psi4.core. jk() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. JOBTYPE (CCLAMBDA). join_path() in module psi4.driver. K. K() psi4.core.JK method. psi4.core.MemDFJK method. KEEP_INTCOS (OPTKING). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. properties(), setting. vmfc, setting. KIND (ADC). kinetic() psi4.core.FISAPT method. kinetic_grad() psi4.core.MintsHelper method. KineticInt class in psi4.core. L. L psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. label qcelemental.datum.Datum attribute. label() psi4.core.Molecule method. psi4.core.MOSpace method. lagrangian() psi4.core.CCWavefunction method. psi4.core.CIWavefunction method. psi4.core.CUHF method. psi4.core.DFEP2Wavefunction method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. psi4.core.Wavefunction method. LaplaceDenominator class in psi4.core. LCC2 (+LMP2) TOTAL ENERGY. LCCD CORRELATION ENERGY. LCCD DOUBLES ENERGY. LCCD OPPOSITE-SPIN CORRELATION ENERGY. LCCD SAME-SPIN CORRELATION ENERGY. LCCD SINGLES ENERGY. LCCD TOTAL ENERGY. LCCSD. (+LMP2). LCCSD CORRELATION ENERGY. LCCSD DOUBLES ENERGY. LCCSD OPPOSITE-SPIN CORRELATION ENERGY. LCCSD SAME-SPIN CORRELATION ENERGY.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/genindex-1.html:80050,optimiz,optimize,80050,psi4manual/1.4.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/genindex-1.html,2,['optimiz'],['optimize']
Performance,"hod?; if (dertype == 2 and func_existed == False):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); return PsiMod.reference_wavefunction().energy(); elif (dertype == 1 and func_existed == False):; # Ok, we're doing frequencies by gradients; info = 'Performing finite difference by gradient calculations'; print info. func = procedures['gradient'][lowername]. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print ' %d displacements needed.' % ndisp. #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacement",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:45860,Load,Loading,45860,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Load'],['Loading']
Performance,"hod_name)). raise ValidationError(""""""Derivative method 'name' %s and derivative level 'dertype' %s are not available.%s""""""; % (method_name, str(dertype), alternatives)). dertype = min(dertype, derivatives[ptype]). return dertype. def _energy_is_invariant(gradient, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient.rms() < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_present = hasattr(mol, 'EFP'). translations_projection_sound = (not core.get_option('SCF', 'EXTERN') and not core.get_option('SCF', 'PERTURB_H'); and not efp_present); rotations_projection_sound = (translations_projection_sound and stationary_point). return translations_projection_sound, rotations_projection_sound. def _process_displacement(derivfunc, method, molecule, displacement, n, ndisp, **kwargs):; """"""A helper function to perform all processing for an individual finite; difference computation. Parameters; ----------; derivfunc : func; The function computing the target derivative.; method : str; A string specifying the method to be used for the computation.; molecule: psi4.core.molecule or qcdb.molecule; The molecule for the computation. All processing is handled internally.; molecule must not be modified!; displacement : dict; A dictionary containing the necessary information for the displacement.; See driver_findif/_geom_generator.py docstring for details.; n : int; The number of the displacement being computed, for print purposes.; ndisp : int; The total number of geometries, for print purposes. Returns; -------; wfn: :py:class:`~psi4.core.Wavefunction`; The wavefunction computed.; """""". # print progress to file and screen; core.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n, ndisp)); print("""""" %d"""""" % (n), end=('\n' if (n == ndisp) else '')); sys.stdout.flush",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:5099,perform,perform,5099,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['perform'],['perform']
Performance,"hods: SCF to FCI; MCSCF: Multi-Configurational Self-Consistent-Field. MCSCF: Multi-Configurational Self-Consistent-Field¶; Code author: Daniel G. A. Smith, C. David Sherrill, and Matthew L. Leininger; Section author: Daniel G. A. Smith and C. David Sherrill; Module: Keywords, PSI Variables, DETCI; As the cost of Full CI scales exponentially with respect to the number of; active orbitals it is often advantageous to neglect orbitals that do not; exhibit strong correlation. These orbitals are variationally optimized; simultaneously with the CI coefficients and known as Multi-Configurational; Self-Consistent Field (MCSCF). The most commonly used MCSCF procedure is the; complete-active-space self-consistent-field (CASSCF) approach [Roos:1980],; which includes all possible determinants (with the proper symmetry) that can be; formed by distributing a set of active electrons among a set of active; orbitals. The MCSCF module performs CASSCF optimization of molecular orbitals; via a two-step procedure in which the CI coefficients and orbitals are; optimized in an alternating manner. The program uses a fairly simple; approximate orbital Hessian [Chaban:1997:88] and a Newton-Raphson update,; accelerated by Pulay’s DIIS procedure [Pulay:1980]. We have also implemented; the RASSCF method [Malmqvist:1990:RASSCF], which is another kind of MCSCF; which is typically less complete (and less expensive) than CASSCF.; Inactive orbitals in the MCSCF may be specified by the; RESTRICTED_DOCC and RESTRICTED_UOCC keywords. These; orbitals will remain doubly-occupied or doubly-unoccupied, respectively, in the; MCSCF wavefunction. However, the form of these orbitals will be optimized in; the MCSCF procedure. It is also possible to literally freeze inactive orbitals; in their original (SCF) form using the FROZEN_DOCC and; FROZEN_UOCC keywords. This is not normally what one wishes to do in; an MCSCF computation (e.g., it complicates the computation of gradients), but; it can make the computations ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/mcscf-1.html:1068,perform,performs,1068,psi4manual/1.4.0/mcscf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/mcscf-1.html,27,"['optimiz', 'perform']","['optimization', 'optimized', 'performs']"
Performance,"holesky; decomposition (CD) techniques are popular in quantum chemistry to avoid; the computation and storage of the 4-index electron repulsion integral; (ERI) tensor and even to reduce the computational scaling of some terms.; DF/CD-CCSD(T) computations are available in Psi4, with or without the; use of FNOs, through the FNOCC module. The implementation and accuracy of; the DF/CD-CCSD(T) method are described in Ref. [DePrince:2013:2687].; The DF-CCSD(T) procedure uses two auxiliary basis sets. The first set is; that used in the SCF procedure, defined by the DF_BASIS_SCF; keyword. If this keyword is not specified, an appropriate -JKFIT set is; automatically selected. This auxiliary set defines the ERI’s used to; build the Fock matrix used in the DF-CCSD(T) procedure. The second; auxiliary set is used to approximate all other ERI’s in the DF-CCSD(T); procedure. The choice of auxiliary basis is controlled by the keyword; DF_BASIS_CC. By default, DF_BASIS_CC is the RI set; (optimized for DFMP2) most appropriate for use with the primary basis.; For example, if the primary basis is aug-cc-pVDZ, the default; DF_BASIS_CC will be aug-cc-pVDZ-RI.; Alternatively, the user can request that the DF-CCSD(T) procedure use a; set of vectors defined by the Cholesky decomposition of the ERI tensor as; the auxiliary basis. This feature is enabled by specifying CC_TYPE CD.; CD methods can be enabled in the SCF; procedure as well, by specifying the SCF_TYPE as CD. The; accuracy of the decomposition can be controlled through the keyword; CHOLESKY_TOLERANCE.; The following input file sets up a DF-CCSD(T); computation using CD integrals; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; scf_type cd; cc_type cd; basis aug-cc-pvdz; freeze_core true; }; energy('ccsd(t)'). The resulting CCSD(T) correlation energy will be equivalent to that; obtained from a conventional computation if CHOLESKY_TOLERANCE is; sufficiently small (e.g. ). Gn theory¶; The FNOCC module contains all the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/fnocc-1.html:9365,optimiz,optimized,9365,psi4manual/1.0.0/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/fnocc-1.html,2,['optimiz'],['optimized']
Performance,"hon 3.8, 3.9, 3.10, and 3.11 (no binary packages for 3.11).; PSI4 1.8 supports Python 3.8, 3.9, 3.10, and 3.11.; The future plan is to (1) be compatible with 3.8 and above until there is a good reason to drop; older versions but (2) only build and test for versions conda-forge supports.; The current master supports 3.8, 3.9, 3.10, and 3.11. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; General GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties.; For more tables with capabilities details:. Full Capabilities (first below) lists all methods; Capabilities Breakdown (second below) lists selected methods by reference, etc.; Module Capabilities lists selected methods by implementation; Energy, Energy (DFT), Energy (MRCC), Energy (CFOUR) fully list energy target methods; Gradient, Gradient (CFOUR) fully list gradient target methods; Frequency fully lists Hessian target methods. Summary of theoretical methods available in PSI4¶. Method [1]; Reference[2]; Type[2]; Variants[3]. Canonical; OO; FNO [4]; DLPNO. HF; RHF/UHF/ROHF/CUHF; CONV/DF/CD; E/G/H. DFT; RKS/UKS; CONV/DF/CD; E/G. DFT-D2, DFT-NL; RKS/UKS; CONV/DF/CD; E/G. DCT; RHF/UHF; CONV/DF; E/G. MP2; RHF/UH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/introduction.html:23682,optimiz,optimization,23682,psi4manual/1.8.x/introduction.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/introduction.html,2,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"hon driver will conveniently set it to UHF for the DCFT; computations. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCFT energy one; needs to solve the system of coupled equations for the orbitals and the density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option.; 1) Two-step algorithm (can be invoked by setting ALGORITHM option to; TWOSTEP and is currently the default). In two-step algorithm the DCFT equations; are solved in macroiterations. Each macroiteration consists of two sets of; microiterations. In the first set the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. The convergence of the two-step algorithm is accelerated using the; DIIS extrapolation technique.; 2) Simultaneous algorithm (set ALGORITHM to SIMULTANEOUS). In this algorithm; each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and the orbitals is achieved. As in the two-step algorithm, the DIIS; extrapolation is used to accelerate the convergence.; 3) Quadratically-convergent algorithm (set ALGORITHM to QC). The; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:6345,perform,performing,6345,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,4,['perform'],['performing']
Performance,"hon interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H atom:; molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:8227,perform,performing,8227,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,10,['perform'],['performing']
Performance,"hon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:16657,perform,performs,16657,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,6,['perform'],['performs']
Performance,"hon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Basis Sets¶. Basis Sets; Built-In Basis Sets; Mixing Basis Sets; Decontracted Basis Sets; User-Defined Basis Sets. PSI Variables¶; To harness the power of Python, Psi4 makes the most pertinent results; of each computation available to the Python interpreter for; post-processing. To demonstrate, we can embellish the previous example of; H2 and H a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:7026,perform,performs,7026,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['perform'],['performs']
Performance,"hon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use the command set_options(); like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function clean_options() that reinitializes; all options may also be useful to separate calculations in a PsiAPI; session. PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:6274,perform,performs,6274,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['perform'],['performs']
Performance,"hon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set {; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes.; In PsiAPI mode, one can use the command set_options(); like below for general and module-specific options. Note that these values; should be of correct type, strings for strings, floats for floats like; convergences. The function ~psi4.core.clean_options that reinitializes; all options may also be useful to separate calculations in a PsiAPI; ses",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:5946,perform,performs,5946,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['perform'],['performs']
Performance,"hould be [[orb1, orb2], [], …] for each irrep. Type: array; Default: No Default. EP_EA_POLES (OCC)¶OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC)¶OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC)¶OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI)¶DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI)¶DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT)¶SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM)¶CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF)¶CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF)¶SCF — An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS)¶GLOBALS (Expert) — Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. FAIL_ON_MAXITER (SCF)¶SCF — Fail if we reach maxiter without conv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:123614,perform,performs,123614,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['perform'],['performs']
Performance,"hould be [[orb1, orb2], [], …] for each irrep. Type: array; Default: No Default. EP_EA_POLES (OCC)¶OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC)¶OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC)¶OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI)¶DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI)¶DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT)¶SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM)¶CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF)¶CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF)¶SCF — An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS)¶GLOBALS (Expert) — Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Default: false. F_CUT (DLPNO)¶DLPNO (Expert) — Fock matrix threshold for treating",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html:123869,perform,performs,123869,psi4manual/1.5.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_glossary_options_c-1.html,3,['perform'],['performs']
Performance,"hould be [[orb1, orb2], [], …] for each irrep. Type: array; Default: No Default. EP_EA_POLES (OCC)¶OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC)¶OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC)¶OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI)¶DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI)¶DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT)¶SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM)¶CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF)¶CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXT_FORCE_BEND (OPTKING)¶OPTKING — Specify formula for external forces for angles between atoms. Type: string; Default: No Default. EXT_FORCE_CARTESIAN (OPTKING)¶OPTKING — Symmetry formula for external forces for cartesian coordinates on atoms . Type: string; Default: No Default. EXT_FORCE_DIHEDRAL (OPTKING)¶OPTKING — Specify formula for external forces for dihedral angles between atoms. Type: string; Default:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:128029,perform,performs,128029,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['perform'],['performs']
Performance,"hould be provided. Type: integer; Default: 2. GDMA_MULTIPOLE_UNITS (GDMA); GDMA — Whether to print DMA results in atomic units or SI. Type: string; Possible Values: AU; Default: AU SI. GDMA_ORIGIN (GDMA); GDMA — The origin (in Angstrom, expressed as an [x, y, z] array) about which the total multipoles will be computed during DMA. Useful for determining single site expansions at an arbitrary point. Type: array; Default: No Default. GDMA_RADIUS (GDMA); GDMA — The radii to be used, overriding the defaults. Specified as an array [ n1, r1, n2, r2, ... ] where n1,n2,n3... are atom type strings and r1,r2,r3 are radii in Angstrom. Type: array; Default: No Default. GDMA_SWITCH (GDMA); GDMA — The value to switch between the older standard DMA and the new grid-based approach. Pairs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. GEOM_MAXITER (OPTKING); OPTKING — Maximum number of geometry optimization steps. Type: integer; Default: 50. GRADIENT_WRITE (FINDIF); FINDIF — Do write a gradient output file? If so, the filename will end in .grad, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. GUESS (SCF); SCF — The type of guess orbitals. Defaults to SAD for RHF, GWH for ROHF and UHF, and READ for geometry optimizations after the first step. Type: string; Possible Values: AUTO, CORE, GWH, SAD, READ; Default: AUTO. GUESS_MIX (SCF); SCF — Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST (SCF); SCF — If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: fal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:133103,optimiz,optimization,133103,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"hreaded (pthreads);  ;  . ACPF/AQCC; RHF; CONV; —; —; threaded [3];  ; E. CISD [10]; RHF/ROHF; CONV; —; —; partially threaded;  ; E. QCISD; RHF; CONV; —; —; threaded [3];  ; E. QCISD(T); RHF; CONV; —; —; threaded [3];  ; E. CI(n); RHF/ROHF; CONV; —; —; partially threaded;  ;  . FCI; RHF/ROHF; CONV; —; —; partially threaded;  ;  . Mk-MRPT2; RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . Mk-MRCCSD; RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . Mk-MRCCSD(T); RHF/ROHF/TCSCF; CONV; —; —; threaded [3];  ;  . RAS-CI; RHF/ROHF; CONV; —; —; partially threaded;  ;  . CASSCF, RASSCF; RHF/ROHF; CONV/DF; —; —; partially threaded;  ;  . SAPT; RHF; CONV; —; —; threaded;  ;  . ADC(2); RHF; CONV; —; —; threaded [3];  ;  . EOM-CC2; RHF; CONV; —; —; threaded [3];  ;  . EOM-CCSD; RHF/UHF/ROHF; CONV; RHF/UHF/ROHF; CONV; threaded [3];  ;  . EOM-CC3; RHF/UHF/ROHF; CONV; —; —; threaded [3];  ;  . DMRG-CI; Y; CONV; —; —;  ;  ;  . DMRG-SCF; Y; CONV; —; —;  ;  ;  . Geometry optimization can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is distributed for free and without any guarantee of; reliability, accuracy, or suitability for any particular purpose. No; obligation to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries on the forum or GitHub. For bug reports,; specific and detailed information, with example inputs, would be; appreciated.; Where-to-post summary:[6]. How do I? – ask the forum; I got this error, why? – ask the forum; I got this error and I’m sure it’s a bug – file a GitHub issue; Can I open a discussion on this bit of code? – file a GitHub issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:22191,optimiz,optimization,22191,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,12,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"hrough triples with iterative quadruples (cheapest terms). ccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). ccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). ccsdt-1b; CC through doubles with iterative triples (cheaper terms). ccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). ccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). ccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). cc2; approximate CC through doubles [details]. cc3; approximate CC through triples [details]. cc4; approximate CC through quadruples. cc5; approximate CC through quintuples. cc6; approximate CC through sextuples. ccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). ccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). ccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). ccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('ccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC. 2; CC(n-1)[n]. 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a. 6; CC(n)-1b. 7; CCn. 8; CC(n)-3. table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities; Interface to MRCC by M. Kállay. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/mrcc.html:4651,optimiz,optimize,4651,psi4manual/1.7.x/mrcc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/mrcc.html,2,['optimiz'],['optimize']
Performance,"hyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. adc1; ADC/6-31G** on H2O. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dft-omega; Test omega is setable. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. cc8; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. scf6; Tests RHF/ROHF/UHF SCF gradients. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. dfccsd-t-grad1; DF-CCSD(T) cc-pVDZ gradients for the H2O molecule. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dft-grad-lr3; wB97X-D test for a large UKS molecule. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. ocepa-freq1; OCEPA cc-pVDZ freqs for C2H2. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. pywrap-db2; Database calculation, run in sow/reap mode. sad1; Test o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:10049,optimiz,optimization,10049,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"i method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number .; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; memory 512 MB. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # FRAC jobs must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do all kinds of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/dft-1.html:19546,optimiz,optimized,19546,psi4manual/4.0b2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/dft-1.html,8,['optimiz'],['optimized']
Performance,"i4'; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to get a Psi4 logo file; How to use a local Add-On repository in the Psi4 build. Installing from Binary; How to install a Psi4 binary with the Psi4conda installer, download site; How to install a Psi4 binary with the Psi4conda installer, command-line; How to install a Psi4 binary into an Ana/Miniconda distribution; How to update a Psi4 binary; How to use conda to compile Psi4 faster and easier; What do the conda packages psi4 & psi4-dev and the installer psi4conda contain; Quick Installation; Detailed Installation of Miniconda; Detailed Installation of P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/external-1.html:2903,queue,queue,2903,psi4manual/1.3.2/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/external-1.html,6,['queue'],['queue']
Performance,"i4.core.OneBodyAOInt attribute. original_coef() psi4.core.GaussianShell method. ORTH_TYPE (DFOCC). (OCC). OS_SCALE (OCC). outfile_name() in module psi4.core. output. ; cbs(). database(). geometry optimization. SAPT. vibrational analysis. overlap() psi4.core.FISAPT method. overlap_3c() psi4.core.IntegralFactory method. OVERLAP_CHECK (CCEOM). overlap_grad() psi4.core.MintsHelper method. OverlapInt class in psi4.core. owner_group psi4.driver.AtomicComputer attribute. P. p psi4.core.AOShellCombinationsIterator attribute. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parent_atom() psi4.core.BlockOPoints method. PARENT_SYMMETRY (GLOBALS). ParsingError. partial_cholesky_factorize() psi4.core.Matrix method. partition() psi4.core.FISAPT method. PastureRequiredError. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32]. PBS queueing system. PCG_BETA_TYPE (DFOCC). (OCC). PCG_CONVERGENCE (DFOCC). (OCC). PCG_MAXITER (DFOCC). (OCC). PCM, [1]. Using PCM. PCM (GLOBALS). PCM POLARIZATION ENERGY. PCM_CC_TYPE (PCM). PCM_enabled() psi4.core.Wavefunction method. pcm_helper() in module psi4.driver. in module psi4.driver.p4util. PCM_SCF_TYPE (PCM). PCMSolver. PCMSOLVER_PARSED_FNAME (PCM). PE. Using PE. PE (GLOBALS). PE ENERGY. PE_ECP (PE). PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). perturb_grad() psi4.core.MintsHelper method. PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method. psi4.core.SOBasisSet method. petite_list1() psi4.core.MintsHelper method. PetiteList class in psi4.core. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() psi4.core.CIWavefunction method. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method. PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). plan() psi4.driver.AtomicComputer me",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:86317,queue,queueing,86317,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['queue'],['queueing']
Performance,"i4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_amplitudes(self: psi4.core.CCWavefunction) → Dict[str, psi4.core.Matrix]¶; Get dict of converged T amplitudes. Returns. amps (dict (spacestr, SharedMatrix)) – spacestr is a description of the amplitude set using the following conventions. I,J,K -> alpha occupied; i,j,k -> beta occupied; A,B,C -> alpha virtual; a,b,c -> beta virtual. The following entries are stored in the amps, depending on the reference type; RHF (tIA, tIjAb); UHF (tIA, tia, tIjAb, tIJAB, tijab); ROHF (tIA, tia, tIjAb, tIJAB, tijab). Examples; RHF T1 diagnostic = sqrt(sum_ia (T_ia * T_ia)/nelec); >>> mol = “””; … 0 1; … Ne 0.0 0.0 0.0; … symmetry c1”””; >>> e, wfn = psi4.energy(“CCSD/cc-pvdz”, return_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html:15331,load,load,15331,psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.ccwavefunction.html,1,['load'],['load']
Performance,"i4.core.Vector¶; Returns the requested Beta Eigenvalues subset. esp_at_nuclei(self: psi4.core.Wavefunction) → psi4.core.Vector¶; returns electrostatic potentials at nuclei. external_pot(self: psi4.core.Wavefunction) → psi4.core.ExternalPotential¶; Gets the requested external potential. force_doccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of doubly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. force_soccpi(self: psi4.core.Wavefunction, arg0: psi4.core.Dimension) → None¶; Specialized expert use only. Sets the number of singly occupied oribtals per irrep. Note that this results in inconsistent Wavefunction objects for SCF, so caution is advised. frequencies()¶. static from_file(wfn_data)¶; Build Wavefunction from data. Parameters; wfn_data (Union[str, Dict, Path]) – If a dict, use data directly. Otherwise, path-like passed to numpy.load(); to read from disk. Returns; A deserialized Wavefunction object. Return type; Wavefunction. frzcpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen core orbitals per irrep. frzvpi(self: psi4.core.Wavefunction) → psi4.core.Dimension¶; Returns the number of frozen virtual orbitals per irrep. get_array(key)¶. Deprecated since version 1.4: Use psi4.core.Wavefunction.variable() instead. get_basisset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.BasisSet¶; Returns the requested auxiliary basis. get_dipole_field_strength(self: psi4.core.Wavefunction) → List[float[3]]¶; Returns a vector of length 3, containing the x, y, and z dipole field strengths. get_print(self: psi4.core.Wavefunction) → int¶; Get the print level of the Wavefunction. get_scratch_filename(filenumber)¶; Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read. get_variable(key)¶. Deprecated since version 1.4: Use psi4.core.Wav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html:15518,load,load,15518,psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.dfep2wavefunction.html,3,['load'],['load']
Performance,"i4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; psi4.set_global_option('E_CONVERGENCE', 8). # Select certain irreps; if 'irrep' in kwargs:; irrep = parse_cotton_irreps(kwargs['irrep']) - 1 # externally, A1 irrep is 1, internally 0; else:; irrep = -1 # -1 implies do all irreps. # Does an analytic procedure exist for the requested method?; if (dertype == 2):; # We have the desired method. Do it.; procedures['hessian'][lowername](lowername, **kwargs); optstash.restore(). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Frequency execution mode \'sow\' not valid for analytic frequency calculation.'). # TODO: check that current energy's being set to the right figure when this code is actually used; psi4.set_variable('CURRENT ENERGY', psi4.wavefunction().energy()). # TODO: return hessian matrix. elif (dertype == 1):; # Ok, we're doing frequencies by gradients; print('Performing finite difference by gradient calculations'). func = procedures['gradient'][lowername]. if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Frequency execution mode \'sow\' not yet implemented for finite difference of analytic gradient calculation.'). # Obtain list of displacements; displacements = psi4.fd_geoms_freq_1(irrep). molecule.reinterpret_coordentry(False); molecule.fix_orientation(True); # Make a note of the undisplaced molecule's symmetry; psi4.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print(' %d displacements needed.' % ndisp). #print displacements to output.dat; #for n, displacement in enumerate(displacements):; # displacement.print_out();. gradients = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:62605,Perform,Performing,62605,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Perform'],['Performing']
Performance,"i4.set_global_option('PUREAM', psi4.MintsHelper().basisset().has_puream()). # broken set-up; if do_broken:; molecule.set_multiplicity(3); psi4.print_out('\n'); p4util.banner(' Computing high-spin triplet guess '); psi4.print_out('\n'). # cast set-up; if (cast):. if yes.match(str(cast)):; guessbasis = '3-21G'; else:; guessbasis = cast. if (castdf):; if yes.match(str(castdf)):; guessbasisdf = p4util.corresponding_jkfit(guessbasis); else:; guessbasisdf = castdf. # Switch to the guess namespace; namespace = psi4.IO.get_default_namespace(); psi4.IO.set_default_namespace((namespace + '.guess')). # Setup initial SCF; psi4.set_global_option('BASIS', guessbasis); if (castdf):; psi4.set_local_option('SCF', 'SCF_TYPE', 'DF'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'none'); psi4.set_global_option('DF_BASIS_SCF', guessbasisdf). # Print some info about the guess; psi4.print_out('\n'); p4util.banner('Guess SCF, %s Basis' % (guessbasis)); psi4.print_out('\n'). # the FIRST scf call; if cast or do_broken:; # Perform the guess scf; psi4.scf(). # broken clean-up; if do_broken:; molecule.set_multiplicity(1); psi4.set_local_option('SCF', 'GUESS', 'READ'); psi4.print_out('\n'); p4util.banner(' Computing broken symmetry solution from high-spin triplet guess '); psi4.print_out('\n'). # cast clean-up; if (cast):. # Move files to proper namespace; psi4.IO.change_file_namespace(180, (namespace + '.guess'), namespace); psi4.IO.set_default_namespace(namespace). # Set to read and project, and reset bases to final ones; optstash2.restore(); psi4.set_local_option('SCF', 'GUESS', 'READ'). # Print the banner for the standard operation; psi4.print_out('\n'); p4util.banner(name.upper()); psi4.print_out('\n'). # the SECOND scf call; e_scf = psi4.scf(precallback, postcallback). optstash.restore(); return e_scf. [docs]def run_mp2_select(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing toward the OCC (conv MP2) or the DFMP2 modules. """"""; if (psi4.get_option(""DF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:19417,Perform,Perform,19417,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,1,['Perform'],['Perform']
Performance,"i4/lib/python/aliases.py; (source location) or psi4/share/psi/python/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. sherrill_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). allen_focal_point(name='mp2', **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). Table Of Contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. Previous topic; BAKERJCC96; Next topic; <no title>; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:15661,perform,performed,15661,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,6,"['optimiz', 'perform']","['optimization', 'optimize', 'performed']"
Performance,"i4/psi4/include/psi4/masses.h. See freq-isotope2 for about; the only use to which isotopologues can presently be put in PSI4. PubChem Database¶; Obtaining rough starting guess geometries can be burdensome. The Z-matrix; coordinate system was designed to provide chemists with an intuitive method for; guessing structures in terms of bond lengths and angles. While Z-matrix input is; intuitive for small molecules with few degrees of freedom, it quickly becomes; laborious as the system size grows. To obtain a reasonable starting guess; geometry, PSI4 can take a chemical name as input; this is then used; to attempt to retrieve Cartesian coordinates from the [PubChem] database.; For example, to run a computation on benzene, we can use the following molecule specification:; molecule benzene {; pubchem:benzene; }. If the computer is connected to the internet, the above code will instruct; PSI4 to search PubChem for a starting structure. The search is actually; performed for compounds whose name contains “benzene”, so multiple; entries will be returned. If the name provided (“benzene” in the above; example) exactly matches one of the results, that entry will be used. If no; exact match is found the results, along with a unique chemical identifier; (CID), are printed to the output file, prompting the user to provide a more; specific name. For example, if we know that we want to run a computation on a; compound whose name(s) contain “benzene”, but we’re not sure of the exact IUPAC; name, the following input can be used:; molecule benzene {; pubchem:benzene*; }. Appending the “*” prevents an exact match from being found and, at the time; of writing, the following results are displayed in the output file:; Chemical ID IUPAC Name; 241 benzene; 7371 benzenesulfonic acid; 91526 benzenesulfonate; 244 phenylmethanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 ben",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:7973,perform,performed,7973,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['perform'],['performed']
Performance,"i4/share/python/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = psi4.get_variable('SCF TOTAL ENERGY'); ce_mp2 = psi4.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = psi4.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; psi4.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; psi4.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; psi4.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); psi4.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""psi4.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); psi4.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 method",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html:2462,optimiz,optimizer,2462,psi4manual/1.0.0/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/quickaddalias-1.html,2,['optimiz'],['optimizer']
Performance,"i4rc File. Note; For developers: during compilation and testing, PSI4 finds its basis sets,; grids, etc., in psi4/lib. After installation, PSI4 will look in; $prefix/share/psi. If you want to specify a non-standard location for this; information, you can do this by setting the environmental variable; $PSI4DATADIR to the directory containg the basis, grids, etc.,; subdirectories. IV. Recommendations for BLAS and LAPACK libraries¶; Much of the speed and efficiency of the PSI4 programs depends on the; corresponding speed and efficiency of the available BLAS and LAPACK libraries; (especially the former). In addition, the most common compilation problems; involve these libraries. Users may therefore wish to consider the following; BLAS and LAPACK recommendations when building PSI4:. It is NOT wise to use the stock BLAS library provided with many; Linux distributions like RedHat. This library is usually just the; netlib distribution and is completely unoptimized. PSI4’s; performance will suffer if you choose this route.; The choice of LAPACK is less critical, and so the unoptimized; netlib distribution is acceptable. If you do choose to use the; RedHat/Fedora stock BLAS and LAPACK, make sure that the blas-devel; and lapack-devel packages are installed. Perhaps the best choice, if you have it available, is; Intel’s MKL library, which includes BLAS and LAPACK (note: use; version 11 or later, we had difficulty with version 10 for very; large coupled-cluster computations). MKL is efficient and works; well in threaded mode.; Otherwise, the simplest choice is to use ATLAS; (http://math-atlas.sourceforge.net/), which is readily available; on all Linux distributions. Another alternative is OpenBLAS; (https://github.com/xianyi/OpenBLAS, formerly GotoBLAS). These; work well on nearly every achitecture to which the PSI4 developers; have access, though we have identified at least one case in which; the Goto libraries yielded faulty DGEMM calls. On Mac OS X; systems, the vecLib packag",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/installfile.html:20911,perform,performance,20911,psi4manual/4.0b3/installfile.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/installfile.html,3,['perform'],['performance']
Performance,"iException.__init__(self, msg); core.print_out('\nPsiException: %s\n\n' % (msg)). [docs]class ConvergenceError(PsiException):; """"""Error called for problems with converging an iterative method. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF, optimization).; iteration; Iteration number on which routine failed.; additional_info; Any additional message to convey. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed. """"""; message: str; iteration: int. def __init__(self, eqn_description: str, iteration: int, additional_info: Optional[str] = None):; msg = f""Could not converge {eqn_description:s} in {iteration:d} iterations.""; if additional_info is not None:; msg += f""\n\n{additional_info}""; PsiException.__init__(self, msg); self.iteration = iteration; self.message = msg; core.print_out(f'\nPsiException: {msg:s}\n\n'). [docs]class OptimizationConvergenceError(ConvergenceError):; """"""Error called for problems with geometry optimizer. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., geometry optimization).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. Attributes; ----------; message; Human readable string describing the exception.; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception. """"""; message: str; iteration: int; wfn: core.Wavefunction. def __init__(self, eqn_description: str, iteration: int, wfn: core.Wavefunction):; ConvergenceError.__init__(self, eqn_description, iteration); self.wfn = wfn. [docs]class SCFConvergenceError(ConvergenceError):; """"""Error called for problems with SCF iterations. Parameters; ----------; eqn_description; Type of QC routine that has failed (e.g., SCF preiterations).; iteration; Iteration number on which routine failed.; wfn; Wavefunction at time of exception.; e_conv; Change in energy for last iteration.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html:5889,optimiz,optimizer,5889,psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/exceptions.html,3,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimizer']"
Performance,"i_{i}^1 \phi_{j}^1; \frac{\mathrm{erf}(\omega r_{12})}{r_{12}} \phi_{i}^2 \phi_{j}^2 \ \mathrm{d}^3 r_1 \ \mathrm{d}^3 r_2\]; For LRC functionals, the choice of range-separation parameter \(\omega\) has; been the subject of considerable activity since the inception of LRC; functionals. Some authors advocate a static range-separation parameter; determined by optimization over a test set of chemical systems. However, a more; physically-motivated and often more accurate approach is the idea of “gap; fitting” or “optimal tuning” or simply “tuning.” The most popular tuned-LRC; approach is IP-fitting, in which the \(\omega\) is varied until the; Koopman’s IP (the opposite of the HOMO energy) matches the true IP (the; difference between \(N-1\)-electron and \(N\)-electron total; energies), within the LRC functional ansatz. This guarantees the asymptotics of; the exchange potential,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{tuned-LRC}} (r) = -; \frac{1}{r} + I_{\mathrm{IP}} +; \epsilon_{\mathrm{HOMO}}\]; Note that LRC functionals with default \(\omega\) only capture the; \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{LRC}} (r) = -; \frac{1}{r},\]; hybrid functionals only capture part of the \(-1/r\) dependence,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Hybrid}} (r) = -; \frac{\alpha}{r},\]; and local functionals decay exponentially, resulting in completely incorrect; asymptotics,. \[\lim_{r\rightarrow\infty} v_{\mathrm{x}}^{\mathrm{Local}} (r) = 0\]; IP-tuned LRC functionals effectively pin the chemical potential at \(N\); electrons to the correct value determined by the ionization potential. This; often cleans up the MSIE problem for a surprisingly large number of high-lying; occupied orbitals, as determined by fractional particle curves. Other gap; fitting techniques involving the electron affinity or band gap are sometimes; also used. IP-fitting is found to be particularly critical for the qualitative; determination of exc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dft-1.html:10906,tune,tuned-LRC,10906,psi4manual/1.2.1/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dft-1.html,15,['tune'],['tuned-LRC']
Performance,"iable('NUCLEAR REPULSION ENERGY', molecule.nuclear_repulsion_energy()); if re.match(r'^verify', lowername):; compare_values(DATA['NUCLEAR REPULSION ENERGY'][rgt], psi4.get_variable('NUCLEAR REPULSION ENERGY'),; 4, '%s %.4f' % (rgt, psi4.get_variable('NUCLEAR REPULSION ENERGY'))); ERGT[rgt] = 7.0; else:; ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; psi4.print_variables(); exec(actives); for envv in db_tabulate:; VRGT[rgt][envv.upper()] = psi4.get_variable(envv); psi4.set_global_option(""REFERENCE"", user_reference); psi4.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(p4util.format_molecule_for_input(GEOS[rgt])). freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""psi4.print_variables()\n""""""); freagent.write(""""""psi4.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""psi4.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""psi4.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (psi4.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv.upper()] = 0.0; exec(banners); exec(actives); try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; psi4.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); psi4.p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:45106,load,loads,45106,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['load'],['loads']
Performance,"iables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; 1; 2; 3; 4basis_sets = [""cc-pVDZ"", ""cc-pVTZ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:10941,optimiz,optimize,10941,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['optimiz'],['optimize']
Performance,"ialInt attribute, [1]. psi4.core.PseudospectralInt attribute, [1]. psi4.core.QuadrupoleInt attribute, [1]. psi4.core.TracelessQuadrupoleInt attribute, [1]. original_coef() psi4.core.GaussianShell method, [1], [2]. ORTH_TYPE (DFOCC). (OCC). outfile_name() in module psi4.core, [1]. output. ; SAPT. cbs(). database(). geometry optimization. vibrational analysis. overlap_3c() psi4.core.IntegralFactory method, [1], [2]. OVERLAP_CHECK (CCEOM). OverlapInt class in psi4.core, [1]. P. p psi4.core.AOShellCombinationsIterator attribute, [1], [2]. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. ParsingError. partial_cholesky_factorize() psi4.core.Matrix method, [1], [2]. pasture_required_modules psi4.driver.PastureRequiredError attribute. PastureRequiredError. PATH, [1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12], [13], [14], [15], [16], [17], [18], [19], [20], [21], [22], [23], [24], [25], [26], [27], [28], [29], [30], [31], [32], [33], [34]. PBS queueing system. PCG_BETA_TYPE (DFOCC). (OCC). PCG_CONVERGENCE (DFOCC). (OCC). PCG_MAXITER (DFOCC). (OCC). PCM. Using PCM. PCM (GLOBALS). PCM_CC_TYPE (GLOBALS). pcm_helper() in module psi4.driver. PCM_SCF_TYPE (GLOBALS). PCMSolver. PEP1. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_DIPOLE (SCF). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). petite_list() psi4.core.MintsHelper method, [1], [2]. psi4.core.SOBasisSet method, [1], [2]. petite_list1() psi4.core.MintsHelper method, [1], [2]. PetiteList class in psi4.core, [1]. PHI_POINTS (SCF). physconst. physical constants. pitzer_to_ci_order_onel() psi4.core.CIWavefunction method, [1], [2]. pitzer_to_ci_order_twoel() psi4.core.CIWavefunction method, [1], [2]. PK_ALGO (SCF). PK_ALL_NONSYM (SCF). PK_MAX_BUCKETS (SCF). PK_NO_INCORE (SCF). play() psi4.core.MintsHelper method, [1], [2]. plugin() in module psi4.core, [1]. plugin_close() in module psi4.core, [1]. plugin_close_all() in module psi4.core, [1]. pl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:73513,queue,queueing,73513,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['queue'],['queueing']
Performance,"ical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:1133,optimiz,optimized,1133,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['optimiz'],['optimized']
Performance,"ical Methods: SCF to FCI ». OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:1133,optimiz,optimized,1133,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['optimiz'],['optimized']
Performance,"ical points in LS-THC grid. Type: integer; Default: 50. MAX_RADIAL_MOMENT¶. Maximum Radial Moment to Calculate. Type: integer; Default: 4. MBIS_D_CONVERGENCE¶. MBIS Convergence Criteria. Type: conv double; Default: 1.0e-8. MBIS_MAXITER¶. Maximum Number of MBIS Iterations. Type: integer; Default: 500. MBIS_PRUNING_SCHEME¶. Pruning scheme for MBIS Grid. Type: string; Default: ROBUST. MBIS_RADIAL_POINTS¶. MBIS Number of Radial Points. Type: integer; Default: 75. MBIS_SPHERICAL_POINTS¶. MBIS Number of Spherical Points. Type: integer; Default: 302. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MP2_TYPE¶. Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE¶. Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Since v1.4, default for non-orbital-optimized MP2.5 and MP3 is DF. Type: string; Possible Values: DF, CONV, CD; Default: CONV. NUM_FROZEN_DOCC¶. The number of core orbitals to freeze in later correlated computations. This trumps FREEZE_CORE. Type: integer; Default: 0. NUM_FROZEN_UOCC¶. The number of virtual orbitals to freeze in later correlated computations. Type: integer; Default: 0. PCM¶. PCM boolean for pcmsolver module. Type: boolean; Default: false. PE¶. PE boolean for polarizable embedding module. Type: boolean; Default: false. PRINT¶. The amount of information to print to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PRINT_NOONS¶. How many NOONS to print – used in libscf_solver/uhf.cc and libmints/oeprop.cc. Type: string; Default: 3. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__globals.html:6541,optimiz,optimized,6541,psi4manual/master/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__globals.html,2,['optimiz'],['optimized']
Performance,"ical rotation of H2O2. gauge = both, omega = (589 355 nm). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cbs-delta-energy; Extrapolated energies with delta correction. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mints15; check SP basis Fortran exponent parsing. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. fci-coverage; 6-31G H2O Test for coverage. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:9377,optimiz,optimization,9377,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. [1]; FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CASCI, in which a full CI is performed in some smaller; set of active orbitals; it is equivalent to CASSCF except without; any orbital optimization. It can be invoked via energy('fci'); with appropriate values selected for FROZEN_DOCC and; ACTIVE. For CI computations, there is no difference between; FROZEN_DOCC and RESTRICTED_DOCC, or between; FROZEN_UOCC and RESTRICTED_UOCC. There are; differences between these keywords for MCSCF: Multi-Configurational Self-Consistent-Field. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/detci.html:6437,perform,performed,6437,psi4manual/1.7.x/detci.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/detci.html,8,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"ich automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Psithon: Structuring an Input File. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:14657,perform,perform,14657,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,2,['perform'],['perform']
Performance,"ich automatically computes a complete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. cbs('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; either be called directly, as in the first example, or the convenience; syntax of the equivalent second example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Psithon: Structuring an Input File. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psithoninput-1.html:14657,perform,perform,14657,psi4manual/1.5.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psithoninput-1.html,2,['perform'],['perform']
Performance,"ich connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; 1; 2; 3; 4; 5; 6; 7molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set ba",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:3097,optimiz,optimization,3097,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,2,['optimiz'],['optimization']
Performance,"ich connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:3149,optimiz,optimization,3149,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,6,['optimiz'],['optimization']
Performance,"ich connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; 1; 2; 3; 4; 5; 6; 7molecule h2o {; O; H 1 1.0; H 1 1.0 2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/optking-1.html:3099,optimiz,optimization,3099,psi4manual/1.2.1/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/optking-1.html,4,['optimiz'],['optimization']
Performance,"ich connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:3120,optimiz,optimization,3120,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimization']
Performance,"ich is; freely available through conda, is the only threaded BLAS/LAPACK; distribution fully supported by PSI4.; On Mac, the native Accelerate libraries are very nice and would; be recommended but for the potential conflict between PSI4; BLAS and NumPy BLAS. Unless you’ve a special NumPy, avoid!; The open-source LAPACK distributions OpenBLAS (formerly GotoBLAS); mostly works. Use it at your own risk and after testing your; particular distribution, including tests run multithreaded,; if you intend to run PSI4 so. Use at least 0.2.15, and; pay attention to how it was compiled - unthreaded seems safe,; openmp-threaded is mostly safe, default pthreaded is not safe. See; https://github.com/psi4/psi4/issues/1009 for recent analysis.; Another open-source LAPACK distribution, ATLAS had; stability issues with the DFOCC module at last testing,; https://github.com/psi4/psi4/issues/391.; ACML libraries are known to work with PSI4 v1.1 at ACML 6. Because of how link loaders work, at runtime, the BLAS of PSI4; and the BLAS of NumPy are not independent. There can be unpredictable; but reproducible numerical and thread-scaling errors if PSI4; and NumPy BLAS don’t match down to the library name (that is,; libmkl_rt, libmkl_core.so, libmkl_core.a are not; interchangeable). See https://github.com/psi4/psi4/issues/1007,; https://github.com/psi4/psi4/issues/748,; https://github.com/psi4/psi4/issues/755 for gory discussions.; Choose your NumPy and PSI4 compile conditions to use the same; BLAS distribution.; The BLAS/LAPACK detected for PSI4 are also linked into any; Add-Ons (e.g., libefp) that require them, rather than relying on; those packages’ native math detection.; The separation between BLAS and LAPACK seen in detection printing; and CMake variables is purely formal. In practice, they get run; together and linked as ${LAPACK_LIBRARIES} ${BLAS_LIBRARIES}.; Sometimes the CMake’s library search capabilites falter at SONAMEs; (e.g., libblas.so.3 vs. libblas.so), extensions (static; vs. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:39014,load,loaders,39014,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,13,['load'],['loaders']
Performance,"ict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). cor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:58443,optimiz,optimizer,58443,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimizer']
Performance,"icted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:5557,optimiz,optimizer,5557,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,6,['optimiz'],['optimizer']
Performance,"iction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. OCEPA. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:3011,optimiz,optimized,3011,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,4,['optimiz'],['optimized']
Performance,"iction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will solve this N-representability problem by disregarding orbital response contribution of one-partical; density matrix.; Although the performance of coupled-cluster singles and doubles (CCSD) and orbital-optimized; CCD (OD) is similar, the situation is different in the case of triples corrections, especially at stretched; geometries [Bozkaya:2012:odtl]. Bozkaya and Schaefer demonstrated that orbital-optimized coupled cluster based; triple corrections, especially those of asymmetrics, provide significantly better potential energy curves than; CCSD based triples corrections. Theory¶; What follows is a very basic description of orbital-optimized Møller–Plesset perturbation; theory as implemented in PSI4. We will follow our previous presentations ([Bozkaya:2011:omp2],; [Bozkaya:2011:omp3], and [Bozkaya:2012:odtl]); The orbital variations may be expressed by means of an exponential unitary operator. where is the orbital rotation operator. The effect of the orbital rotations on the MO coefficients can be written as. where is the initial MO coefficient matrix and is the new; MO coefficient matrix as a function of .; Now, let us define a variational energy functional (Lagrangian) as a function of . OMP2. OMP3. where , , and defined as. and first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:3009,optimiz,optimized,3009,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['optimiz'],['optimized']
Performance,"ided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Compute the hessian; H, wfn = hessian(name, return_wfn=True, molecule=molecule, **kwargs). # Project final frequencies?; translations_projection_sound, rotations_projection_sound = _energy_is_invariant(wfn.gradient()); project_trans = kwargs.get('project_trans', translations_projection_sound); project_rot = kwargs.get('project_rot', rotations_projection_sound). irrep = kwargs.get('irrep', None); vibinfo = vibanal_wfn(wfn, irrep=irrep, project_trans=project_trans, project_rot=project_rot); wfn.frequency_analysis = vibinfo. for postcallback in hooks['frequency']['post']:; postcallback(lowername, wfn=wfn, **kwargs). if return_wfn:; return (core.variable('CURRENT ENERGY'), wfn); else:; return core.variable('CURRENT ENERGY'). [docs]def vibanal_wfn(wfn: core.Wavefunction, hess: np.ndarray = None, irrep: Union[int, str] = None, molecule=None, project_trans: bool = True, project_rot: bool = True):; """"""Function to perform analysis of a hessian or hessian block, specifically...; calling for and printing vibrational and thermochemical analysis, setting thermochemical variables,; and writing the vibrec and normal mode files. Parameters; ----------; wfn; The wavefunction which had its Hessian computed.; hess; Hessian to analyze, if not the hessian in wfn.; (3*nat, 3*nat) non-mass-weighted Hessian in atomic units, [Eh/a0/a0].; irrep; The irrep for which frequencies are calculated. Thermochemical analysis is skipped if this is given,; as only one symmetry block of the hessian has been computed.; molecule : :py:class:`~psi4.core.Molecule` or qcdb.Molecule, optional; The molecule to pull information from, if not the molecule in wfn. Must at least have similar; geometry to the molecule in wfn.; project_trans; Should translations be projected in the harmonic analysis?; project_rot; Should rotations be projected in the harmonic analysis?. Returns; -------; vibinfo : dict",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:86578,perform,perform,86578,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['perform'],['perform']
Performance,"iding; the transformation of the four-index virtual two-electron integrals; and computing the terms that involve these integrals in the AO; basis. In order to do that one needs to set the AO_BASIS option to; DISK. For more recommendations on the choice of the algorithm see; Recommendations section. Analytic Gradients¶; Analytic gradients are available for the DC-06 method. Gradients are only; available if the ALGORITHM option is set to TWOSTEP or SIMULTANEOUS for; the energy computation. Evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/dcft-1.html:9846,perform,perform,9846,psi4manual/4.0b5/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/dcft-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"ied or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:22817,perform,performance,22817,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['perform'],['performance']
Performance,"ied or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t__gradient(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only ccenergy. func = None; if reference in ['RHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_t__gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_at_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(AT) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:22698,perform,performance,22698,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,8,['perform'],['performance']
Performance,"ields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simply use “reference rohf” option. For DFT orbitals one should use “reference uks” and “dft_functional b3lyp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; Psi4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through ‘type select’ values; see rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:6224,optimiz,optimized,6224,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimized']
Performance,"ient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'.; format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()); _hessian_write(wfn). if return_wfn:; return (wfn.hessian(), wfn); else:; return wfn.hessian(). elif dertype == 1:; core.print_out(""""""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = core.fd_geoms_freq_1(moleculeclone, irrep); moleculeclone.reinterpret_coordentry(False); moleculeclone.fix_orientation(True). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements); print("""""" %d displacements needed."""""" % ndisp); gradients = []; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if freq_mode == 'sow':; instructionsO = """"""\n# The frequency sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """"""# to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """"""# has produced a number of input files (FREQ-*.in) for individual components\n""""""; instr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:71212,perform,perform,71212,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"ient = G, **kwargs); steps_since_last_hessian = 0; core.set_legacy_gradient(G); core.set_global_option('CART_HESS_READ', True); elif (full_hess_every == -1) and core.get_global_option('CART_HESS_READ') and (n == 1):; pass; # Do nothing; user said to read existing hessian once; else:; core.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:72230,optimiz,optimization,72230,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,8,['optimiz'],['optimization']
Performance,"ient in the presence of a dipole field. cbs-xtpl-func; optimization with method defined via cbs. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. mints-helper; A general test of the MintsHelper function. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf7; Tests SCF gradient in the presence of a dipole field. cc13c; Tests RHF CCSD(T)gradients. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. scf3; File retention, docc, socc, and bond distances specified explicitly. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure updated reference due to new BraggSlater radii. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:25795,perform,performed,25795,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"ient of 1-1B2 state of H2O with EOM-CCSD. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). fci-h2o; 6-31G H2O Test FCI Energy Point. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. opt-multi-dimer-c2h; Multi-fragment opt of C2h methane dimer with user-combined reference points. fd-freq-energy; SCF STO-3G finite-difference frequencies from energies. cc30; CCSD/sto-3g optical",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:18323,optimiz,optimizations,18323,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimizations']
Performance,"ient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; —; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCSD(T); Y; Y [1]; RHF/ROHF/UHF; threaded (pthreads). CC3; Y; —; RHF/ROHF/UHF; threaded (pthreads). EOM-CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. Mk-MRCCSD; Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRCCSD(T); Y; N; RHF/ROHF/TCSCF; threaded [3]. Mk-MRPT2; Y; N; RHF/ROHF/TCSCF; threaded [3]. Geometry optimization (currently restricted to true minima on the potential; energy surface) can be performed using either analytic gradients; or energy points. Likewise, vibrational frequencies can be; computed by analytic second derivatives, by finite; differences of analytic gradients, or by finite differences of energies.; PSI4 can also compute an extensive list of one-electron properties. Technical Support¶; The PSI4 package is; distributed for free and without any guarantee of reliability,; accuracy, or suitability for any particular purpose. No obligation; to provide technical support is expressed or implied. As time; allows, the developers will attempt to answer inquiries directed to; crawdad@vt.edu.; For bug reports, specific and detailed information, with example; inputs, would be appreciated. Questions or comments regarding; this user’s manual may be sent to; sherrill@gatech.edu.; Footnotes. [1]UHF-CCSD(T) gradients only, as of beta2. [2]RHF reference only. DF-MP2 is recommended as a faster alternative. [3](1, 2, 3, 4, 5, 6, 7, 8) threading through BLAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/introduction-1.html:8406,optimiz,optimization,8406,psi4manual/4.0b2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html,4,"['optimiz', 'perform']","['optimization', 'performed']"
Performance,"ies and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3.95e-05 * 3.35e-05 o 1.37e-04 * 1.05e-04 o ~. The full list of keywords for optking is provided in Appendix OPTKING.; Information on the Psithon function that drives geometry optimizations is provided; at optimize(). Important User Changes from cpp-optking¶. FIXED_COORD keywords have been generalized to RANGED_COORD e.g. RANGED_DISTANCE; Detailed optimization is now printed through the python logging system. If more information about; the optimization is needed. Please see <output_name>.log. table of contents. Geometry Optimization; Basic Keywords; OPT_TYPE; STEP_TYPE; GEOM_MAXITER; G_CONVERGENCE; FULL_HESS_EVERY. Optimizing Minima; Hessian; Transition States and Reaction Paths; Constrained Optimizations; Multi-Fragment Optimizations; Dealing with problematic optimizations; Convergence Criteria; Interface to GeomeTRIC; Output; Important User Changes from cpp-optking. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; Geometry Optimization. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:25433,optimiz,optimization,25433,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,3,['optimiz'],"['optimization', 'optimizations']"
Performance,"ies=['rotation']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. properties = kwargs.get('properties', ['dipole', 'quadrupole']); kwargs['properties'] = p4util.drop_duplicates(properties). optstash = driver_util._set_convergence_criterion('property', lowername, 6, 10, 6, 10, 8); wfn = procedures['property'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`fun",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:49246,optimiz,optimized,49246,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['optimiz'],['optimized']
Performance,"ies=['rotation']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. properties = kwargs.get('properties', ['dipole', 'quadrupole']); kwargs['properties'] = p4util.drop_duplicates(properties). optstash = driver_util._set_convergence_criterion('property', lowername, 6, 10, 6, 10, 8); wfn = procedures['property'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (psi4.get_variable('CURRENT ENERGY'), wfn); else:; return psi4.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. I",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:47910,optimiz,optimized,47910,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['optimiz'],['optimized']
Performance,"ies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) or LSDA density functional theory (DFT)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html:1147,perform,performs,1147,psi4manual/1.7.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.frequencies.html,8,['perform'],['performs']
Performance,"if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (function",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:1783,perform,performs,1783,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,25,['perform'],['performs']
Performance,"if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """"""; import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMM() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator to ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html:1971,optimiz,optimization,1971,psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/mdi_engine.html,4,['optimiz'],['optimization']
Performance,"if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""Support for using Psi4 as an MDI engine.; For details regarding MDI, see https://molssi.github.io/MDI_Library/html/index.html. """"""; import numpy as np; import qcelemental as qcel. import psi4. _have_mdi = False; try:; from mdi import MDI_Init, MDI_MPI_get_world_comm, MDI_Accept_Communicator, \; MDI_Send, MDI_Recv, MDI_Recv_Command, MDI_INT, MDI_DOUBLE, \; MDI_Register_Node, MDI_Register_Command; _have_mdi = True; except ImportError:; pass. try:; from mpi4py import MPI; use_mpi4py = True; except ImportError:; use_mpi4py = False. class MDIEngine():; def __init__(self, scf_method, **kwargs):; """""" Initialize an MDIEngine object for communication with MDI. Arguments:; scf_method: Method used when calculating energies or gradients; """""". # Method used when the SCF command is received; self.scf_method = scf_method. # Additional arguments for energy, gradient, or optimization calculations; self.kwargs = kwargs. # Molecule all MDI operations are performed on; input_molecule = kwargs.pop('molecule', psi4.core.get_active_molecule()); self.molecule = input_molecule.clone(); psi4.core.set_active_molecule(self.molecule). # Most recent SCF energy; self.energy = 0.0. # Variables used when MDI sets a lattice of point charges; self.nlattice = 0 # number of lattice point charges; self.clattice = [] # list of lattice coordinates; self.lattice = [] # list of lattice charges; self.lattice_field = psi4.QMMMbohr() # Psi4 chargefield. # MPI variables; self.mpi_world = None; self.world_rank = 0. # Flag for if a lattice of point charges has been set; self.set_lattice = False. # Get correct intra-code MPI communicator; if use_mpi4py:; self.mpi_world = MDI_MPI_get_world_comm(); self.world_rank = self.mpi_world.Get_rank(). # Psi4 does not currently support multiple MPI ranks; if self.mpi_world.Get_size() != 1:; MPI.COMM_WORLD.Abort(). # Accept a communicator",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html:1971,optimiz,optimization,1971,psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/mdi_engine.html,2,['optimiz'],['optimization']
Performance,"if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; 1; 2; 3; 4F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; 1; 2; 3; 4F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria ava",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:10844,optimiz,optimize,10844,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimize']
Performance,"if symbol[p] == 'F':; d = 1.287; if symbol[p] == 'Ne':; d = 1.243; if symbol[p] == 'Na':; d = 1.144; if symbol[p] == 'Mg':; d = 1.364; if symbol[p] == 'Al':; d = 1.639; if symbol[p] == 'Si':; d = 1.716; if symbol[p] == 'P':; d = 1.705; if symbol[p] == 'S':; d = 1.683; if symbol[p] == 'Cl':; d = 1.639; if symbol[p] == 'Ar':; d = 1.595; ; return d / 1.5. #Automatically detect fragments and build a new molecule for fragment; #needing methods (SAPT0, etc...); [docs]def auto_fragments(name, **kwargs):; r""""""; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. usage: auto_fragments(''); """"""; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); ; geom = molecule.save_string_xyz(). numatoms = molecule.natom(); VdW = [1.2, 1.7, 1.5, 1.55, 1.52, 1.9, 1.85, 1.8]; ; symbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:2218,Queue,Queue,2218,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Queue'],['Queue']
Performance,"if verbose:; print(""""""%d systems in %s for %s vs. %s, subset %s.\n%s"""""" %; (len(err), self.dbse, modelchem, benchmark, sset, format_errors(error, mode=2))); if returnindiv:; return error, err; else:; return error. [docs] def load_qcdata(self, modname, funcname, pythonpath=None, failoninc=True):; """"""Loads qcdb.ReactionDatums from module *modname* function; *funcname*. Module search path can be prepended with *pythonpath*. """"""; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; if not failoninc:; print(""""""%s data unavailable for database %s.\n"""""" % (modname, self.dbse)); return; else:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""""""Python module loading problem for database data """""" + str(modname)); try:; getattr(datamodule, funcname)(self); except AttributeError:; if not failoninc:; print(""""""%s %s data unavailable for database %s.\n"""""" % (modname, funcname, self.dbse)); return; else:; raise ValidationError(""Python module missing function %s for loading data "" % (str(funcname))). print(""""""WrappedDatabase %s: %s %s results loaded"""""" % (self.dbse, modname, funcname)). [docs] def load_qcdata_byproject(self, project, pythonpath=None):; """"""Loads qcdb.ReactionDatums from standard location for *project*; :module dbse_project and function load_project. Module search path; can be prepended with *pythonpath*. """"""; mod = self.dbse + '_' + project; func = 'load_' + project; self.load_qcdata(modname=mod, funcname=func, pythonpath=pythonpath). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; """"""""""""; if path is None:; path = os.path.dirname(__file__) + '/../data'; pklfile = os.path.abspath(path) + os.sep + self.dbse + '_hrxn_' + project + '.pickle'; if not os.path.isfile(pklfile):; raise Valida",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:38144,load,loading,38144,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loading']
Performance,"ific_path(1, './'); if 'opt_datafile' in kwargs:; restartfile = kwargs.pop('opt_datafile'); if(psi4.me() == 0):; shutil.copy(restartfile, p4util.get_psifile(1)). # compute Hessian as requested; frequency wipes out gradient so stash it; if ((full_hess_every > -1) and (n == 1)) or (steps_since_last_hessian + 1 == full_hess_every):; G = psi4.get_gradient(); psi4.IOManager.shared_object().set_specific_retention(1, True); psi4.IOManager.shared_object().set_specific_path(1, './'); frequencies(name, **kwargs); steps_since_last_hessian = 0; psi4.set_gradient(G); psi4.set_global_option('CART_HESS_READ', True); elif ((full_hess_every == -1) and (psi4.get_global_option('CART_HESS_READ')) and (n == 1)):; pass; # Do nothing; user said to read existing hessian once; else:; psi4.set_global_option('CART_HESS_READ', False); steps_since_last_hessian += 1. # print 'cart_hess_read', psi4.get_global_option('CART_HESS_READ'); # Take step; if psi4.optking() == psi4.PsiReturnType.EndLoop:; print('Optimizer: Optimization complete!'); psi4.print_out('\n Final optimized geometry and variables:\n'); psi4.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (psi4.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; psi4.opt_clean(); psi4.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy; psi4.print_out('\n Structure for next step:\n'); psi4.get_active_molecule().print_in_input_format(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = p4util.get_psifile(1); kwargs['mode'] = 'sow'. n += 1. psi4.print_out('\tOptimizer: Did",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:53491,Optimiz,Optimizer,53491,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['Optimiz'],"['Optimization', 'Optimizer']"
Performance,"ification in; the regular QM region. Additional MM molecules may be specified by adding; extra calls to addCharge to describe the full MM region.; To run a computation in a constant dipole field, the PERTURB_H,; PERTURB_WITH and PERTURB_DIPOLE keywords can be used. As an; example, to add a dipole field of magnitude 0.05 a.u. in the y direction and; 0.1 a.u. in the z direction, we can use the following keywords:; set perturb_h true; set perturb_with dipole; set perturb_dipole [ 0, 0.05, 0.1 ]. Note that if any specified fields do not fall along a symmetry axis, the; symmetry of the calculation should be reduced accordingly; if in doubt run the; calculation in C1 symmetry. For examples of SCF and MP2 calculations in an; external field, see scf7 and dfmp2-grad5. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type 1¶. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency 7; 8; 8. SCF of post-HF; energy; 8; 8; PK 3. optimization; 10; 10. frequency 7; 10; 10. CC property 2; 10; 10. Post-SCF convergence criteria defaults by calculation type 4¶. Ab Initio Method; Calculation Type; E_CONVERGENCE 5; R_CONVERGENCE 6. post-HF of post-HF; energy; 6. optimization; 8. frequency 7; 8. CC property 2; 8. Footnotes. 1; Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. 2(1,2); This applies to properties computed through the properties() function. 3; Post-HF methods that do not rely upon the usual 4-index AO integrals use a; density-fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. 4; Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. 5; The E_CONVERGENCE keyword is implement",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/scf-1.html:39774,optimiz,optimization,39774,psi4manual/1.4.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/scf-1.html,4,['optimiz'],['optimization']
Performance,"ifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. CFOUR_ESTATE_TRANS¶. Specifies whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS¶. Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION¶. Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE¶. Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD¶. Specifies the strength of a Fermi-Contact perturbation as required for finite-field calculations of spin densities and the FC contributions to indirect spin-spin coupling constants. The value must be specified as an integer and the F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:20906,optimiz,optimizations,20906,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,44,['optimiz'],"['optimizations', 'optimizer']"
Performance,"ikely will give rise to multiple; *CFOUR(...) directives in the prospective ZMAT, execution of; which will be trapped and halted. Proper uses for the cfour {...}; block are for the sandwich mode, where the entire ZMAT is enclosed,; or for extra directives like %excite*, which presently have no other; specification route.; Specifying the basis is perhaps the regulated piece of input. Since; basis set names differ between PSI4 and Cfour and it’s not; practical to compare exponent-to-exponent, any input file with both; BASIS and CFOUR_BASIS keywords present will halt. Once; a basis set has been requested through BASIS, overriding the; default spherical/Cartesian setting must be done through; PUREAM (as opposed to CFOUR_SPHERICAL).; Specifying keywords that control geometry optimization is; straightforward. Unless the optimization is invoked in sandwich mode,; all Cfour optimization keywords (e.g., CFOUR_GEO_MAXCYC) are; ineffective, as the Cfour optimizer is never invoked. PSI4; optimization keywords (e.g., GEOM_MAXITER) instead fill; these roles.; Specifying the computational method (through, for instance,; energy('c4-ccsd') instead of energy('cfour')) often; sets additional keywords consistent with best practices (e.g.,; CFOUR_CC_PROGRAM). Since those settings are implicit, any; explicit setting of those those keywords, whether contradicting or; concurring, takes priority (halts never generated). The following are; some concrete examples. For the moment, click the source button at; muster_modelchem for details of what keywords; get set. runs in vcc since that’s Cfour’s default for cc_program; set cfour_calc_level ccsd; energy('cfour'). runs in ecc since Cfour’s default overwritten by keyword; set cfour_calc_level ccsd; set cfour_cc_program ecc; energy('cfour'). runs in ecc since that’s best practice for the requested ccsd; energy('c4-ccsd'). runs in vcc since hidden default overwritten by keyword; set cfour_cc_program vcc; energy('c4-ccsd'). Specifying certain keywor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:31503,optimiz,optimization,31503,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,9,['optimiz'],['optimization']
Performance,"ilability. [4]; (1,2); a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old \(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cc.html:6964,optimiz,optimizations,6964,psi4manual/1.7.x/cc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cc.html,1,['optimiz'],['optimizations']
Performance,"ilable after a license agreement from; http://www.cfour.de/. Installation¶; Follow the instructions provided with the Cfour download to install the; executable or to build the source. To by used by PSI4, the program; binary (xcfour) must be found in your PATH or; PSIPATH. The GENBAS file containing basis sets in Cfour; format is not necessary for this interface, but if you prefer to access; basis sets the “Cfour way” using a custom GENBAS file (the distributed; one is included with the interface), it, too, must be in PATH or; PSIPATH. If PSI4 is unable to execute the binary, an error; will be reported. Caution; The p4c4 interface hasn’t been fully adapted for the new March 2014 version. Cfour for PSI4 Users¶. Set memory as usual; Set molecule as usual; Set basis set as usual (Cfour only cares about orbital basis, no fitting; bases); Set the task as usual, indicating Cfour as the intended code by; prepending “c4-” to the method argument. So energy('scf') becomes; energy('c4-scf') and optimize('ccsd(t)') becomes; optimize('c4-ccsd(t)'). Find available methods for; energy() at Energy (CFOUR); and for optimize() at Gradient (CFOUR).; Generally, the p4c4 interface will handle best practices for path of; execution: vcc/ecc, derivative type, etc. The user is still; responsible for setting convergence, frozen core, guess, diis, etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through PSI4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like PSI4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE whe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cfour-1.html:1454,optimiz,optimize,1454,psi4manual/1.2.1/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cfour-1.html,30,['optimiz'],['optimize']
Performance,"ilable after a license agreement from; http://www.cfour.de/. Installation¶; Follow the instructions provided with the Cfour download to install the; executable or to build the source. To by used by Psi4, the program; binary (xcfour) must be found in your PATH or; PSIPATH. The GENBAS file containing basis sets in Cfour; format is not necessary for this interface, but if you prefer to access; basis sets the “Cfour way” using a custom GENBAS file (the distributed; one is included with the interface), it, too, must be in PATH or; PSIPATH. If Psi4 is unable to execute the binary, an error; will be reported. Caution; The p4c4 interface hasn’t been fully adapted for the new March 2014 version. Cfour for Psi4 Users¶. Set memory as usual; Set molecule as usual; Set basis set as usual (Cfour only cares about orbital basis, no fitting; bases); Set the task as usual, indicating Cfour as the intended code by; prepending “c4-” to the method argument. So energy('scf') becomes; energy('c4-scf') and optimize('ccsd(t)') becomes; optimize('c4-ccsd(t)'). Find available methods for; energy() at Energy (CFOUR); and for optimize() at Gradient (CFOUR).; Generally, the p4c4 interface will handle best practices for path of; execution: vcc/ecc, derivative type, etc. The user is still; responsible for setting convergence, frozen core, guess, diis, etc.; For the moment, so-called “best-practices” keywords are summarized at; Best Practices.; For the type of computation intended, find appropriate options at; Keywords. These keyword summaries contain the same; information as the proper CFOUR options list; plus notes on keyword relevance when run through Psi4. Information; at the CFOUR manual may; also be useful, as may the many samples at psi4/samples/cfour.; Set Cfour keywords just like Psi4 keywords. The names of keywords; are unchanged beyond a prepended “cfour_”. (Though be aware that common; abbreviations like CALC and REF must be fully spelled out as; CFOUR_CALC_LEVEL and CFOUR_REFERENCE whe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:1508,optimiz,optimize,1508,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['optimiz'],['optimize']
Performance,ilable) or finite difference; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj. b3lyp-d3mbj. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj. b3pw91; B3PW91 Hyb,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:3012,optimiz,optimized,3012,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,25,['optimiz'],['optimized']
Performance,"ile (Sec. ~/.psi4rc File). For example,; the following makes the default memory 2 GB.; set_memory(2000000000). However, unless you’re assured of having only one job running on a node at; a time (and all nodes on the filesystem with ~/.psi4rc have similar memory; capacities), it is advised to set memory in the input file on a; per-calculation basis.; That same command can be used for PsiAPI mode:; psi4.set_memory(int(5e8)). PSIthonPsiAPIset_memory(2000000000). psi4.set_memory(int(5e8)). Note; For parallel jobs, the memory keyword represents the total memory; available to the job, not the memory per thread. Molecule and Geometry Specification¶. Molecule and Geometry Specification; Coordinates; Molecule Keywords; Multiple Molecules; Ghost Atoms; Isotopic Substitution; PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Advanced Python. To add EFP fragments to a molecule, see Molecule Specification. Job Control Keywords¶; PSI4 comprises a number of C++ modules that each perform; specific tasks and are callable directly from the Python front end. Each module; recognizes specific keywords in the input file which control its function.; These keywords are detailed in Appendix Keywords by Module.; The keywords can be made global, or scoped to apply to; certain specific modules. The following examples demonstrate some of the ways; that global keywords can be specified:; # all equivalent. set globals basis cc-pVDZ. set basis cc-pVDZ. set globals basis = cc-pVDZ. set basis = cc-pVDZ. set globals{; basis cc-pVDZ; }. set {; basis cc-pVDZ; }. set {; basis = cc-pVDZ; }. Note the lack of quotes around cc-pVDZ, even though it is a string. The; Psithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set {; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psithoninput.html:4310,perform,perform,4310,psi4manual/1.9.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psithoninput.html,2,['perform'],['perform']
Performance,"ile contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2¶. This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3¶. This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4¶. This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV¶. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC¶. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP¶. Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD¶. Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:29410,optimiz,optimizations,29410,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,48,['optimiz'],"['optimizations', 'optimizer']"
Performance,"ile? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MOM_OCC (SCF)¶SCF — The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START (SCF)¶SCF — The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR (SCF)¶SCF — The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. MP2_AMP_TYPE (DFOCC)¶DFOCC — The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly * whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_AMPS_PRINT (CCENERGY)¶CCENERGY — Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. MP2_CCSD_METHOD (PSIMRCC)¶PSIMRCC — How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS (PSIMRCC)¶PSIMRCC — Do start from a MP2 guess?. Type: boolean; Default: true. MP2_OS_SCALE (CCENERGY)¶CCENERGY — MP2 opposite-spin scaling value. Type: double; Default: 1.20. MP2_OS_SCALE (DFMP2)¶DFMP2 — OS Scale. Type: double; Default: 6.0. MP2_OS_SCALE (DFOCC)¶DFOCC — MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_OS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SCALE_OS (FNOCC)¶FNOCC — Opposite-spin scaling factor for SCS-MP2. Type: double; Default: 1.20. MP2_SCALE_SS (FNOCC)¶FNOCC — Same-spin scaling factor for SCS-MP2. Type: double; Default: 1.0. MP2_SOS_SCALE (DFOCC)¶DFOCC — MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2 (DFOCC)¶DFOCC — Spin-opposite scaling (SOS) value for optimized",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:169103,perform,perform,169103,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['perform'],['perform']
Performance,"ility analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly update ref_dft_2e/xc due to new BraggSlater radii. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. dft-custom-gga; DFT (LDA/GGA) test of custom implementations in: gga_superfuncs.py. sapt11; sapt example with orbital freezing with alkali metal and dMP2. scf-guess-read2; Test if the the guess read in the same basis converges. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. mints-benchmark; run some BLAS benchmarks. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. linK-1; RHF Linear Exchange Algorithm test for water. fci-h2o-2; 6-31G H2O Test FCI Energy Point. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. psithon1; Spectroscopic constants of H2, and the full ci ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:2517,perform,performed,2517,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"ill be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver; from psi4.driver.p4util.exceptions import *. [docs]def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before UKS?; continuous_guess : Optional[bool]; Do carry along guess rather than reguessing at each occupation?; filename : Optional[str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:1686,tune,tuned,1686,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,2,['tune'],['tuned']
Performance,"ill, J. M. Turney, and H. F. Schaefer, J.; Chem. Phys. 135, 174017 (2011).; “Density Fitting and Cholesky Decomposition Approximations; in Symmetry-Adapted Perturbation Theory: Implementation and Application; to Probe the Nature of Interactions in Linear Acenes,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 132,; 184111 (2010). SAPT2, SAPT2+, SAPT2+(3), SAPT2+3. “Density Fitting of Intramonomer Correlation Effects in; Symmetry-Adapted Perturbation Theory,”; E. G. Hohenstein and C. D. Sherrill, J. Chem. Phys. 133,; 014101 (2010).; “Wavefunction Methods for Noncovalent Interactions,” E. G.; Hohenstein and C. D. Sherrill, WIREs: Comput. Mol. Sci. 2,; 304-326 (2012). Using Natural Orbitals in SAPT. “Efficient Evaluation of Triple Excitations in Symmetry-Adapted; Perturbation Theory via MP2 Natural Orbitals,” E. G. Hohenstein; and C. D. Sherrill, J. Chem. Phys. 133, 104107 (2010). OMP2. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller-Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011). OMP3. “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/introduction-1.html:6192,optimiz,optimization,6192,psi4manual/4.0b3/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"ill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/introduction-1.html:9533,optimiz,optimization,9533,psi4manual/4.0b5/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/introduction-1.html,6,['optimiz'],"['optimization', 'optimized']"
Performance,"im1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:2737,load,load,2737,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,6,['load'],['load']
Performance,"imary use of the ~/.psi4rc file is to control the; handling of scratch files. PSI4 has a number of utilities that manage; input and output (I/O) of quantities to and from the hard disk. Most; quantities, such as molecular integrals, are intermediates that are not of; interest to the user and can be deleted after the computation finishes, but; pertinent details of computations are also written to a checkpoint file and; might be useful in subsequent computations. All files are sequentially; numbered and are written to /tmp, then deleted at the end of the computation,; unless otherwise instructed by the user.; A Python callable handle to the PSI4 I/O management routines is available,; and is called psi4_io. To instruct the I/O manager to send all files to; another location, say /scratch/user, add the following command to the ~/.psi4rc; file.:; psi4_io.set_default_path('/scratch/user'). For batch jobs running through a queue, it might be more convenient to use an; environmental variable (in this case $MYSCRATCH) to set the scratch directory;; the following code will do that:; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). Individual files can be sent to specific locations. For example, file 32 is; the checkpoint file that the user might want to retain in the working directory; (i.e., where PSI4 was launched from) for restart purposes. This is; accomplished by the commands below:; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). A guide to the contents of individual scratch files may be found at PSIOH Intermediate Files.; To circumvent difficulties with running multiple jobs in the same scratch, the; process ID (PID) of the PSI4 instance is incorporated into the full file; name; therefore, it is safe to use the same scratch directory for calculations; running simultaneously.; To override any of these defaults for selected jobs, simply place the; appropriate commands from the snippets a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/external-1.html:3162,queue,queue,3162,psi4manual/4.0b3/external-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/external-1.html,2,['queue'],['queue']
Performance,"imate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/energy.html:37423,perform,perform,37423,psi4manual/1.7.x/energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/energy.html,2,['perform'],['perform']
Performance,"imation,”; R. Schäffer and G. Jansen, Mol. Phys. 111, 2570 (2013).; (doi: 10.1080/00268976.2013.827253). Orbital-Optimized Post-Hartree–Fock Methods¶; Orbital-optimized second-order perturbation theory (OMP2). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Analytic energy gradients for the orbital-optimized second-order; Møller–Plesset perturbation theory,” U. Bozkaya and; C. D. Sherrill, J. Chem. Phys. 138, 184103 (2013).; (doi: 10.1063/1.4803662).; “Orbital-Optimized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/introduction-1.html:16788,optimiz,optimized,16788,psi4manual/1.4.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/introduction-1.html,9,['optimiz'],['optimized']
Performance,"imit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; 1; 2set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; 1; 2; 3; 4; 5; 6set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:5587,optimiz,optimize,5587,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimize']
Performance,"imization via analytic gradients. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. cc12; Single point energies of multiple excited states with EOM-CCSD. dft2; DFT Functional Test. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. cbs-xtpl-func; optimization with method defined via cbs. cubeprop; RHF orbitals and density for water. omp3-1; OMP3 c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:28164,perform,performs,28164,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['perform'],['performs']
Performance,"imized Second-Order Perturbation Theory with Density-Fitting; and Cholesky Decomposition Approximations: An Efficient Implementation,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2371 (2014).; (doi: 10.1021/ct500231c). Orbital-optimized third-order perturbation theory (OMP3). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q).; “Analytic energy gradients for the orbital-optimized third-order Møller–Plesset; Perturbation Theory,” U. Bozkaya,; J. Chem. Phys. 139, 104116 (2013).; (doi: 10.1063/1.4820877). Orbital-optimized linearized coupled-cluster doubles method (OLCCD). “Orbital-optimized coupled-electron pair theory and its analytic gradients:; Accurate equilibrium geometries, harmonic vibrational frequencies, and hydrogen transfer; reactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 139, 054104 (2013).; (doi: 10.1063/1.4816628). Orbital-optimized MP2.5 (OMP2.5). “Orbital-optimized MP2.5 and its analytic gradients: Approaching CCSD(T); quality for noncovalent interactions,” U. Bozkaya and C. D. Sherrill,; J. Chem. Phys. 141, 204105 (2014).; (doi: 10.1063/1.4902226). Extended Koopmans’ Theorem. “The extended Koopmans’ theorem for orbital-optimized methods: Accurate; computation of ionization potentials,” U. Bozkaya, J. Chem. Phys.; 139, 154105 (2013).; (doi: 10.1063/1.4825041).; “Accurate Electron Affinities from the Extended Koopmans’ Theorem Based on Orbital-Optimized Methods,”; U. Bozkaya, J. Chem. Theory Comput. 10, 2041 (2014).; (doi: 10.1021/ct500186j). Density-Fitted and Cholesky-Decomposed Orbital-opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:14459,optimiz,optimized,14459,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,17,['optimiz'],['optimized']
Performance,"imizer\n""""""; instructionsM += """"""# data file to accelerate convergence, the OPT-master jobs must run on the same computer.\n\n"""""". fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write(format_molecule_for_input(molecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:27270,Load,Loading,27270,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Load'],['Loading']
Performance,"imizer\n""""""; instructionsM += """"""# data file to accelerate convergence, the OPT-master jobs must run on the same computer.\n\n"""""". fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write(format_molecule_for_input(molecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:29748,Load,Loading,29748,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['Load'],['Loading']
Performance,"imize¶. psi4.driver.optimize(name, **kwargs)[source]¶; Function to perform a geometry optimization. Aliases; opt(). Returns; float – Total electronic energy of optimized structure in Hartrees. Returns; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises; psi4.OptimizationConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables. CURRENT ENERGY. Parameters. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. engine (str) – \(\Rightarrow\) 'optking' \(\Leftarrow\) || 'geometric'; Indicates the optimization engine to use, which can be either Psi4’s; native Optking optimizer or the GeomeTRIC program. optimizer_keywords (dict) – Options passed to the GeomeTRIC optimizer; Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.optimize-1.html:1215,optimiz,optimization,1215,psi4manual/1.4.0/api/psi4.driver.optimize-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.optimize-1.html,10,['optimiz'],['optimization']
Performance,"imum excitation level. This is used ONLY if it is explicitly set by the user. Single-reference case: all excitations up to this level are included, e.g., 2 for CCSD, 3 for CCSDT, 4 for CCSDTQ, etc. This becomes ex.lev (option #1) in fort.56. Type: integer; Default: 2. MRCC_NUM_DOUBLET_ROOTS¶. Number of root in case of open shell system. This becomes ndoub (option #13) int fort.56. Type: integer; Default: 0. MRCC_NUM_SINGLET_ROOTS¶. Number of singlet roots. (Strictly speaking number of of roots with M_s=0 and S is even.) Use this option only with closed shell reference determinant, it must be zero otherwise. This becomes nsing (option #2) in fort.56. Type: integer; Default: 1. MRCC_NUM_TRIPLET_ROOTS¶. Number of triplet roots. (Strictly speaking number of of roots with \(M_s=0\) and S is odd.) See notes at option MRCC_NUM_SINGLET_ROOTS This becomes ntrip (option #3) in fort.56. Type: integer; Default: 0. Expert¶. MRCC_METHOD¶. If more than one root is requested and calc=1, LR-CC (EOM-CC) calculation is performed automatically for the excited states. This overrides all automatic determination of method and will only work with energy(). This becomes CC/CI (option #5) in fort.56. See Table MRCC_METHOD for details. Type: integer; Default: 1. MRCC_OMP_NUM_THREADS¶. Sets the OMP_NUM_THREADS environment variable before calling MRCC. If the environment variable OMP_NUM_THREADS is set prior to calling Psi4 then that value is used. When set, this option overrides everything. Be aware the -n command-line option described in section Threading does not affect MRCC. Type: integer; Default: 1. MRCC_RESTART¶. The program restarts from the previously calculated parameters if it is 1. In case it is 2, the program executes automatically the lower-level calculations of the same type consecutively (e.g., CCSD, CCSDT, and CCSDTQ if CCSDTQ is requested) and restarts each calculation from the previous one (rest=2 is available only for energy calculations). Currently, only a value of 0 and 2 a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html:1572,perform,performed,1572,psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__mrcc-1.html,24,['perform'],['performed']
Performance,imum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 6. DIIS_MIN_VECS¶. Minimum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 3. IGNORE_TAU¶. Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. LOCK_OCC¶. Controls whether to force the occupation to be that of the SCF guess. For practical applications only the default must be used. Type: boolean; Default: true. MO_RELAX¶. Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. RELAX_TAU¶. Controls whether to relax tau during the cumulant updates or not. Type: boolean; Default: true. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the c,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__dcft-1.html:4741,perform,performing,4741,psi4manual/4.0b4/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__dcft-1.html,8,['perform'],['performing']
Performance,"imum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PERTURB_CBS¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: false. PERTURB_CBS_COUPLING¶. Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Default: SECOND_ORDER. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__psimrcc-1.html:2822,perform,perform,2822,psi4manual/1.4.0/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__psimrcc-1.html,18,['perform'],['perform']
Performance,"imum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Default: SECOND_ORDER. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: S",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html:2815,perform,perform,2815,psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__psimrcc-1.html,2,['perform'],['perform']
Performance,"imum number of error vectors stored for DIIS extrapolation. Type: integer; Default: 7. DIIS_START¶. The number of DIIS vectors needed before extrapolation is performed. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FAVG_CCSD_T¶. Do use the averaged Fock matrix over all references in (T) computations?. Type: boolean; Default: false. FOLLOW_ROOT¶. Which root of the effective hamiltonian is the target state?. Type: integer; Default: 1. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do disregard updating single excitation amplitudes?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html:2846,perform,perform,2846,psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__psimrcc-1.html,6,['perform'],['perform']
Performance,"imum number of iterations to determine the amplitudes. Type: integer; Default: 50. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DIIS_MAX_VECS¶. Number of vectors used in DIIS. Type: integer; Default: 4. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: false. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. Type: conv double; Default: 1e-8. HESS_TYPE¶. Type Hessian matrix will be used in orbital optimization procedure. Type: string; Possible Values: NONE; Default: NONE. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html:1746,optimiz,optimization,1746,psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp2-1.html,4,['optimiz'],['optimization']
Performance,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; Configuration: Preparing ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:23804,perform,performed,23804,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,2,['perform'],['performed']
Performance,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through cbs().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers. Previous topic; A PSI4 Tutor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html:24381,perform,performed,24381,psi4manual/4.0b3/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psithoninput-1.html,2,['perform'],['performed']
Performance,"in Avals:; h2o.A = A; energy('df-mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('DF-MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-DF-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final table is printed to the output file (line 24). The; table is converted from absolute energies to relative energies (in kcal mol-1); on line 26, before being printed again. The relative energies are reported with; respect to the lowest value in each column. More examples of how to control the; formatting of the tables can be found in the sample input files provided; see; Appendix Test Suite and Sample Inputs for a complete listing. Python Wrappers¶; The Python foundations of the PSI4 driver and Psithon syntax permit; many commonly performed post-processing procedures to be integrated into; the PSI4 suite.; Among these are automated computations of interaction energies through; cp(), of a model chemistry applied to a database of systems through; database(), and of several model chemistries together approximating greater; accuracy through complete_basis_set().; These are discussed separately in section Psithon Functions: Invoking a Calculation.; Note that the options documented for Python functions are placed as arguments; in the command that calls the function,; not in the set globals block or with any other set command. Table Of Contents. Psithon: Structuring an Input File; Physical Constants; Molecule and Geometry Specification; Multiple Molecules; Molecule Keywords; Ghost Atoms. Geometries from the PubChem Database; Symmetry; Non-Covalently Bonded Molecule Fragments; Job Control; Assigning Basis Sets; Memory Specification; Return Values and PSI Variables; Loops; Tables of Results; Python Wrappers.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html:27246,perform,performed,27246,psi4manual/4.0b4/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psithoninput-1.html,4,['perform'],['performed']
Performance,"in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html:1321,perform,performed,1321,psi4manual/1.3.2/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.driver.opt-1.html,4,['perform'],['performed']
Performance,"in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.OptimizationConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. return_history (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:1321,perform,performed,1321,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,4,['perform'],['performed']
Performance,"in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if n_response > 0:; if (""ref_wfn"" in kwargs and not kwargs[""ref_wfn""].same_a_b_orbs()) or core.get_option('SCF', 'REFERENCE') != 'RHF':; raise ValidationError(f""Non-RHF CC response properties are not implemented.""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(f""CC property name {name.upper()} not recognized""). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:99131,Perform,Perform,99131,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,5,['Perform'],['Perform']
Performance,"in excited_properties:; excited.append(prop); else:; invalid.append(prop); else:; raise ValidationError(""""""The ""properties"" keyword is required with the property() function.""""""). # People are used to requesting dipole/quadrupole and getting dipole,quadrupole,mulliken_charges and NO_occupations; if ('DIPOLE' in one) or ('QUADRUPOLE' in one):; one = list(set(one + ['DIPOLE', 'QUADRUPOLE', 'MULLIKEN_CHARGES', 'NO_OCCUPATIONS'])). n_one = len(one); n_two = len(two); n_response = len(response); n_excited = len(excited); n_invalid = len(invalid). if n_invalid > 0:; print(""""""The following properties are not currently supported: %s"""""" % invalid). if n_excited > 0 and (name not in ['eom-ccsd', 'eom-cc2']):; raise ValidationError(""""""Excited state CC properties require EOM-CC2 or EOM-CCSD.""""""). if (name in ['eom-ccsd', 'eom-cc2']) and n_response > 0:; raise ValidationError(""""""Cannot (yet) compute response properties for excited states.""""""). if 'roa' in response:; # Perform distributed roa job; run_roa(name, **kwargs); return # Don't do anything further. if (n_one > 0 or n_two > 0) and (n_response > 0):; print(""""""Computing both density- and response-based properties.""""""). if name in ['ccsd', 'cc2', 'eom-ccsd', 'eom-cc2']:; this_name = name.upper().replace('-', '_'); core.set_global_option('WFN', this_name); ccwfn = run_ccenergy(name, **kwargs); core.set_global_option('WFN', this_name); else:; raise ValidationError(""""""CC property name %s not recognized"""""" % name.upper()). # Need cchbar for everything; core.cchbar(ccwfn). # Need ccdensity at this point only for density-based props; if n_one > 0 or n_two > 0:; if name == 'eom-ccsd':; core.set_global_option('WFN', 'EOM_CCSD'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); elif name == 'eom-cc2':; core.set_global_option('WFN', 'EOM_CC2'); core.set_global_option('DERTYPE', 'NONE'); core.set_global_option('ONEPDM', 'TRUE'); core.cceom(ccwfn); core.set_global_option('DERTYPE', 'N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:98234,Perform,Perform,98234,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['Perform'],['Perform']
Performance,"in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57231,optimiz,optimize,57231,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['optimiz'],['optimize']
Performance,"in line -decontract option for basis sets. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. fsaptd-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. dct-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-freq; Various gradients for a strained helium dimer an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:11774,optimiz,optimize,11774,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimize']
Performance,"in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For the “frozen” bonds, angles and dihedrals, these coordinates are constrained to remain at their initial values. For “fixed” bonds, angles, or dihedrals, the equilibrium (final) value of the coordinate is provided by the user. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2_5-2; OMP2 cc-pVDZ energy for the H2O molecule. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. mp2-grad2; MP2 cc-pVDZ gradient for the NO radical. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:16236,optimiz,optimization,16236,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. table of contents. DCT; General; ALGORITHM; AO_BASIS; DCT_FUNCTIONAL; DCT_TYPE; DF_BASIS_DCT; DIIS_START_CONVERGENCE; E_CONVERGENCE; GUESS_R_CONVERGENCE; MAXITER; ODC_GUESS; OPDM; QC_COUPLING; QC_TYPE; REFERENCE; RESPONSE_ALGORITHM; R_CONVERGENCE; THREE_PARTICLE. Expert; CACHELEVEL; DAMPING_PERCENTAGE; DCT_GUESS; DIIS_MAX_VECS; DIIS_MIN_VECS; ENERGY_LEVEL_SHIFT; INTS_TOLERANCE; ORBITAL_LEVEL_SHIFT; RELAX_GUESS_ORBITALS; STABILITY_ADD_VECTORS; STABILITY_AUGMENT_SPACE_TOL; STABILITY_CHECK; STABILITY_CONVERGENCE; STABILITY_MAX_SPACE_SIZE; STABILITY_N_EIGENVALUES; STABILITY_N_GUESS_VECTORS; TIKHONOW_OMEGA. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; DCT. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__dct.html:7096,CACHE,CACHELEVEL,7096,psi4manual/master/autodir_options_c/module__dct.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__dct.html,1,['CACHE'],['CACHELEVEL']
Performance,"in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__ccresponse-1.html:3781,CACHE,CACHELEVEL,3781,psi4manual/1.4.0/autodir_options_c/module__ccresponse-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__ccresponse-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__ccresponse-1.html:3781,CACHE,CACHELEVEL,3781,psi4manual/1.5.0/autodir_options_c/module__ccresponse-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__ccresponse-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"in-opposite scaled OMP2 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp3 | orbital-optimized third-order MP perturbation theory :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp3>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | scs-omp3 | spin-component scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | sos-omp3 | spin-opposite scaled OMP3 :ref:`[manual] <sec:occ_oo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | omp2.5 | orbital-optimized MP2.5 :ref:`[manual] <sec:occ_oo>` :ref:`[details] <dd_omp2p5>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | lccsd, cepa(0) | coupled electron pair approximation variant 0 :ref:`[manual] <sec:fnocepa>` :ref:`[details] <dd_lccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | fno-lccsd, fno-cepa(0) | CEPA(0) with frozen natural orbitals :ref:`[manual] <sec:fnocc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------------------------------+; | cepa(1) | coupled electron pair approximation variant 1 :ref:`[manual] <sec:fnocepa>` :ref:`[details] <dd_cepa_pr1_pr>` |; +-------------------------+--------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:13025,optimiz,optimized,13025,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimized']
Performance,"in.cc.o; [100%] Linking CXX shared module testplugin.so; [100%] Built target testplugin. # run sample input.dat; >>> psi4; Attention! This SCF may be density-fitted. Please note that the conda distribution must be in $PATH or the; conda enviroment must be activated before compilation and execution of; plugins created using this procedure. Files in a Plugin Directory¶; In addition to the main myplugin.cc file, a fresh plugin directory contains the following files. CMakeLists.txt — CMake file governing project plugin.; The plugin source and CMakeLists.txt is independent of platform; and PSI4 installation. You use CMake (version 3.1 or later); to generate a Makefile for the plugin by pointing it to a specific; PSI4 installation. Run psi4 --plugin-compile to get a command; to execute to generate the Makefile. What that command is doing is; loading the compilers and options used to build the parent PSI4; (the -C psi4PluginCache part) which in turn can be overridden; by passing -Doption=value commands to cmake and pointing; toward a particular PSI4 (and probably pybind11) library to; link against (the CMAKE_PREFIX_PATH part) and telling it to; do an in-source build (the . part). Then just run make in; your plugin directory. After any change to the plugin C++ code,; make must be run in the plugin directory to recompile the; myplugin.so executable, but recompiling the main PSI4 code; is not necessary. Should you add additional (non-header) files to; the plugin or need to link to additional external libraries, add that; information here.; input.dat — Sample input file for the plugin.; Since the __init__.py file makes the plugin directory look like a; Python module, the plugin can be treated as such in an input file. The; location of the plugin directory must be included in PYTHONPATH,; either externally in the calling shell or defined in the input file.; This is usually done by manipulating PSIPATH. Then,; the plugin can be loaded as import myplugin and executed as; energy('",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/plugins-1.html:5491,load,loading,5491,psi4manual/1.1.0/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/plugins-1.html,15,['load'],['loading']
Performance,"in_path() in module psi4.driver. JSCH module, [1]. K. K() psi4.core.JK method, [1], [2]. KEEP_INTCOS (OPTKING). keywords. ; anharmonicity(), setting. cbs(), setting. cp, setting. database(), setting. energy(), setting. frequency(), setting. general, setting. molecule, setting. optimize(), setting. property(), setting. vmfc, setting. KineticInt class in psi4.core, [1]. L. L psi4.core.BoysLocalizer attribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. label() psi4.core.Molecule method, [1], [2]. LaplaceDenominator class in psi4.core, [1]. LCC2(+LMP2)TOTALENERGY. LCCSD. LCCSD(+LMP2)TOTALENERGY. legacy_wavefunction() in module psi4.core, [1]. LEVEL_SHIFT (DFOCC). (MCSCF). (OCC). levenshtein() in module psi4.driver. LIBEFP. libfock() in module psi4.core, [1]. Libint. license. LINEAR (CCRESPONSE). LINEQ_SOLVER (DFOCC). (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). LITERAL_CFOUR (GLOBALS). load() psi4.core.Matrix method, [1], [2]. load_mpqc() psi4.core.Matrix method, [1], [2]. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_CONVERGENCE (FISAPT). (SCF). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_DO_SINGLES (CCEOM). LOCAL_FILTER_SINGLES (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_GHOST (CCEOM). LOCAL_IBO_CONDITION (FISAPT). LOCAL_IBO_POWER (FISAPT). LOCAL_IBO_STARS (FISAPT). LOCAL_IBO_STARS_COMPLETENESS (FISAPT). LOCAL_IBO_USE_STARS (FISAPT). LOCAL_MAXITER (FISAPT). (SCF). LOCAL_METHOD (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). LOCAL_PAIRDEF (CCENERGY). (CCLAMBDA). (CCRESPONSE). LOCAL_PRECONDITIONER (CCEOM). LOCAL_USE_GHOSTS (FISAPT). LOCAL_WEAKP (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). localize() psi4.core.BoysLocalizer method, [1]. psi4.core.Localizer method, [1], [2]. psi4.core.PMLocalizer method, [1]. Localizer class in psi4.core, [1]. LOCK_SINGLET (PSIMRCC). lsda_cutoff() psi4.c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/genindex-1.html:58481,load,load,58481,psi4manual/1.1.0/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/genindex-1.html,2,['load'],['load']
Performance,"inates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_energy(), 4, ""geom2 took""). Molecules can be initiated from XYZ files and fragmented for SAPT computations.; # >>> cat mol1.xyz; #7; #; #O 0.00000000 -0.05786571 -1.47979303; #N 0.00000000 0.01436394 1.46454628; #H 0.00000000 0.82293384 -1.85541474; #H 0.81348351 0.39876776 1.92934049; #H 0.00000000 0.07949567 -0.51934253; #H 0.00000000 -0.98104857 1.65344779; #H -0.81348351 0.39876776 1.92934049. # >>> cat mol2.xyz; # 6 au; # stuff; # C 0.00000000000000 0.00000000000000 5.26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000000 -1.12178201232889; # N 0.00000000000000 0.00000000000000 3.08339310458383; # N 0.00000000000000 0.00000000000000 -5.33865984413460. sapt = {'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:17520,load,load,17520,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['load'],['load']
Performance,"inates in an input file in Python.; molecule formaldehyde {; C 0.0 0.0 0.0; O 0.0 1.2 0.0; H -0.8 -0.3 0.0; H 0.8 -0.3 0.0 # set geometry in angstroms; }. formaldehyde.update_geometry() # update the molecule internals since pre-energy()-like call; formaldehyde.print_out() # print molecule to output file; geom1psi = formaldehyde.geometry() # get coordinates in bohr as a psi4.Matrix. geom1psi.print_out() # print coordinates array to output file; geom1py = mat2arr(geom1psi) # get coordinates as a Python array; print geom1py # print coordinates to screen. geom2py = [[ 0.0, 0.0, 0.0],; [ 0.0, 1.5, 0.0],; [-0.8, -0.3, 0.0],; [ 0.8, -0.3, 0.0]] # define alternate coordinates in angstroms as Python array. geom2psi = psi4.Matrix(4, 3) # initialize psi4.Matrix; geom2psi.set(geom2py) # load Python array into psi4.Matrix; geom2psi.scale(1.0/psi_bohr2angstroms) # scale into bohr; geom2psi.print_out() # print alternate coord array to output file. formaldehyde.set_geometry(geom2psi) # load alternate coordinates into molecule; formaldehyde.update_geometry() # update the molecule internals; formaldehyde.print_out() # print new molecule to output file; compare_values(28.9950517332, formaldehyde.nuclear_repulsion_energy(), 4, ""geom2 took""). Molecules can be initited from XYZ files and fragmented for SAPT computations.; # >>> cat mol1.xyz; #7; #; #O 0.00000000 -0.05786571 -1.47979303; #N 0.00000000 0.01436394 1.46454628; #H 0.00000000 0.82293384 -1.85541474; #H 0.81348351 0.39876776 1.92934049; #H 0.00000000 0.07949567 -0.51934253; #H 0.00000000 -0.98104857 1.65344779; #H -0.81348351 0.39876776 1.92934049. # >>> cat mol2.xyz; # 6 au; # stuff; # C 0.00000000000000 0.00000000000000 5.26601138679877; # C 0.00000000000000 0.00000000000000 -3.15195886530135; # H 0.00000000000000 0.00000000000000 7.28558683837122; # H 0.00000000000000 0.00000000000000 -1.12178201232889; # N 0.00000000000000 0.00000000000000 3.08339310458383; # N 0.00000000000000 0.00000000000000 -5.33865984413460. sapt = {'m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:17133,load,load,17133,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['load'],['load']
Performance,"inations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. sapt-dft-api; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. dft-grad-meta; meta-GGA gradients of water and ssh molecules reference gradients updated due to new BraggSlater radii. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. pywrap-cbs1; Various basis set extrapolation tests. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. dct10; The multiple guesses for DCT amplitudes for ODC-12. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fsapt-ext; Quick test of external potential in F-SAPT (see fsapt1 for a real example). props4; Electrostatic potential and electric field evaluated on a grid around water. cc4; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. After the computation, the checkpoint file is renamed, using the PSIO handler. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:10714,optimiz,optimized,10714,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimized']
Performance,"include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:67026,optimiz,optimize,67026,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,4,['optimiz'],['optimize']
Performance,"include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:69600,optimiz,optimize,69600,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimize']
Performance,"include:: /autodoc_dft_opt.rst. .. include:: /cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_spec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:62235,optimiz,optimize,62235,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimize']
Performance,"ine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.set_local_option('OCC', 'DO_SCS', 'TRUE'); psi4.occ(). optstash.restore(). [docs]def run_sos_omp2(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a spin-opposite scaled OMP2 computation. """"""; lowername = name.lower(). optstash = p4util.OptionsState(; ['OCC', 'SOS_TYPE'],; ['OCC', 'DO_SOS']). # what type of sos?; if (lowername == 'sos-omp2'):; psi4.set_local_option('OCC', 'SOS_TYPE', 'SOS'); elif (lowername == 'sos-pi-omp2'):; psi4.set_local_option('OCC', 'SOS_TYPE', 'SOSPI'). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.set_local_option('OCC', 'DO_SOS', 'TRUE'); psi4.occ(). optstash.restore(). [docs]def run_omp3(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. """"""; optstash = p4util.OptionsState(; ['OCC', 'WFN_TYPE']). # Bypass routine scf if user did something special to get it to converge; if not (('bypass_scf' in kwargs) and yes.match(str(kwargs['bypass_scf']))):; scf_helper(name, **kwargs). psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); psi4.occ(). optstash.restore(). [docs]def run_omp3_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; OMP3 gradient calculation. """"""; optstash = p4util.OptionsState(; ['OCC', 'WFN_TYPE'],; ['GLOBALS', 'DERTYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); psi4.set_local_option('OCC', 'WFN_TYPE', 'OMP3'); run_omp3(name, **kwargs); psi4.deriv(). optstash.restore(). [docs]def run_mp3(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a MP3 calculation. """"""; optstash = p4util.OptionsState(; ['OCC', 'ORB_OPT']). psi4.set_local_option('OCC', 'ORB_OPT', 'FALSE'); run_omp3(name, **kwargs). o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/proc.html:6317,optimiz,optimized,6317,psi4manual/4.0b5/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/proc.html,2,['optimiz'],['optimized']
Performance,"ine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters by solving the orbital-reponse (coupled-perturbed CC) equations. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: ORB_RESP. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html:5045,optimiz,optimization,5045,psi4manual/1.3.2/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html,2,['optimiz'],['optimization']
Performance,"ined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INDEPENDENT_J_TYPE¶. JK Independent options. Type: string; Possible Values: DIRECT_SCREENING; Default: DIRECT_SCREENING. INTS_TOLERANCE¶. Minimum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. PRINT_BASIS¶. Flag to print the basis set. Type: boolean; Default: false. PRINT_MOS¶. Flag to print the molecular orbitals. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, FAST_DF, CD, INDEPENDENT, GTFOCK; Default: PK. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by per",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html:2230,perform,perform,2230,psi4manual/1.1.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"ined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INDEPENDENT_J_TYPE¶. JK Independent options. Type: string; Possible Values: DIRECT_SCREENING; Default: DIRECT_SCREENING. INTS_TOLERANCE¶. Minimum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. PRINT_BASIS¶. Flag to print the basis set. Type: boolean; Default: false. PRINT_MOS¶. Flag to print the molecular orbitals. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, FAST_DF, CD, INDEPENDENT; Default: PK. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:2284,perform,perform,2284,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"ines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:10389,optimiz,optimize,10389,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['optimiz'],['optimize']
Performance,"ine} is not supported.""). name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS and nbody wrappers, need to set retention on INTCO file; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, True). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['OPTKING', 'INTRAFRAG_STEP_LIMIT'],; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:63614,optimiz,optimize,63614,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimize']
Performance,"ing Cartesian coordinates. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/kw-1; testing best practices options, part i. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. cfour/s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html:3520,optimiz,optimization,3520,psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"ing INTERFRAG_MODE to multi should suffice in almost all cases.; Dimer coordinate table. provides the name and ordering; convention for the coordinates. Basic multi-fragment optimization. Use automatically generated reference points. memory 4GB; molecule mol {; 0 1; O -0.5026452583 -0.9681078610 -0.4772692868; H -2.3292990446 -1.1611084524 -0.4772692868; H -0.8887241813 0.8340933116 -0.4772692868; --; 0 1; C 0.8853463281 -5.2235996493 0.5504918473; C 1.8139169342 -2.1992967152 3.8040686146; C 2.8624456357 -4.1143863257 0.5409035710; C -0.6240195463 -4.8153482424 2.1904642137; C -0.1646305764 -3.3031992532 3.8141619690; C 3.3271056135 -2.6064153737 2.1669340785; H 0.5244823836 -6.4459192939 -0.7478283184; H 4.0823309159 -4.4449979205 -0.7680411190; H -2.2074914566 -5.7109913627 2.2110247636; H -1.3768100495 -2.9846751653 5.1327625515; H 4.9209603634 -1.7288723155 2.1638694922; H 2.1923374156 -0.9964630692 5.1155773223; nocom; units au; }. set {; basis 6-31+G; frag_mode MULTI; }. optimize(""mp2""). Warning; The molecule input for psi4 has no effect upon optking, expect to provide Cartesian; coordinates. Specifying independent fragments with the – seperator, will not trigger; optking to add specific interfragment coordinates. Use FRAG_MODE multi. Specify the reference points to use for coordinates via FRAG_REF_ATOMS.; Each list corresponds to a fragment. A list of indices denotes a linear combination; of the atoms. In this case, the first reference point for the second fragment is the center; of the benzene ring. Indexing starts at 1, so the second fragment in this example starts at index 4. memory 4GB; molecule mol {; 0 1; O -0.5026452583 -0.9681078610 -0.4772692868; H -2.3292990446 -1.1611084524 -0.4772692868; H -0.8887241813 0.8340933116 -0.4772692868; --; 0 1; C 0.8853463281 -5.2235996493 0.5504918473; C 1.8139169342 -2.1992967152 3.8040686146; C 2.8624456357 -4.1143863257 0.5409035710; C -0.6240195463 -4.8153482424 2.1904642137; C -0.1646305764 -3.3031992532 3.814161",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:11098,optimiz,optimize,11098,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,4,['optimiz'],['optimize']
Performance,"ing Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134).; “Assessment of Orbital-Optimized Third-Order Møller–Plesset; Perturbation Theory and Its Spin-Component and Spin-Opposite Scaled Variants; for Thermochemistry and Kinetics,” E. Soydas and U. Bozkaya,; J. Chem. Theory Comput. 9, 1452 (2013).; (doi: 10.1021/ct301078q). Orbital-optimized coupled electron pair approximation (OCEPA). “Quadratically convergent algorithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,”; U. Bozkaya, J. M. Turney, Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; (doi: 10.1063/1.3631129).; “Orbital-optimized coupled electron pair theory and its analytic gradients:; Applications to equilibrium geometries, harmonic vibrational frequencies,; and hydrogen transfer reactions,” U. Bozkaya and C. D. Sherrill,; (unpublished). Orbital-optimized MP2.5 (OMP2.5). “Orbital-Optimized Third-Order Møller–Plesset Perturbation; Theory and Its Spin-Component and Spin-Opposite Scaled Variants: Application; to Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011).; (doi: 10.1063/1.3665134). Bozkaya and C. D. Sherrill, (unpublished). Second-Order Algebraic-Diagrammatic Construction [ADC(2)]¶; General ADC(2) theory. “Intermediate state representation approach to physical properties of; electronically excited molecules,”; J. Schirmer, and A. B. Trofimov, J. Chem. Phys. 120,; 11449-11464 (2004).; (doi: 10.1063/1.1752875). Theory of “Partially-renormalized” CIS(D) and ADC(2) [PR-CIS(D) and PR-ADC(2)]; and their implementation in PSI4. “Excited State Calculation for Free-Base and Metalloporphyrins with; the Partially Renormalized Polarization Propagator Approach,”; M. Saitow and Y. Mochizuki, Chem. Phys. Lett. 525, 144-149; (2012).; (doi: 10.1016/j.cplett.2011.12.063). Supported Architectures¶; The majority of PSI4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/introduction-1.html:9964,optimiz,optimized,9964,psi4manual/4.0b4/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/introduction-1.html,4,['optimiz'],['optimized']
Performance,"ing a Calculation ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT). dcft; density cumulant functional theory. mp2; 2nd-order Moller-Plesset perturbation theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/opt-1.html:1163,perform,performed,1163,psi4manual/4.0b2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html,2,['perform'],['performed']
Performance,"ing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. BASIS_RELATIVISTIC (GLOBALS); GLOBALS — Auxiliary basis set for solving Dirac equation in X2C and DKH calculations. Defaults to decontracted orbital basis. Type: string; Default: No Default. BCCD_MAXITER (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BENCH (GLOBALS); GLOBALS — Some codes (DFT) can dump benchmarking data to separate output files. Type: integer; Default: 0. BENDAZZOLI (DETCI); DETCI (Expert) — Do use some routines based on the papers of Bendazzoli et al. to calculate sigma? Seems to be slower and not worthwhile; may disappear eventually. Works only for full CI and I don’t remember if I could see how their clever scheme might be extended to RAS in general. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC); FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY); CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:6523,optimiz,optimization,6523,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"ing available quantum; chemical methods and functions driving the main quantum chemical; functionality, namely single-point energies, geometry optimizations,; properties, and vibrational frequency calculations. wrapper_autofrag¶. auto_fragments(**kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT. Returns:Molecule) – fragmented molecule. Parameters:molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> molecule mol {\nH 0.0 0.0 0.0\nH 2.0 0.0 0.0\nF 0.0 1.0 0.0\nF 2.0 1.0 0.0\n}; >>> print mol.nfragments() # 1; >>> fragmol = auto_fragments(); >>> print fragmol.nfragments() # 2. qmmm¶; Module with classes to integrate MM charges into; a QM calculation. class Diffuse(molecule, basisname, ribasisname)[source]¶. fitGeneral()[source]¶; Function to perform a general fit of diffuse charges; to wavefunction density. fitScf()[source]¶; Function to run scf and fit a system of diffuse charges to; resulting density. populateExtern(extern)[source]¶. class QMMM[source]¶. addChargeAngstrom(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Angstroms. addChargeBohr(Q, x, y, z)[source]¶; Function to add a point charge of magnitude Q at; position (x, y, z) Bohr. addDiffuse(diffuse)[source]¶; Function to add a diffuse charge field diffuse. populateExtern()[source]¶; Function to define a charge field external to the; molecule through point and diffuse charges. qcdb¶; Module to facilitate quantum chemical computations on chemical; databases. Contains Molecule class and physical constants from psi4 suite.; Module with commands building BasisFamily objects; for Pople and other non-Dunning orbital basis sets. Some; plausible fitting basis sets are supplied as defaults. load_basfam_other()[source]¶. class CharacterTable(*ar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:8953,perform,perform,8953,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['perform']
Performance,"ing factor used in MSD. Type: double; Default: 0.01. OPDM (DCT)¶DCT — Compute a (relaxed) one-particle density matrix? Can be set manually. Set internally for property and gradient computations. Type: boolean; Default: false. OPDM (DETCI)¶DETCI — Do compute one-particle density matrix if not otherwise required?. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY)¶CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2)¶DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING)¶OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC)¶DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC)¶OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. OPT_TYPE (OPTKING)¶OPTKING — Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. ORB_OPT (DFOCC)¶DFOCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_OPT (OCC)¶OCC — Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER (DFOCC)¶DFOCC — The algorithm will be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:182316,optimiz,optimization,182316,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"ing frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; ranged_distance = (""; 1 3 0.949 0.95; 2 4 0.949 0.95; ""); }. Note; The effect of the frozen and ranged keywords is generally independent of; how the geometry of the molecule was input (whether Z-matrix or Cartesian, etc.)..; At this time; however, enforcing Cartesian constraints when using a zmatrix for; molecular input is not supported. Freezing or constraining Cartesian coordinates; requires Cartesian molecule input. If numerical errors results in symmetry; breaking, while Cartesian constraints are active, symmetrization cannot occur and; an error will be raised, prompting you to restart the job. As a shortcut, the entire set of dihedral angles can be frozen. A subset can then be unfrozen if desired. set {; freeze_all_dihedrals true; unfreeze_dihedrals ""1 2 3 4""; }. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. lower_bound = [99.99, 109.99, 119.99, 129.99, 149.99]; upper_bound = [100, 110, 120, 130, 140, 150]; PES = []. for lower, upper in zip(lower_bound, upper_bound):; my_string = f""1 2 3 4 {lower} {upper}""; set optking ranged_dihedral = $my_string; E = optimize('scf'); PES.append((upper, E)). print(""\n\tcc-pVDZ SCF energy as a function of phi\n""); for point in PES:; print(""\t%5.1f%20.10f"" % (point[0], point[1])). To scan the potential energy surface without the RANGED_DIHEDRAL keyword, a zmatrix; can be used. Warning; Rotating dihedrals in large increments without allowing the molecule to relax; in between increments can lead to unphysical geometries with overlapping functional groups in larger molecules,; which may prevent successful con",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:7394,optimiz,optimizing,7394,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['optimiz'],['optimizing']
Performance,"ing integrals stored on disk. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. mom-h2o-4; MOM excitation from LUMO HOMO+4. fci-h2o; 6-31G H2O Test FCI Energy Point. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. stability3; Test LDA stability analysis against QChem. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. options1; check all variety of options parsing. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. pywrap-checkrun-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:41006,optimiz,optimization,41006,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ing it ideal for; large systems and multi-core CPUs. See COSX Exchange for more information. LINKAn implementation of the linear-scaling “Linear Exchange” (LinK); algorithm described in [Ochsenfeld:1998:1663]. The LINK algorithm provides; many of the benefits of integral-direct SCF algorithms, including no disk I/O,; low memory usage, and effective parallelization. Additionally, the; LINK implementation scales well with system size; while simultaneously providing a formally-exact computation of the; Exchange term. See Linear Exchange for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation. Additionally, expert users; can manually switch between the in-memory and on-disk options within MEM_DF or DISK_DF using; the SCF_SUBTYPE option. Using SCF_SUBTYPE = AUTO, where ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:30336,optimiz,optimized,30336,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,2,['optimiz'],['optimized']
Performance,"ing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:8086,cache,cache,8086,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['cache'],['cache']
Performance,"ing level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI); DETCI — Do calculate the value of for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CC (DETCI)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:10714,cache,cache,10714,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"ing resets the history""; ""and needs another Hessian"",; n,; wfn; ). core.print_out(opt_object.post_step_str()) # print convergence and step info. # Update psi4's molecule with new step. (Psi4 can rotate this molecule); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.update_geometry(). opt_status = opt_object.status() # Query optking for convergence, failure or continuing opt.; if opt_status == 'CONVERGED':. # Last geom is normally last in history. For IRC last geom is last in IRC trajectory; # Not sure how to handle ensuring that wfn corresponds to last point.; final_energy, final_geom = opt_object.summarize_result(). # Changing environment to optimized geometry as expected by user; molecule.set_geometry(core.Matrix.from_array(final_geom)); molecule.update_geometry(). print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); molecule.print_in_input_format(). for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). optstash.restore(). if return_history:; history = {; 'energy': [step.E for step in opt_object.history.steps],; 'gradient': [step.cart_grad for step in opt_object.history.steps],; 'coordinates': [step.geom for step in opt_object.history.steps],; }. # Create OptimizationResult like Schema. Not validated since optimize() does not pass AtomicResults.; opt_data = opt_object.close(); if core.get_option('OPTKING', 'WRITE_OPT_HISTORY'):; with open(f""{core.get_writer_file_prefix(molecule.name())}.opt.json"", 'w+') as f:; json.dump(opt_data, f, indent=2). if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif opt_status == 'FAILED':. print('Optimizer: Optimization failed!'); molecule.set_geometry(core.Matrix.from_array(opt_object.molsys.geom)); molecule.updat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:75998,optimiz,optimize,75998,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimize']
Performance,"ing that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. RESTART (CCLAMBDA)¶CCLAMBDA — Do restart the coupled-cluster iterations from old \(\lambda_1\) and \(\lambda_2\) amplitudes?. Type: boolean; Default: false. RESTART (CCRESPONSE)¶CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI)¶DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM)¶CCEOM — Do restart from on-disk?. Type: boolean; Default: false. RESTRICTED_DOCC (GLOBALS)¶GLOBALS — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (GLOBALS)¶GLOBALS — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING)¶OPTKING — Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX (OPTKING)¶OPTKING — Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT (OPTKING)¶OPTKING — Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RHF_TRIPLETS (CCEOM)¶CCEOM — Do form a triplet state from RHF reference?. Type: boolean; Default: false. RMS_DISP_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. RMS_FORCE_G_CONVERGENCE (OPTKING)¶OPTKING — Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_MOGRAD_CONVERGENCE (DF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:202876,optimiz,optimized,202876,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['optimiz'],['optimized']
Performance,"ing the number; of reactions sset should contain and the second being a list of; the reaction names (dbrxn) not available for modelchem. Absence; of benchmark not considered. get_reactions(modelchem, sset='default', benchmark='default', failoninc=True)[source]¶; Collects the reactions present in sset from each WrappedDatabase,; checks that modelchem and benchmark ReactionDatum are present; (fails if failoninc True), then returns in an array a tuple for; each reaction containing the modelchem key needed to access; modelchem, the modelchem key needed to access benchmark, and; the Reaction object. integer_reactions()[source]¶; Returns boolean of whether reaction names need to be cast to integer. load_qcdata_byproject(project, pythonpath=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; standard location for project :module dbse_project and function; load_project. Module search path can be prepended with pythonpath. load_qcdata_hdf5_trusted(project, path=None)[source]¶; For each component database, loads qcdb.ReactionDatums from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. load_qcdata_hrxn_byproject(project, path=None)[source]¶. load_saptdata_frombfdb(sset='default', pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True)[source]¶; This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. load_subsets(modname='subsetgenerator', pythonpath=None)[source]¶; For each component database, loads subsets from all functions; in module modname. Default modname usues standard generators. mcs = None¶; assembly pattern for transspecies modelchems; >>> print asdf.mcs.keys(); XXXX. plot_all_flats(modelchem=None, sset='default', xlimit=4.0, failoninc=True, saveas=None, relpath=False, graphicsformat=['pdf'])[source]¶; Generate pieces for inclusion into tables. Supply list of; modelchemistries to plot from modelchem, otherwi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:33214,load,loads,33214,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['load'],['loads']
Performance,"ing the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the convergence (STABILITY_CONVERGENCE) is not satisfied. Type: integer; Default: 200. STABILITY_N_EIGENVALUES¶. The number of Hessian eigenvalues computed during the stability check. Type: integer; Default: 3. STABILITY_N_GUESS_VECTORS¶. The number of guess vectors used for Davidson’s diagonalization in stability check. Type: integer; Default: 20. TIKHONOW_OMEGA¶. The shift applied to the denominator in the density cumulant update iterations. Type: double; Default: 0.0. TPDM¶. Controls whether to compute unrelaxed two-particle density matrix at the end of the energy computation. Type: boolean; Default: false. Table Of Contents. DCFT; General; ALGORITHM; AO_BASIS; DCFT_FUNCTIONAL; DIIS_START_CONVERGENCE; LAMBDA_MAXITER; MAXITER; QC_COUPLING; REFERENCE; RESPONSE_ALGORITHM; R_CONVERGENCE; SCF_MAXITER. Expert; CACHELEVEL; DAMPING_PERCENTAGE; DCFT_GUESS; DIIS_MAX_VECS; DIIS_MIN_VECS; IGNORE_TAU; INTS_TOLERANCE; LOCK_OCC; MO_RELAX; RELAX_GUESS_ORBITALS; RELAX_TAU; STABILITY_ADD_VECTORS; STABILITY_AUGMENT_SPACE_TOL; STABILITY_CHECK; STABILITY_CONVERGENCE; STABILITY_MAX_SPACE_SIZE; STABILITY_N_EIGENVALUES; STABILITY_N_GUESS_VECTORS; TIKHONOW_OMEGA; TPDM. Previous topic; TDHF_MEM_SAFETY_FACTOR; Next topic; ALGORITHM; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__dcft-1.html:6554,CACHE,CACHELEVEL,6554,psi4manual/4.0b4/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__dcft-1.html,2,['CACHE'],['CACHELEVEL']
Performance,"ing to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; 1; 2>>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). 1; 2>>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). 1; 2>>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cbs-1.html:19220,optimiz,optimization,19220,psi4manual/1.2.1/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cbs-1.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,"ing; Default: No Default. CHOLESKY_TOLERANCE¶. Tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1e-4. DF_BASIS_SCF¶. Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_SCF_GUESS¶. Use DF integrals tech to converge the SCF before switching to a conventional tech in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. GUESS¶. The type of guess orbitals. Defaults to SAD for RHF, GWH for ROHF and UHF, and READ for geometry optimizations after the first step. Type: string; Possible Values: AUTO, CORE, GWH, SAD, READ; Default: AUTO. GUESS_MIX¶. Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INDEPENDENT_J_TYPE¶. JK Independent options. Type: string; Possible Values: DIRECT_SCREENING; Default: DIRECT_SCREENING. INTS_TOLERANCE¶. Minimum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. PRINT_BASIS¶. Flag to print the basis set. Type: boolean; Default: false. PRINT_MOS¶. Flag to print the molecular orbitals. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:1490,optimiz,optimization,1490,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,4,['optimiz'],['optimization']
Performance,"ing; Default: No Default. CHOLESKY_TOLERANCE¶. Tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1e-4. DF_BASIS_SCF¶. Auxiliary basis set for SCF density fitting computations. Defaults to a JKFIT basis. Type: string; Possible Values: basis string; Default: No Default. DF_SCF_GUESS¶. Use DF integrals tech to converge the SCF before switching to a conventional tech in a SCF_TYPE DIRECT calculation. Type: boolean; Default: true. GUESS¶. The type of guess orbitals. Defaults to SAD for RHF, GWH for ROHF and UHF, and READ for geometry optimizations after the first step. Type: string; Possible Values: AUTO, CORE, GWH, SAD, READ; Default: AUTO. GUESS_MIX¶. Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST¶. If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. INTS_TOLERANCE¶. Minimum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. MAX_MEM_BUF¶. Max memory per buf for PK algo REORDER, for debug and tuning. Type: integer; Default: 0. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. PRINT_BASIS¶. Flag to print the basis set. Type: boolean; Default: false. PRINT_MOS¶. Flag to print the molecular orbitals. Type: boolean; Default: false. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html:1438,optimiz,optimization,1438,psi4manual/1.2.1/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html,2,['optimiz'],['optimization']
Performance,"ingle d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR); CFOUR — Specifies the used geometry optimization methods. Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:47684,optimiz,optimizations,47684,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,12,['optimiz'],"['optimizations', 'optimizer']"
Performance,"ingles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Psithon Functions: Invoking a Calculation; Single-Point Energy — energy(). © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/energy.html:38981,perform,perform,38981,psi4manual/master/energy.html,https://psicode.org,https://psicode.org/psi4manual/master/energy.html,2,['perform'],['perform']
Performance,"ining PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Installation and Runtime Configuration; Obtaining PSI4. Obtaining PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid.; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository (only path to develop PSI4); Tarball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac or Windows with Ubuntu Bash Shell. I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4. In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_obtaining-1.html:977,optimiz,optimization,977,psi4manual/1.4.0/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_obtaining-1.html,2,['optimiz'],['optimization']
Performance,"ining PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Installation and Runtime Configuration; Obtaining PSI4. Obtaining PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid.; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository (only path to develop PSI4); Tarball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac or Windows with Ubuntu Bash Shell. I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4. In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/build_obtaining-1.html:977,optimiz,optimization,977,psi4manual/1.5.0/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/build_obtaining-1.html,2,['optimiz'],['optimization']
Performance,"ining PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Installation and Runtime Configuration; Obtaining PSI4. Obtaining PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid.; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository (only path to develop PSI4); Tarball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac or Windows with Ubuntu Bash Shell. I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4. In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_obtaining.html:977,optimiz,optimization,977,psi4manual/1.6.x/build_obtaining.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_obtaining.html,1,['optimiz'],['optimization']
Performance,"ining PSI4. Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Installation and Runtime Configuration; Obtaining PSI4. Obtaining PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid.; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; Conda Binary Package; Clone from GitHub Repository; Fork from GitHub Repository (only path to develop PSI4); Tarball from GitHub Repository. Find-the-code Quiz¶; A better decision tree is available at psicode.org/installs/latest,; though the below remains valid. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base. Provided I still get good, threaded BLAS/LAPACK, OpenMP parallelism,; and optimization for a variety of processor architectures, I’m willing to forgo; architecture tuning wizardry to avoid compiling it myself. I’m on Linux or Mac or Windows with Ubuntu Bash Shell. I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself to eke out best performance on my; computer. I accept responsibility for navigating compiler, threading,; and BLAS/LAPACK compatibility. I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4. In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_obtaining.html:977,optimiz,optimization,977,psi4manual/1.7.x/build_obtaining.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_obtaining.html,1,['optimiz'],['optimization']
Performance,"inite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:50062,perform,perform,50062,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,6,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. mints6; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cbs-delta-energy; Extrapolated energies with delta correction. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. mints15; check SP basis Fortran exponent parsing. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. fci-coverage; 6-31G H2O Test fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:9043,optimiz,optimization,9043,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. RESTART (CCLAMBDA); CCLAMBDA — Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. RESTART (CCRESPONSE); CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do restart from on-disk?. Type: boolean; Default: false. RESTRICTED_DOCC (GLOBALS); GLOBALS — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (GLOBALS); GLOBALS — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING); OPTKING — Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX (OPTKING); OPTKING — Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT (OPTKING); OPTKING — Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RHF_TRIPLETS (CCEOM); CCEOM — Do form a triplet state from RHF reference?. Type: boolean; Default: false. RMS_DISP_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. RMS_FORCE_G_CONVERGENCE (OPTKING); OPTKING — Convergence criterion for geometry optmization: rms force (internal coordinates, atomic units). Type: conv double; Default: 3.0e-4. RMS_MOGRAD_CONVERGE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:196314,optimiz,optimized,196314,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; PSI4 is, in many ways, a whole new package compared to Psi3.; While some libraries and modules remain the same, the majority of the code has; been rewritten from scratch based on a powerful set of new libraries written; in C++. A totally new Python front-end makes PSI4 incredibly user-friendly; and automates many common tasks such as basis set extrapolation, composite; methods, running the same computation on every molecule in a test set, etc.; Density-functional theory, absent in Psi3, is quite efficient; in PSI4, with many functionals available. Density fitting is ubiquitous in; PSI4, leading to some of the most efficient MP2 and CCSD(T) code available.; PSI4 also introduces extensive,; powerful features for energy component analysis of non-covalent interactions; via symmetry-adapted perturbation theory. Orbital-optimized versions of; perturbation theory and coupled-cluster methods, and their analytic gradients,; have also been added. Through external libraries, PSI4 gains access to implicit; solvent (PCM) capabilities, density-matrix renormalization group CI, effective; fragment potentials, Grimme dispersion corrections, and high-order; coupled-cluster theory.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations whi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:1354,optimiz,optimized,1354,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,15,['optimiz'],['optimized']
Performance,"insensitive) set? Prefer has_variable(). has_global_option_changed(key); Whether keyword key value has been touched at global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay's MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay's MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer's scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:7346,optimiz,optimizer,7346,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['optimiz'],['optimizer']
Performance,"insensitive) set? Prefer has_variable(). has_global_option_changed(key); Whether keyword key value has been touched at global (all-module) scope. has_local_option_changed(module, key); Whether keyword key value has been touched at module scope. has_option_changed(module, key); Whether keyword key value has been touched or is default. has_scalar_variable(key); Is the double QCVariable key (case-insensitive) set? Prefer has_variable(). has_variable(key); Whether scalar or array QCVariable key has been set in global memory. initialize(); Called upon psi4 module import to initialize timers, singletons, and I/O. legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(ref_wfn); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(module, key); Whether keyword key is a valid keyword for module. options_to_python(arg0); Get dictionary of whether options of module have changed. optking(); Runs the geometry optimization code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(name); Sets up the options library to return options pertaining to the module or plugin name (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints to output file all QCVariables that have been set in global memory. psi_top_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psi4api-1.html:7259,optimiz,optimizer,7259,psi4manual/1.4.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psi4api-1.html,2,['optimiz'],['optimizer']
Performance,"install_path>!. export BRIANQC_INSTALL_PATH=<brianqc_install_path>; bin/sample_hf_and_dft --molecule ../share/qc_molecules/cis-decalin.raw --basis ../share/basis_sets/cc-pvdz. Building PSI4 with BrianQC¶; When CMake-ing PSI4, set the ENABLE_BrianQC CMake variable to 1; and set the BrianQC_DIR CMake variable to the path where BrianQC’s; components have been built (usually <brianqc_install_path>/build), then build PSI4 normally. Using BrianQC from PSI4¶; To use BrianQC, the BRIANQC_INSTALL_PATH environment variable; must be set to the full path of your BrianQC installation.; There are two ways to enable BrianQC for a specific calculation:. setting the BRIANQC_ENABLE input option to True;; setting the BRIANQC_ENABLE environment variable to 1. If both the input option and the environment variable are specified,; then the environment variable takes precedence. When to enable BrianQC¶; The operation of BrianQC is transparent from a user’s point of view; every; internal computation is either performed by PSI4 (if unsupported by BrianQC),; or taken over by BrianQC, yielding the same result to within the required; precision. In particular, BrianQC will respect all of PSI4’s usual precision; parameters, like INTS_TOLERANCE and E_CONVERGENCE.; BrianQC can speed up a number of internal computations, including Fock and; gradient computation. Thus, BrianQC will speed up any calculation involving; those terms, such as. HF and DFT single point energies; HF and DFT geometry optimizations; HF and DFT frequency analysis. Note that not every term of every calculation can be handled by BrianQC, thus,; the actual speedup depends on the specifics of the calculation. Necessary and recommended option values¶; To ensure that a calculation works with BrianQC, the following options need to; be set when enabling BrianQC:. BrianQC currently only handles the C1 molecular symmetry point group. Thus, if; the molecule has any symmetries (which PSI4 would detect by default), the; input geometry must ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/brianqc-1.html:2637,perform,performed,2637,psi4manual/1.4.0/brianqc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/brianqc-1.html,9,['perform'],['performed']
Performance,"insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. table of contents. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Theoretical Methods: SCF to FCI; DCT: Density Cumulant Theory. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/dct.html:15384,perform,performing,15384,psi4manual/master/dct.html,https://psicode.org,https://psicode.org/psi4manual/master/dct.html,1,['perform'],['performing']
Performance,"int CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/opt-rhf-mp2; optimization MP2/cc-pvtz on water. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/kw-1; testing best practices options, part i. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-cc3; single-point CC3/qz2p ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html:2904,optimiz,optimization,2904,psi4manual/1.6.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"int to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , performs scaling with . Type: string; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of a nucleic acid base pair), more; accurate interaction energies can be obtained through high",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:10623,perform,performs,10623,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performs']
Performance,"int(""""""filedict = mpl.valerr(%s,\n color='%s',\n title='%s',\n xtitle='%s',\n view=%s\n saveas=%s\n relpath=%s\n graphicsformat=%s)\n\n"""""" %; (dbdat, color, title, axis, view, repr(saveas), repr(relpath), repr(graphicsformat))); else:; # if running from Canopy, call mpl directly; filedict = mpl.valerr(dbdatdict, color=color, title=title, xtitle=axis,; view=view,; saveas=saveas, relpath=relpath, graphicsformat=graphicsformat); return filedict. [docs] def load_saptdata_frombfdb(self, sset='default',; pythonpath='/Users/loriab/linux/bfdb/sapt_punt', failoninc=True): # pythonpath=None; """"""This is a stopgap function that loads sapt component data from; sapt_punt in bfdb repo. """"""; saptpackage = OrderedDict(); for db, odb in self.dbdict.items():; modname = 'sapt_' + odb.dbse; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../data'); try:; datamodule = __import__(modname); except ImportError:; print(""""""\nPython module for database data %s failed to load\n\n"""""" % (modname)); print(""""""\nSearch path that was tried:\n""""""); print(', '.join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database subset generator "" + str(modname)). try:; saptdata = getattr(datamodule, 'DATA'); except AttributeError:; raise ValidationError(""SAPT punt module does not contain DATA"" + str(modname)); saptmc = saptdata['SAPT MODELCHEM']. dbix = self.dbdict.keys().index(db); for rxn, orxn in odb.hrxn.iteritems():; lss = self.sset[sset][dbix]; if lss is not None:; if rxn in odb.sset[lss]:; dbrxn = orxn.dbrxn; try:; elst = saptdata['SAPT ELST ENERGY'][dbrxn]; exch = saptdata['SAPT EXCH ENERGY'][dbrxn]; ind = saptdata['SAPT IND ENERGY'][dbrxn]; disp = saptdata['SAPT DISP ENERGY'][dbrxn]; except (KeyError, AttributeError):; print(""""""Warning: DATA['SAPT * ENERGY'] missing for reaction %s"""""" % (dbrxn)); if failoninc:; break; else:; if not all([elst, ind, disp]): # exch sometimes physically zero; print(""""""Warning: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:65168,load,load,65168,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['load']
Performance,"int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self: psi4.core.Matrix, alpha: float, cutoff: ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:11037,Load,Load,11037,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,3,['Load'],['Load']
Performance,"int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serial",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11380,Load,Load,11380,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,1,['Load'],['Load']
Performance,"int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11445,Load,Load,11445,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,1,['Load'],['Load']
Performance,"int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11394,Load,Load,11394,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,1,['Load'],['Load']
Performance,"int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be seria",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11374,Load,Load,11374,psi4manual/1.8.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html,1,['Load'],['Load']
Performance,"inted to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. 1; 2; 3; 4; 5; 6>>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/opt-1.html:5626,optimiz,optimize,5626,psi4manual/1.2.1/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/opt-1.html,2,['optimiz'],['optimize']
Performance,"integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CALC_S_SQUARED (DETCI); DETCI — Do calculate the value of \(\langle S^2\rangle\) for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CC (DETCI); DETCI — Do coupled-cluster computation?. Type: boolean; Default: false. CC3_FOLLOW_ROOT (CCEOM); CCEOM ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:10414,cache,cache,10414,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['cache'],['cache']
Performance,"integer; Default: 30. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. Table Of Contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_DIIS_MAX_VECS; CC_DIIS_MIN_VECS; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_DIIS_NUM_VECS; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; MP2_TYPE; NAT_ORBS; OCC_ORBS_PRINT; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; TPDM_ABCD_TYPE; WFN_TYPE. Previous topic; MRCC_RESTART; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta4] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Apr 25, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html:7512,CACHE,CACHELEVEL,7512,psi4manual/4.0b4/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__occ-1.html,4,['CACHE'],['CACHELEVEL']
Performance,"integer; Default: 30. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5; Default: OMP2. Table Of Contents. OCC; General; CACHELEVEL; CCL_ENERGY; CC_DIIS_MAX_VECS; CC_DIIS_MIN_VECS; CC_MAXITER; CEPA_OS_SCALE; CEPA_SOS_SCALE; CEPA_SS_SCALE; CEPA_TYPE; CUTOFF; DO_DIIS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; EA_POLES; EKT_EA; EKT_IP; EP_EA_POLES; EP_IP_POLES; EP_MAXITER; E_CONVERGENCE; IP_POLES; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MOGRAD_DAMPING; MO_DIIS_NUM_VECS; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; MP2_SS_SCALE; MP2_TYPE; NAT_ORBS; OCC_ORBS_PRINT; OPT_METHOD; ORB_OPT; ORB_RESP_SOLVER; ORTH_TYPE; PCG_BETA_TYPE; PCG_CONVERGENCE; PCG_MAXITER; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_TYPE; TPDM_ABCD_TYPE; WFN_TYPE. Previous topic; MRCC_RESTART; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Appendices »; Keywords by Module ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__occ-1.html:7512,CACHE,CACHELEVEL,7512,psi4manual/4.0b5/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__occ-1.html,4,['CACHE'],['CACHELEVEL']
Performance,"integer; Default: 5. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html:7181,perform,perform,7181,psi4manual/1.5.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"interal superfunctional. get_block(self, arg0); Returns the requested BlockOPoints. get_np_xyzw(); Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects. grid(self); Returns the grid object. initialize(*args, **kwargs); Overloaded function. nblocks(self); Total number of blocks. print_header(self); Prints the objects header. properties(self); Returns the properties computer. quadrature_values(self); Returns the quadrature values. set_D(self, arg0); Sets the internal density. set_debug(self, arg0); Sets the debug level of the object. set_print(self, arg0); Sets the print level of the object. Methods Documentation. Dao(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; Returns internal AO density. basis(self: psi4.core.VBase) → psi4.core.BasisSet¶; Returns the internal basis set. build(arg0: psi4.core.BasisSet, arg1: psi4.core.SuperFunctional, arg2: str) → psi4.core.VBase¶. build_collocation_cache(self: psi4.core.VBase, arg0: int) → None¶; Constructs a collocation cache to prevent recomputation. clear_collocation_cache(self: psi4.core.VBase) → None¶; Clears the collocation cache. compute_V(self: psi4.core.VBase, arg0: List[psi4.core.Matrix]) → None¶; doctsring. compute_Vx(self: psi4.core.VBase, arg0: List[psi4.core.Matrix], arg1: List[psi4.core.Matrix]) → None¶; doctsring. compute_gradient(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear gradient contribution. compute_hessain(self: psi4.core.VBase) → psi4.core.Matrix¶; Compute the DFT nuclear Hessian contribution. finalize(*args, **kwargs)¶; Overloaded function. finalize(self: psi4.core.VBase) -> None. doctsring. finalize(self: psi4.core.VBase) -> None. Finalizes the V object. functional(self: psi4.core.VBase) → psi4.core.SuperFunctional¶; Returns the interal superfunctional. get_block(self: psi4.core.VBase, arg0: int) → psi::BlockOPoints¶; Returns the requested BlockOPoints. get_np_xyzw()¶; Returns the x, y, z, and weights of a grid as a tuple of NumPy array objects",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vbase.html:1791,cache,cache,1791,psi4manual/1.3.2/api/psi4.core.vbase.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.vbase.html,1,['cache'],['cache']
Performance,"interfragment stretching coordinate instead of R. Type: boolean; Default: false. INTERFRAG_HESS¶. Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, PRINCIPAL_AXES; Default: FIXED. Misc.¶. OPT_RESTART¶. Restart the optimization from optking’s written history. Type: double; Default: 0. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. SAVE_OPTIMIZATION¶. Save OptKing’s internal classes for possible restart upon error. Type: boolean; Default: false. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. WRITE_OPT_HISTORY¶. Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT¶. Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY¶. Write Optimization Trajectory. Type: boolean; Default: false. table of contents. OPTKING; Optimization Algorithm; CARTESIAN_SYM_TOLERANCE; CONSECUTIVE_BACKSTEPS; CUSTOM_COORDS; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; EXT_FORCE_BEND; EXT_FORCE_CARTESIAN; EXT_FORCE_DIHEDRAL; EXT_FORCE_DISTANCE; EXT_FORCE_OOFP; FREEZE_ALL_DIHEDRALS; FROZEN_BEND; FROZEN_CARTESIAN; FROZEN_DIHEDRAL; FROZEN_DISTANCE; FROZEN_OOFP; GEOM_MAXITER; H_UPDATE_DEN_TOL; INTERFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT_MAX; INTRAFRAG_STEP_LIMIT_MIN; IRC_DIRECTION; IRC_POINTS; IRC_STEP_SIZE; OPT_COORDINATES; OPT_TYPE; PRINT_OPT_PARAMS; RANGED_BEND; RANGED_DIHEDRAL; RANGED_DISTANCE; RANGED_OOFP; RFO_FOLLOW_ROOT; RFO_NORMALIZATION_MAX; RFO_ROOT; RSRFO_ALPHA_MAX; STEP_TYPE; UNFREEZE_DIHEDRALS. Convergence Control; FLEXIBLE_G_CONVERGENCE; G_C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html:11029,Optimiz,OptimizationResult,11029,psi4manual/master/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__optking.html,1,['Optimiz'],['OptimizationResult']
Performance,"interfragment stretching coordinate instead of R. Type: boolean; Default: false. INTERFRAG_HESS¶. Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, PRINCIPAL_AXES; Default: FIXED. Misc.¶. OPT_RESTART¶. Restart the optimization from optking’s written history. Type: double; Default: 0. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. SAVE_OPTIMIZATION¶. Save OptKing’s internal classes for possible restart upon error. Type: boolean; Default: false. TEST_B¶. Do test B matrix?. Type: boolean; Default: false. TEST_DERIVATIVE_B¶. Do test derivative B matrix?. Type: boolean; Default: false. WRITE_OPT_HISTORY¶. Write the full history to disk. Produces a non validated OptimizationResult. Type: boolean; Default: false. WRITE_OPT_RESULT¶. Write the optimization history / state to disc. Type: boolean; Default: false. WRITE_TRAJECTORY¶. Write Optimization Trajectory. Type: boolean; Default: false. table of contents. OPTKING; Optimization Algorithm; CARTESIAN_SYM_TOLERANCE; CONSECUTIVE_BACKSTEPS; DYNAMIC_LEVEL; ENSURE_BT_CONVERGENCE; EXT_FORCE_BEND; EXT_FORCE_CARTESIAN; EXT_FORCE_DIHEDRAL; EXT_FORCE_DISTANCE; EXT_FORCE_OOFP; FROZEN_BEND; FROZEN_CARTESIAN; FROZEN_DIHEDRAL; FROZEN_DISTANCE; FROZEN_OOFP; GEOM_MAXITER; H_UPDATE_DEN_TOL; INTERFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT; INTRAFRAG_STEP_LIMIT_MAX; INTRAFRAG_STEP_LIMIT_MIN; IRC_DIRECTION; IRC_POINTS; IRC_STEP_SIZE; OPT_COORDINATES; OPT_TYPE; PRINT_OPT_PARAMS; RANGED_BEND; RANGED_DIHEDRAL; RANGED_DISTANCE; RANGED_OOFP; RFO_FOLLOW_ROOT; RFO_NORMALIZATION_MAX; RFO_ROOT; RSRFO_ALPHA_MAX; STEP_TYPE. Convergence Control; FLEXIBLE_G_CONVERGENCE; G_CONVERGENCE; MAX_DISP_G_CONVERGENCE; MAX_ENERGY_G_CONVERGE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html:10506,Optimiz,OptimizationResult,10506,psi4manual/1.7.x/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html,3,['Optimiz'],['OptimizationResult']
Performance,"internal coordinates and then stop?. Type: boolean; Default: false. INTERFRAGMENT_CONNECT¶. When connecting disparate fragments when frag_mode = SIMPLE, a “bond” is assigned if interatomic distance is less than (this number) * sum of covalent radii. The value is then increased until all the fragments are connected (directly or indirectly). Type: double; Default: 1.8. INTERFRAG_DIST_INV¶. Do use for the stretching coordinate between fragments? Otherwise, use . Type: boolean; Default: false. INTERFRAG_HESS¶. Model Hessian to guess interfragment force constants. Type: string; Possible Values: DEFAULT, FISCHER_LIKE; Default: DEFAULT. INTERFRAG_MODE¶. When interfragment coordinates are present, use as reference points either principal axes or fixed linear combinations of atoms. Type: string; Possible Values: FIXED, PRINCIPAL_AXES; Default: FIXED. Misc.¶. FINAL_GEOM_WRITE¶. Do save and print the geometry from the last projected step at the end of a geometry optimization? Otherwise (and by default), save and print the previous geometry at which was computed the gradient that satisfied the convergence criteria. Type: boolean; Default: false. FIXED_COORD_FORCE_CONSTANT¶. In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. KEEP_INTCOS¶. Keep internal coordinate definition file. Type: boolean; Default: false. LINESEARCH_STATIC_MAX¶. If doing a static line search, this fixes the largest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.100. LINESEARCH_STATIC_MIN¶. If doing a static line search, this fixes the shortest step, whose largest change in an internal coordinate is set to this value (in au). Type: double; Default: 0.001. LINESEARCH_STATIC_N¶. If doing a static line search, scan this many points. Type: integer; Default: 8. TEST_B¶. Do test B matrix?. Type: b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html:8648,optimiz,optimization,8648,psi4manual/1.0.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html,2,['optimiz'],['optimization']
Performance,"internal coordinates such; as torsions become poorly defined when they contain near-linear bends.; An internal error AlgError may be raised in such cases. Optking will avoid such; coordinates when choosing an initial coordinate system; however, they may arise in the course; of an optimization. In such cases, try restarting from the most recent geometry.; Alternatively, setting OPT_COORDINATES to cartesian will avoid any internal; coordinate difficulties altogether. These coordinate changes can be automatically; performed by turning DYNAMIC_LEVEL to 1. Warning; In some cases, such as the coordinate issues described above, optking will reset to maintain; a consistent history. If an error occurs in Psi4 due to GEOM_MAXITER being exceeded but; the final step report indicates that optking has not taken GEOM_MAXITER steps, such a; reset has occured. Inspection will show that the step counter was reset to 1 somewhere in the; optimization. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; G_CONVERGENCE which sets the aforementioned in accordance; with Table Geometry Convergence. Summary of sets of geometry optimization criteria available in PSI4¶. G_CONVERGENCE; Max Energy; Max Force; RMS Force; Max Disp; RMS Disp. NWCHEM_LOOSE [4]. \(4.5 \times 10^{-3}\); \(3.0 \times 10^{-3}\); \(5.4 \times 10^{-3}\); \(3.6 \times 10^{-3}\). GAU_LOOSE [6]. \(2.5 \times 10^{-3}\); \(1.7 \times 10^{-3}\); \(1.0 \times 10^{-2}\); \(6.7 \ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:18287,optimiz,optimization,18287,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,4,['optimiz'],['optimization']
Performance,"internal name of database; #:; #: >>> print asdf.dbse; #: 'NBC1'; self.dbse = None. #: description line; #:; #: >>> print asdf.tagl; #: 'interaction energies of dissociation curves for non-bonded systems'; self.tagl = None. #: OrderedDict of reactions/members; #:; #: >>> print asdf.hrxn.keys(); #: ['BzBz_S-3.2', 'BzBz_S-3.3', ... 'BzBz_PD36-2.8', 'BzBz_PD36-3.0']; self.hrxn = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self.dbse = database.dbse; try:; self.tagl = database.TAGL['dbse']; except KeyError:; print(""""""Warning: TAGL missing for da",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:21807,load,load,21807,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['load']
Performance,"into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_column",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:2808,Load,Loads,2808,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,3,['Load'],['Loads']
Performance,"ints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_dr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:58254,Optimiz,Optimizer,58254,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['Optimiz'],['Optimizer']
Performance,"inue. # The last 'ene' in iface is the one the user requested.; ref_wfn.set_variable('CURRENT ENERGY', ene); ref_wfn.set_variable('CURRENT CORRELATION ENERGY', ene - vscf). for subm in [""MP2"", ""CCSD""]:; if ref_wfn.has_variable(f""{subm} TOTAL ENERGY"") and core.get_option(""SCF"", ""REFERENCE"") in [""RHF"", ""UHF""]:; ref_wfn.set_variable(f""{subm} SINGLES ENERGY"", 0.0); ref_wfn.set_variable(f""{subm} DOUBLES ENERGY"", ref_wfn.variable(f""{subm} CORRELATION ENERGY"")). if ref_wfn.has_variable(""CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""(T) CORRECTION ENERGY"", ref_wfn.variable(""CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). if ref_wfn.has_variable(""A-CCSD(T) CORRELATION ENERGY"") and ref_wfn.has_variable(""CCSD CORRELATION ENERGY""):; ref_wfn.set_variable(""A-(T) CORRECTION ENERGY"", ref_wfn.variable(""A-CCSD(T) CORRELATION ENERGY"") - ref_wfn.variable(""CCSD CORRELATION ENERGY"")). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep is False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Return to submission directory; os.chdir(current_directory). # If we're told to keep the files or the user provided a path, do nothing.; if keep or ('path' in kwargs):; core.print_out('\nMRCC scratch files have been kept.\n'); core.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; core.print_out('\n'); p4util.banner('Full results from MRCC'); core.print_out('\n'); core.print_out(iface_contents). # Shove variables into global space; for k, v in ref_wfn.variables().items():; core.set_variable(k, v). core.print_variables(); return ref_wfn. def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a [FNO-](DF|CD)-CCSD[(T)] ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:165541,Load,Load,165541,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,4,['Load'],['Load']
Performance,"inuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than nor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:23675,Perform,Performing,23675,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Perform'],['Performing']
Performance,"inuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:26144,Perform,Performing,26144,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Perform'],['Performing']
Performance,"ion Functional. x1b95; X1B95 Hyb-GGA Exchange-Correlation Functional. x3lyp; X3LYP Hyb-GGA Exchange-Correlation Functional. x3lyp-d3bj;  . xb1k; XB1K Hyb-GGA Exchange-Correlation Functional. xlyp; XLYP GGA Exchange-Correlation Functional. xlyp-d3bj;  . zlp; ZLP GGA Exchange-Correlation Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). 1; 2; 3; 4; 5; 6; 7; 8>>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html:12345,optimiz,optimization,12345,psi4manual/1.2.1/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.opt-1.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,"ion can be used alongside; Psi4’s separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction; algorithm when specifying SCF_TYPE to use a composite algorithm combination (DFDIRJ+K_alg).; DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI; screening (set SCREENING to DENSITY) and incremental Fock matrix construction (set INCFOCK to TRUE). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. COSX Exchange¶; The semi-numerical COSX algorithm described in [Neese:2009:98] evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in DFT: Density Functional Theory.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; The SCF algorithm is first converged on a smaller grid, followed by a final SCF; iteration on a larger grid. This results in numerical errors comparable to; performing the entire SCF on the expensive larger grid at a computational cost; much closer to the smaller grid. The size of the initial grid is controlled by the; keywords COSX_RADIAL_POINTS_INITIAL and COSX_SPHERICAL_POINTS_INITIAL.; The final grid is controlled by COSX_RADIAL_POINTS_FINAL and; COSX_SPHERICAL_POINTS_FINAL. The defaults for both grids aim to balance; cost and accuracy.; Screening thresholds over integrals, densities, and basis extents are set; with the COSX_INTS_TOLERANCE, COSX_DENSITY_TOLERANCE, and; COSX_BASIS_TOLERANCE key",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:35704,perform,performed,35704,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,1,['perform'],['performed']
Performance,"ion complete!'); PsiMod.get_active_molecule().print_in_input_format(); # Check if user wants to see the intcos; if so, don't delete them.; if (PsiMod.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False):; PsiMod.opt_clean(); PsiMod.clean(). # S/R: Clean up opt input file; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; fmaster = open('OPT-master.in', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write('# Optimization complete!\n\n'); fmaster.close(). optstash.restore(); return thisenergy. PsiMod.print_out('\n Structure for next step:\n'); PsiMod.get_active_molecule().print_out_in_angstrom(). # S/R: Preserve opt data file for next pass and switch modes to get new displacements; if ('mode' in kwargs) and (kwargs['mode'].lower() == 'reap'):; kwargs['opt_datafile'] = get_psifile(1); kwargs['mode'] = 'sow'. n += 1. PsiMod.print_out('\tOptimizer: Did not converge!'); optstash.restore(); return 0.0. ## Aliases ##; opt = optimize. [docs]def parse_arbitrary_order(name):; r""""""Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. """"""; namelower = name.lower(). # matches 'mrccsdt(q)'; if namelower.startswith('mrcc'):; # grabs 'sdt(q)'; ccfullname = namelower[4:]. # A negative order indicates perturbative method; methods = {; 'sd' : { 'method' : 1, 'order' : 2, 'fullname' : 'CCSD' },; 'sdt' : { 'method' : 1, 'order' : 3, 'fullname' : 'CCSDT' },; 'sdtq' : { 'method' : 1, 'order' : 4, 'fullname' : 'CCSDTQ' },; 'sdtqp' : { 'method' : 1, 'order' : 5, 'fullname' : 'CCSDTQP' },; 'sdtqph' : { 'method' : 1, 'order' : 6, 'fullname' : 'CCSDTQPH' },; 'sd(t)' : { 'method' : 3, 'order' : -3, 'fullname' : 'CCSD(T)' },; 'sdt(q)' : { 'method' : 3, 'order' : -4, 'fullname' : 'CCSDT(Q)' },; 'sdtq(p)' : { 'method' : 3, 'order' : -5, 'fullname' : 'CCSDTQ(P)' },; 'sdtqp(h)' : { 'method' : 3, 'order' : -6, 'fullname' : 'CCSDTQP(H)' },; 'sd(t)_l' : ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:41945,optimiz,optimize,41945,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['optimiz'],['optimize']
Performance,"ion correction for a neon trimer could; be computed with:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Footnotes. 1; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. 12; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dispersion programs can be run independently of the scf; through the python function run_dftd3() or run_dftd4(). (These functions; call QCEngine, which is the same PSI4 + dftd3/dftd4 interface that is called during an scf job.); This “D-only” route is much faster than running a DFT-D energy.; Note that in a DFT+D energy or gradient calculation, user-specified; dispersion parameters override any information provided about the; functional. The same holds true for a dftd3 “D-only” calculation. But; in a dftd4 “D-only” calculation, functional information overrides; any user-specified dispersion para",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:8894,optimiz,optimization,8894,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['optimiz'],['optimization']
Performance,"ion coupled cluster code, for excited states. cchbar((arg0: psi::Wavefunction) -> None); Runs the code to generate the similarity transformed Hamiltonian. cclambda(...); Runs the coupled cluster lambda equations code. ccresponse((arg0: psi::Wavefunction) -> float); Runs the coupled cluster response theory code. cctransort((arg0: psi::Wavefunction) -> None); Runs CCTRANSORT, which transforms and reorders integrals for use in the coupled cluster codes. cctriples((arg0: psi::Wavefunction) -> float); Runs the coupled cluster (T) energy code. clean(() -> None); Function to remove scratch files. clean_options(() -> None); Function to reset options to clean state. clean_variables(() -> None); Empties all PSI variables that have set internally. close_outfile(() -> None); Closes the output file. dcft(...); Runs the density cumulant functional theory code. detci(...); Runs the determinant-based configuration interaction code. dfmp2(...); Runs the DF-MP2 code. dfocc(...); Runs the density-fitted orbital optimized CC codes. displace_atom((arg0: psi::Matrix, arg1: int, ...); Displaces one coordinate of single atom. dmrg(...); Runs the DMRG code. efp_init(() -> psi4.core.EFP); Initializes the EFP library and returns an EFP object. efp_set_options(() -> None); Set EFP options from environment options object. fd_1_0((arg0: psi::Molecule, ...); Performs a finite difference gradient computation, from energy points. fd_freq_0((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference frequency computation, from energy points, for a given irrep. fd_freq_1((arg0: psi::Molecule, arg1: list, ...); Performs a finite difference frequency computation, from gradients, for a given irrep. fd_geoms_1_0(...); Gets list of displacements needed for a finite difference gradient computation, from energy points. fd_geoms_freq_0((arg0: psi::Molecule, ...); Gets list of displacements needed for a finite difference frequency computation, from energy points, for a given irrep. fd_geoms_freq_1((a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:163405,optimiz,optimized,163405,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['optimiz'],['optimized']
Performance,"ion for energy (change). Type: conv double; Default: 1e-7. FOCK_TOLERANCE¶. Minimum absolute value below which parts of the Fock matrix are skipped. Type: conv double; Default: 1e-2. INTS_TOLERANCE¶. Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-7. LOCAL_CUTOFF¶. Localization cutoff. Type: double; Default: 0.02. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. MEMORY¶. The amount of memory available (in Mb). Type: integer; Default: 2000. MP2_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. NEGLECT_DISTANT_PAIR¶. Do neglect distant pairs?. Type: boolean; Default: true. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. SCREEN_INTS¶. Do screen integrals?. Type: boolean; Default: false. SCS¶. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS_N¶. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: LMP2. Table Of Contents. LMP2; General; DF_BASIS_MP2; DF_LMP2; DIIS; DIIS_MAX_VECS; DIIS_START_ITER; DISTANT_PAIR_CUTOFF; DOMAIN_PRINT_EXIT; E_CONVERGENCE; FOCK_TOLERANCE; INTS_TOLERANCE; LOCAL_CUTOFF; MAXITER; MEMORY; MP2_OS_SCALE; MP2_SS_SCALE; NEGLECT_DISTANT_PAIR; REFERENCE; R_CONVERGENCE; SCREEN_INTS; SCS; SCS_N. Expert; WFN. Previous topic; POINTS; Next topic; DF_BASIS_MP2; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__lmp2-1.html:2152,optimiz,optimized,2152,psi4manual/4.0b3/autodir_options_c/module__lmp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__lmp2-1.html,4,['optimiz'],['optimized']
Performance,"ion for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions. PSIthonPsiAPI# E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = psi4.energy(...); E = psi4.optimize(...); E = psi4.frequency(...); G = psi4.gradient(...) # used by optimize(); H = psi4.hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction. PSIthonPsiAPI# power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). # power user returns; E, wfn = psi4.energy(..., return_wfn=True); E, wfn = psi4.optimize(..., return_wfn=True); E, wfn = psi4.frequency(..., return_wfn=True); G, wfn = psi4.gradient(..., return_wfn=True) # used by optimize(); H, wfn = psi4.hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print(wfn.gradient().rms()). # format output for other programs; psi4.molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:11131,optimiz,optimize,11131,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['optimiz'],['optimize']
Performance,"ion of Da (SO->MO); >>> E, wfn = properties('ccsd', properties=['dipole'], return_wfn=True); >>> Da_so = wfn.Da(); >>> SCa = core.doublet(wfn.S(), wfn.Ca(), False, False); >>> Da_mo = core.triplet(SCa, Da_so, SCa, True, False, False); >>> molden(wfn, 'ccsd_no.molden', density_a=Da_mo). """""". if filename is None:; filename = core.get_writer_file_prefix(wfn.molecule().name()) + "".molden"". if dovirtual is None:; dovirt = bool(core.get_option(""SCF"", ""MOLDEN_WITH_VIRTUAL"")). else:; dovirt = dovirtual. if density_a:; nmopi = wfn.nmopi(); nsopi = wfn.nsopi(). NO_Ra = core.Matrix(""NO Alpha Rotation Matrix"", nmopi, nmopi); NO_occa = core.Vector(nmopi); density_a.diagonalize(NO_Ra, NO_occa, core.DiagonalizeOrder.Descending); NO_Ca = core.Matrix(""Ca Natural Orbitals"", nsopi, nmopi); NO_Ca.gemm(False, False, 1.0, wfn.Ca(), NO_Ra, 0). if density_b:; NO_Rb = core.Matrix(""NO Beta Rotation Matrix"", nmopi, nmopi); NO_occb = core.Vector(nmopi); density_b.diagonalize(NO_Rb, NO_occb, core.DiagonalizeOrder.Descending); NO_Cb = core.Matrix(""Cb Natural Orbitals"", nsopi, nmopi); NO_Cb.gemm(False, False, 1.0, wfn.Cb(), NO_Rb, 0). else:; NO_occb = NO_occa; NO_Cb = NO_Ca. mw = core.MoldenWriter(wfn); mw.write(filename, NO_Ca, NO_Cb, NO_occa, NO_occb, NO_occa, NO_occb, dovirt). else:; try:; occa = wfn.occupation_a(); occb = wfn.occupation_b(); except AttributeError:; core.print_out(""\n!Molden warning: This wavefunction does not have occupation numbers.\n""; ""Writing zero's for occupation numbers\n\n""); occa = core.Vector(wfn.nmopi()); occb = core.Vector(wfn.nmopi()). mw = core.MoldenWriter(wfn); mw.write(filename, wfn.Ca(), wfn.Cb(), wfn.epsilon_a(), wfn.epsilon_b(), occa, occb, dovirt). # Aliases; opt = optimize; freq = frequency; frequencies = frequency; prop = properties. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  · ; 1.3.2;  · . PSI4. Module code. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:84872,optimiz,optimize,84872,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"ion of both the Coulomb and Exchange parts; of the Fock Matrix:. PK [Default]An out-of-core, presorted algorithm using exact ERIs. Quite fast for a; zero-error algorithm if enough memory is available. Integrals are; generated only once, and symmetry is utilized to reduce number of; integrals. OUT_OF_COREAn out-of-core, unsorted algorithm using exact ERIs. Overcomes the; memory bottleneck of the current PK algorithm. Integrals are generated; only once, and symmetry is utilized to reduce number of integrals. DIRECTA threaded, sieved, integral-direct algorithm, with full permutational; symmetry. This algorithm is brand new, but seems to be reasonably fast; up to 1500 basis functions, uses zero disk (if DF pre-iterations are; turned off), and can obtain significant; speedups with negligible error loss if INTS_TOLERANCE; is set to 1.0E-8 or so. DF [Default]A density-fitted algorithm designed for computations with thousands of; basis functions. This algorithm is highly optimized, and is threaded; with a mixture of parallel BLAS and OpenMP. Note that this algorithm; should use the -JKFIT series of auxiliary bases, not the -RI or; -MP2FIT bases. The default guess for auxiliary basis set should work; for most bases, otherwise the DF_BASIS_SCF keyword can; be used to manually specify the auxiliary basis. This algorithm is; preferred unless either absolute accuracy is required; [\(\gtrsim\)CCSD(T)] or a -JKFIT auxiliary basis is unavailable; for the orbital basis/atoms involved. CDA threaded algorithm using approximate ERIs obtained by Cholesky; decomposition of the ERI tensor. The accuracy of the Cholesky; decomposition is controlled by the keyword CHOLESKY_TOLERANCE.; This algorithm is similar to the DF algorithm, but it is not suitable; for gradient computations. The algorithm to obtain the Cholesky; vectors is not designed for computations with thousands of basis; functions. PSI4 also features the capability to use “composite” Fock matrix build; algorithms - arbitrary combi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/scf.html:26603,optimiz,optimized,26603,psi4manual/1.8.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/scf.html,3,['optimiz'],['optimized']
Performance,"ion of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; CI: Configuration Interaction. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:15219,perform,perform,15219,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,2,['perform'],['perform']
Performance,"ion of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Spin Multiplicities of Higher Roots; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; CI: Configuration Interaction. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/detci-1.html:15219,perform,perform,15219,psi4manual/1.5.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/detci-1.html,2,['perform'],['perform']
Performance,"ion of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). table of contents. Complete Basis Set; Output; Extrapolation Schemes; Aliases. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2019, The Psi4 P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/cbs-1.html:21592,perform,performed,21592,psi4manual/1.3.2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/cbs-1.html,2,['perform'],['performed']
Performance,"ion of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:12673,perform,perform,12673,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,2,['perform'],['perform']
Performance,"ion options are available; How to install elsewhere than /usr/local/psi4; How to compile for debugging; How to fix error “RuntimeError: value for ERI“; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set PSIDATADIR and why; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct“; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Installation and Runtime Configuration. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:43807,queue,queue,43807,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['queue'],['queue']
Performance,"ion property() (instead of, for example, energy(),; e.g., property('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cc-1.html:4434,optimiz,optimizations,4434,psi4manual/4.0b2/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cc-1.html,4,['optimiz'],['optimizations']
Performance,"ion step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). engine = kwargs.pop('engine', 'optking'); if engine == 'geometric':; return optimize_geometric(name, **kwargs); elif engine != 'optking':; raise ValidationError(f""Optimizer {engine} is not supported.""). import optking. name = driver_util.upgrade_interventions(name); if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False). # This might be incorrect now?; if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). _filter_renamed_methods(""optimize"", lowername). optstash = p4util.OptionsState(; ['FINDIF', 'HESSIAN_WRITE'],; ['OPTKING', 'CART_HESS_READ'],; ['SCF', 'GUESS_PERSIST'], # handle on behalf of cbs(); ['SCF', 'GUESS']). n = kwargs.get('opt_iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if any([core.get_option('OPTKING', 'FROZEN_CARTESIAN'), core.get_option('OPTKING', 'EXT_FORCE_CARTESIAN')]):; if molecule.has_zmatrix():; raise ValidationError(""Job includes cartesian coordinate constraints. This cannot be fully ""; ""obeyed due to zmatrix in input. Please convert your zmatrix to cartesian ""; ""coordinates if cartesian constraints are needed ""); molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). if core.get_option('OPTKING', 'OPT_RESTART'):; # Recreate all of optking's internal classes to restart an optimization; # This has not been well teste",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:70577,optimiz,optimize,70577,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimize']
Performance,"ion theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order Moller–Plesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. scs-omp2; spin-component scaled OMP2 [manual]. scs(n)-omp2; a special version of SCS-OMP2 for nucleobase interactions [manual]. scs-omp2-vdw; a special version of SCS-OMP2 (from ethene dimers) [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. sos-pi-omp2; A special version of SOS-OMP2 for pi systems [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. scs-omp3; spin-component scaled OMP3 [manual]. scs(n)-omp3; a special version of SCS-OMP3 for nucleobase interactions [manual]. scs-omp3-vdw; a special version of SCS-OMP3 (from ethene dimers) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual]. fno-aqcc; AQCC with frozen natural orbitals [manu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/energy-1.html:2519,optimiz,optimized,2519,psi4manual/1.0.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/energy-1.html,2,['optimiz'],['optimized']
Performance,"ion theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order Møller–Plesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. scs-omp2; spin-component scaled OMP2 [manual]. scs(n)-omp2; a special version of SCS-OMP2 for nucleobase interactions [manual]. scs-omp2-vdw; a special version of SCS-OMP2 (from ethene dimers) [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. sos-pi-omp2; A special version of SOS-OMP2 for pi systems [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. scs-omp3; spin-component scaled OMP3 [manual]. scs(n)-omp3; a special version of SCS-OMP3 for nucleobase interactions [manual]. scs-omp3-vdw; a special version of SCS-OMP3 (from ethene dimers) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual]. fno-aqcc; AQCC with frozen natural orbitals [manu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/energy-1.html:2644,optimiz,optimized,2644,psi4manual/1.1.0/energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/energy-1.html,17,['optimiz'],['optimized']
Performance,"ion theory (MP2). ccsd; coupled cluster singles and doubles (CCSD). ccsd(t); CCSD with perturbative triples. eom-ccsd; equation of motion (EOM) CCSD. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules |. next |. previous |; PSI4 [beta2] » ; Psithon Functions: Invoking a Calculation ». © Copyright 2012, Psi4 Project.; Last updated on Sep 30, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/opt-1.html:1925,optimiz,optimization,1925,psi4manual/4.0b2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/opt-1.html,16,"['optimiz', 'perform']","['optimization', 'optimize', 'performed']"
Performance,"ion theory; Coupled electron pair approximation; Density-fitted coupled cluster; Gn theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Interpreting SAPT Results. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Theory. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Output. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/methods-1.html:3230,optimiz,optimizations,3230,psi4manual/1.1.0/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/methods-1.html,2,['optimiz'],['optimizations']
Performance,"ion to call; func = kwargs.pop('db_func', kwargs.pop('func', energy)); kwargs['db_func'] = func; # Bounce to CP if bsse kwarg (someday); if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). allowoptexceeded = kwargs.get('allowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; db_paths = []; db_paths.append(os.getcwd()); db_paths.extend(os.environ.get('PSIPATH', '').split(os.path.pathsep)); db_paths.append(os.path.join(core.get_datadir(), 'databases')); db_paths.append(os.path.dirname(__file__)); db_paths = list(map(os.path.abspath, db_paths)); sys.path[1:1] = db_paths; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:9437,load,load,9437,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,15,['load'],['load']
Performance,"ion(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_DCFT"", aux_basis). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(core.get_option('SCF', 'SCF_TYPE'), ref_wfn). dcft_wfn = core.dcft(ref_wfn); return dcft_wfn. def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). core.set_global_option('DERTYPE', 'FIRST'); dcft_wfn = run_dcft(name, **kwargs). derivobj = core.Deriv(dcft_wfn); derivobj.set_tpdm_presorted(True); grad = derivobj.compute(). dcft_wfn.set_gradient(grad). optstash.restore(); return dcft_wfn. def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(mtd_type):; type_val = core.get_global_option(mtd_type); if type_val == 'DF':; core.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); elif type_val == 'CD':; core.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'CD'); core.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if core.get_option('SCF', 'SCF_TYPE') != 'CD':; core.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:41734,optimiz,optimized,41734,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimized']
Performance,"ion. Navigation. index. modules    . toc    ; PSI4 [beta3] » ; Module code ». Source code for aliases; """"""Module with functions that call upon those in modules; :py:mod:`proc`, :py:mod:`driver`, and :py:mod:`wrappers`. Place in this file quickly defined procedures such as; - aliases for complex methods; - simple modifications to existing methods. """"""; import PsiMod; import re; import os; import math; import warnings; from driver import *; from wrappers import *; from molutil import *; from text import *; from procutil import *. # Python procedures like these can be run directly from the input file or integrated; # with the energy(), etc. routines by means of lines like those at the end of this file. [docs]def sherrillgroup_gold_standard(name='mp2', **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~wrappers.complete_basis_set` to evaluateo; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~wrappers.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> energy('sherrillgroup_gold_standard'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). if not ('func_cbs' in kwargs):; kwargs['func_cbs'] = energy. if not ('scf_basis' in kwargs):; kwargs['scf_basis'] = 'aug-cc-pVQZ'; if not ('scf_scheme' in kwargs):; kwargs['scf_scheme'] = highest_1. if not ('corl_wfn' in kwargs):; kwargs['corl_wfn'] = 'mp2'; if not ('corl_basis' in kwargs):; kwargs['corl_basis'] = 'aug-cc-pV[TQ]Z'; if not ('corl_scheme' in kwargs):; kwargs['corl_scheme'] = corl_xtpl_helgaker_2. if not ('delta_wfn' in kwargs):; kwargs['delta_wfn'] = 'ccsd(t)'; if not ('delta_wfn_lesser' in kwargs):; kwargs['delta_wfn_lesser'] = 'mp2'; if not ('delta_basis' in kwargs):; kwargs['delta_basis'] = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html:1041,perform,performed,1041,psi4manual/4.0b3/_modules/aliases.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/aliases.html,2,['perform'],['performed']
Performance,"ion. Type: double; Default: 2.2. BORDER_RMIN_UNIT (PE)¶PE — unit of BORDER_RMIN, default is atomic units (AU). Type: string; Possible Values: AU, AA; Default: AU. BORDER_TYPE (PE)¶PE — border type, either remove or redistribute moments/polarizabilities. Type: string; Possible Values: REMOVE, REDIST; Default: REMOVE. BRIANQC_ENABLE (GLOBALS)¶GLOBALS — Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC)¶FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC)¶ADC — How to cache quantities within the DPD library. This option is only available for the built-in ADC backend. Type: integer; Default: 2. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all fo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:8232,perform,perform,8232,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['perform'],['perform']
Performance,"ion. stability3; Test LDA stability analysis against QChem. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. options1; check all variety of options parsing. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. cc-module; check that CC is returning the same values btwn CC*, FNOCC, and DFOCC modules. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cc13b; Tests RHF CCSD(T)gradients. sapt-sf1; Tests the Psi4 SF-SAPT code. tdscf-2; td-uhf test on triplet states of methylene (tda), wfn passing. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. mints-helper; A general test of the MintsHelper function. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. sapt9; usapt example with empty beta. dfmp2-1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. matrix1; An example of using BLAS and ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:42465,optimiz,optimization,42465,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ional OO-REMP/cc-pVDZ engrad single points for the H2O molecule. single point energies were independently checked using the original wavels code. ao-casscf-sp; CASSCF/6-31G** energy point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. cc51; EOM-CC3/cc-pVTZ on H2O. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfccsd-grad2; DF-CCSD cc-pVDZ gradient for the NH molecule. cepa3; cc-pvdz H2O Test coupled-pair CISD against DETCI CISD. scf-upcast-custom-basis; test scf castup with custom basis sets. aediis-2; EDIIS test case from 10.1063/1.1470195. dct4; DCT calculation for the HF+ using DC-06 functional. This performs both two-step and simultaneous update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next two the ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. The computation is then repeated using the DC-12 functional with the same algorithms. extern1; External potential calculation involving a TIP3P water and a QM water. Finite different test of the gradient is performed to validate forces. mints2-bse; Similar to mints2, but using the BSE to specify the basis sets. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:17612,perform,performs,17612,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"ional due to the improper; idempotence properties of the SAD guess, but the first true iteration is within; 2.0E-4 relative error of the final answer, highlighting the; efficiency of the SAD guess. The energy and density then converge smoothly,; assisted by Pulay’s Direct Inversion of the Iterative Subspace (DIIS), which is; activated by default. DIIS from a high-quality guess is usually sufficient to; converge the nonlinear SCF equations, however enhanced control of DIIS; parameters and additional convergence algorithms are available and detailed; below.; After the iterations are completed, a number of one-electron properties are; printed, and some bookkeeping is performed to set up possible correlated; computations. Additional one-electron properties are available by increasing the; PRINT option. Also printed are the occupied and virtual orbital energies,; which are useful in elucidating the stability and reactivity of the system. Theory¶; The objective of Hartree-Fock (HF) Theory is to produce the optimized Molecular; Orbitals (MOs) ,. Here, are the basis functions, which, in PSI4 are; contracted cartesian Gaussian functions often referred to as Atomic Orbitals; (AOs). The matrix contains the MO coefficients, which are the; constrained variational parameters in Hartree-Fock. The molecular orbitals, are; used to build the simplest possible antisymmetric wavefunction, a single Slater; determinant,. This form for the Hartree-Fock wavefunction is actually entirely equivalent to; treating the electron correlation as a mean field repulsion in; instead of a more complicated effect in; .; Considering the electronic Hamiltonian,. the Hartree-Fock energy is, by Slater’s rules,. Here is the AO-basis one-electron potential, encapsulating both; electron-nuclear attraction and kinetic energy,. is the AO-basis density matrix, build from the occupied orbital; coefficients,. and is the Fock matrix, which is the effective one-body potential at; the current value of the density,. H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:3348,optimiz,optimized,3348,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,4,['optimiz'],['optimized']
Performance,"ional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; opt. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.opt.html:13110,perform,perform,13110,psi4manual/1.6.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.opt.html,13,"['Optimiz', 'optimiz', 'perform']","['OptimizationConvergenceError', 'optimization', 'optimize', 'perform']"
Performance,"ions (AUTO ; usual mode) or forcibly select a sub-algorithm (usually only for debugging or profiling). Presently, SCF_SUBTYPE=DF, SCF_SUBTYPE=MEM_DF, and SCF_SUBTYPE=DISK_DF can have INCORE and OUT_OF_CORE selected; and SCF_TYPE=PK can have INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, and REORDER_OUT_OF_CORE selected. Type: string; Possible Values: AUTO, INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, REORDER_OUT_OF_CORE; Default: AUTO. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. Expert Convergence Control/Stabilization¶. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS FOLLOW, how much to scale the step along the eigenvector by. A full step of \(pi/2\) corresponds to a value of 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. DF_INTS_IO¶. IO caching for CP corrections, etc. Changing this selects Disk_DF over Mem_DF. Note that setting this forces DiskDFJK when SCF_TYPE=DF. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert COSX Algorithm¶. COSX_BASIS_TOLERANCE¶. Screening criteria for basis ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__scf.html:20712,optimiz,optimization,20712,psi4manual/master/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__scf.html,2,['optimiz'],['optimization']
Performance,"ions (AUTO ; usual mode) or forcibly select a sub-algorithm (usually only for debugging or profiling). Presently, SCF_SUBTYPE=DF, SCF_SUBTYPE=MEM_DF, and SCF_SUBTYPE=DISK_DF can have INCORE and OUT_OF_CORE selected; and SCF_TYPE=PK can have INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, and REORDER_OUT_OF_CORE selected. Type: string; Possible Values: AUTO, INCORE, OUT_OF_CORE, YOSHIMINE_OUT_OF_CORE, REORDER_OUT_OF_CORE; Default: AUTO. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. Expert Convergence Control/Stabilization¶. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS FOLLOW, how much to scale the step along the eigenvector by. A full step of \(pi/2\) corresponds to a value of 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition, i.e. eigenvalue threshold for RI basis. Analogous to S_TOLERANCE. Type: double; Default: 1.0e-10. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert COSX Algorithm¶. COSX_BASIS_TOLERANCE¶. Screening criteria for basis function values on COSX grids. Type: conv double; Default: 1.0e-10. COSX_DENSITY_TOLERANCE¶. Screeni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html:19666,optimiz,optimization,19666,psi4manual/1.8.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__scf.html,4,['optimiz'],['optimization']
Performance,"ions (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Opti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html:3384,perform,performed,3384,psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/wrapper_database.html,8,['perform'],['performed']
Performance,"ions (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/lib/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:25144,perform,performed,25144,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['perform'],['performed']
Performance,"ions, there is no difference between; FROZEN_DOCC and RESTRICTED_DOCC, or between; FROZEN_UOCC and RESTRICTED_UOCC. There are; differences between these keywords for sec:mcscf. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. CI_MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 24. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:7242,optimiz,optimized,7242,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['optimiz'],['optimized']
Performance,"ions. Used to capture C++; options information for distributed (sow/reap) input files. Caution; Some features are not yet implemented. Buy a developer a coffee. Does not cover local (as opposed to global) options.; Does not work with array-type options. get_psifile(fileno, pidspace='18820')[source]¶; Function to return the full path and filename for psi file; fileno (e.g., psi.32) in current namespace pidspace. getattr_ignorecase(module, attr)[source]¶; Function to extract attribute attr from module if attr; is available in any possible lettercase permutation. Returns; attribute if available, None if not. import_ignorecase(module)[source]¶; Function to import module in any possible lettercase ; permutation. Returns module object if available, None if not. kwargs_lower(kwargs)[source]¶; Function to rebuild and return kwargs dictionary; with all keys made lowercase. Should be called by every; function that could be called directly by the user. driver¶. gradient(name, **kwargs)[source]¶; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. hessian(name, **kwargs)[source]¶; Function to compute force constants. Presently identical to frequency(). molden(filename)[source]¶; Function to write wavefunction information in molden; format to filename. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. optproc¶; Module to provide mechanism to store and restore option states in driver. class OptionState(option, module=None)[source]¶; Class to store the state of a single option. If module given, the option; value and has_changed value is stored for global, local to module, and used by; module scopes; otherwise (used for BASIS keywords), only global scope is stored.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:15973,optimiz,optimize,15973,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,2,['optimiz'],['optimize']
Performance,"ions. Used to capture C++; options information for distributed (sow/reap) input files. Caution; Some features are not yet implemented. Buy a developer a coffee. Does not cover local (as opposed to global) options.; Does not work with array-type options. get_psifile(fileno, pidspace='27558')[source]¶; Function to return the full path and filename for psi file; fileno (e.g., psi.32) in current namespace pidspace. getattr_ignorecase(module, attr)[source]¶; Function to extract attribute attr from module if attr; is available in any possible lettercase permutation. Returns; attribute if available, None if not. import_ignorecase(module)[source]¶; Function to import module in any possible lettercase ; permutation. Returns module object if available, None if not. kwargs_lower(kwargs)[source]¶; Function to rebuild and return kwargs dictionary; with all keys made lowercase. Should be called by every; function that could be called directly by the user. driver¶. gradient(name, **kwargs)[source]¶; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. hessian(name, **kwargs)[source]¶; Function to compute force constants. Presently identical to frequency(). molden(filename)[source]¶; Function to write wavefunction information in molden; format to filename. parse_arbitrary_order(name)[source]¶; Function to parse name string into a method family like CI or MRCC and specific; level information like 4 for CISDTQ or MRCCSDTQ. parse_cotton_irreps(irrep)[source]¶; Function to return validated Cotton ordering index from string or integer; irreducible representation irrep. optproc¶; Module to provide mechanism to store and restore option states in driver. class OptionState(option, module=None)[source]¶; Class to store the state of a single option. If module given, the option; value and has_changed value is stored for global, local to module, and used by; module scopes; otherwise (used for BASIS keywords), only global scope is stored.; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:18091,optimiz,optimize,18091,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['optimiz'],['optimize']
Performance,"ions; need to be solved, which makes the computation of the analytic gradients very; efficient. Analytic gradients are not available for the three-particle energy; correction . Methods Summary¶; The table below summarizes current DCFT code features:. Method; Available algorithms; Energy; Gradient; Reference. ODC-06; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-12; SIMULTANEOUS, QC; Y; Y; RHF/UHF. ODC-13; SIMULTANEOUS, QC; Y; Y; UHF. SIMULTANEOUS, QC; Y; N; UHF. SIMULTANEOUS, QC; Y; N; UHF. DC-06; SIMULTANEOUS, QC, TWOSTEP; Y; Y; UHF. DC-12; SIMULTANEOUS, QC, TWOSTEP; Y; N; UHF. Note that for ODC-06 and ODC-12 REFERENCE = RHF is only available for; ALGORITHM = SIMULTANEOUS. To compute correction,; the THREE_PARTICLE option needs to be set to PERTURBATIVE. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. energy('dcft'). The energy('dcft') call to energy() executes the DCFT; module, which will first call the SCF module and perform the SCF computation; with RHF reference to obtain a guess for the DCFT orbitals. After SCF is; converged, the program will perform the energy computation using the ODC-12; method. By default, simultaneous algorithm will be used for the solution of; the equations. One can also request to perform geometry; optimization following example below:; molecule {; H; H 1 1.0; }. set basis cc-pvdz. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the ODC-12 energy. After that, the ODC-12 analytic; gradients code will be executed and geometry optimization will be performed. Recommendations¶; Here is a list of recommendations for the DCFT module:. Generally, the use of the simultaneous algorithm together with the; AO_BASIS = DISK option is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS = DISK option; is recommended. This will significantly reduce the memory requirem",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:12792,perform,perform,12792,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['perform'],['perform']
Performance,"ipole field. dft-reference; MP2 with a PBE0 reference computation. mbis-1; MBIS calculation on H2O. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. cbs-xtpl-func; optimization with method defined via cbs. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. fci-h2o; 6-31G H2O Test FCI Energy Point. opt11; Transition-state optimizations of HOOH to both torsional transition states. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). pywrap-align-chiral; testing aligner on e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:41527,optimiz,optimizations,41527,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimizations']
Performance,"ipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-dipole; 6-31G H2O Test FCI Energy Point. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. mints-helper; A general test of the MintsHelper function. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. castup3; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup2) that output file doesn’t depend on options (scf_type) being set global or local. This input uses local. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. cepa-module; routing check on lccd, lccsd, cepa(0). psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. scf-bs; U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:17540,perform,performed,17540,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"ir energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT); FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCFT); DCFT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCFT); DCFT (Expert) — Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCFT); DCFT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCFT); DCFT (Expert) — The maximum size of the subspace for the stability check. The program will term",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:209920,perform,performed,209920,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ir energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. SSAPT0_SCALE (FISAPT); FISAPT — Do sSAPT0 exchange-scaling with F-SAPT. Type: boolean; Default: false. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCFT); DCFT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCFT); DCFT (Expert) — Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCFT); DCFT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCFT); DCFT (Expert) — The maximum size of the subspace for the stability check. The program will ter",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:213462,perform,performed,213462,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['perform'],['performed']
Performance,"ir natural orbital domains [manual]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. fno-mp3; MP3 with frozen natural orbitals [manual]. mp2.5; average of MP2 and MP3 [manual] [details]. mp4(sdq); 4th-order MP perturbation theory (MP4) less triples [manual]. fno-mp4(sdq); MP4 (less triples) with frozen natural orbitals [manual]. mp4; full MP4 [manual] [details]. fno-mp4; full MP4 with frozen natural orbitals [manual]. mpn; nth-order Møller–Plesset (MP) perturbation theory [manual]. zaptn; nth-order z-averaged perturbation theory (ZAPT) [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. scs-omp2; spin-component scaled OMP2 [manual]. scs(n)-omp2; a special version of SCS-OMP2 for nucleobase interactions [manual]. scs-omp2-vdw; a special version of SCS-OMP2 (from ethene dimers) [manual]. sos-omp2; spin-opposite scaled OMP2 [manual]. sos-pi-omp2; A special version of SOS-OMP2 for pi systems [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. scs-omp3; spin-component scaled OMP3 [manual]. scs(n)-omp3; a special version of SCS-OMP3 for nucleobase interactions [manual]. scs-omp3-vdw; a special version of SCS-OMP3 (from ethene dimers) [manual]. sos-omp3; spin-opposite scaled OMP3 [manual]. sos-pi-omp3; A special version of SOS-OMP3 for pi systems [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual]. fno-aqcc; AQCC with frozen natural orbitals [manu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.energy-1.html:2921,optimiz,optimized,2921,psi4manual/1.5.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.energy-1.html,9,['optimiz'],['optimized']
Performance,"irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. sapt-ecp; sapt0 of charged system in ECP basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. fci-dipole; 6-31G H2O Test FCI Energy Point. sapt-dft1; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. dft1; DFT Functional Test. nbody-intermediates; HF/cc-pVDZ many body energies of an arbitrary noble gas trimer complex Size vs cost tradeoff is rough here. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. pywrap-cbs1; Various basis set extrapolation tests. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. cubeprop-esp; RHF orbitals and density for water. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. opt-multi-dimer-c1; Multi-fragment opt of C2h methane dimer with user-combined reference points. pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. cc13c; Tests RHF CCSD(T)gradients. mom; Maximum Overlap Method (MOM) Test. MOM is designed to stabilize SCF convergence and to target excited Slater determinants directly. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:12831,optimiz,optimization,12831,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type :rtype: Union[Matrix, Vector]. gemm(self, transa, transb, alpha, a, b, beta); Generalized matrix multiplication argument transa Transpose the left matrix? argument transb Transpose the right matrix? argument alpha Prefactor for the matrix multiplication argument A Left matrix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self); Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs); Overloaded function. get_block(self, rows, cols); Get a matrix block. hermitivitize(self); Average off-diagonal element in-place. hermitize(self); Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self); Sets the matrix to the identity. invert(self); Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs); Overloaded function. load_mpqc(self, filename); Loads a matrix from an ASCII file in MPQC format. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). partial_cholesky_factorize(self[, delta, ...]); Computes the fully pivoted partial Cholesky factorization of a real symmetric positive semidefinite matrix, to numerical precision delta. power(self, alpha[, cutoff]); Takes the matrix to the alpha power with precision cutoff. print_atom_vector(self[, RMRoutfile]); Print the matrix with atom labels, assuming it is an natom X 3 tensor. print_out(self); Prints the matrix to the output file. pseudoinverse(self, condition, nremoved); Computes the matrix which is the conditioned pseudoinverse of this matrix. remove_symmetry(self, a, transformer); Remove symmetry from a matrix A with PetiteList::sotoao(). rms(self); Returns the rms of this matrix. rotate_column",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:2841,Load,Loads,2841,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,1,['Load'],['Loads']
Performance,"is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_omp2p5_property', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'DF':; if module in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:8351,perform,performance,8351,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['perform'],['performance']
Performance,"is \(\langle ab|cd \rangle\)). fnocc2; Test G2 method for H2O. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. props4; Electrostatic potential and electric field evaluated on a grid around water. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. cbs-xtpl-dict; Extrapolated water energies. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:31231,optimiz,optimizations,31231,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimizations']
Performance,"is called a; RASSCF. CASSCF and RASSCF computations are types of multi-configurational; self-consistent-field procedures, and are described in MCSCF: Multi-Configurational Self-Consistent-Field.; As mentioned above, the DETCI module is designed for challenging; chemical systems for which simple CISD is not suitable. Because; CI wavefunctions which go beyond CISD (such as RAS CI) are fairly complex,; typically the DETCI code will be used in cases where the; tradeoffs between computational expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:4722,optimiz,optimize,4722,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,9,['optimiz'],['optimize']
Performance,"is determined based on the largest amplitude. Type: conv double; Default: 1e-5. CACHELEVEL (ADC); ADC — How to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (CCDENSITY); CCDENSITY — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY); CCENERGY — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:7091,cache,cache,7091,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,4,['cache'],['cache']
Performance,"is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; Some existing examples are below. psi4.driver.aliases.sherrill_gold_standard(**kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type:; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306, https://doi.org/10.1063/1.2747241 .; Uses the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cbs.html:31098,optimiz,optimization,31098,psi4manual/1.7.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cbs.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; Some existing examples are below. psi4.driver.aliases.sherrill_gold_standard(**kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). Return type; List[Dict[str, Any]]. psi4.driver.aliases.allen_focal_point(**kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; the composite wrapper to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. \[E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}\]; >>> ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cbs.html:31037,optimiz,optimization,31037,psi4manual/1.6.x/cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cbs.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: str; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type db_name: str; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: str; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the ``bsse_type=""cp""``; function for BSSE correction in database(). Option available; (See :ref:`sec:availableDatabases`) only for databases of bimolecular complexes. :type rlxd: :ref:`boolean <op_py_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html:3493,perform,performs,3493,psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/wrapper_database.html,24,"['optimiz', 'perform']","['optimization', 'optimize', 'performs']"
Performance,"is recommended for most applications).; Recently, we have added the automatic capability to use the extremely fast DF; code for intermediate convergence of the orbitals, for SCF_TYPE other; than DF. At the moment, the code defaults to cc-pVDZ-JKFIT as the; auxiliary basis, unless the user specifies DF_BASIS_SCF manually. For; some atoms, cc-pVDZ-JKFIT is not defined, so this procedure will fail. In these; cases, you will see an error message of the form:; RuntimeError: sanity check failed! Gaussian94BasisSetParser::parser:; Unable to find the basis set for HE. This failure can be fixed by either setting DF_BASIS_SCF to an auxiliary; basis set defined for all atoms in the system, or by setting DF_SCF_GUESS; to false, which disables this acceleration entirely. Convergence and Algorithm Defaults¶. SCF algorithm and convergence criteria defaults by calculation type [1]. Ab Initio Method; Calculation Type; E_CONVERGENCE; D_CONVERGENCE; SCF_TYPE. SCF of HF or DFT; energy; 6; 6; DF. optimization; 8; 8. frequency [7]; 8; 8. SCF of post-HF; energy; 8; 8; PK [3]. optimization; 10; 10. frequency [7]; 10; 10. CC property [2]; 10; 10. Post-SCF convergence criteria defaults by calculation type [4]. Ab Initio Method; Calculation Type; E_CONVERGENCE [5]; R_CONVERGENCE [6]. post-HF of post-HF; energy; 6;  . optimization; 8;  . frequency [7]; 8;  . CC property [2]; 8;  . Footnotes. [1]Note that this table applies only the SCF module,; not to the final convergence criteria for post-HF methods or to methods; that use an alternate starting point, like MCSCF. SAPT computations, too,; set tighter values. [2](1, 2) This applies to properties computed through the property() function. [3]Post-HF methods that do not rely upon the usual 4-index AO integrals use a density-; fitted SCF reference. That is, for DF-MP2 and SAPT, the default SCF_TYPE is DF. [4]Note that this table applies to the final convergence criteria for; all the post-SCF modules that define a E_CONVERGENCE keyword. [5]The E_CO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/scf-1.html:21240,optimiz,optimization,21240,psi4manual/4.0b4/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/scf-1.html,4,['optimiz'],['optimization']
Performance,"is test should match RHF values exactly. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dft1-alt; DFT Functional Test. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mints4; A demonstration of mixed Cartesian/ZMatrix geometry specification, using variables, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. fci-h2o; 6-31G H2O Test FCI Energy Point. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dfmp2-ecp; Ne-Xe dimer MP2 energies with ECP, with electrons correlated then frozen. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. mints5; Tests to determine full point group symmetry. Currently, these only matter for the rotational symmetry number in thermodynamic computations. mbis-5; MBIS calculation on ZnO. cc3; cc3: RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:33489,optimiz,optimization,33489,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"is-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Psithon: Structuring an Input File. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/psithoninput.html:14442,perform,perform,14442,psi4manual/1.8.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/psithoninput.html,1,['perform'],['perform']
Performance,"is-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Psithon: Structuring an Input File. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; .",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psithoninput.html:14506,perform,perform,14506,psi4manual/1.9.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psithoninput.html,1,['perform'],['perform']
Performance,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]; class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html:2719,perform,perform,2719,psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qmmm.html,6,['perform'],['perform']
Performance,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM():; """"""Hold charges and :py:class:`psi4.core.ExternalPotential`. Use :py:class:`psi4.driver.QMMMbohr` instead."""""". def __init__(self):; raise UpgradeHelper(self.__class__.__name__, ""QMMMbohr"", 1.6, ' Replace object with a list of charges and locations in Bohr p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html:2723,perform,perform,2723,psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/qmmm.html,4,['perform'],['perform']
Performance,"isChanged = core.has_option_changed(""BASIS""); ribasisChanged = core.has_option_changed(""DF_BASIS_SCF""); scftypeChanged = core.has_option_changed(""SCF_TYPE""). basis = core.get_option(""BASIS""); ribasis = core.get_option(""DF_BASIS_SCF""); scftype = core.get_global_option(""SCF_TYPE""). core.print_out("" => Diffuse SCF (Determines Da) <=\n\n""). core.set_global_option(""BASIS"", self.basisname); core.set_global_option(""DF_BASIS_SCF"", self.ribasisname); core.set_global_option(""SCF_TYPE"", ""DF""); E, ref = energy('scf', return_wfn=True, molecule=self.molecule); self.wfn = ref; core.print_out(""\n""). self.fitGeneral(). core.clean(). core.set_global_option(""BASIS"", basis); core.set_global_option(""DF_BASIS_SCF"", ribasis); core.set_global_option(""SCF_TYPE"", scftype). if not basisChanged:; core.revoke_option_changed(""BASIS""); if not ribasisChanged:; core.revoke_option_changed(""DF_BASIS_SCF""); if not scftypeChanged:; core.revoke_option_changed(""SCF_TYPE""). def fitGeneral(self):; """"""Function to perform a general fit of diffuse charges; to wavefunction density. """"""; core.print_out("" => Diffuse Charge Fitting (Determines da) <=\n\n""); self.Da = self.wfn.Da(); self.basis = self.wfn.basisset(); parser = core.Gaussian94BasisSetParser(); self.ribasis = core.BasisSet.construct(parser, self.molecule, ""DF_BASIS_SCF""). fitter = core.DFChargeFitter(); fitter.setPrimary(self.basis); fitter.setAuxiliary(self.ribasis); fitter.setD(self.Da); self.da = fitter.fit(); self.da.scale(2.0). def populateExtern(self, extern):; # Electronic Part; extern.addBasis(self.ribasis, self.da); # Nuclear Part; for A in range(0, self.molecule.natom()):; extern.addCharge(self.molecule.Z(A), self.molecule.x(A), self.molecule.y(A), self.molecule.z(A)). [docs]class QMMM(object):. def __init__(self):; self.charges = []; self.diffuses = []; self.extern = core.ExternalPotential(). [docs] def addDiffuse(self, diffuse):; """"""Function to add a diffuse charge field *diffuse*.""""""; self.diffuses.append(diffuse). [docs] def addChargeBohr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html:2707,perform,perform,2707,psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/qmmm.html,6,['perform'],['perform']
Performance,"isFamily object. add_rifit(fit)[source]¶; Function to add basis fit as associated fitting basis; member rifit to a BasisFamily object. name()[source]¶; Function to return the ornate name of the orbital basis,; e.g., 6-311++G** for 6-311ppgss. corresponding_dualfit(name)[source]¶; Function to return an appropriate DUAL helper basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_jkfit(name)[source]¶; Function to return an appropriate JK fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. corresponding_rifit(name)[source]¶; Function to return an appropriate RI fitting basis for; the orbital basis name in coded or ornate form. None; is returned if no fitting basis is defined or if the; orbital basis is not found. load_basis_families()[source]¶; Function to load into the array basisfamily_list; BasisFamily objects for all Psi4’s standard installed bases. print_basis_families()[source]¶; Function to print to the output file a formatted summary; of all the BasisFamily objects in basisfamily_list, by; default all Psi4’s standard installed bases. sanitize_basisname(name)[source]¶; Function to return name in coded form, stripped of ; characters that confuse filenames, characters into lowercase, ; + into p, * into s, and (, ), & , ; into _. input¶. bad_option_syntax(line)[source]¶; Function to report bad syntax to screen and output file. check_parentheses_and_brackets(input_string, exit_on_error)[source]¶; Function to check that all parenthesis and brackets; in input_string are paired. On that condition, exit_on_error =1,; otherwise 0. parse_multiline_array(input_list)[source]¶; Function to squash multiline arrays into a single line; until all parentheses and brackets are fully paired. process_basis_block(matchobj)[source]¶; Function to process match of basis name { ... ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html:1840,load,load,1840,psi4manual/4.0b3/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_driver-1.html,4,['load'],['load']
Performance,"isapt; set DO_DISP_EXCH_SINF true # calculate Exch-Disp20 (S^inf); energy('sapt(dft)'). These calculations are performed with the atomic orbital and; density-fitting scheme of [J. M. Waldrop et al., to be published]. S^inf Keywords¶. DO_IND_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT(DFT) computes the \(S^{inf}\) Exchange-Dispersion terms. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; Grimme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. energy('sapt0-d3mbj') # runs the recommended dispersion correction; energy('sapt0-d3') # tests an alternative damping scheme/parameterization. Given the naturally pairwise-atomic nature of these empirical dispersion corrections,; integration with existing FSAPT functionality is also available simply by calling; energy(“fsapt0-d3mbj”). See FSAPT <fisapt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:45560,optimiz,optimized,45560,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,4,['optimiz'],['optimized']
Performance,"ish the previous example of; H2 and H atom:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19molecule h2 {; H; H 1 0.9; }. set basis cc-pvdz; set reference rhf; h2_energy = energy('scf'). molecule h {; H; }. set basis cc-pvdz; set reference uhf; h_energy = energy('scf'). D_e = psi_hartree2kcalmol * (2*h_energy - h2_energy); print ""De=%f"" % D_e. The energy() function returns the final result of the; computation, the requested total energy in Hartrees, which we assign to a; Python variable. The two energies are then converted to a dissociation; energy and printed to the output file using standard Python notation.; Generally, there are multiple quantities of interest. Appendix; PSI Variables by Module lists PSI variables variables set by each; module, and PSI Variables by Alpha defines them. These can be; accessed through the get_variable() function. For example, after; performing a density fitted MP2 computation, both the spin component; scaled energy and the unscaled MP2 energy are made available:; 1; 2e_mp2 = get_variable('MP2 TOTAL ENERGY'); e_scs_mp2 = get_variable('SCS-MP2 TOTAL ENERGY'). Each module and the Python driver set PSI variables over the course of a; calculation. The values for all can be printed in the output file with; the input file command print_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html:9508,perform,performing,9508,psi4manual/1.1.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithoninput-1.html,6,['perform'],['performing']
Performance,"ision of the molecular orbitals into various subspaces such as; RAS spaces, or frozen vs. active orbitals, etc., needs to be clear not; only to detci, but also at least to the transformation program; (and in the case of MCSCF, to other programs as well). Thus, orbital; subspace keywords such as RAS1,; RAS2, RAS3, FROZEN_DOCC, FROZEN_UOCC,; ACTIVE, etc., should be set; in the global section of input so they may also be read by other modules.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-refernce CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specifed by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/detci-1.html:4699,perform,performed,4699,psi4manual/4.0b2/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/detci-1.html,8,['perform'],['performed']
Performance,"isk (the JOBARC file) and CORE means to use a core Hamiltonian initial guess. If MOREAD is chosen but no disk file is present, the core Hamiltonian is used. (Default: MOREAD). Type: string; Possible Values: MOREAD, CORE; Default: MOREAD. CFOUR_HBAR (CFOUR); CFOUR — This keyword determines which action is taken by the linear response program. ON (=1) the full effective Hamiltonian is calculated and written to disk; OFF (=0) the “lambda” linear response equations are solved. Type: boolean; Default: false. CFOUR_HFSTABILITY (CFOUR); CFOUR — Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR); CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the \(\langle ab\vert\vert cd\rangle\) molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the \(\langle ab\vert\vert cd\rangle\) and \(\langle ab\vert\vert ci\rangle\) integrals are held in core; (=5) \(\langle ij\vert\vert kl\rangle\) and \(\langle ij\vert\vert ka\rangle\) and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:51355,perform,performs,51355,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['perform'],['performs']
Performance,"isk (the JOBARC file) and CORE means to use a core Hamiltonian initial guess. If MOREAD is chosen but no disk file is present, the core Hamiltonian is used. (Default: MOREAD). Type: string; Possible Values: MOREAD, CORE; Default: MOREAD. CFOUR_HBAR (CFOUR); CFOUR — This keyword determines which action is taken by the linear response program. ON (=1) the full effective Hamiltonian is calculated and written to disk; OFF (=0) the “lambda” linear response equations are solved. Type: boolean; Default: false. CFOUR_HFSTABILITY (CFOUR); CFOUR — Control analysis of the stability of RHF, ROHF and UHF wavefunctions, as well as a possible search for a lower SCF solution. There are three possible options for this keyword. OFF (=0) does nothing, while ON (=1) performs a stability analysis and returns the number of negative eigenvalues in the orbital rotation Hessian. A third option, FOLLOW (=2) performs the stability analysis and then proceeds to rotate the SCF orbitals in the direction of a particular negative eigenvalue of the orbital rotation Hessian (see the explanation of keyword CFOUR_ROT_EVEC), after which the SCF is rerun. Type: string; Possible Values: OFF, ON, FOLLOW; Default: OFF. CFOUR_INCORE (CFOUR); CFOUR — This keyword can be used to significantly reduce disk i/o, and should be implemented very soon. The following options are available: OFF (= 0), no special algorithms are used (the default case); ALL (=1) all quantities except the molecular integral lists are held in core; PARTIAL (= 2), the T2 and T1 vectors are held in core throughout the calculation; (=4) all quantities except the and integrals are held in core; (=5) and and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC (CFOUR); CFOUR — Specifi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:51209,perform,performs,51209,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performs']
Performance,"issociation curve for benzene-H2S; 'BzMe' dissociation curve for benzene-methane; 'MeMe' dissociation curve for methane dimer; 'PyPy_S2' dissociation curve for pyridine dimer, sandwich; 'PyPy_T3' dissociation curve for pyridine dimer, t-shaped; 'BzBz_PD32' dissociation curve for benzene dimer, parallel displaced by 3.2A; 'BzBz_PD36' dissociation curve for benzene dimer, parallel displaced by 3.6A. RSE42¶. Database of radical stabilization energies.; Geometries from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; Reference radical stabilization energies from [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)] at CCSD(T)/cc-pCVTZ level. benchmark. 'RSE42' [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)].; \(\Rightarrow\) 'RSE42' \(\Leftarrow\) [E. Soydas and U. Bozkaya, JCTC, 9, 1452-1460 (2013)]. subset. 'small' <members_description>; 'large' <members_description>; 'RSE30' smaller systems in RSE42; '<subset>' <members_description>. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. BBI¶. Database (Merz) of protein backbone-backbone interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from Sherrill group, Georgia Tech.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BASIC¶. Database of simple molecules, mostly for testing.; Geometries from nowhere special, and no reference energies defined. cp 'off'; rlxd 'off'; subset ['h2o', 'nh3', 'ch4']. RGC10¶. Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.; Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003). cp 'off' || 'on'; rlxd 'off'; subset. 'small'; 'large'; 'equilibrium'; 'HeHe' 18-point dissociation c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_available_databases-1.html:9672,optimiz,optimize,9672,psi4manual/1.5.0/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_available_databases-1.html,4,['optimiz'],['optimize']
Performance,"issue; I have an idea/request and a plan – file a GitHub issue; I have an idea/request – ask the forum; Why do you? – ask the forum; When will you? – ask the forum; I have an experience that can improve the build documentation – inform the forum or add to the documentation itself; Anything you want to share privately – crawdad@vt.edu or sherrill@gatech.edu. Footnotes. [1]Frozen natural orbital variant available. In particular, RHF available as CONV. [2](1, 2) Frozen natural orbital variant available. In particular, RHF available as CONV/DF. [3](1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22) threading through BLAS routines only. [4]DFT gradients only implemented for SCF type DF. LRC-DFT gradients not implemented yet. DH-DFT gradients not implemented. [5]Both EFP/EFP and QM/EFP energies are available. [6]Adapted from here. [7]DH-DFT only available with DF-MP2. [8](1, 2, 3) Not all combinations of reference and algorithm available. In particular, non-RHF references only available as CONV. For CCSD(T), gradients are not available with frozen core. [9]Orbital-optimized variant available. In particular, all references available as CONV/DF. [10](1, 2, 3, 4, 5, 6, 7, 8, 9, 10) Capabilities breakdown in great detail can be found here. table of contents. Introduction; Overview; Citing PSI4; Overall PSI4 Package; Density Cumulant Functional Theory (DCFT); Configuration Interaction (CI); Coupled Cluster (CC); Mukherjee State-Specific Multi-Reference Coupled Cluster (Mk-MRCC); Symmetry-Adapted Perturbation Theory (SAPT); Orbital-Optimized Post-Hartree–Fock Methods; Second-Order Algebraic-Diagrammatic Construction [ADC(2)]; Density Matrix Renormalization Group (DMRG); Scalar Relativistic Corrections. Supported Architectures; License; Capabilities; Technical Support. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/introduction-1.html:24243,optimiz,optimized,24243,psi4manual/1.1.0/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/introduction-1.html,2,['optimiz'],['optimized']
Performance,"istage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html:2805,optimiz,optimize,2805,psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequencies-1.html,4,['optimiz'],['optimize']
Performance,"istage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequencies-1.html:2805,optimiz,optimize,2805,psi4manual/1.5.0/api/psi4.driver.frequencies-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequencies-1.html,4,['optimiz'],['optimize']
Performance,"isting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. fnocc1; Test QCISD(T) for H2O/cc-pvdz Energy. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. opt1; SCF STO-3G geometry optimzation, with Z-matrix input. cc10; ROHF-CCSD cc-pVDZ energy for the state of the CN radical. casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. cepa1; cc-pvdz H2O Test CEPA(1) Energy. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. mp2-module; OMP2 cc-pVDZ energy for the H2O molecule. psimrcc-pt2; Mk-MRPT2 single point. F2 state described using the Ms = 0 component of the singlet. Uses TCSCF singlet orbitals. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. cepa0-grad1; CEPA0 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. cisd-sp-2; 6-31G** H2O Test CISD Energy Point. rasci-h2o; RASCI/6-31G** H2O Energy Point. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. dcft-grad2; RHF-ODC-12 analytic gradient computations for H2O use AO_BASIS=DISK and AO_BASIS=NONE, respectively. RHF-ODC-06 analytic gradient computations for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:19090,optimiz,optimization,19090,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"ists of two sets of; microiterations. In the first set, the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods.; 3) Quadratically-convergent algorithm (set ALGORITHM to QC). The; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below .; The choice of the iterative algorithm can signific",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:9114,perform,performed,9114,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['perform'],['performed']
Performance,"it matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.symmetryoperation.html:2617,Perform,Performs,2617,psi4manual/1.4.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.symmetryoperation.html,2,['Perform'],['Performs']
Performance,"it matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotation by theta. sigma_xy(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xy plane. sigma_xz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in xz plane. sigma_yz(self: psi4.core.SymmetryOperation) → None¶; Set equal to reflection in yz plane. trace(self: psi4.core.SymmetryOperation) → float¶; Returns trace of transformation matrix. transform(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the transform arg2 * arg1 * arg2~. transpose(self: psi4.core.SymmetryOperation) → None¶; Performs transposition of matrix operation. unit(self: psi4.core.SymmetryOperation) → None¶; Set equal to a unit matrix. zero(self: psi4.core.SymmetryOperation) → None¶; Zero out the symmetry operation. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; SymmetryOperation. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.core.symmetryoperation.html:2617,Perform,Performs,2617,psi4manual/1.5.0/api/psi4.core.symmetryoperation.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.core.symmetryoperation.html,2,['Perform'],['Performs']
Performance,"it. Basis set and auxiliary basis sets are assigned by atom type. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/psi-uhf-scsmp2; UHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Appendices; Test Suite and Sample Inputs. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html:4359,optimiz,optimization,4359,psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_cfour-1.html,4,['optimiz'],['optimization']
Performance,"itals (restricted open-shell Hartree-Fock, or ROHF).; Usually, UHF is a little easier to converge (although it may be more; susceptible to spin contamination than ROHF). III. Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step      ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:7197,optimiz,optimization,7197,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['optimiz'],['optimization']
Performance,"itals; if name in ['mp2', 'mp2.5', 'mp3', 'lccd',; 'ccd', 'ccsd', 'ccsd(t)', 'ccsd(at)']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_dfocc_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['REFERENCE'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'CC_LAMBDA'],; ['GLOBALS', 'DERTYPE']). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); elif name in ['mp2.5', 'omp2.5']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2.5'); elif name in ['mp3', 'omp3']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP3'); elif name in ['lccd', 'olccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OLCCD'); elif name in ['ccd']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:36671,optimiz,optimized,36671,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['optimiz'],['optimized']
Performance,"ite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html:6662,perform,performed,6662,psi4manual/1.3.2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__scf-1.html,10,['perform'],['performed']
Performance,"ite(p4util.format_options_for_input()); p4util.format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""psi4.print_out('\\n')\n""""""; banners += """"""p4util.banner(' Gradient %d Computation: Displacement %d ')\n"""""" % (opt_iter, n + 1); banners += """"""psi4.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; psi4.print_out('\n'); p4util.banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; psi4.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = psi4.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; psi4.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(p4util.format_molecule_for_input(molecule)); freagent.write(p4util.format_options_for_input()); p4util.format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""psi4.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:39476,Perform,Perform,39476,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Perform'],['Perform']
Performance,"ite-differences frequencies from gradients for H2O. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. freq-masses; check nonphysical masses possible. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. dft1; DFT Functional Test all values update for new BraggSlater radii. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. scf-level-shift-rks; SCF level shift on an RKS computation. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). dfccsd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. mints3; Test individual integral objects for correctness. dft-smoke; DFT Functional Smoke Test. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. linK-1; RHF Linear Exchange Algorithm test for water. mbis-3; MBIS calculation on OH radical. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. dft2; DFT Functional Test. soscf-large; Seco",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:31237,optimiz,optimizations,31237,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance,"iter', 1). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()). # If we are freezing cartesian, do not orient or COM; if core.get_local_option(""OPTKING"", ""FROZEN_CARTESIAN""):; molecule.fix_orientation(True); molecule.fix_com(True); molecule.update_geometry(). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). initial_sym = moleculeclone.schoenflies_symbol(); while n <= core.get_option('OPTKING', 'GEOM_MAXITER'):; current_sym = moleculeclone.schoenflies_symbol(); if initial_sym != current_sym:; raise ValidationError(""""""Point group changed! (%s <-- %s) You should restart """"""; """"""using the last geometry in the output, after """"""; """"""carefully making sure all symmetry-dependent """"""; """"""input, such as DOCC, is correct."""""" % (current_sym, initial_sym)); kwargs['opt_iter'] = n; core.set_variable('GEOMETRY ITERATIONS', n). # Use orbitals from previous iteration as a guess; # set within loop so that can be influenced by fns to optimize (e.g., cbs); if (n > 1) and (not core.get_option('SCF', 'GUESS_PERSIST')):; core.set_local_option('SCF', 'GUESS', 'READ'). # Before computing gradient, save previous molecule and wavefunction if this is an IRC optimization; if (n > 1) and (core.get_option('OPTKING', 'OPT_TYPE') == 'IRC'):; old_thisenergy = core.variable('CURRENT ENERGY'). # Compute the gradient - preserve opt data despite core.clean calls in gradient; core.IOManager.shared_object().set_specific_retention(1, True); G, wfn = gradient(lowername, return_wfn=True, molecule=moleculeclone, **kwargs); thisenergy = core.variable('CURRENT ENERGY'). # above, used to be getting energy as last of energy list from gradient(); # thisenergy below should ultimately be testing on wfn.energy(). # Record optimization steps; # Add wavefunctions later; if return_history:; step_energies.append(thisenergy); step_coordinates.append(moleculeclone.geometry()); step_gradients.append(G.clone(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:64911,optimiz,optimize,64911,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimize']
Performance,"iteration consists of two sets of; microiterations. In the first set, the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods.; QC; In the quadratically-convergent algorithm, the; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below \(10^{-7}\). The choice of the iterative algorithm ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:10009,perform,performed,10009,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['perform'],['performed']
Performance,"iteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOCC (density-fitted; DF and Cholesky-decomposed CD) keywords. Switching between; the integrals treat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/occ-1.html:15855,optimiz,optimization,15855,psi4manual/1.4.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/occ-1.html,5,['optimiz'],['optimization']
Performance,"itertools.combinations(fragment_range, nbody):; basis_tuple = tuple(cp_combos); for interior_nbody in nbody_range:; for x in itertools.combinations(cp_combos, interior_nbody):; combo_tuple = (x, basis_tuple); vmfc_compute_list[interior_nbody].add(combo_tuple); vmfc_level_list[len(basis_tuple)].add(combo_tuple). # Build a comprehensive compute_range; compute_list = {x: set() for x in nbody_range}; for n in nbody_range:; compute_list[n] |= cp_compute_list[n]; compute_list[n] |= nocp_compute_list[n]; compute_list[n] |= vmfc_compute_list[n]; core.print_out("" Number of %d-body computations: %d\n"" % (n, len(compute_list[n]))). metadata['compute_dict'] = {; 'all': compute_list,; 'cp': cp_compute_list,; 'nocp': nocp_compute_list,; 'vmfc_compute': vmfc_compute_list,; 'vmfc_levels': vmfc_level_list; }. return metadata. def compute_nbody_components(func, method_string, metadata):; """"""Computes requested N-body components. Performs requested computations for psi4::Molecule object `molecule` according to; `compute_list` with function `func` at `method_string` level of theory. Parameters; ----------; func : str; {'energy', 'gradient', 'hessian'}; Function object to be called within N-Body procedure.; method_string : str; Indicates level of theory to be passed to function `func`.; metadata : dict of str; Dictionary of N-body metadata. Required ``'key': value`` pairs:; ``'compute_list'``: dict of int: set; List of computations to perform. Keys indicate body-levels, e.g,. `compute_list[2]` is the; list of all 2-body computations required.; ``'kwargs'``: dict; Arbitrary keyword arguments to be passed to function `func`. Returns; -------; dict of str: dict; Dictionary containing computed N-body components. Contents:; ``'energies'``: dict of set: float64; Dictionary containing all energy components required for given N-body procedure.; ``'ptype'``: dict of set: float64 or dict of set: psi4.Matrix; Dictionary of returned quantities from calls of function `func` during N-body computations;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html:15598,Perform,Performs,15598,psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver_nbody.html,2,['Perform'],['Performs']
Performance,"ites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM — The criterion used to retain/release cached data. Type: string; Possible Values: LOW, LRU; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRIT",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:10637,cache,cache,10637,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"ith:; molecule ne3 {; Ne 0.0 0.0 0.0; Ne 0.0 0.0 1.0; Ne 0.0 1.0 1.0; }; ne.update_geometry(); energy = m.run_dftd3('d3-atmgr', dertype=0); print(energy). Footnotes. 1; Note that there are functionals with these extensions (e.g., wB97X-D) that,; not being Grimme corrections, won’t follow this table exactly. 2; [Grimme:2004:1463]. 3; [Grimme:2006:1787]. 4; [Grimme:2010:154104]. 5; [Grimme:2011:1456]. 6(1,2); [Smith:2016:2197]. 7; [Hujo:2011:3866]. 8; [Chai:2010:6615]. 9; [Pernal:2009:263201]. 10; [Podeszwa:2010:550]. 11; Keyword not used for user-defined functionals where the dft_dict[""dispersion""][""params""]; is easily editable for this purpose. See Advanced Functional Use and Manipulation. 12; [Caldeweyher:2019:154122]. A few practical examples:. DFT-D2 single point with default parameters (dftd3 not called); energy('bp86-d'). DFT-D3BJ optimization with default parameters; optimize('pbe-d3bj'). DFT-D2 optimization with custom s6 parameter; set dft_dispersion_parameters [1.20]; optimize('b3lyp-d2'). DFT-D3ZERO single point (b3lyp) with custom s8 parameter (reset all four values); set dft_dispersion_parameters [1.0, 2.0, 1.261, 14.0]; energy('b3lyp-d3'). DFT-D2 single point with dftd3 instead of PSI4‘s libdisp; energy('pbe-d2', engine='dftd3'). If only dispersion corrections (rather than total energies) are of; interest, the dispersion programs can be run independently of the scf; through the python function run_dftd3() or run_dftd4(). (These functions; call QCEngine, which is the same PSI4 + dftd3/dftd4 interface that is called during an scf job.); This “D-only” route is much faster than running a DFT-D energy.; Note that in a DFT+D energy or gradient calculation, user-specified; dispersion parameters override any information provided about the; functional. The same holds true for a dftd3 “D-only” calculation. But; in a dftd4 “D-only” calculation, functional information overrides; any user-specified dispersion parameters. Some set-up:; molecule nene {; Ne; Ne 1 2.0; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dftd3-1.html:8971,optimiz,optimize,8971,psi4manual/1.5.0/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dftd3-1.html,3,['optimiz'],['optimize']
Performance,"ither absolute accuracy is required; [CCSD(T)] or a -JKFIT auxiliary basis is unavailable for the; primary basis/atoms involved. For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_TOLERANCE keyword to your desired cutoff; (1.0E-12 is recommended for most applications). Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; OUT_OF_CORE unless you run out of disk space.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; He; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('scf'). Table Of Contents. Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Orthogonalization; Initial Guess/Convergence Stabilization; ERI Algor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/scf-1.html:19341,perform,performing,19341,psi4manual/4.0b2/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/scf-1.html,2,['perform'],['performing']
Performance,"ithm for a CISD energy call; and directing to specified or best-performance default modules. select_fnoccsd(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. select_fnoccsd_t_(name, **kwargs)[source]¶; Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. select_lccd(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD energy call; and directing to specified or best-performance default modules. select_lccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. select_mp2(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. select_mp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing to specified or best-performance default modules. select_mp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. select_mp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. select_mp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. select_mp3(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy ca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:168242,perform,performance,168242,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"ithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 calculation. run_mp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_ocepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. run_ocepa_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OCEPA gradient calculation. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2.5 computation. run_omp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2.5 gradient calculation. run_omp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_omp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP3 gradient calculation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. run_sapt(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a SAPT calculation of any level. ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:12718,optimiz,optimized,12718,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"ithm for orbital optimization in the; orbital-optimized coupled-cluster doubles method and in orbital-optimized; second-order Møller–Plesset perturbation theory,” U. Bozkaya, J. M. Turney,; Y. Yamaguchi, H. F. Schaefer, and C. D. Sherrill,; J. Chem. Phys. 135, 104103 (2011).; “Orbital-Optimized Third-Order Møller–Plesset Perturbation Theory and; Its Spin-Component and Spin-Opposite Scaled Variants: Application to; Symmetry Breaking Problems,” U. Bozkaya,; J. Chem. Phys. 135, 224103 (2011). Supported Architectures¶; The majority of PSI4 was developed on Mac and Linux machines. In; principle, it should work on any Unix system; however, we have not tested; extensively on systems other than Mac and Linux. There is not a Windows; version of PSI4.; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. For the Intel compilers, use versions 11 or; 12.1 (we have had trouble with version 12.0). Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contrated Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Gradient, and Frequency. Summary of theoretical methods available in PSI4. Method; Energy; Gradient; Reference; Parallelism. SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. DF-SCF; Y; Y [4]; RHF/ROHF/UHF; threaded. CIS/RPA/TDHF; Y; —;  ;  . DCFT; Y; Y; UHF; partially threaded. SAPT; Y; —; RHF; threaded. MP2; Y; Y [2]; RHF/ROHF/UHF; threaded [3]. DF-MP2; Y; Y; RHF; threaded. ADC(2); Y; —; RHF/ROHF; threaded [3]. CI(n); Y; —; RHF/ROHF; threaded (pthreads). RAS-CI; Y; —; RHF/ROHF; threaded (pthreads). MP(n); Y; —; RHF/ROHF; threaded (pthreads). ZAPT(n); Y; —; RHF/ROHF; threaded (pthreads). CC2; Y; —; RHF/ROHF/UHF; threaded [3]. CCSD; Y; Y; RHF/ROHF/UHF; threaded [3]. CCS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/introduction-1.html:7432,perform,perform,7432,psi4manual/4.0b3/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/introduction-1.html,2,['perform'],['perform']
Performance,"ithon Functions: Invoking a Calculation; Function Intercalls. Function Intercalls¶; This topic is in transition. As of 1.0, the functionality provided by; cp() and cbs() should not be accessed directly. Instead, use the; cp kwarg and/or the extended method syntax like; 'mp3/aug-cc-pv[dt]z' to energy(), opt(), etc., respectively.; For many of the PSI4 Python functions described above, it makes scientific; sense that they could be called in combination. For instance, one could; optimize all the reagents in a database or compute a; counterpoise-corrected interaction energy with an extrapolated method. The; table below outlines permitted intercalls between functions, showing that; db(opt(cbs(energy()))) is allowed, while db(cp(energy())) is not. This; table is not yet validated for calls with cp(). Permitted nesting of Psithon functions¶. Caller; Callee. cp; db; opt; cbs; energy. Basis Set Superposition Corrections. —; Y; Y; Y. Database — database(); —. Y; Y; Y. Geometry Optimization — optimize() and gradient(); —; —. Y; Y. Complete Basis Set; —; —; —. Y. Single-Point Energy — energy(); —; —; —; —. The command db(opt(cbs(energy()))) is actually expressed as db(...,; db_func=opt, opt_func=cbs). The perhaps expected final argument of; cbs_func=energy is not necessary since energy() is always the function; called by default. Also, the outermost internal function call (db_func; above can be called as just func. Several examples of intercalls; between Python functions can be found in sample input pywrap-all.; All keyword arguments are passed along to each function traversed in the; Python driver, so there should be no concern for separating them, grouping; them, or designating them for a particular function when undertaking a; nested calculation. Where the same keyword is used by multiple functions,; prefixes are added, e.g., db_mode and opt_mode.; Function intercalls should not be used in sow/reap mode. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/intercalls-1.html:1091,optimiz,optimize,1091,psi4manual/1.4.0/intercalls-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/intercalls-1.html,9,['optimiz'],['optimize']
Performance,"ithon into pure Python and runs it internally. In PsiAPI mode, you write a pure Python script with import psi4 at the top and commands are behind the psi4. namespace, then submit it to the python interpreter.; Both modes are equally powerful. This tutorial covers the PsiAPI mode. Warning: Although the developers have been using PsiAPI mode stably for months before the 1.1 release and while we believe we’ve gotten everything nicely arranged within the psi4. namespace, the API should not be considered completely stable. Most importantly, as we someday deprecate the last of the global variables, options will be added to the method calls (e.g., energy('scf', molecule=mol, options=opt)); Note: Consult How to run Psi4 as Python module after compilation or How to run Psi4 as a Python module from conda installation for assistance in setting up Psi4. Unlike in the past, where Psi4 was executable software which could only be called via input files like input.dat, it is now interactive, able to be loaded directly as a Python module. Here, we will explore the basics of using Psi4 in this new style by reproducing the section A Psi4 Tutorial from the Psi4 manual in an interactive Jupyter Notebook.; Note: If the newest version of Psi4 (v.1.1a2dev42 or newer) is in your path, feel free to execute each cell as you read along by pressing Shift+Enter when the cell is selected. I. Basic Input Structure¶; Psi4 is now a Python module; so, we need to import it into our Python environment:. [1]:. try:; import os, sys; sys.path.insert(1, os.path.abspath('/scratch/psilocaluser/conda-builds/psi4-docs-multiout_1557966099526/work/build/stage//opt/anaconda1anaconda2anaconda3/lib/python3.6/site-packages')); except ImportError:; pass. import psi4. Psi4 is now able to be controlled directly from Python. By default, Psi4 will print any output to the screen; this can be changed by giving a file name (with path if not in the current working directory) to the function psi4.core.set_output_file() API, a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:1484,load,loaded,1484,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,2,['load'],['loaded']
Performance,"ithon preprocessor automatically wraps any string values in set commands in; strings. The last three examples provide a more convenient way for specifying; multiple keywords:; set{; basis = cc-pVDZ; print = 1; reference = rhf; }. For arguments that require an array input, standard Python list syntax should; be used, viz.:; set{; docc = [3, 0, 1, 1]; }. List/matrix inputs may span multiple lines, as long as the opening [ is; on the same line as the name of the keyword.; Any of the above keyword specifications can be scoped to individual modules,; by adding the name of the module after the set keyword. Omitting the module; name, or using the name global or globals will result in the keyword being; applied to all modules. For example, in the following input; molecule{; o; h 1 roh; h 1 roh 2 ahoh. roh = 0.957; ahoh = 104.5; }. set basis cc-pVDZ; set ccenergy print 3; set scf print 1; energy('ccsd'). the basis set is set to cc-pVDZ throughout, the SCF code will have a print; level of 1 and the ccenergy code, which performs coupled cluster computations,; will use a print level of 3. In this example a full CCSD computation is; performed by running the SCF code first, then the coupled cluster modules;; the energy() Python helper function ensures that this is performed correctly.; Note that the Python interpreter executes commands in the order they appear in; the input file, so if the last four commands in the above example were to read; set basis cc-pVDZ; energy('ccsd'); set ccenergy print 3; set scf print 1. the commands that set the print level would be ineffective, as they would be; processed after the CCSD computation completes. Assigning Basis Sets¶; While the above syntax will suffice for specifying basis sets in most cases,; the user may need to assign basis sets to specific atoms. To achieve this, a; basis block can be used. We use a snippet from the mints2 sample; input file, which performs a benzene SCF computation, to demonstrate this; feature.; basis {; assign DZ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:16083,perform,performs,16083,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,2,['perform'],['performs']
Performance,"ithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:; Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; Function intercalls (e.g., db(opt())) are not tested with sow/reap procedures. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sowreap-1.html:1461,optimiz,optimize,1461,psi4manual/1.2.1/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sowreap-1.html,2,['optimiz'],['optimize']
Performance,"ition data for water cation. fsapt-ext-abc2; FSAPT with external charge on dimer. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. sapt9; usapt example with empty beta. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. ao-dfcasscf-sp; CASSCF/6-31G** energy point. pywrap-basis; SAPT calculation on bimolecular complex where monomers are unspecified so driver auto-fragments it. Basis set and auxiliary basis sets are assigned by atom type. dfmp2-grad1; DF-MP2 cc-pVDZ gradients for the H2O molecule. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. remp-energy1; integral conventional REMP/cc-pVDZ energies for the H2O molecule. results were independently verified against the initial wavels implementation. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. scf-response2; Compute the dipole polarizability for water with custom basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:18698,perform,performs,18698,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"itly depend on orbitals or (CISD, CEPA(0), ACPF,; and AQCC) have solutions that render the energy stationary with respect; variations in the amplitudes. This convenient property allows density; matrices and 1-electron properties to be evaluated without any additional; effort. Note, however, that 1-electron properties are currently; unavailable when coupling these stationary CEPA-like methods with frozen; natural orbitals. Density-fitted coupled cluster¶; Density fitting (DF) or resolution of the identity (RI) techniques are; popular in quantum chemistry to avoid the computation and storage of the; 4-index electron repulsion integral (ERI) tensor and even to reduce the; computational scaling of some terms. DF-CCSD(T) computations are; available in PSI4, with or without the use of FNOs, through the FNOCC; module. The implementation and accuracy of the DF-CCSD(T) method are; described in Ref. [DePrince:2013:inprep].; The default auxiliary basis set for a DF-CCSD computation is chosen to be; the RI set (optimized for DFMP2) most similar to the primary basis set.; For example, if the primary basis set is aug-cc-pVDZ, the default; auxiliary basis set will be the aug-cc-pVDZ-RI set. PSI4 of course; allows the user to specify any supported predefined basis set as the; auxiliary set. Alternatively, the user can request a set defined by the; partial Cholesky decomposition of the 4-index ERI tensor.; The following is a minimal input file that describes a DF-CCSD(T); computation using 3-index integrals obtained by partial Cholesky; decomposition of the 4-index ERI tensor.; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; df_basis_cc cholesky; basis aug-cc-pvdz; freeze_core true; }; energy('df-ccsd(t)'). The accuracy of the Cholesky decomposition may be controlled through the; keyword CHOLESKY_TOLERANCE. Note that the keyword; SCF_TYPE has not been specified here. By default, a DF-CCSD(T); computation exploits DF technology in the SCF procedure, but one can; override ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/fnocc-1.html:8213,optimiz,optimized,8213,psi4manual/4.0b4/fnocc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/fnocc-1.html,2,['optimiz'],['optimized']
Performance,"itting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number \(N\).; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:25301,tune,tuned,25301,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,9,['tune'],['tuned']
Performance,"itudes. Type: integer; Default: 50. CEPA_OS_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 1.27. CEPA_SOS_SCALE¶. CEPA Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. CEPA_SS_SCALE¶. CEPA same-spin scaling value from SCS-CCSD. Type: double; Default: 1.13. CEPA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: CEPA0; Default: CEPA0. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 14. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. Scaling value for 3rd order energy correction (S. Grimme, Vol. 24, pp. 1529, J. Comput. Chem.). Type: double; Default: 0.25. EA_POLES¶. Do compute OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EKT_EA¶. Do compute virtual orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EKT_IP¶. Do compute occupied orbital energies based on extended Koopmans’ theorem?. Type: boolean; Default: false. EP_EA_POLES¶. Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES¶. Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER¶. Maximum number of electron propagator iterations. Type: integer; Def",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html:2105,perform,perform,2105,psi4manual/1.3.2/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__occ-1.html,16,['perform'],['perform']
Performance,"itudes. Type: integer; Default: 50. CHOLESKY¶. Do Cholesky decomposition of the ERI tensor. Type: boolean; Default: false. CHOLESKY_TOLERANCE¶. tolerance for Cholesky decomposition of the ERI tensor. Type: conv double; Default: 1.0e-4. COMPUT_S2¶. Do compute <S2> for DF-OMP2/DF-MP2?. Type: boolean; Default: false. CUTOFF¶. Cutoff value for numerical procedures. Type: integer; Default: 8. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. DO_SCS¶. Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SOS¶. Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. E3_SCALE¶. CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. EKT_IP¶. Do compute ionization potentials based on the extended Koopmans’ theorem?. Type: boolean; Default: false. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. INTEGRAL_CUTOFF¶. Cutoff value for DF integrals. Type: integer; Default: 9. LEVEL_SHIFT¶. Level shift to aid convergence. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html:1577,perform,perform,1577,psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"ity analysis. (Overrides SOLVER_N_ROOT.). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indices specified above (\(0.0\le {\rm occ} \le 1.0\)). Type: array; Default: No Default. Environmental Effects¶. EXTERN¶. An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html:9482,perform,perform,9482,psi4manual/1.7.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html,8,['perform'],['perform']
Performance,"ive molecule to have 2 fragments, not %s.' % (nfrag)). sapt_basis = 'dimer'; if 'sapt_basis' in kwargs:; sapt_basis = kwargs.pop('sapt_basis'); sapt_basis = sapt_basis.lower(). if (sapt_basis == 'dimer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); elif (sapt_basis == 'monomer'):; molecule.update_geometry(); monomerA = molecule.extract_subsets(1); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2); monomerB.set_name('monomerB'). ri = PsiMod.get_option('SCF_TYPE'); df_ints_io = PsiMod.get_option('DF_INTS_IO'). PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); if (sapt_basis == 'dimer'):; PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF' and sapt_basis == 'dimer'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). PsiMod.IO.change_file_namespace(121, 'monomerA', 'dimer'); PsiMod.IO.change_file_namespace(122, 'monomerB', 'dimer'). activate(molecule); PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SAPT', 'E_CONVERGENCE', 10e-10); PsiMod.set_loc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/proc.html:26337,LOAD,LOAD,26337,psi4manual/4.0b2/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,"iven excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (DFOCC); DFOCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_DIIS_NUM_VECS (OCC); OCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (DFOCC); DFOCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_MAXITER (OCC); OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC); OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT (Expert) — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (DFOCC); DFOCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OCC); OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC); OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOGRAD_DAMPING (OCC); OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WITH_VIRTUAL (GLOBALS); GLOBALS — Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MOLDEN_WRITE (DCFT); DCFT — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:163689,optimiz,optimization,163689,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimization']
Performance,"iven excitation level EX_LEVEL. Type: boolean; Default: true. MO_DIIS_NUM_VECS (DFOCC); DFOCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_DIIS_NUM_VECS (OCC); OCC — Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER (DFOCC); DFOCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_MAXITER (OCC); OCC — Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ (MCSCF); MCSCF — Do read in from file the MOs from a previous computation?. Type: boolean; Default: true. MO_READ (OCC); OCC — Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_RELAX (DCFT); DCFT (Expert) — Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. MO_STEP_MAX (DFOCC); DFOCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_STEP_MAX (OCC); OCC — Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE (OCC); OCC — Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MODULE (CPHF); CPHF — What app to test?. Type: string; Possible Values: RCIS, RCPHF, RTDHF, RCPKS, RTDA, RTDDFT; Default: RCIS. MOGRAD_DAMPING (OCC); OCC — Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MOLDEN_WRITE (DCFT); DCFT — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MOLDEN_WRITE (DFOCC); DFOCC — Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:161418,optimiz,optimization,161418,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"iver.OptimizationConvergenceError` if :term:`GEOM_MAXITER <GEOM_MAXITER (OPTKING)>` exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY`. :type name: str; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Extra options passed to the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:62255,optimiz,optimization,62255,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,8,['optimiz'],['optimization']
Performance,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:10772,load,load,10772,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,6,['load'],['load']
Performance,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11115,load,load,11115,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11180,load,load,11180,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was sav",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11129,load,load,11129,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11109,load,load,11109,psi4manual/1.8.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for sa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:135362,load,load,135362,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['load'],['load']
Performance,"ix argument B Right matrix argument beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:10575,load,load,10575,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"ix input. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. omp3-3; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. sapt3; SAPT2+3 aug-cc-pVDZ computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. opt1-fd; SCF STO-3G geometry optimzation, with Z-matrix input, by finite-differences. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). adc1; ADC/6-31G** on H2O. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:15313,optimiz,optimization,15313,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"ix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric positive ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11959,load,load,11959,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:12024,load,load,12024,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ixyz2database.py.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters. name (str) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; psi4.energy(). db_name (str) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (str) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the bsse_type=""cp""; function for BSSE correction in database(). Option available; (See Available Database",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/db-1.html:1859,optimiz,optimize,1859,psi4manual/1.4.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/db-1.html,10,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"ization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:7383,optimiz,optimize,7383,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['optimiz'],['optimize']
Performance,"ization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations (as specified by the psi4.energy() API function). Of course there are other kinds of computations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step; (in principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734908 -76.026632734908 0.01523518",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:7257,optimiz,optimize,7257,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['optimiz'],['optimize']
Performance,"ization of water. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. psimrcc-ccsd_t-3; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt11; Transition-state optimizations of HOOH to both torsional transition states. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. scf-bs; UHF and broken-symmetry UHF energy for molecular hydrogen. pywrap-opt-sowreap; Finite difference optimization, run in sow/reap mode. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. sapt5; SAPT0 aug-cc-pVTZ computation of the charge transfer energy of the water dimer. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. mints3; Test individual integral objects for correctness. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. pywrap-db2; Database calculation, run in sow/reap",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:27698,optimiz,optimization,27698,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"ize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:7172,optimiz,optimizing,7172,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimizing']
Performance,"ize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2; freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3; freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4; set optking {; fixed_distance = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:7184,optimiz,optimizing,7184,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['optimiz'],['optimizing']
Performance,"ized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC; Module: Keywords, PSI Variables, DFOCC. Introduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:1186,optimiz,optimized,1186,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimized']
Performance,"ized Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OCC; Module: Keywords, PSI Variables, DFOCC. Introduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann–Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:1134,optimiz,optimized,1134,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,15,['optimiz'],['optimized']
Performance,"izer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` |; +---------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:61666,perform,perform,61666,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,12,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"ject.__setattr__(self, name, value). [docs]def new_get_attr(self, name):; """"""Function to redefine get_attr method of molecule class.""""""; fxn = object.__getattribute__(self, ""is_variable""); isvar = fxn(name). if isvar:; fxn = object.__getattribute__(self, ""get_variable""); return fxn(name). return object.__getattribute__(self, name). [docs]def BFS(self):; """"""Perform a breadth-first search (BFS) on the real atoms; in molecule, returning an array of atom indices of fragments.; Relies upon van der Waals radii and so faulty for close; (esp. hydrogen-bonded) fragments. Original code from; Michael S. Marshall. """"""; vdW_diameter = {; 'H': 1.001 / 1.5,; 'HE': 1.012 / 1.5,; 'LI': 0.825 / 1.5,; 'BE': 1.408 / 1.5,; 'B': 1.485 / 1.5,; 'C': 1.452 / 1.5,; 'N': 1.397 / 1.5,; 'O': 1.342 / 1.5,; 'F': 1.287 / 1.5,; 'NE': 1.243 / 1.5,; 'NA': 1.144 / 1.5,; 'MG': 1.364 / 1.5,; 'AL': 1.639 / 1.5,; 'SI': 1.716 / 1.5,; 'P': 1.705 / 1.5,; 'S': 1.683 / 1.5,; 'CL': 1.639 / 1.5,; 'AR': 1.595 / 1.5}. Queue = []; White = range(self.natom()) # untouched; Black = [] # touched and all edges discovered; Fragment = [] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). # Simply start with the first atom, do a BFS when done, go to any; # untouched atom and start again iterate until all atoms belong; # to a fragment group; while len(White) > 0 or len(Queue) > 0: # Iterates to the next fragment; Fragment.append([]). while len(Queue) > 0: # BFS within a fragment; for u in Queue: # find all (still white) nearest neighbors to vertex u; for i in White:; dist = physconst.psi_bohr2angstroms * math.sqrt((self.x(i) - self.x(u)) ** 2 + \; (self.y(i) - self.y(u)) ** 2 + (self.z(i) - self.z(u)) ** 2); if dist < vdW_diameter[self.symbol(u)] + vdW_diameter[self.symbol(i)]:; Queue.append(i) # if you find you, put in the queue; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[-1].app",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html:5023,Queue,Queue,5023,psi4manual/4.0b4/_modules/molutil.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/molutil.html,1,['Queue'],['Queue']
Performance,"jection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set global basis cc-pVDZ; >>> set global reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn = True); >>> H2.set_multiplicity(3); >>> psi4.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set globals basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn = True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""MP2/cc-pV[DT]Z""). """"""; kwargs = p4util.kwargs_lower(kwargs). # Bounce if name is function; if hasattr(name, '__call__'):; return name(energy, kwargs.pop('label', 'custom function'), ptype='energy', **kwargs). # Allow specification of methods to arbitrary order; lowername = name.lower(); lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # Bounce to CP if bsse kwarg; if kwargs.get('bsse_type', None) is not None:; return driver_nbody._nbody_gufunc(energy, name, ptype='energy', **kwargs). # Bounce to CBS if ""method/basis"" name; if ""/"" in lowername:; return driver_cbs._cbs_gufunc(energy, name, ptype='energy', **kwargs). # Commit to procedures['energy'] call hereafter; return_wfn = kwargs.pop('return_wfn', False); psi4.clean_variables(). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). for precallback in ho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:28443,perform,perform,28443,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['perform']
Performance,"jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. fsapt-ext-abc; FSAPT with external charge on trimer. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. fsapt-allterms; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for HSG-18-dimer from the HSG database. dft1; DFT Functional Test all values update for new BraggSlater radii. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dct11; Restricted DF-DCT ODC-12 energies with linearly dependent basis functions. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. density-screen-2; RKS Density Matrix based-Integral Screening Test for benzene. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. nbody-multi-level-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:37321,optimiz,optimization,37321,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"jun-cc-pvdz; scf_type df; guess sad; freeze_core true; fisapt_do_plot true # For extra analysis; }. energy('fisapt0'). This is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4‘s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; 1>>> copy_pymol2.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/fisapt-1.html:10790,perform,performed,10790,psi4manual/1.1.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/fisapt-1.html,2,['perform'],['performed']
Performance,"jun-cc-pvdz; scf_type df; guess sad; freeze_core true; fisapt_do_plot true # For extra analysis; }. energy('fisapt0'). This is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4‘s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; >>> copy_pymol2.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some spe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:10841,perform,performed,10841,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,9,['perform'],['performed']
Performance,"jun-cc-pvdz; scf_type df; guess sad; freeze_core true; fisapt_do_plot true # For extra analysis; }. energy('fisapt0'). This is essentially the same input as for F-SAPT, except that the molecular; system is now divided into three moieties – subsystems A and B whose; intramolecular interaction we wish to compute, and a linking unit C. This file; runs a DF-HF computation on the full system using PSI4’s existing SCF code.; At the start of the FISAPT code, the occupied orbitals are localized and divided; by charge considerations into A, B, C, and link sets. By default, linking sigma; bonds are assigned to C (this can be changed by the FISAPT_LINK_ASSIGNMENT; options). Then, non-interacting Hartree–Fock solutions for A and B are optimized; in the embedding field of the linking moiety C. At this point, A and B are not; interacting with each other, but have any potential covalent links or other; interactions with C built in by the embedding. A standard F-SAPT0 computation; is then performed between A and B, yielding the I-SAPT interaction energy. Any; F-SAPT considerations are also possible when I-SAPT is performed – F and I are; completely direct-product-separable considerations. Cube File Visualization with PyMol¶; Setting FISAPT_DO_PLOT true above generates a set of .cube files; containing the densities and ESPs of the various subsystems in the I-SAPT; embedding procedure. These can be used to gain a detailed understanding of the; intermolecular partition and the polarization between non-interacting and; Hartree–Fock-interacting moieties. We have developed a set of template; .pymol scripts to help with this process. These can be obtained by running:; 1>>> copy_pymol2.py. and then in PyMol:; 1>>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; DA.pymol), which in turn load in the molecule and cube file data; (contained in the .cube file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/fisapt-1.html:11159,perform,performed,11159,psi4manual/1.2.1/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/fisapt-1.html,4,['perform'],['performed']
Performance,"k SP basis Fortran exponent parsing. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. dfccsd1; DF-CCSD cc-pVDZ energy for the H2O molecule. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. cbs-xtpl-func; optimization with method defined via cbs. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. mints-helper; A general test of the MintsHelper function. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. scf7; Tests SCF gradient in the presence of a dipole field. cc13c; Tests RHF CCSD(T)gradients. dft-grad-disk; A range-seperated gradient for SO2 to test disk algorithms by explicitly setting low memory. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cbs-x",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:24864,optimiz,optimization,24864,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"k and; gradient computation. Thus, BrianQC will speed up any calculation involving; those terms, such as. HF and DFT single point energies; HF and DFT geometry optimizations; HF and DFT frequency analysis. Note that not every term of every calculation can be handled by BrianQC, thus,; the actual speedup depends on the specifics of the calculation. Necessary and recommended option values¶; To ensure that a calculation works with BrianQC, the following options need to; be set when enabling BrianQC:. BrianQC currently only handles the C1 molecular symmetry point group. Thus, if; the molecule has any symmetries (which PSI4 would detect by default), the; input geometry must contain the line symmetry c1 to force PSI4 to; disregard the symmetry. To achieve peak performance, the following settings are recommended when enabling; BrianQC:. By default, PSI4 uses density-fitted preiterations for SCF, which BrianQC; doesn’t handle yet. To ensure that no non-BrianQC-accelerated iterations are; performed, disable the preiterations by setting DF_SCF_GUESS to False.; By default, PSI4 uses a disk-based Fock building, but BrianQC currently only; accelerates direct Fock builds. To ensure that Fock building is accelerated by; BrianQC, set SCF_TYPE to direct. Keywords¶. BRIANQC_ENABLE¶. Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. Environment Variables¶. BRIANQC_SDK_INSTALL¶; Toggle for type of BrianQC installation.; See https://s3.amazonaws.com/streamnovation-brianqc-manual/BrianQC_Manual_v1_1_0.pdf for details. BRIANQC_INSTALL_PATH¶; Location of BrianQC installation.; See https://s3.amazonaws.com/streamnovation-brianqc-manual/BrianQC_Manual_v1_1_0.pdf for details. BRIANQC_ENABLE¶; Runtime toggle of whether to use BrianQC. table of contents. Interface to the BrianQC GPU module by the BrianQC team; Installing BrianQC; Building BrianQC’s user-built components; Building PSI4 with BrianQC; Using BrianQC from PSI4; When to enable BrianQC; Necessary and recomm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/brianqc-1.html:3954,perform,performed,3954,psi4manual/1.4.0/brianqc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/brianqc-1.html,9,['perform'],['performed']
Performance,"k(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html:1240,optimiz,optimized,1240,psi4manual/1.8.x/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.fchk.html,2,['optimiz'],['optimized']
Performance,"k(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns:; None. Parameters:. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples:. Parameters:. wfn (Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). table of contents. fchk; fchk(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.fchk.html:1240,optimiz,optimized,1240,psi4manual/1.9.x/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.fchk.html,2,['optimiz'],['optimized']
Performance,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than two; excitations. In practice, this usually means that the active space can have; at most two particles, or at most two holes. Examples would include; CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to a; complete-active-space configuration interaction (CAS-CI) reference with n; electrons in m orbitals. If the user specifies active spaces that do not fit; these limitations, then the code will still run, but some relevant; determinants will be missing, and the answer obtained will be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psimrcc-1.html:3086,perform,perform,3086,psi4manual/1.1.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psimrcc-1.html,38,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"k-MRCC with singles and doubles; [Mk-MRCCSD] and Mk-MRCCSD with perturbative triples [Mk-MRCCSD(T)]; as formulated in [Evangelista:2010:074107]. A companion perturbation; method (Mk-MRPT2) has been developed based on the Mukherjee formalisim; as shown in [Evangelista:2009:4728].; The current version of the code is limited to reference active spaces; in which all determinants are connected to each other by no more than; two excitations. In practice, this usually means that the active space; can have at most two particles, or at most two holes. Examples would; include CAS(2,2), CAS(2,8), CAS(4,3), etc., where CAS(n,m) refers to; a complete-active-space configuration interaction (CAS-CI) reference; with n electrons in m orbitals. If the user specifies active spaces; that do not fit these limitations, then the code will still run, but; some relevant determinants will be missing, and the answer obtained; will be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:2400,perform,perform,2400,psi4manual/4.0b2/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html,4,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"k. 'HSG0' Faver et al. JCTC 7 790 (2011).; \(\Rightarrow\) 'HSGA' \(\Leftarrow\) Marshall et al. JCP 135 194102 (2011). subset. 'small'; 'large'. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark. '<benchmark_name>' <Reference>.; \(\Rightarrow\) '<default_benchmark_name>' \(\Leftarrow\) <Reference>. subset. 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. NHTBH¶. Database (Truhlar) of non-hydrogen-transfer barrier height reactions.; Geometries and Reaction energies from Truhlar and coworkers at site http://t1.chem.umn.edu/misc/database_group/database_therm_bh/non_H.htm (broken link). cp 'off'; rlxd 'off'; subset. 'small'; 'large'. CORE¶. Database of Pulay corannulene structures. Subsumed into CFLOW. cp 'off' || 'on'; rlxd 'off'. BBI¶. Database (Merz) of protein backbone-backbone interactions.; Geometries from Kenneth Merz Group, Univ. of Florida.; Reference interaction energies from Sherrill group, Georgia Tech.; Part of the BioFragment Database (BFDb). cp 'off' || 'on'; rlxd 'off'. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset. 'small'; 'large'. table of contents. BAKERJCC96; HBC6; NBC10; S22; NCB31; A24; RSE42; O24by5; O24by5mb; RGC10; S66by8; JSCH; ACENES; A24alt; SSI; HTBH; BASIC; S66; S22by5; HTR40; HSG; BENCH12; NHTBH; CORE; BBI; BAKERJCC93. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon Functions: Invoking a Calculation; Database — database(); BAKERJCC96. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_available_databases.html:13922,optimiz,optimize,13922,psi4manual/1.6.x/autodoc_available_databases.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_available_databases.html,1,['optimiz'],['optimize']
Performance,"k], energies[k], potentials[k], convs[k])); E[Ns[k]] = energies[k]. core.print_out('\n'); core.print_out("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; core.print_out(line). core.print_out('\n ""You shoot a nuke down a bug hole, you got a lot of dead bugs""\n'); core.print_out(' -Starship Troopers\n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]; def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:14593,Optimiz,Optimize,14593,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,3,['Optimiz'],['Optimize']
Performance,"ka Bash on Ubuntu on Windows); or as source code (git repository or zipped archive from; https://github.com/psi4/psi4).; Compilers; PSI4 has been successfully compiled using Intel, GCC, and Clang; compilers. Compiler requirements are primarily; C++11 compliance (i.e., GCC version 4.9 or above).; For some architectures, a precompiled binary is available. See Compiling and Installing for details.; Python; PSI4 1.1 and 1.2 are supported on Python 2.7, 3.5,; and 3.6. After 1.2, only Python 3 will be supported; in accordance with other scientific software projects). Once Python 3.7 is released,; the plan is to support >=3.6 or at least two Python versions. License¶; PSI4 is distributed under the GNU Lesser General Public License; version 3, LGPL-3.0. Its; required dependencies and add-ons have their own licenses, ranging from; BSD-2-Clause to GPL-2.0+. It is possible to build PSI4 without any; GPL dependencies. Capabilities¶; PSI4 can perform ab initio computations employing basis; sets of contracted Gaussian-type functions of virtually arbitrary; orbital quantum number. Many parts of PSI4 can recognize and; exploit the largest Abelian subgroup of the molecular point group.; Table Methods displays the range of theoretical methods; available in PSI4.; For more details, see Tables Energy,; Energy (DFT), Energy (MRCC),; Energy (CFOUR), Gradient,; Gradient (CFOUR), and Frequency. Summary of theoretical methods available in PSI4¶. Method; Energy; Gradient; Parallelism; Variants. Reference; Type; Reference; Type; OO [9]; FNO [1]. HF, HF-3c; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF/ROHF; CONV/DF; threaded;  ;  . DFT, PBEh-3c; RKS/UKS; CONV/DF/CD [7]; RKS/UKS; DF [4]; threaded;  ;  . EFP [5]; RHF;  ; —; —;  ;  ;  . DCFT; RHF/UHF; CONV/DF; RHF/UHF; CONV; partially threaded;  ;  . MP2 [10]; RHF/UHF/ROHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded [3]; E/G;  . MP3 [10]; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded [3]; E/G; E. MP2.5 [10]; RHF/UHF; CONV/DF/CD; RHF/UHF; CONV/DF; threaded [3];",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/introduction-1.html:20419,perform,perform,20419,psi4manual/1.2.1/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/introduction-1.html,2,['perform'],['perform']
Performance,"kash Verma, Wallace D. Derricotte, and Francesco A. Evangelista; The exact-two-component (X2C) approach is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; PSI4 implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian \(H_{\rm X2C}\):. \[H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}\]; that is a sum of a kinetic energy (\(T_{\rm X2C}\)) and potential energy; (\(V_{\rm X2C}\)) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114].; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass–Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos’ ANO basis sets. Note; See also Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess for another relativistic Hamiltonian. A First Example¶; The following is a simple input that will perform a Hartree–Fock calculation; using the X2C Hamiltonian.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy:; 1; 2; 3; 4; 5; 6; 7; 8@RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options¶; The X2C module in PSI4 supports different combinations of basis set.; By default, if the input file specifies only BASIS, then the X2C; module will solve the mod",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/relativistic-1.html:1249,perform,perform,1249,psi4manual/1.1.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/relativistic-1.html,6,['perform'],['perform']
Performance,"kash Verma, Wallace D. Derricotte, and Francesco A. Evangelista; The exact-two-component (X2C) approach is a convenient way to introduce scalar; relativistic effects in DFT and wave function-based methods.; PSI4 implements the spin-free one-electron version of X2C, which produces; a modified one-electron Hamiltonian \(H_{\rm X2C}\):. \[H_{\rm X2C} = T_{\rm X2C} + V_{\rm X2C}\]; that is a sum of a kinetic energy (\(T_{\rm X2C}\)) and potential energy; (\(V_{\rm X2C}\)) operator.; Our implementation is equivalent to the one reported by Cheng and Gauss [Cheng:084114].; X2C calculations require the use of special (alternatively fully uncontracted) basis sets designed for relativistic; calculations. Common choices include the Dunning Douglass–Kroll basis sets; (cc-pVXZ-DK, cc-pCVXZ-DK, cc-pwCVXZ-DK) and Roos’ ANO basis sets. Note; See also Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess for another relativistic Hamiltonian. A First Example¶; The following is a simple input that will perform a Hartree–Fock calculation; using the X2C Hamiltonian.; molecule {; H; F 1 0.92; }. set {; scf_type pk; basis cc-pvdz; relativistic x2c; }. energy('hf'). This computation yields the following result:; @RHF Final Energy: -100.10007984692388. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.7611816259664579; Two-Electron Energy = 45.4843682167491039; Total Energy = -100.1000798469238902. while a non-relativistic calculation yields the following energy:; @RHF Final Energy: -100.01928891411315. => Energetics <=. Nuclear Repulsion Energy = 5.1767335622934780; One-Electron Energy = -150.6645256529074572; Two-Electron Energy = 45.4685031765008461; Total Energy = -100.0192889141131474. Basis sets options¶; The X2C module in PSI4 supports different combinations of basis set.; By default, if the input file specifies only BASIS, then the X2C; module will solve the modified Dirac equation in an uncontracted basis and then; recontract the X2C Hamilt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/relativistic-1.html:1283,perform,perform,1283,psi4manual/1.4.0/relativistic-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/relativistic-1.html,9,['perform'],['perform']
Performance,"keyword is identical to that used in CFOUR_OCCUPATION. For example, for a computational subgroup having four symmetry species, the string 3/1/0/2 specifies that 6 total roots should be searched for, three in the first block, one in the second block, and two in the fourth block. It is also important to note that the %excite* input, if present, takes precedence over this keyword. Default: All zeros. Psi4 Interface: The array above is specified in PSI as (white space tolerant) [3,1,0,2]. Type: array; Default: No Default. CFOUR_ESTATE_TRANS (CFOUR)¶CFOUR — Specifies whether just the excitation energies (OFF, =0) or in addition transition moments (EXPECTATION, =1) are calculated. Note that this keyword should not be used in excited-state calculations involving analytic gradients and that transition moments are essentially only available for EOM-CCSD/CCSD-LR. Type: string; Possible Values: OFF, EXPECTATION; Default: OFF. CFOUR_EVAL_HESS (CFOUR)¶CFOUR — Tells the program, in the course of a geometry optimization, to calculate the Hessian explicitly every N cycles. 0 means never calculated explicitly. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly FULL_HESS_EVERY. Type: integer; Default: 0. CFOUR_EXCITATION (CFOUR)¶CFOUR — Specifies in CC calculations using mrcc the excitation level if the calculation level has been chosen as CC(n), CI(n), or CCn(n). Type: integer; Default: 0. CFOUR_EXCITE (CFOUR)¶CFOUR — Specifies the type of EOM-CC/LR-CC treatment to be performed. Available options are NONE (=0), EOMEE (=3, the EOM-CC/CC-LR approach for the treatment of excited states), EOMIP (=4, the EOM-CC/CC-LR approach for the treatment of ionized states), EOMEA (=7, the EOM-CC/CC-LR approach for the treatment of electron-attached states). Type: string; Possible Values: NONE, EOMEE, EOMIP, EOMEA; Default: NONE. CFOUR_FC_FIELD (CFOUR)¶CFOUR — Specifies the ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:39086,optimiz,optimization,39086,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['optimiz'],['optimization']
Performance,"keyword must match the database python file. Examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; 1; 2; 3; 4RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/db-1.html:6334,perform,performed,6334,psi4manual/1.3.2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/db-1.html,2,['perform'],['performed']
Performance,"keyword must match the database python file. Examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichiometric weights by which the reagent energies are transformed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the dat",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/db.html:6361,perform,performed,6361,psi4manual/1.7.x/db.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/db.html,4,['perform'],['performed']
Performance,"keyword must match the database python file. Examples:. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('mp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric weights by which the reagent energies are transfromed; into the reaction energy. In this case, the dimer is +1 and the monomer is -2,; indicating the the interaction energy is computed from dimer less first monomer; less second (identical) monomer. Error statistics are computed with respect to the reference; energies stored in the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/db-1.html:6100,perform,performed,6100,psi4manual/1.0.0/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/db-1.html,2,['perform'],['performed']
Performance,"kiecutter. This env presently accessed through conda activate cookie.; Enter “constructor-cutter-unified” in the psi4meta repo. There’s a good README there, https://github.com/psi4/psi4meta/blob/master/conda-recipes/constructor-cutter-unified/README.md; Edit cookiecutter/cookiecutter.json for control. Edit which python versions, if necessary; Edit release field; Edit hash field. This is the 7-char hash that’s on every psi4 conda pkg as part of version; Edit ltrtver field. This matches the current setting in conda_build_config.yaml; For prereleases, ""channel_tag"": ""/label/dev"", while for (post)releases, it should be the empty string; Leave this file set to a “rc” with Git, as that has more details. For (post)releases (not prereleases), copy cookiecutter.json to cookiecutter.json-vXXX; Edit cookiecutter/{{.../construct.yaml for templating. This is rarely needed; If it’s been a while or you need the space, clear out ~/.conda/constructor, where the downloaded packages are cached; Note that installers get written to build/ and this gets regenerated each time. Clear out between runs.; python run.py; [Outdated] Watch out for py_ in buildstring as this means a noarch package has been pulled. It must be eliminated. Constructors can’t handle “noarch” packages and will fail at runtime. If see a “noarch” package, must find the recipe and rebuild for all OS & Python combinations. Then run constructor again.; [Replacement] After adding a post_install to reposition the noarch packages, they are safe to include.; If fetching times out, may have to run run.py several times. Clear out build/ in between. It’s the fetching that takes a long time, not constucting; In the end, should have several installers; >>> ls -l build/psi4conda-1.3-py3.*/*64.sh; -rwxr-xr-x. 516M Feb 28 20:30 build/psi4conda-1.3-py3.6-linux-64/psi4conda-1.3-py36-Linux-x86_64.sh; -rwxr-xr-x. 299M Feb 28 20:31 build/psi4conda-1.3-py3.6-osx-64/psi4conda-1.3-py36-MacOSX-x86_64.sh; -rwxr-xr-x. 518M Feb 28 20:30 build/psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:12054,cache,cached,12054,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,7,['cache'],['cached']
Performance,"king_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); opts",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:60098,optimiz,optimize,60098,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,5,['optimiz'],['optimize']
Performance,"kner orbitals. The convergence is determined based on the largest amplitude. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. MP2_AMPS_PRINT¶. Do print the MP2 amplitudes which are the starting guesses for RHF and UHF reference functions?. Type: boolean; Default: false. Larger Calculations¶; Here are a few recommendations for carrying out large-basis-set coupled; cluster calculations with PSI4:. In most cases it is reasonable to set the memory keyword to 90% of; the available physical memory, at most. There is a small amount of overhead; associated with the; coupled",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cc-1.html:5246,cache,cache,5246,psi4manual/4.0b2/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cc-1.html,4,['cache'],['cache']
Performance,"kwargs; check distributed driver is correctly passing function kwargs. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc13b; Tests RHF CCSD(T)gradients. cc17; Single point energies of multiple excited states with EOM-CCSD. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dft-grad-lr3; wB97X-D test for a large UKS molecule update ref gradient due to new BraggSlater radii. decontract; RHF/cc-pvdz-decontract HCl single-point energy Testing the in line -decontract option for basis sets. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. fsapt-terms; F-SAPT0/jun-cc-pvdz procedure for methane dimer. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. scf-ecp3; Water-Argon complex with ECP present; check of UHF Hessian. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:10911,perform,performs,10911,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"l MP2 computations for RHF reference functions. General¶. ABCD¶. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DF_BASIS_MP2¶. Auxiliary basis set for MP2 density fitting calculations. Type: string; Possible Values: basis string; Default: No Default. DF_LMP2¶. Do use density fitting? Turned on with specification of fitting basis. Type: boolean; Default: true. DIAG_METHOD¶. Diagonalization method for the CI matrix. Type: string; Possible Values: DAVIDSON, FULL; Default: DAVIDSON. DIIS¶. Do use DIIS extrapolation to",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html:1201,cache,cache,1201,psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,4,['cache'],['cache']
Performance,"l bases.; Used by complete_basis_set(). scf_xtpl_helgaker_3(**largs)[source]¶; Extrapolation scheme for reference energies with three adjacent zeta-level bases.; Used by complete_basis_set(). corl_xtpl_helgaker_2(**largs)[source]¶; Extrapolation scheme for correlation energies with two adjacent zeta-level bases.; Used by complete_basis_set(). Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/lib/python/aliases.py; (source location) or psi4/share/psi/python/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. sherrill_gold_standard(name='mp2', **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses complete_basis_set() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). allen_focal_point(name='mp2', **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; complete_basis_set() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helgaker_2(). CCSDT and CCSDT(Q); are plain deltas. This wrapper requires Kallay’s MRCC code. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference ge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:14911,perform,performed,14911,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,2,['perform'],['performed']
Performance,"l be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver; from psi4.driver.p4util.exceptions import *. [docs]; def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before UKS?; continuous_guess : Optional[bool]; Do carry along guess rather than reguessing at each occupation?; filename : Optional[str",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html:1690,tune,tuned,1690,psi4manual/1.8.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/frac.html,2,['tune'],['tuned']
Performance,"l control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Psithon Functions: Invoking a Calculation; Geometry Optimization — optimize() and gradient(). © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:17569,optimiz,optimize,17569,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,2,['optimiz'],['optimize']
Performance,"l cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this cas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:26138,optimiz,optimized,26138,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['optimiz'],['optimized']
Performance,"l for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Caching level for libdpd governing the storage of amp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:8632,cache,cache,8632,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['cache'],['cache']
Performance,"l gradient. Type: conv double; Default: 1e-3. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MP2_AMP_TYPE¶. The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently Quasy Newton-Raphson algorithm avaliable with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html:3604,optimiz,optimized-,3604,psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,2,['optimiz'],['optimized-']
Performance,"l gradient. Type: conv double; Default: 1e-3. MOLDEN_WRITE¶. Do write a MOLDEN output file? If so, the filename will end in .molden, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MP2_AMP_TYPE¶. The algorithm that used to handle mp2 amplitudes. The DIRECT option means compute amplitudes on the fly whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html:3575,optimiz,optimized-,3575,psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__dfocc-1.html,4,['optimiz'],['optimized-']
Performance,"l orbital methods [Parrish:2013:174102], the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; 1; 2; 3energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; 1; 2; 3; 4; 5; 6energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an EC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/sapt-1.html:20697,perform,performed,20697,psi4manual/1.3.2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/sapt-1.html,2,['perform'],['performed']
Performance,"l orbital methods [Parrish:2013:174102], the SAPT code; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; 1; 2; 3energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; 1; 2; 3; 4; 5; 6energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (give",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:20361,perform,performed,20361,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,4,['perform'],['performed']
Performance,"l size. Returns; -------; disp_geom; (nat, 3) Displaced geometry.; label; Displacement label for the metadata dictionary. """"""; label = []; disp_geom = np.copy(geom); # This for loop and tuple unpacking is why the function can handle; # an arbitrary number of SALCs.; for salc_index, disp_steps in i_m:; # * Python error if iterate through `salc_list`; for i in range(len(salc_list[salc_index])):; component = salc_list[salc_index][i]; disp_geom[component.atom, component.xyz] += disp_steps * step_size * component.coef / np.sqrt(mass[component.atom]); label.append(f""{salc_index}: {disp_steps}""). # salc_index is in descending order. We want the label in ascending order, so...; # ...add the new label part from the left of the string, not the right.; label = ', '.join(reversed(label)); return disp_geom, label. def _initialize_findif(mol: Union[""qcdb.Molecule"", core.Molecule],; freq_irrep_only: int,; mode: str,; stencil_size: int,; step_size: float,; initialize_string: Callable,; t_project: bool,; r_project: bool,; initialize: bool,; verbose: int = 0) -> Dict:; """"""Perform initialization tasks needed by all primary functions. Parameters; ----------; mol; The molecule to displace; freq_irrep_only; The Cotton ordered irrep to get frequencies for. Choose -1 for all; irreps.; mode; {""1_0"", ""2_0"", ""2_1""}; The first number specifies the derivative level determined from; displacements, and the second number is the level determined at.; stencil_size; {3, 5}; Number of points to evaluate for each displacement basis vector inclusive of central reference geometry.; step_size; [a0]; initialize_string; A function that returns the string to print to show the caller was entered.; The string is both caller-specific and dependent on values determined; in this function.; initialize; For printing, whether call is from generator or assembly stages.; verbose; Set to 0 to silence extra print information, regardless of the print level.; Used so the information is printed only during geometry generati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:6913,Perform,Perform,6913,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Perform'],['Perform']
Performance,"l to the geometry projection module. optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || 'off' ; Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:1717,perform,performs,1717,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,2,['perform'],['performs']
Performance,"l transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously. Setting the QC_TYPE; option to TWOSTEP will perform the Newton-Raphson update only for the orbitals,; while the equations for the cumulant will be solved using a standard Jacobi update.; If requested by the user (set QC_COUPLING to TRUE), the electronic Hessian can include; matrix elements that couple the orbitals and the density cumulant.; The computation of these coupling elements increases; the cost of the macroiteration, but usually leads to faster convergence and is; recommended for open-shell systems.; It is important to note that the quadratically-convergent algorithm is not yet fully; optimized and often converges slowly when the RMS of the cumulant or; the orbital gradient is below .; The choice of the iterative algorithm can significantly affect the cost of the; energy computation. While the two-step algorithm requires a small number of; disk-intensive integral transformations, the simultaneous; algorithm benefits from a smaller number of expensive ; cumulant updates. As a result, for small closed-shell systems the two-step; algorithm is usually preferred, while for larger systems and molecules with; open-shell character it is recommended to use the simultaneous algorithm.; Efficiency of the simultaneous algorithm can be greatly increased by avoiding; the transformation of the four-index virtual two-electron integrals; and computing the terms that involve these integrals in the AO; basis. In order to do that one needs to set the AO_BASIS option to; DISK (currently used by default). For more recommendations on the choice of the algorithm see; Recommendations section. Anal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dcft-1.html:10024,optimiz,optimized,10024,psi4manual/1.0.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dcft-1.html,2,['optimiz'],['optimized']
Performance,"l-ish, but you get the idea; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 90.0; }. set scf {; basis cc-pvdz; scf_type df; }. # Run from 1 to 4 threads, for instance, to record timings; for nthread in range(1,5):; set_num_threads(nthread); energy('scf'). (4) Method-Specific Control; Even more control is possible in certain circumstances. For instance, the; threaded generation of AO density-fitted integrals involves a memory requirement; proportional to the number of threads. This requirement may exceed the total; memory of a small-memory node if all threads are involved in the generation of; these integrals. For general DF algorithms, the user may specify:; set MODULE_NAME df_ints_num_threads n. to explicitly control the number of threads used for integral formation. Setting; this variable to 0 (the default) uses the number of threads specified by the; set_num_threads() Psithon method or the default environmental variables. PBS job file¶; To run a Psi4 job on a PBS queueing system, you need to properly set up; all necessary variables in the PBS job file. Below is a minimal example of; a PBS job file for a threaded job, and a short explanation for each section.; #!/bin/tcsh; #PBS -j oe; #PBS -l pmem=2120mb; #PBS -N jobname; #PBS -V. setenv OMP_NUM_THREADS 4; setenv MKL_NUM_THREADS 4; cd $PBS_O_WORKDIR; setenv myscratch /scratch/user/psi4.$PBS_JOBID. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Creating scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; ssh $i mkdir -p $myscratch; end. unsetenv PSI4DATADIR; unsetenv PSIDATADIR; setenv PSI_SCRATCH $myscratch; if ! ( $?PSIPATH ) setenv PSIPATH """"; setenv PSIPATH /path/to/external/modules:${PSIPATH}; setenv PSIPATH /path/to/python/modules:${PSIPATH}; /psi/install/directory/bin/psi4 -i input.in -o input.out. foreach i (`sort $PBS_NODEFILE | uniq`); echo ""Removing scratch directory "" $myscratch "" on "" $i; ssh $i rm -rf $myscratch; end. The top section features PBS-specific commands. These depend on the; spec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:9749,queue,queueing,9749,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['queue'],['queueing']
Performance,"l.nfragments() # 2. psi4.driver.inputparser.process_input(raw_input, print_level=1)[source]¶; Function to preprocess raw input, the text of the input file, then; parse it, validate it for format, and convert it into legitimate Python.; Does a series of regular expression filters, where the matching portion of the; input is replaced by the output of the corresponding function (in this; module) call. Returns a string concatenating module import lines, a copy; of the user’s .psi4rc files, a setting of the scratch directory, a dummy; molecule, and the processed raw_input. Parameters:. raw_input (str) – Input in a mixture of Python and PSIthon syntax.; print_level (int) – raw_input is printed to the output file unless print_level =0. Return type:; str. psi4.driver.frac.ip_fitting(name, omega_l=0.05, omega_r=2.5, omega_convergence=0.001, maxiter=20, **kwargs)[source]¶; Optimize DFT omega parameter for molecular system. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l (float) – Minimum omega to be considered during fitting.; omega_r (float) – Maximum omega to be considered during fitting.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence (float) – Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter (int) – Maximum number of iterations towards omega convergence. Returns:; Optimal omega parameter. Return type:; float. psi4.driver.frac.frac_traverse(name, **kwargs)[source]¶; Scan electron occupancy from +1 electron to -1. Parameters:. name (Union[str, Callable]) – DFT functional string name or function defining functional; whose omega is to be optimized.; molecule (molecule, optional) – Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult (Optional[int]) – Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult (Optio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/external_apis.html:3305,optimiz,optimized,3305,psi4manual/1.7.x/external_apis.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/external_apis.html,2,['optimiz'],['optimized']
Performance,"l; Point Analysis. JCP 127 014306. Uses; :py:func:`~driver_cbs.complete_basis_set` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD - MP2; kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'mrccsd'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'cc-pV[56]Z'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD(T) - CCSD; kwargs['delta2_wfn'] = kwargs.get('delta2_wfn', 'mrccsd(t)'); kwargs['delta2_wfn_lesser'] = kwargs.get('delta2_wfn_lesser', 'mrccsd'); kwargs['delta2_basis'] = kwargs.get('delta2_basis', 'cc-pV[56]Z'); kwargs['delta2_scheme'] = kwargs.get('delta2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/aliases.html:5405,optimiz,optimization,5405,psi4manual/1.3.2/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/aliases.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,"lFactory (class in psi4.core). integrals, [1]. integrals() (psi4.core.MintsHelper method). integrals_erf() (psi4.core.MintsHelper method). integrals_erfc() (psi4.core.MintsHelper method). IntegralTransform (class in psi4.core). INTERFRAG_COLLINEAR_TOL (OPTKING). INTERFRAG_COORDS (OPTKING). INTERFRAG_DIST_INV (OPTKING). INTERFRAG_HESS (OPTKING). INTERFRAG_MODE (OPTKING). INTERFRAG_STEP_LIMIT (OPTKING). INTERFRAGMENT_CONNECT (OPTKING). INTERNAL_ROTATIONS (MCSCF). INTRAFRAG_HESS (OPTKING). INTRAFRAG_STEP_LIMIT (OPTKING). INTRAFRAG_STEP_LIMIT_MAX (OPTKING). INTRAFRAG_STEP_LIMIT_MIN (OPTKING). INTS_TOLERANCE (CCDENSITY). (DCT). (DFMP2). (FISAPT). (MRCC). (SAPT). (SCF). IntVector (class in psi4.core). invert() (psi4.core.Matrix method). IO (class in psi4.core). IOManager (class in psi4.core). iota() (psi4.core.IntVector static method). ip_fitting() (in module psi4.driver.frac). IP_POLES (OCC). ipi_broker() (in module psi4.driver). IPIBroker (class in psi4.driver.ipi_broker). IRC. ; geometry optimization. IRC_DIRECTION (OPTKING). IRC_POINTS (OPTKING). IRC_STEP_SIZE (OPTKING). IrreducibleRepresentation (class in psi4.core). irrep() (psi4.core.CdSalc method). irrep_index() (psi4.core.CdSalc method). irrep_labels() (psi4.core.Molecule method). is_c_hybrid() (psi4.core.SuperFunctional method). is_c_lrc() (psi4.core.SuperFunctional method). is_c_scs_hybrid() (psi4.core.SuperFunctional method). is_cartesian() (psi4.core.GaussianShell method). is_done() (psi4.core.AOShellCombinationsIterator method). is_gga() (psi4.core.Functional method). (psi4.core.SuperFunctional method). is_inverted() (psi4.core.FittingMetric method). is_libxc_func() (psi4.core.SuperFunctional method). is_lrc() (psi4.core.Functional method). is_meta() (psi4.core.Functional method). (psi4.core.SuperFunctional method). is_poisson() (psi4.core.FittingMetric method). is_pure() (psi4.core.GaussianShell method). is_variable() (psi4.core.Molecule method). is_x_hybrid() (psi4.core.SuperFunctional method). is_x_lrc() (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/genindex.html:67145,optimiz,optimization,67145,psi4manual/1.9.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/genindex.html,2,['optimiz'],['optimization']
Performance,"l_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call (only energy makes sense for cbs); if not('cbs_func' in kwargs):; if ('func' in kwargs):; kwargs['cbs_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['cbs_func'] = energy; func = kwargs['cbs_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper complete_basis_set.' % (func.__name__)); if not(func is energy):; raise ValidationError('Wrapper complete_basis_set is unhappy to be calling function \'%s\' instead of \'energy\'.' % (func.__name__)). # Define some quantum chemical knowledge, namely what methods are subsumed in others; VARH = {}; VARH['scf'] = { 'scftot': 'SCF TOTAL ENERGY'}; VARH['oldmp2'] = { 'scftot': 'SCF TOTAL ENERG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:63352,optimiz,optimize,63352,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,4,['optimiz'],['optimize']
Performance,"l_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs('mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] cbs() coupled with database(); >>> database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [8] cbs() coupled with optimize(); >>> optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). Output¶; At the beginning of a cbs() job is printed a listing of the individual; energy calculations which will be performed. The output snippet below is; from the example job [2] above. It shows first each model chemistry needed; to compute the aggregate model chemistry requested through cbs(). Then,; since, for example, an energy('ccsd(t)') yields CCSD(T), CCSD, MP2,; and SCF energy values, the wrapper condenses this task list into the second; list of minimum number of calculations which will actually be run.; Naive listing of computations required.; scf / aug-cc-pvqz for SCF TOTAL ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvqz for MP2 CORRELATION ENERGY; ccsd(t) / aug-cc-pvdz for CCSD(T) CORRELATION ENERGY; ccsd(t) / aug-cc-pvtz for CCSD(T) CORRELATION ENERGY; mp2 / aug-cc-pvdz for MP2 CORRELATION ENERGY; mp2 / aug-cc-pvtz for MP2 CORRELATION ENERGY. Enlightened listing of computations require",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cbs-1.html:9924,optimiz,optimize,9924,psi4manual/4.0b5/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cbs-1.html,4,['optimiz'],['optimize']
Performance,"l_option_changed((arg0: str) -> bool); Returns boolean for whether the keyword arg1 has been touched in the global scope, by either user or code. has_local_option_changed((arg0: str, ...); Returns boolean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed((arg0: str, ...); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_variable((arg0: str) -> bool); Returns true if the PSI variable exists/is set. initialize(() -> bool). legacy_wavefunction(() -> psi::Wavefunction); Returns the current legacy_wavefunction object from the most recent computation. libfock(...); Runs a CPHF calculation, using libfock. mcscf(...); Runs the MCSCF code, (N.B. mrcc_generate_input(...); Generates an input for Kallay’s MRCC code. mrcc_load_densities(...); Reads in the density matrices from Kallay’s MRCC code. occ(...); Runs the orbital optimized CC codes. opt_clean(() -> None); Cleans up the optimizer’s scratch files. optking(() -> int); Runs the geometry optimization / frequency analysis code. outfile_name(() -> str); Returns the name of the output file. plugin((arg0: str, ...); Call the plugin of name arg0. plugin_close((arg0: str) -> None); Close the plugin of name arg0. plugin_close_all(() -> None); Close all open plugins. plugin_load((arg0: str) -> int); Load the plugin of name arg0. prepare_options_for_module((arg0: str) -> None); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(() -> None); Prints the currently set global (all modules) options to the output file. print_options(() -> None); Prints the currently set options (to the output file) for the current module. print_out((arg0: str) -> None); Prints a string (using sprintf-like notation) to the output file. print_variables(() -> None); Prints all PSI variables that have been set internally. psi_top_s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psi4api-1.html:168271,optimiz,optimized,168271,psi4manual/1.1.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psi4api-1.html,2,['optimiz'],['optimized']
Performance,"labels are present and whether; # all the findif[displacement][energy-or-gradient] values; # are ready. Not sure what type of error/query is best,; # so deferring for now. Also, possibly need to check if; # step size matches before using values from one findifrec; # to construct another quantity.; else:; self.findifrec[""reference""][""gradient""] = G0. if dipole_available:; DD0 = assemble_dipder_from_dipoles(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][""dipole derivative""] = DD0. H0 = assemble_hessian_from_energies(self.findifrec, self.metameta['irrep']); self.findifrec[""reference""][self.driver.name] = H0. [docs]; def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as FiniteDifference-flavored QCSchema."""""". instructions = ""\n"" + p4util.banner(f"" FiniteDifference Results"", strNotOutfile=True) + ""\n""; core.print_out(instructions). self._prepare_results(client=client) # assembled_results. # load QCVariables & properties; qcvars = self.task_list['reference'].get_results().extras['qcvars']; E0 = self.findifrec['reference']['energy']. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": E0,; }. qcvars['FINDIF NUMBER'] = len(self.task_list); qcvars['NUCLEAR REPULSION ENERGY'] = self.molecule.nuclear_repulsion_energy(); qcvars['CURRENT ENERGY'] = E0. DD0 = self.findifrec['reference'].get('dipole derivative'); if DD0 is not None:; qcvars['CURRENT DIPOLE GRADIENT'] = DD0; qcvars[f""{self.method.upper()} DIPOLE GRADIENT""] = DD0. G0 = self.findifrec['reference'].get('gradient'); if G0 is not None:; qcvars['CURRENT GRADIENT'] = G0; qcvars[f""{self.method.upper()} TOTAL GRADIENT""] = G0; properties[""return_gradient""] = G0. H0 = self.findifrec['reference'].get('hessian'); if H0 is not None:; qcvars['CURRENT HESSIAN'] = H0; qcvars[f""{self.method.upper()} TOTAL HESSIAN""] = H0; properties[""return_hessian""] = H0. # if i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html:50457,load,load,50457,psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver_findif.html,6,['load'],['load']
Performance,"lable memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. table of contents. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Theoretical Methods: SCF to FCI; DCT: Density Cumulant Theory. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:15375,perform,performing,15375,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,2,['perform'],['performing']
Performance,"lable memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. table of contents. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Theoretical Methods: SCF to FCI; DCT: Density Cumulant Theory. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/dct-1.html:15375,perform,performing,15375,psi4manual/1.5.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/dct-1.html,2,['perform'],['performing']
Performance,"langle VV||VV\right \rangle\) terms. Type: string; Possible Values: NONE, DISK, DIRECT; Default: NONE. CACHELEVEL¶. The amount of caching of data to perform. Type: integer; Default: 2. DEBUG¶. Reproducing energies from densities ?. Type: integer; Default: 0. GAUGE¶. The type of gauge to use for properties. Type: string; Default: LENGTH. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-14. OPDM_RELAX¶. Do relax the one-particle density matrix?. Type: boolean; Default: false. PROP_ALL¶. Compute non-relaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. WRITE_NOS¶. Do write natural orbitals (molden). Type: boolean; Default: false. XI¶. Do compute Xi?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. OPDM_ONLY¶. For internal use only! Compute the one-particle density matrix, but not the two-particle density matrix. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Default: SCF. XI_CONNECT¶. Do require \(\bar{H}\) and \(R\) to be connected?. Type: boolean; Default: false. table of contents. CCDENSITY; General; AO_BASIS; CACHELEVEL; DEBUG; GAUGE; INTS_TOLERANCE; OPDM_RELAX; PROP_ALL; PROP_ROOT; PROP_SYM; REFERENCE; ROOTS_PER_IRREP; WRITE_NOS; XI; ZETA. Expert; OPDM_ONLY; WFN; XI_CONNECT. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Appendices; Keywords by Module; CCDENSITY. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__ccdensity.html:1862,CACHE,CACHELEVEL,1862,psi4manual/master/autodir_options_c/module__ccdensity.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__ccdensity.html,1,['CACHE'],['CACHELEVEL']
Performance,"lar entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2¶. This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3¶. This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4¶. This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV¶. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC¶. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP¶. Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; De",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:29268,optimiz,optimization,29268,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,24,['optimiz'],['optimization']
Performance,"last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. properties = kwargs.get('properties', ['dipole', 'quadrupole']); kwargs['properties'] = p4util.drop_duplicates(properties). optstash = driver_util._set_convergence_criterion('property', lowername, 6, 10, 6, 10, 8); wfn = procedures['property'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (core.get_variable('CURRENT ENERGY'), wfn); else:; return core.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :raises: psi4.ConvergenceError if |optking__geom_maxiter| exceeded without reaching geometry convergence. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunct",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:49101,optimiz,optimize,49101,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = p4util.kwargs_lower(kwargs); return_wfn = kwargs.pop('return_wfn', False). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', psi4.get_active_molecule()); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = driver_util.parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. properties = kwargs.get('properties', ['dipole', 'quadrupole']); kwargs['properties'] = p4util.drop_duplicates(properties). optstash = driver_util._set_convergence_criterion('property', lowername, 6, 10, 6, 10, 8); wfn = procedures['property'][lowername](lowername, **kwargs). optstash.restore(). if return_wfn:; return (psi4.get_variable('CURRENT ENERGY'), wfn); else:; return psi4.get_variable('CURRENT ENERGY'). [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: *float* |w--w| Total electronic energy of optimized structure in Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:47765,optimiz,optimize,47765,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"last_hessian += 1. # Take step. communicate to/from/within optking through legacy_molecule; core.set_legacy_molecule(moleculeclone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if not core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT'):; if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if not core.get_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:67886,optimiz,optimized,67886,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimized']
Performance,"lated energies with delta correction. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfmp2-freq2; DF-MP2 frequency by difference of energies for H2O. cc51; EOM-CC3/cc-pVTZ on H2O. dfccsdl1; DF-CCSDL cc-pVDZ energy for the H2O molecule. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. nbo; Generation of NBO file. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis and properties for particular root. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. pywrap-freq-e-sowreap; Finite difference of energies frequency, run in sow/reap mode. scf-guess-read3; Test if the the guess read in the same basis converges. dct2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cubeprop; RHF orbitals and density for water. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. opt11; Transition-state optimizations of HOOH to both torsional transition states. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. cc13d; Tests analytic CC2 gradients. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. fnocc6; Test method/basis with disk_df. dft-b3lyp; Check flavors of B3LYP (b3lyp3/b3lyp5) against other programs. pywrap-molecule; Check that C++ Molecule class and qcdb molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:37372,perform,performs,37372,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"lation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to BASIS-RI. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are invo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:4107,perform,performance,4107,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,2,['perform'],['performance']
Performance,"lation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Elst10 and Exch10 density fitting computations, may be important if heavier elements are in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/sapt-1.html:4134,perform,performance,4134,psi4manual/4.0b3/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/sapt-1.html,6,['perform'],['performance']
Performance,"lation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; Psi4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:7363,perform,performance,7363,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performance']
Performance,lcComponent; sapt; SaveType; scalar_variable; scalar_variables; scatter; scfgrad; scfhess; set_active_molecule; set_array_variable; set_datadir; set_global_option; set_global_option_python; set_gradient; set_legacy_gradient; set_legacy_molecule; set_legacy_wavefunction; set_local_option; set_local_option_python; set_memory_bytes; set_num_threads; set_output_file; set_psi_file_prefix; set_scalar_variable; set_variable; ShellInfo; Slice; SOBasisSet; SOMCSCF; SuperFunctional; SymmetryOperation; ThreeCenterOverlapInt; timer_off; timer_on; TracelessQuadrupoleInt; triplet; tstart; tstop; TwoBodyAOInt; TwoElectronInt; UHF; UKSFunctions; variable; variables; VBase; Vector; Vector3; version; Wavefunction; activate; ancestor; AtomicComputer; banner; basis_helper; cbs; check_iwl_file_from_scf_type; compare_fchkfiles; compare_fcidumps; compare_moldenfiles; ConvergenceError; copy_file_from_scratch; copy_file_to_scratch; create_plugin; CSXError; cubeprop; Dftd3Error; dynamic_variable_bind; EmpiricalDispersion; energies_from_fcidump; energy; fchk; fchkfile_to_string; fcidump; fcidump_from_file; find_approximate_string_matches; free_atom_volumes; freq; frequencies; frequency; gdma; geometry; get_memory; gradient; hessian; ipi_broker; join_path; levenshtein; ManagedMethodError; mdi_run; message_box; MissingMethodError; molden; molecule_get_attr; molecule_set_attr; oeprop; opt; OptimizationConvergenceError; optimize; optimize_geometric; ParsingError; PastureRequiredError; pcm_helper; print_stderr; print_stdout; process_input; prop; properties; PsiException; PsiImportError; compare_vibinfos; filter_nonvib; filter_omega_to_real; harmonic_analysis; hessian_symmetrize; print_molden_vibs; print_vibs; thermo; QMMM; QMMMbohr; sanitize_name; scf_helper; scf_wavefunction_factory; SCFConvergenceError; set_memory; set_module_options; set_options; Table; tdscf; TDSCFConvergenceError; temp_circular_import_blocker; TestComparisonError; UpgradeHelper; ValidationError; vibanal_wfn; write_eigenvalues.,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:764045,optimiz,optimize,764045,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,1,['optimiz'],['optimize']
Performance,"lccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:54022,perform,perform,54022,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"lculation is used simply as a device to converge the orbitals. Type: boolean; Default: false. CFOUR_RAMAN_INT (CFOUR)¶CFOUR — ON (=1) requests a calculation of Raman intensities based on the geometrical derivatives of the static polarizability tensor, while DYN (=2) requests a calculation of Raman intensities based on the derivatives of the dynamical polarizability tensor. Type: string; Possible Values: ON, DYN, OFF; Default: OFF. CFOUR_RAMAN_ORB (CFOUR)¶CFOUR — Specifies whether Raman intensities are calculated with orbital relaxation with respect to the electric field perturbation (RELAXED, = 1) or without orbital relaxation (UNRELAXED, = 0). Type: string; Possible Values: RELAXED, UNRELAXED; Default: UNRELAXED. CFOUR_RDO (CFOUR)¶CFOUR — Specifies whether or not relaxed density natural orbitals are to be computed. This option only has meaning for a correlated calculation. For =0, Do not compute. For =1, compute. Type: boolean; Default: true. CFOUR_REFERENCE (CFOUR)¶CFOUR — Specifies the type of SCF calculation to be performed. RHF (= 0) requests a restricted Hartree-Fock reference; UHF (= 1) an unrestricted Hartree-Fock reference; ROHF (= 2) a restricted open-shell Hartree-Fock calculation; TCSCF (=3) a two-configurational SCF calculation, and CASSCF (=4) a complete-active space SCF calculations (currently not implemented). Psi4 Interface: Keyword subject to translation from value of REFERENCE unless set explicitly. Type: string; Possible Values: RHF, UHF, ROHF, TCSCF, CASSCF; Default: RHF. CFOUR_RELATIVISTIC (CFOUR)¶CFOUR — Specifies the treatment of relativistic effects. The default is a non-relativistic treatment (OFF), while perturbational treatments are invoked via MVD1 (mass-velocity and 1-electron Darwin contribution), MVD2 (mass-velocity and 1- and 2-electron Darwin contribution), DPT2 (second-order direct perturbation theory approach), SF-DPT4 (scalar-relativistic part of fourth-order direct perturbation theory, DPT4 (full fourth-order DPT including spin-o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:70624,perform,performed,70624,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['perform'],['performed']
Performance,"lculation. run_mp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 gradient calculation. run_mp2_select(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2_select_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 calculation. run_mp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_ocepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. run_ocepa_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OCEPA gradient calculation. run_oldmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2.5 computation. run_omp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2.5 gradient calculation. run_omp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_omp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:10039,optimiz,optimized,10039,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"lculation. run_mp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 gradient calculation. run_mp2_select(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 energy call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2_select_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 calculation. run_mp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_ocepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. run_ocepa_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OCEPA gradient calculation. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2.5 computation. run_omp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2.5 gradient calculation. run_omp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_omp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP3 gradient calculation. run_psimrcc(name, **kwargs)[source]¶; Function encoding seq",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html:12340,optimiz,optimized,12340,psi4manual/4.0b4/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"lculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. RESTART (CCLAMBDA); CCLAMBDA — Do restart the coupled-cluster iterations from old and amplitudes?. Type: boolean; Default: false. RESTART (CCRESPONSE); CCRESPONSE — Do restart from on-disk amplitudes?. Type: boolean; Default: true. RESTART (DETCI); DETCI — Do restart a DETCI iteration that terminated prematurely? It assumes that the CI and sigma vectors are on disk; the number of vectors specified by RESTART_VECS (obsolete) is collapsed down to one vector per root. Type: boolean; Default: false. RESTART_EOM_CC3 (CCEOM); CCEOM — Do restart from on-disk?. Type: boolean; Default: false. RESTRICTED_DOCC (DETCI); DETCI — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_DOCC (PSIMRCC); PSIMRCC — The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. RESTRICTED_DOCC (TRANSQT); TRANSQT — An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (DETCI); DETCI — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC (TRANSQT); TRANSQT — An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RFO_FOLLOW_ROOT (OPTKING); OPTKING — Do follow the initial RFO vector after the first step?. Type:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:105035,optimiz,optimized,105035,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,6,['optimiz'],['optimized']
Performance,"lds. \[{\bf \kappa} = -{\bf A^{-1}w}\]; This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals, simply set reference rohf. For DFT orbitals, set reference uks and set dft_functional b3lyp. Of; course users can use any DFT functional available in PSI4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; PSI4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through “type select” values in the rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type select. omp2; Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE CONV. Density-Fitted Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP2_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP2; RHF/UHF/ROHF/RKS/UKS; —; MP2_TYPE CD. omp3; Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE CONV. Density-Fitted Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; RHF/UHF/ROHF/RKS/UKS; MP_TYPE DF. Cholesky-Decomposed Orbital-Optimized MP3; RHF/UHF/ROHF/RKS/UKS; —; MP_TYPE CD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:9065,optimiz,optimized,9065,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,11,['optimiz'],['optimized']
Performance,"le Values: SOS, SOSPI; Default: SOS. SPINADAPT_ENERGIES (CCENERGY); CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM); CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG (CCEOM); CCEOM — Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT (CCEOM); CCEOM — SS vectors stored per root. Type: integer; Default: 5. STABILITY_ADD_VECTORS (DCFT); DCFT (Expert) — The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_ANALYSIS (SCF); SCF — Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. STABILITY_AUGMENT_SPACE_TOL (DCFT); DCFT (Expert) — The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK (DCFT); DCFT (Expert) — Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE (DCFT); DCFT (Expert) — Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE (DCFT); DCFT (Expert) — The maximum size of the subspace for the stability check. The program will term",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:118647,perform,performed,118647,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,6,['perform'],['performed']
Performance,"le compilers.; >>> `psi4-path-advisor [your args]` -Dany_addl_cmake_vals=ON; >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; >>> make install. Same for Linux/Mac/Windows. Substitute desired python version: 2.7, 3.5, 3.6. Fine; to choose your own env name. Include -c psi4/label/dev to get dependencies to; build current master, as opposed to latest release.; Activate environment, conda activate; p4dev. Go to where you’ve cloned psi4. Execute psi4-path-advisor.; It gives you a basic cmake command covering python, sphinx, link-time qc; addons, and run-time qc addons. There’s a help menu -h that gives more; info. There’s other options that will also pre-configure compilers. For; example, at GaTech psi4-path-advisor --intel works. On Macs with; XCode, psi4-path-advisor --clang works. Just read the help. For users; who want a minimal build, there’s a --disable-addons, but it is generally not; encouraged. It gives you a fully; functional cmake command, but those are just setting up CMake cache; — like the plugins you can always add your own CMake variables to; the command.; For run-time, you may also wish to install the executable add-ons (e.g., dftd3); >>> conda install numpy psi4-rt. What do the conda packages psi4 & psi4-dev and the installer psi4conda contain¶; psi4 - has full-featured psi4 itself and necessarily all the link-time qc; addons (e.g., chemps2). It has python, pytest, numpy, and a few more python; modules for specialized functions. Of gcc-ness, it has minimal, run-time; libraries (e.g., libgcc-ng) not compilers.; It doesn’t have the run-time qc addons psi4-rt (e.g., dftd3) or build tools (e.g., g++, sphinx, cmake).; psi4-dev - does not have psi4 itself or the run-time addons psi4-rt or numpy (though fine to install them; alongside). Does have all the link-time addons. Does have; cmake and sphinx (and python). Of gcc-ness, has full packages, that is,; compilers as well as runtime packages.; Psi4conda installer - has full-featured psi4 itself, all link-ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/conda-1.html:9642,cache,cache,9642,psi4manual/1.2.1/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/conda-1.html,2,['cache'],['cache']
Performance,"le compilers.; >>> `psi4-path-advisor [your args]` -Dany_addl_cmake_vals=ON; >>> cd objdir && make -j`getconf _NPROCESSORS_ONLN`; >>> make install. Same for Linux/Mac/Windows. Substitute desired python version: 3.5, 3.6, 3.7. Fine; to choose your own env name. Include -c psi4/label/dev to get dependencies to; build current master, as opposed to latest release.; Activate environment, conda activate; p4dev. Go to where you’ve cloned psi4. Execute psi4-path-advisor.; It gives you a basic cmake command covering python, sphinx, link-time qc; addons, and run-time qc addons. There’s a help menu -h that gives more; info. There’s other options that will also pre-configure compilers. For; example, at GaTech psi4-path-advisor --intel works. On Macs with; XCode, psi4-path-advisor --clang works. Just read the help. For users; who want a minimal build, there’s a --disable-addons, but it is generally not; encouraged. It gives you a fully; functional cmake command, but those are just setting up CMake cache; — like the plugins you can always add your own CMake variables to; the command.; For run-time, you may also wish to install the executable add-ons (e.g., dftd3); >>> conda install numpy psi4-rt. What do the conda packages psi4 & psi4-dev and the installer psi4conda contain¶; psi4 - has full-featured psi4 itself and necessarily all the link-time qc; addons (e.g., chemps2). It has python, pytest, numpy, and a few more python; modules for specialized functions. Of gcc-ness, it has minimal, run-time; libraries (e.g., libgcc-ng) not compilers.; It doesn’t have the run-time qc addons psi4-rt (e.g., dftd3) or build tools (e.g., g++, sphinx, cmake).; psi4-dev - does not have psi4 itself or the run-time addons psi4-rt or numpy (though fine to install them; alongside). Does have all the link-time addons. Does have; cmake and sphinx (and python). Of gcc-ness, has full packages, that is,; compilers as well as runtime packages.; Psi4conda installer - has full-featured psi4 itself, all link-ti",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/conda-1.html:9642,cache,cache,9642,psi4manual/1.3.2/conda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/conda-1.html,2,['cache'],['cache']
Performance,"le method. O. OCC_ORBS_PRINT (OCC). OCC_TOLERANCE (FNOCC). (SAPT). OCEPA; . setting keywords. theory. OCEPA(0)CORRELATIONENERGY. OCEPA(0)TOTALENERGY. OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module p4util.util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (CPHF). (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (CPHF). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in p4util.optproc. OptionState class in p4util.optproc. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). p4const module. p4const.__init__ module. p4const.physconst module. p4const.psifiles module. p4regex module. p4util module. p4util.__init__ module. p4util.basislist module. p4util.basislistdunning module. p4util.basislistother module. p4util.optproc module. p4util.procutil module. p4util.text module. p4util.util module. PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_erro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:33502,optimiz,optimization,33502,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['optimiz'],['optimization']
Performance,"le should be provided. Type: integer; Default: 2. GDMA_MULTIPOLE_UNITS (GDMA); GDMA — Whether to print DMA results in atomic units or SI. Type: string; Possible Values: AU; Default: AU SI. GDMA_ORIGIN (GDMA); GDMA — The origin (in Angstrom, expressed as an [x, y, z] array) about which the total multipoles will be computed during DMA. Useful for determining single site expansions at an arbitrary point. Type: array; Default: No Default. GDMA_RADIUS (GDMA); GDMA — The radii to be used, overriding the defaults. Specified as an array [ n1, r1, n2, r2, … ] where n1,n2,n3… are atom type strings and r1,r2,r3 are radii in Angstrom. Type: array; Default: No Default. GDMA_SWITCH (GDMA); GDMA — The value to switch between the older standard DMA and the new grid-based approach. Pairs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. GEOM_MAXITER (OPTKING); OPTKING — Maximum number of geometry optimization steps. Type: integer; Default: 50. GRADIENT_WRITE (FINDIF); FINDIF — Do write a gradient output file? If so, the filename will end in .grad, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. GUESS (SCF); SCF — The type of guess orbitals. Defaults to READ for geometry optimizations after the first step, to CORE for single atoms, and to SAD otherwise. The HUCKEL guess employs on-the-fly calculations like SAD, as described in doi:10.1021/acs.jctc.8b01089. Type: string; Possible Values: AUTO, CORE, GWH, SAD, HUCKEL, READ; Default: AUTO. GUESS_MIX (SCF); SCF — Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST (SCF); SCF — If true, then repeat th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:136105,optimiz,optimization,136105,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"le should be provided. Type: integer; Default: 2. GDMA_MULTIPOLE_UNITS (GDMA); GDMA — Whether to print DMA results in atomic units or SI. Type: string; Possible Values: AU; Default: AU SI. GDMA_ORIGIN (GDMA); GDMA — The origin (in Angstrom, expressed as an [x, y, z] array) about which the total multipoles will be computed during DMA. Useful for determining single site expansions at an arbitrary point. Type: array; Default: No Default. GDMA_RADIUS (GDMA); GDMA — The radii to be used, overriding the defaults. Specified as an array [ n1, r1, n2, r2, … ] where n1,n2,n3… are atom type strings and r1,r2,r3 are radii in Angstrom. Type: array; Default: No Default. GDMA_SWITCH (GDMA); GDMA — The value to switch between the older standard DMA and the new grid-based approach. Pairs of primitives whose exponents sum is above this value will be treated using standard DMA. Set to 0 to force all pairs to be treated with standard DMA. Type: double; Default: 4.0. GEOM_MAXITER (OPTKING); OPTKING — Maximum number of geometry optimization steps. Type: integer; Default: 50. GRADIENT_WRITE (FINDIF); FINDIF — Do write a gradient output file? If so, the filename will end in .grad, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. GUESS (SCF); SCF — The type of guess orbitals. Defaults to SAD for RHF, GWH for ROHF and UHF, and READ for geometry optimizations after the first step. Type: string; Possible Values: AUTO, CORE, GWH, SAD, READ; Default: AUTO. GUESS_MIX (SCF); SCF — Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST (SCF); SCF — If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: fal",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:137163,optimiz,optimization,137163,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimization']
Performance,"le that is not linear in the optimized structure but is in a symmetry plane of the molecule. fci-h2o-2; 6-31G H2O Test FCI Energy Point. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. mom-h2o-4; MOM excitation from LUMO HOMO+4. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. mp2-1; All-electron MP2 6-31G** geometry optimization of water. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:4816,optimiz,optimizations,4816,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimizations']
Performance,"le with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at the output from running the; previous example, we see that the OH bond length is about 0.9463 Ångstroms,; and the bond angle is about 104.575 degrees. It’s good to give this many; digits (or more) to make sure there’s not significant roundoff error in the; geometry when running a frequency computation. So, our frequency; computation input (which can be found as test case; tu4-h2o-freq) is:; #! Frequencies for H2O HF/cc-pVDZ at optimized geometry. memory 250 mb. molecule h2o {; O ; H 1 0.9463; H 1 0.9463 2 104.575; }. set basis cc-pVDZ; set scf_type pk; frequencies('scf'). Alternatively, it’s also possible for PSI4 to use Cartesian coordinate; input. Here, the Cartesian coordinates of the optimized geometry can be; extracted from the bottom of the optimization output. The input; would then look like this:; molecule h2o {; O 0.0000000000 0.0000000000 -0.0647163165; H 0.0000000000 -0.7490459647 0.5135474533; H 0.0000000000 0.7490459647 0.513",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:6158,optimiz,optimized,6158,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['optimiz'],['optimized']
Performance,"le, to study the interaction; energy of ethane and ethyne molecules, we can use the following molecule; block:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15molecule eneyne {; 0 1; C 0.000000 -0.667578 -2.124659; C 0.000000 0.667578 -2.124659; H 0.923621 -1.232253 -2.126185; H -0.923621 -1.232253 -2.126185; H -0.923621 1.232253 -2.126185; H 0.923621 1.232253 -2.126185; --; 0 1; C 0.000000 0.000000 2.900503; C 0.000000 0.000000 1.693240; H 0.000000 0.000000 0.627352; H 0.000000 0.000000 3.963929; }. In this case, the charge and multiplicity of each interacting fragment is; explicitly specified. If the charge and multiplicity are specified for the; first fragment, it is assumed to be the same for all fragments. When; considering interacting fragments, the overall charge is simply the sum of all; fragment charges, and any unpaired electrons are assumed to be coupled to; yield the highest possible \(M_s\) value.; Having defined a molecule containing fragments like eneyne above, it; is a simple matter to perform calculations on only a subset of the; fragments. For instance, the commands below run a scf first on the ethene; fragment alone (extract_subsets(1) pulls out fragment 1 as Real atoms; and discards remaining fragments) and next on the ethene fragment with the; ethyne fragment ghosted (extract_subsets(1,2) pulls out fragment 1 as; Real atoms and sets fragment 2 as Ghost atoms). For beyond bimolecular; complexes, arrays can be used, e.g. extract_subsets(2,[1,3]):; 1; 2; 3; 4; 5; 6; 7mA = eneyne.extract_subsets(1); energy('scf'). clean(). mAcp = eneyne.extract_subsets(1,2); energy('scf'). If the molecule contains fragments but is not conveniently ordered for the; -- marker, the auto_fragments() function can be applied, as shown in; pywrap-basis, to return as active molecule the previous; active molecule, only fragmented. Advanced Python¶; A named molecule in an input file is a full-fledged instance of the; powerful C++ Molecule class. Thus, all member; functions ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html:15944,perform,perform,15944,psi4manual/1.1.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psithonmol-1.html,6,['perform'],['perform']
Performance,"le-point CCSD(T)/qz2p on water with ecc module. cfour/sp-uhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-uhf-cc3; single-point CC3/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/pywrap-cbs1; Various basis set extrapolation tests only in Cfour instead of Psi4. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/puream; Basis set spherical/Cartesian behavior in cfour. cfour/mp2-1; All-electron MP2 6-31G** geometry optimization of water. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd-ao; single-point CCSD/qz2p on water with aobasis. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qc2p on water with ecc, aobasis. cfour/kw-1; testing best practices options, part i. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rhf-cc3; single-point CC3/qz2p on water. cfour/sp-rohf-ccsd_t_-ao; single-point CCSD(T)/qz2p on NH2 with aobasis. cfour/sp-rohf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/sp-rohf-mp4-sc; single-point MP4/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-6; Basis set spherical/Cartesian with cfour_basis and puream. cfour/sp-rhf-scf; single-point HF/qz2p on water. cfour/psi-rhf-mp3; MP3 energy components. Checks that computed identically between cfour and psi4. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. Prev",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:4045,optimiz,optimization,4045,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"le. :type wfn: :py:class:`~psi4.core.Wavefunction`; :param wfn: set of molecule, gradient from which to generate file11. :examples:. >>> # [1] file11 for CISD calculation; >>> G, wfn = gradient('cisd', return_wfn=True); >>> fake_file11(wfn, 'mycalc.11'). """"""; molecule = wfn.molecule(); molecule.update_geometry(); gradient = wfn.gradient(). with open(filename, 'w') as handle:; handle.write('%d\n' % (molecule.natom())). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:2926,perform,performed,2926,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html,4,['perform'],['performed']
Performance,"le. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC)¶FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR)¶CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:8465,cache,cache,8465,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['cache'],['cache']
Performance,"le. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. psimrcc-ccsd_t-4; Mk-MRCCSD(T) single point. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). scf-response2; Compute the dipole polarizability for water with custom basis set. dct5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. nbody-he-4b; MP2/aug-cc-pvDZ many body energies of an arbitrary Helium complex, addressing 4-body formulas. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. zaptn-nh2; ZAPT(n)/6-31G NH2 Energy Point, with n=2-25. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. fsapt1; This test case shows an example of running and analyzing a standard F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. tdscf-5; td-camb3lyp with DiskDF and method/basis specification. pywrap-checkrun-uhf; This checks that all energ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:2155,perform,performs,2155,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,4,"['optimiz', 'perform']","['optimization', 'performs']"
Performance,"le.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'hessian' || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – -1 || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; , requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are not available. Frequencies will proceed through; finite differences according to availability of gradients or energies. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and He",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/freq-1.html:2482,perform,performed,2482,psi4manual/1.0.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/freq-1.html,2,['perform'],['performed']
Performance,"le.schoenflies_symbol(); molecule.reset_point_group('c1'); molecule.fix_orientation(True); molecule.update_geometry(). nfrag = molecule.nfragments(); if nfrag != 2:; raise ValidationError('SAPT requires active molecule to have 2 fragments, not %s.' % (nfrag)). monomerA = molecule.extract_subsets(1, 2); monomerA.set_name('monomerA'); monomerB = molecule.extract_subsets(2, 1); monomerB.set_name('monomerB'); molecule.update_geometry(); monomerAm = molecule.extract_subsets(1); monomerAm.set_name('monomerAm'); monomerBm = molecule.extract_subsets(2); monomerBm.set_name('monomerBm'). ri = PsiMod.get_option('SCF', 'SCF_TYPE'); df_ints_io = PsiMod.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. PsiMod.IO.set_default_namespace('dimer'); PsiMod.set_local_option('SCF', 'SAPT', '2-dimer'); PsiMod.print_out('\n'); banner('Dimer HF'); PsiMod.print_out('\n'); PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); e_dimer = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). activate(monomerA); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'dimer', 'monomerA'); PsiMod.IO.set_default_namespace('monomerA'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF (Dimer Basis)'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerB); if (ri == 'DF'):; PsiMod.IO.change_file_namespace(97, 'monomerA', 'monomerB'); PsiMod.IO.set_default_namespace('monomerB'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_B'); PsiMod.print_out('\n'); banner('Monomer B HF (Dimer Basis)'); PsiMod.print_out('\n'); e_monomerB = scf_helper('RHF', **kwargs); PsiMod.set_global_option('DF_INTS_IO', df_ints_io). activate(monomerAm); PsiMod.IO.set_default_namespace('monomerAm'); PsiMod.set_local_option('SCF', 'SAPT', '2-monomer_A'); PsiMod.print_out('\n'); banner('Monomer A HF (Monomer Basis)'); PsiMod.print_out('\n'); e_monomerA = scf_helper('RHF', **kwargs). activate(monomerBm); Psi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:37348,LOAD,LOAD,37348,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['LOAD'],['LOAD']
Performance,"le; 6-31G H2O Test FCI Energy Point. docs_psimod; This test is used to construct the documentation; it is not suitable for emulation by users. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dfmp2_1; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excita",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:10238,optimiz,optimization,10238,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"le; 6-31G H2O Test FCI Energy Point. tu4-h2o-freq; Frequencies for H2O HF/cc-pVDZ at optimized geometry. dcft3; DCFT-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. pywrap-alias; Test parsed and exotic calls to energy() like zapt4, mp2.5, and cisd are working. cc8b; ROHF-CCSD cc-pVDZ frozen-core energy for the state of the CN radical, with Cartesian input. mints3; Test individual integral objects for correctness. omp3-2; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:12699,optimiz,optimization,12699,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"le; Description. cfour/mints5; geometries from a variety of input formats. references from psi4, testing whether geometry strings read identically for psi4/cfour. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:1180,optimiz,optimization,1180,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"le=monomerB,return_wfn=True). psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'). psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses set df_ints_io save to keep file 97,; which contains the three-index integrals for density fitting. set df_ints_io load; then instructs the program to read these integrals from disk instead of recomputing; them. For each SCF computation, we use psi4.IO.set_default_namespace to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; psi4.IO.change_file_namespace so that integrals can be read from it.; For more information on stability analysis, see the stability; documentation. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. If the open-shell SAPT0 code is used,; [Gonthier:2016:134106] should be add",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:13384,perform,performance,13384,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['perform'],['performance']
Performance,"leInt method. psi4.core.ThreeCenterOverlapInt method. psi4.core.TracelessQuadrupoleInt method. psi4.core.TwoBodyAOInt method. psi4.core.TwoElectronInt method. compute_spin_contamination() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. compute_state_transfer() psi4.core.CIWavefunction method. COMPUTE_TRIPLES (FNOCC). compute_V() psi4.core.VBase method. compute_Vx() psi4.core.VBase method. computeExternExternInteraction() psi4.core.ExternalPotential method. computeNuclearEnergy() psi4.core.ExternalPotential method. computePotentialMatrix() psi4.core.ExternalPotential method. CONDA_PREFIX, [1]. connectivity() psi4.core.Molecule method. CONSECUTIVE_BACKSTEPS (OPTKING). construct() psi4.driver.AtomicComputer class method. construct_from_pydict() psi4.core.BasisSet static method. contact. converged psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. convergence criteria. ; geometry optimization. ConvergenceError. copy() psi4.core.CIVector method. psi4.core.Matrix method. psi4.core.Vector method. psi4.driver.AtomicComputer method. psi4.driver.Table method. copy_file_from_scratch() in module psi4.driver. copy_file_to_scratch() in module psi4.driver. copy_lower_to_upper() psi4.core.Matrix method. copy_upper_to_lower() psi4.core.Matrix method. core_hamiltonian_grad() psi4.core.MintsHelper method. corl_xtpl_helgaker_2() in module psi4.driver.driver_cbs_helper. CORR_ANSATZ (PSIMRCC). CORR_CCSD_T (PSIMRCC). CORR_CHARGE (PSIMRCC). CORR_MULTP (PSIMRCC). CORR_WFN (PSIMRCC). Correlated psi4.core.DerivCalcType attribute. CorrelationFactor class in psi4.core. CorrelationTable class in psi4.core. COSX_BASIS_TOLERANCE (SCF). COSX_DENSITY_TOLERANCE (SCF). COSX_INCFOCK (SCF). COSX_INTS_TOLERANCE (SCF). COSX_OVERLAP_FITTING (SCF). COSX_PRUNING_SCHEME (SCF). COSX_RADIAL_POINTS_FINAL (SCF). COSX_RADIAL_POINTS_INITIAL (SCF). COSX_SPHERICAL_POINTS_FINAL (SCF). COSX_SPHERICAL_POINTS_INI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:36543,optimiz,optimization,36543,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['optimiz'],['optimization']
Performance,"le\) and \(\langle ab\vert\vert ci\rangle\) integrals are held in core; (=5) \(\langle ij\vert\vert kl\rangle\) and \(\langle ij\vert\vert ka\rangle\) and two-index quantities are held in core; (=6) all direct access files (MOINTS, GAMLAM, etc.) are held in core. At present, these options have been implemented only in the energy code xvcc and the excitation energy code xvee. (Default: 0). Type: string; Possible Values: OFF, ALL, PARTIAL; Default: OFF. CFOUR_INPUT_MRCC (CFOUR); CFOUR — Specifies whether an input for mrcc is written (ON, =0) or not (OFF, =1) if CFOUR_CC_PROGRAM =EXTERNAL has been specified. Type: boolean; Default: true. CFOUR_INTEGRALS (CFOUR); CFOUR — This keyword defines what type of integral input will be written by xjoda. VMOL (=1) has to be used with the programs of CFOUR. Using ARGOS (=0), input for Pitzer’s ARGOS integral program will be written. (Default: VMOL). Type: string; Possible Values: VMOL, ARGOS; Default: VMOL. CFOUR_JODA_PRINT (CFOUR); CFOUR — Controls amount of debug printing performed by xjoda. The higher the number, the more information is printed. Values of 25 or higher generally do not produce anything of interest to the general user. Do not set JODA_PRINT to 999 as this will cause the core vector to be dumped to disk. Type: integer; Default: 0. CFOUR_LINEQ_CONV (CFOUR); CFOUR — Convergence threshold for linear equations controlled by LINEQ_TYPE. Equations are iterated until smallest residual falls below \(10^{-N}\), where \(N\) is the value associated with this keyword. Type: integer; Default: 7. CFOUR_LINEQ_MAXCY (CFOUR); CFOUR — The maximum number of iterations in all linear CC equations. Type: integer; Default: 50. CFOUR_LINEQ_TYPE (CFOUR); CFOUR — Determines the algorithm used to solve linear equations ( \(\Lambda\) and derivative \(T\) and \(\Lambda\) ). POPLE (=0) uses Pople’s method of successively orthogonalized basis vectors, while DIIS (=1) uses Pulay’s DIIS method. The latter offers the practical advantage of requiri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:53164,perform,performed,53164,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['perform'],['performed']
Performance,"le_name(), shell=True). if retcode < 0:; print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); exit(1); elif retcode > 0:; print('MRCC errored %d' % retcode, file=sys.stderr); exit(1). except OSError as e:; print('Execution failed: %s' % e, file=sys.stderr); exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; fields = line.split(); m = fields[1]; try:; e = float(fields[5]); if m == ""MP(2)"":; m = ""MP2""; PsiMod.set_variable(m + ' TOTAL ENERGY', e); PsiMod.set_variable(m + ' CORRELATION ENERGY', e - vscf); except ValueError:; continue. # The last 'e' in iface is the one the user requested.; PsiMod.set_variable('CURRENT ENERGY', e); PsiMod.set_variable('CURRENT CORRELATION ENERGY', e - vscf). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSError as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. [docs]def run_fnodfcc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a DF-CCSD(T) computation. >>> energy('df-ccsd(t)'). """"""; lowername = name.lowe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/proc.html:67113,Load,Load,67113,psi4manual/4.0b4/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/proc.html,1,['Load'],['Load']
Performance,"le_psi4rc_file).; All the commands mentioned in section Scratch Files and Elementary Restart can be used in this file,; namely:; psi4_io.set_default_path('/scratch/user'). to set up the scratch path,; import os; scratch_dir = os.environ.get('MYSCRATCH'); if scratch_dir:; psi4_io.set_default_path(scratch_dir + '/'). to set up the scratch path from a variable $MYSCRATCH,; psi4_io.set_specific_path(32, './'); psi4_io.set_specific_retention(32, True). which is equivalent to; psi4_io.set_specific_path(PSIF_CHKPT, './'); psi4_io.set_specific_retention(PSIF_CHKPT, True). to set up a specific path for the checkpoint file and instruct Psi4 not to delete it.; The Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. As a consequence, the commands in the input files supersede; any instructions in the ~/.psi4rc file. During; excecution, the ~/.psi4rc defaults will be loaded in first, but then the commands; in the input file will be executed.; The ~/.psi4rc file can also be used to define constants that are accessible; in input files or to place any Python statements that should be executed; with every Psi4 instance. Threading¶; Most new modules in Psi4 are designed to run efficiently on SMP architectures; via application of several thread models. The de facto standard for Psi4; involves using threaded BLAS/LAPACK (particularly Intel’s excellent MKL package); for most tensor-like operations, OpenMP for more general operations, and Boost; Threads for some special-case operations. Note: Using OpenMP alone is a really; bad idea. The developers make little to no effort to explicitly parallelize; operations which are already easily threaded by MKL or other threaded BLAS. Less; than 20% of the threaded code in Psi4 uses OpenMP, the rest is handled by; parallel DGEMM and other library routines. From this point forward, it is; assumed that you have compiled Psi4 with OpenMP and MKL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/external-1.html:6278,load,loaded,6278,psi4manual/1.0.0/external-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/external-1.html,2,['load'],['loaded']
Performance,"lean for whether the keyword arg2 has been touched in the scope of the specified module arg1, by either user or code. has_option_changed(arg0, arg1); Returns boolean for whether the option arg2 has been touched either locally to the specified module arg1 or globally, by either user or code. has_scalar_variable(arg0); Is the double QC variable (case-insensitive) set?. has_variable(key). initialize(). legacy_wavefunction(); Returns the current legacy_wavefunction object from the most recent computation. mcscf(arg0); Runs the MCSCF code, (N.B. mrcc_generate_input(arg0, arg1); Generates an input for Kallay’s MRCC code. mrcc_load_densities(arg0, arg1); Reads in the density matrices from Kallay’s MRCC code. occ(arg0); Runs the orbital optimized CC codes. opt_clean(); Cleans up the optimizer’s scratch files. option_exists_in_module(arg0, arg1); Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. optking(); Runs the geometry optimization / frequency analysis code. outfile_name(); Returns the name of the output file. plugin(arg0, arg1); Call the plugin of name arg0. plugin_close(arg0); Close the plugin of name arg0. plugin_close_all(); Close all open plugins. plugin_load(arg0); Load the plugin of name arg0. prepare_options_for_module(arg0); Sets the options module up to return options pertaining to the named argument (e.g. print_global_options(); Prints the currently set global (all modules) options to the output file. print_options(); Prints the currently set options (to the output file) for the current module. print_out(arg0); Prints a string (using sprintf-like notation) to the output file. print_variables(); Prints all PSI variables that have been set internally. psi_top_srcdir(); Returns the location of the source code. psimrcc(arg0); Runs the multireference coupled cluster code. reopen_outfile(); Reopens the output file. revoke_global_option_changed(arg0); Given a string of a keyword name arg1, sets the ha",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:297414,optimiz,optimization,297414,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['optimiz'],['optimization']
Performance,"lean; Default: true. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html:6840,perform,perform,6840,psi4manual/1.4.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"least-squares; fitting. Substitution of the DF factorization into the MP2 equations results in; a formal scaling and prefactor reduction of MP2, and further speed gains are; possible due to heavy utilization of matrix-multiplication kernels and minimal; storage requirements in a DF approach. The method has been found to be quite; robust and accurate, and it should be preferred unless extreme accuracy is required; or a fitting basis is not defined for the primary basis and atom type; encountered. In particular, we have found excellent efficiency and tractability; gains when using DF-MP2 in concert with a DF-SCF reference. An efficient,; threaded, disk-based DF-MP2 code is available in PSI4 for all single; reference types available in the SCF module.; MP2 defaults in PSI4 to the density-fitted code.; The support for MP2 by the DFMP2 module in PSI4 is detailed in; Table DFMP2 Capabilities. Even without; set qc_module dfmp2, methods will default to this module, but; alternate implementations and use of MP2_TYPE for performing; a MP2 with conventional integrals can be seen at other modules. Detailed capabilities of the DFMP2 module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[1] ↓ →; FREEZE_CORE[2]→. QC_MODULE=DFMP2 Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[3]; energy(); gradient()[3]; energy(); gradient()[3]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. mp2[4]; MP2_TYPE. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. ✓̳; ✓̳. [1]; Algorithm type selection keyword below. Values to the right: conventional CV, density-fitted DF, and Cholesky-decomposed CD. [2]; Active orbital values to the right: all-electron A and frozen-c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dfmp2.html:2038,perform,performing,2038,psi4manual/1.7.x/dfmp2.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dfmp2.html,4,['perform'],['performing']
Performance,"lecting the algorithm for a CCSD gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy_gradient. if func is None:; raise ManagedMethodError(['select_ccsd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:21192,perform,performance,21192,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"lecular systems. The choices for this; keyword are case sensitive and must match the database python file. [1,2,5] || ['1','2','5'] || ['BzMe-3.5', 'MeMe-5.0'] || etc.; Specify a list of database members to run. Consult the; database python files for available molecular systems. The; choices for this keyword are case sensitive and must match the; database python file. Examples :. >>> # [1] Two-stage SCF calculation on short, equilibrium, and long helium dimer; >>> db('scf','RGC10',cast_up='sto-3g',subset=['HeHe-0.85','HeHe-1.0','HeHe-1.5'], tabulate=['scf total energy','natom']). >>> # [2] Counterpoise-corrected interaction energies for three complexes in S22; >>> # Error statistics computed wrt an old benchmark, S22A; >>> database('dfmp2','S22',cp=1,subset=[16,17,8],benchmark='S22A'). >>> # [3] SAPT0 on the neon dimer dissociation curve; >>> db('sapt0',subset='NeNe',cp=0,symm=0,db_name='RGC10'). >>> # [4] Optimize system 1 in database S22, producing tables of scf and mp2 energy; >>> db('mp2','S22',db_func=optimize,subset=[1], tabulate=['mp2 total energy','current energy']). >>> # [5] CCSD on the smallest systems of HTBH, a hydrogen-transfer database; >>> database('ccsd','HTBH',subset='small', tabulate=['ccsd total energy', 'mp2 total energy']). Output¶; At the beginning of a database job is printed a listing of the individual system; calculations which will be performed. The output snippet below is from the example job [1]; above. It shows each reagent required for the subset of database reactions requested.; Note that this is an un-counterpoise-corrected example, and the wrapper is smart enough; to compute only once the monomer whose energy will be subtracted from each of the three dimers.; RGC1-HeHe-0.85-dimer; RGC1-He-mono-unCP; RGC1-HeHe-1.0-dimer; RGC1-HeHe-1.5-dimer. At the end of the job, the Requested Energy table is printed that gives the total; energies for the requested model chemistry for each reagent and each reaction, as; well as the stoichoimetric we",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/db-1.html:5401,optimiz,optimize,5401,psi4manual/4.0b2/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/db-1.html,2,['optimiz'],['optimize']
Performance,"lecule object.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed at this link. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Tre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/dft-1.html:22271,optimiz,optimizing,22271,psi4manual/4.0b3/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/dft-1.html,12,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"lecule object.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac_nuke(h2o, nmax = 2). Note: this feature is new/powerful enough that we have several papers pending on; it, and are interested in expanding this work. If you would like to publish; results using this code, please contact Rob Parrish to make arrangements for; collaboration. Dispersion Corrections¶; Dispersion corrections are discussed at this link. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; Psi4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Table Of Contents. DFT: Density Functional Theory; Theory; Minimal Input; Spin/Symmetry Tre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:22639,optimiz,optimizing,22639,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,4,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"lecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=""""). # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.close(). # S/R: Read energy from eac",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:30016,Perform,Perform,30016,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['Perform'],['Perform']
Performance,"lecule. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. sapt10; usapt example with empty beta due to frozen core. dft-grad-lr1; wB97X-D cc-pVDZ gradient of S22 HCN update df/pk_ref values due to new BraggSlater radii. scf-cholesky-basis; incremental Cholesky filtered SCF. scf-guess-read3; Test if the the guess read in the same basis converges. extern3; External potential calculation with one Ghost atom and one point charge at the same position. mbis-3; MBIS calculation on OH radical. dfomp2p5-2; DF-OMP2.5 cc-pVDZ energy for the H2O+ cation. isapt-charged; This test case shows an example of running the I-SAPT0/aug-cc-pVDZ computation for a positively charged system, illustrating the cation-pi interaction. The SIAO1 link partitioning algorithm is used. The system is taken from http://dx.doi.org/10.1016/j.comptc.2014.02.008. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. soscf-ref; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. x2c2; Test of SFX2C-1e on Water cc-pVDZ-DK. In this test the Dirac equation is solved in the uncontracted cc-pVDZ-DK basis. The reference numbers are from Lan Cheng’s implementation in Cfour. props2; DF-SCF cc-pVDZ of benzene-hydronium ion, scanning the dissociation coordinate with Python’s built-in loop mechanism. The geometry is specified by a Z-matrix with dummy atoms, fixed parameters, updated parameters, and separate charge/multiplicity specifiers for each monomer. One-electron properties computed for dimer and one monomer. scf7; Tests SCF gradient in the presence of a dipole field. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gra",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:21637,optimiz,optimization,21637,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,4,['optimiz'],"['optimization', 'optimized']"
Performance,"lecule. pywrap-db2; Database calculation, run in sow/reap mode. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. sapt9; usapt example with empty beta. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. psimrcc-fd-freq2; Mk-MRCCSD frequencies. \(^1A_1\) O$_3` state described using the Ms = 0 component of the singlet. Uses TCSCF orbitals. scf-guess-read2; Test if the the guess read in the same basis converges. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mbis-1; MBIS calculation on H2O. phi-ao; Test computing values of basis functions (puream and non-puream) at points. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. sapt-sf1; Tests the Psi4 SF-SAPT code. dft-ghost; DFT Functional Test for Range-Seperated Hybrids and Ghost atoms. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cc53; Matches Table II a-CCSD(T)/cc-pVDZ H2O @ 2.5 * Re value from Crawford and Stanton, IJQC 98, 601-611 (1998). nbody-hessian; Computation of VMFC-corrected HF dimer Hessian. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. opt1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:19265,optimiz,optimization,19265,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"lecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] Optical rotation calculation; >>> property('cc2', properties=['rotation']). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); #PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['property'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Property method %s not available.' % (lowername)). ## Aliases ##; prop = property. [docs]def optimize(name, **kwargs):; r""""""Function to perform a geometry optimization. :aliases: opt(). :returns: (*float*) Total electronic energy of optimized structure in Hartrees. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------+; | name | calls method |; +=========================+=======================================================================================+; | scf | Hartree--Fock (HF) or density functional theory (DFT) |; +-------------------------+---------------------------------------------------------------------------------------+; | dcft | density cumulant functional theory |; +-------------------------+---------------------------------------------------------------------------------------+; | mp2 | 2nd-order Moller-Plesset perturbation theory (MP2) |; +----------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:35305,optimiz,optimized,35305,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['optimiz'],['optimized']
Performance,"lecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: string; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:50774,optimiz,optimization,50774,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['optimiz'],['optimization']
Performance,"led as part of any coupled cluster computation. General¶. ABCD¶. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-8. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html:1226,cache,cache,1226,psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodir_options_c/module__ccenergy-1.html,4,['cache'],['cache']
Performance,"led cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). 1; 2; 3; 4; 5>>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). 1; 2>>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). 1; 2; 3; 4; 5; 6; 7; 8; 9>>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). 1; 2; 3; 4; 5>>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). 1; 2>>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). 1; 2; 3; 4>>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html:14488,perform,perform,14488,psi4manual/1.1.0/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.energy.html,2,['perform'],['perform']
Performance,"led equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]; In the simultaneous algorithm the DCFT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. The macroiterations are repeated until the simultaneous; convergence of the cumulant and orbitals is achieved.; Convergence of the simultaneous algorithm is accelerated using the; DIIS extrapolation technique.; TWOSTEP; In the two-step algorithm each macroiteration consists of two sets of; microiterations. In the first set, the density cumulant equations are solved; iteratively, while the orbitals are kept fixed. After the density cumulant is; converged, the second set of microiterations is performed for the; self-consistent update of the orbitals with the fixed density cumulant. Each; macroiteration is completed by performing the orbital transformation of the; integrals. As in the simultaneous algorithm, the DIIS; extrapolation is used to accelerate convergence. Two-step algorithm is; only available for the DC-06 and DC-12 methods.; QC; In the quadratically-convergent algorithm, the; orbital and cumulant update equations are solved using the Newton-Raphson; method. Each macroiteration of the quadratically-convergent algorithm consists; of a single Newton-Raphson update followed by the orbital transformation; of the integrals. The solution of the Newton-Raphson equations is performed; iteratively using the preconditioned conjugate gradients method, where only the; product of the electronic Hessian with the step vector is computed for; efficiency. By default, the electronic Hessian is build for both the cumulant and orbital; updates and both updates are performed simultaneously",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:9312,perform,performed,9312,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,6,['perform'],['performed']
Performance,"led. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`psi4.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple. :type return_history: :ref:`boolean <op_py_boolean>`; :param return_history: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return dictionary of lists of geometries,; energies, and gradients at each step in the optimization. :type engine: str; :param engine: |dl| ``'optking'`` |dr| || ``'geometric'``. Indicates the optimization engine to use, which can be either Psi4's; native Optking optimizer or the GeomeTRIC program. :type optimizer_keywords: dict; :param optimizer_keywords: Options passed to the GeomeTRIC optimizer. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:60794,optimiz,optimizer,60794,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['optimiz'],['optimizer']
Performance,"ler # Rarely needed; dft_nuclear_scheme treutler # Rarely needed; dft_density_tolerance 1.0E-10 # Rarely needed; dft_basis_tolerance 1.0E-11 # Can speed things up, but benchmark the error; dft_pruning_scheme robust # Generally safe and will speed things up; }. energy('b3lyp'). ERI Algorithms¶; The ERI algorithms for the Coulomb and hybrid exchange are identical to; those for Hartree–Fock. However, for LRC functionals, the long-range; exchange contributions to the Kohn–Sham matrix have only been implemented in the; DF and DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:24370,perform,perform,24370,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,5,['perform'],['perform']
Performance,"les (cheapest terms). mrccsdtqp-1a; CC through quadruples with iterative quintuples (cheapest terms). mrccsdtqph-1a; CC through quintuples with iterative sextuples (cheapest terms). mrccsdt-1b; CC through doubles with iterative triples (cheaper terms). mrccsdtq-1b; CC through triples with iterative quadruples (cheaper terms). mrccsdtqp-1b; CC through quadruples with iterative quintuples (cheaper terms). mrccsdtqph-1b; CC through quintuples with iterative sextuples (cheaper terms). mrcc2; approximate CC through doubles. mrcc3; approximate CC through triples. mrcc4; approximate CC through quadruples. mrcc5; approximate CC through quintuples. mrcc6; approximate CC through sextuples. mrccsdt-3; CC through doubles with iterative triples (all but the most expensive terms). mrccsdtq-3; CC through triples with iterative quadruples (all but the most expensive terms). mrccsdtqp-3; CC through quadruples with iterative quintuples (all but the most expensive terms). mrccsdtqph-3; CC through quintuples with iterative sextuples (all but the most expensive terms). Frozen-core approximation is also supported in the MRCC interface.; To optimize CH4 with CCSDT freezing the 1s on carbon, run:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14molecule H2O {; O; H 1 r; H 1 r 2 104.5. r = 1.0; }. set {; basis cc-pVDZ; freeze_core true; }. optimize('mrccsdt'). Interface Details¶. MRCC methods¶. MRCC_METHOD; Method; Description. 1; CC;  . 2; CC(n-1)[n];  . 3; CC(n-1)(n); (CC(n-1)[n] energy is also calculated). 4; CC(n-1)(n)_L; (CC(n-1)[n] and CC(n-1)(n) energies are also calculated). 5; CC(n)-1a;  . 6; CC(n)-1b;  . 7; CCn;  . 8; CC(n)-3;  . table of contents. Interface to MRCC by M. Kállay; Installation; Running MRCC; Interface Details. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Interfaces: Enhancing PSI4 Capabilities. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/mrcc-1.html:3926,optimiz,optimize,3926,psi4manual/1.3.2/mrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/mrcc-1.html,4,['optimiz'],['optimize']
Performance,"les, doubles, quadruples level of theory. Quantity; MP4(SDQ) CORRELATION ENERGY is; first right-hand term in Eq. (2). MP4 TOTAL ENERGY¶. MP4 CORRELATION ENERGY¶. MP4(SDTQ) TOTAL ENERGY¶. MP4(SDTQ) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the full MP4 level of theory. Quantity MP4 CORRELATION; ENERGY / MP4(SDTQ) CORRELATION ENERGY is left-hand term in Eq. (2). (2)¶\[E_{\text{MP4}} = E_{\text{MP4(SDQ)}} + E_{\text{MP4(T)}}\]. MPn TOTAL ENERGY¶. MPn CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the labeled Møller–Plesset perturbation theory level.; n is MP perturbation order. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [H] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized CEPA(0) level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP2 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [H] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles level; of theory. QCISD(T) TOTAL ENERGY¶. QCISD(T) CORRELATION ENERGY¶; The total electronic energy [H] and correlation energy component [H]; for the quadratic configuration interaction singles and doubles with; perturbative triples correction level of theory. SAPT DISP ENERGY¶. SAPT ELST ENE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html:14766,optimiz,optimized,14766,psi4manual/1.1.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/glossary_psivariables-1.html,2,['optimiz'],['optimized']
Performance,"les, for the benzene-hydronium complex. Atoms can be placed using ZMatrix coordinates, whether they belong to the same fragment or not. Note that the Cartesian specification must come before the ZMatrix entries because the former define absolute positions, while the latter are relative. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt2; SCF DZ allene geometry optimization, with Cartesian input, first in c2v symmetry, then in Cs symmetry from a starting point with a non-linear central bond angle. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. cisd-h2o+-1; 6-31G** H2O+ Test CISD Energy Point. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. dfomp2p5-grad2; DF-OMP2.5 cc-pVDZ gradients for the H2O+ cation. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. ci-property; CI/MCSCF cc-pvDZ ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:19304,optimiz,optimization,19304,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"les. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""); # Considering only [df]occ/dfmp2. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc_gradient; elif module in ['', 'DFMP2']:; func = run_dfmp2_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:5296,perform,performance,5296,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['perform'],['performance']
Performance,"les; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. CFOUR; CHEMPS2; DFTD3; DKH; LIBEFP; ERD; GDMA; MRCC; PCMSOLVER. Sample inputs for PSI4 as distributed are below. Input File; Description. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. cbs-xtpl-gradient; Various gradients for a strained helium dimer and water molecule. cbs-xtpl-opt; Various extrapo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:1404,optimiz,optimization,1404,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,2,['optimiz'],['optimization']
Performance,"let orbitals. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. rasci-ne; Ne atom RASCI/cc-pVQZ Example of split-virtual CISD[TQ] from Sherrill and Schaefer, J. Phys. Chem. XXX This uses a “primary” virtual space 3s3p (RAS 2), a “secondary” virtual space 3d4s4p4d4f (RAS 3), and a “tertiary” virtual space consisting of the remaining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:32807,perform,performs,32807,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['perform'],['performs']
Performance,"lf: psi4.core.Matrix) → None¶; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None¶; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix) → None¶; Zero the lower triangle. zero_upper(self: psi4.core.Matrix) → None¶; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; Matrix. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:18773,load,load,18773,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"lf: psi4.core.Matrix) → None¶; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None¶; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix) → None¶; Zero the lower triangle. zero_upper(self: psi4.core.Matrix) → None¶; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; Matrix. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Crea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:18768,load,load,18768,psi4manual/1.8.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"lf: psi4.core.Matrix) → None¶; Zero all elements of the matrix. zero_diagonal(self: psi4.core.Matrix) → None¶; Zero the diagonal of the matrix. zero_lower(self: psi4.core.Matrix) → None¶; Zero the lower triangle. zero_upper(self: psi4.core.Matrix) → None¶; Zero the upper triangle. table of contents. Matrix; Matrix; Matrix.name; Matrix.np; Matrix.nph; Matrix.shape; Matrix.absmax(); Matrix.accumulate_product(); Matrix.add(); Matrix.add_and_orthogonalize_row(); Matrix.apply_denominator(); Matrix.array_interface(); Matrix.axpy(); Matrix.back_transform(); Matrix.chain_dot(); Matrix.cholesky_factorize(); Matrix.clone(); Matrix.coldim(); Matrix.cols(); Matrix.copy(); Matrix.copy_lower_to_upper(); Matrix.copy_upper_to_lower(); Matrix.diagonalize(); Matrix.doublet(); Matrix.from_array(); Matrix.from_list(); Matrix.from_serial(); Matrix.gemm(); Matrix.general_invert(); Matrix.get(); Matrix.get_block(); Matrix.hermitivitize(); Matrix.hermitize(); Matrix.identity(); Matrix.invert(); Matrix.load(); Matrix.load_mpqc(); Matrix.nirrep(); Matrix.np_read(); Matrix.np_write(); Matrix.partial_cholesky_factorize(); Matrix.power(); Matrix.print_atom_vector(); Matrix.print_out(); Matrix.pseudoinverse(); Matrix.remove_symmetry(); Matrix.rms(); Matrix.rotate_columns(); Matrix.rowdim(); Matrix.rows(); Matrix.save(); Matrix.scale(); Matrix.scale_column(); Matrix.scale_row(); Matrix.schmidt(); Matrix.set(); Matrix.set_block(); Matrix.subtract(); Matrix.sum_of_squares(); Matrix.symmetrize_gradient(); Matrix.symmetry(); Matrix.to_array(); Matrix.to_serial(); Matrix.trace(); Matrix.transform(); Matrix.transpose(); Matrix.transpose_this(); Matrix.triplet(); Matrix.vector_dot(); Matrix.zero(); Matrix.zero_diagonal(); Matrix.zero_lower(); Matrix.zero_upper(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; Matrix. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Crea",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:18864,load,load,18864,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"lgorithm for a MP3 energy call; and directing to specified or best-performance default modules. select_mp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. select_mp4(name, **kwargs)[source]¶; Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. select_olccd(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. select_olccd_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. select_omp2(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. select_omp2_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. select_omp2_property(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. select_omp2p5(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. select_omp2p5_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP2.5 gradient call; and directing to specified or best-performance default modules. select_omp3(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. select_omp3_gradient(name, **kwargs)[source]¶; Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. check_iwl_file_from_scf_type(scf_type, wfn)[source]¶; Ensures that a IWL ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:169891,perform,performance,169891,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['perform'],['performance']
Performance,"lgorithm to use. For debug purposes, selection will be automated later. Type: string; Possible Values: REORDER, YOSHIMINE; Default: REORDER. PK_ALL_NONSYM¶. All densities are considered non symmetric, debug only. Type: boolean; Default: false. PK_MAX_BUCKETS¶. Maximum numbers of batches to read PK supermatrix. Type: integer; Default: 500. PK_NO_INCORE¶. Deactivate in core algorithm. For debug purposes. Type: boolean; Default: false. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. Expert Convergence Control/Stabilization¶. FOLLOW_STEP_INCREMENT¶. When using STABILITY_ANALYSIS = FOLLOW, the increment to modify FOLLOW_STEP_SCALE value if we end up in the same SCF solution. Type: double; Default: 0.2. FOLLOW_STEP_SCALE¶. When using STABILITY_ANALYSIS = FOLLOW, how much to scale the step along the eigenvector by. A full step of pi/2 corresponds to a value of 1.0. Type: double; Default: 0.5. MAX_ATTEMPTS¶. When using STABILITY_ANALYSIS = FOLLOW, maximum number of orbital optimization attempts to make the wavefunction stable. Type: integer; Default: 1. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert SAD Guess Algorithm¶. DF_BASIS_SAD¶. Fitting SAD basis. Type: string; Possible Values: bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:12608,optimiz,optimization,12608,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,2,['optimiz'],['optimization']
Performance,"lgorithms by explicitly setting low memory. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. cisd-sp; 6-31G** H2O Test CISD Energy Point. cbs-xtpl-alpha; Extrapolated water energies. tdscf-3; td-wb97x excitation energies of singlet states of h2o, wfn passing. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. cc13b; Tests RHF CCSD(T)gradients. olccd-grad1; OLCCD cc-pVDZ gradient for the H2O molecule. omp2p5-1; OMP2.5 cc-pVDZ energy for the H2O molecule. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). mbis-4; MBIS calculation on NaCl. numpy-array-interface; Numpy interface testing. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. fci-dipole; 6-31G H2O Test FCI Energy Point. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. ci-multi; BH single points, checking that program can run multiple instances of DETCI in a single input, without an intervening clean() call. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. dfomp2p5-1; DF-OMP2.5 cc-pVDZ energy for the H2O molecule. mints-helper; A general test of the MintsHelper function. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. cc34",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:16559,perform,performed,16559,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"lgorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDINATES set to “BOTH” which; includes both the redundant internal coordinate set, as well as cartesian coordinates,; works well for systems with long ‘arms’ or floppy portions of a molecule poorly; described by local internals. Direct manipulation of the optmization coordinates¶. Generate the internal coordinates and then stop:; 1; 2set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10F 1 3; R 1 2; R 1 3; B 2 1 3; C 1; 1 1.000000; C 1; 2 1.000000; C 1; 3 1.000000. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; 1; 2; 3; 4F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:9930,optimiz,optimizations,9930,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimizations']
Performance,"lib/scripts/ixyz2database.pl.; See Creating a Database for details. Caution; Some features are not yet implemented. Buy a developer some coffee. In sow/reap mode, use only global options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4 ; distribution, add the path to the directory containing the database ; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in ; psi4/lib/databases or PYTHONPATH. Consult that ; directory for available databases and literature citations. func (function) – energy || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || 'off' ; Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || 'off' ; Ind",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/db-1.html:1787,optimiz,optimize,1787,psi4manual/4.0b3/db-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/db-1.html,8,"['optimiz', 'perform']","['optimize', 'performed']"
Performance,"libfock() -> int :; Runs a CPHF calculation, using libfock.; ; mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; occ(...); occ() -> float :; Runs the orbital optimized CC codes.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/psimod-1.html:111392,optimiz,optimizer,111392,psi4manual/4.0b4/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/psimod-1.html,4,['optimiz'],['optimizer']
Performance,"libmintsgshell. INT_ICART() in module qcdb.libmintsgshell. INT_IPURE() in module qcdb.libmintsgshell. INT_NCART() in module qcdb.libmintsgshell. INT_NFUNC() in module qcdb.libmintsgshell. INT_NPURE() in module qcdb.libmintsgshell. INTCOS_GENERATE_EXIT (OPTKING). integer_reactions() Database method. WrappedDatabase method. INTEGRAL_CUTOFF (DFOCC). INTEGRAL_PACKAGE (GLOBALS). interactive module. INTERFRAG_DIST_INV (OPTKING). INTERFRAG_HESS (OPTKING). INTERFRAG_MODE (OPTKING). INTERFRAG_STEP_LIMIT (OPTKING). INTERFRAGMENT_CONNECT (OPTKING). INTERNAL_ROTATIONS (MCSCF). INTRAFRAG_HESS (OPTKING). INTRAFRAG_STEP_LIMIT (OPTKING). INTRAFRAG_STEP_LIMIT_MAX (OPTKING). INTRAFRAG_STEP_LIMIT_MIN (OPTKING). INTS_TOLERANCE (CCDENSITY). (CCSORT). (DCFT). (DFMP2). (FISAPT). (MRCC). (SAPT). (SCF). (TRANSQT2). invalidate() CartesianEntry method. CoordValue method. ZMatrixEntry method. inverse() CharacterTable method. iowa() in module qcdb.mpl. ip_fitting() in module frac. IP_POLES (OCC). IRC; . geometry optimization. IRC_DIRECTION (OPTKING). IRC_STEP_SIZE (OPTKING). IRC_STOP (OPTKING). IrreducibleRepresentation class in qcdb.libmintspointgrp. irrep_labels() LibmintsMolecule method. is_axis() LibmintsMolecule method. is_cartesian() ShellInfo method. is_computed() CoordEntry method. is_equivalent_to() CoordEntry method. is_ghosted() CoordEntry method. is_linear_planar() LibmintsMolecule method. is_plane() LibmintsMolecule method. is_pure() ShellInfo method. is_variable() LibmintsMolecule method. Isotopes. ISTOP (DETCI). items() OrderedDict method. iteritems() in module qcdb.textables. OrderedDict method. iterkeys() OrderedDict method. itervalues() in module qcdb.textables. OrderedDict method. J. jajo2mol() in module qcdb.cfour. JOBTYPE (CCLAMBDA). JSCH module, [1]. K. KEEP_INTCOS (OPTKING). KEEP_OEIFILE (CCSORT). KEEP_TEIFILE (CCSORT). keys() OrderedDict method. keywords; . anharmonicity(), setting. cbs(), setting. database(), setting. energy(), setting. frequency(), setting. general, set",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:43984,optimiz,optimization,43984,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['optimiz'],['optimization']
Performance,"licity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/libefp-1.html:5203,perform,performed,5203,psi4manual/1.4.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/libefp-1.html,9,['perform'],['performed']
Performance,"licity specifications are encoded in the fragment file; and so are not read from input.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in Psi4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. Psi4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:4557,perform,performed,4557,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,2,['perform'],['performed']
Performance,"lif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI': # no default for this case; func = run_detci; elif module in ['']:; psi4.print_out(""""""\nThis method is available inefficiently as a """"""; """"""byproduct of a CISD computation.\n Add ""set """"""; """"""qc_module detci"" to input to access this route.\n""""""). if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_mp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_mp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_omp3(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 energy call; and directing to specified or best-performance default modules. """"""; referen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:9303,perform,performance,9303,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; 1; 2; 3; 4F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; 1; 2; 3; 4F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:10734,optimiz,optimization,10734,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,6,['optimiz'],['optimization']
Performance,"line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. The lines below the simple internal coordinates; specify linear combinations of coordinates. In the simplest default case, the lines; above simply define combination coordinates which are identical to the simple internals.; If OPT_COORDINATES specifies delocalized coordinates, then the combinations; will be more complex.; Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen by adding an asterisk after the letter of the coordinate. The; asterisk results in that internal coordinate being frozen at its initial value. The; “intco” file below for water specifies an optimization with both O-H bonds frozen.:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. If one instead wishes to optimize toward (“fix”) a value that is not satisfied by the; initial structure, then the value is added to the end of the line. The following; corresponds to an optimization that will add additional forces to move the O-H bonds; to 1.70 au.; F 1 3; R 1 2 1.70; R 1 3 1.70; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of displacement (RMS_DISP_G_CONVERGENCE),; all in internal coordinates and atomic units. Usually, these options will not; be set directly. Primary control for geometry convergence lies with the keyword; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:10409,optimiz,optimization,10409,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,7,['optimiz'],['optimization']
Performance,"ling the function property() (instead of, for example, energy(),; e.g., property('ccsd'). There are many sample; coupled cluster inputs provided in psi4/samples. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Breuckner orbitals. The convergence is determined based on the largest amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “lo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/cc-1.html:4469,optimiz,optimizations,4469,psi4manual/4.0b5/cc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/cc-1.html,2,['optimiz'],['optimizations']
Performance,"list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The Psithon function psi4.driver.p4util.Table has been removed,; as the Python ecosystem provides many more flexible alternatives. An; example tabulating a potential energy surface scan for water with Pandas; is shown below:; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,103,2). rows = []; table = []. set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = variable('SCF TOTAL ENERGY'); edfmp2 = variable('MP2 TOTAL ENERGY'); escsmp2 = variable('SCS-MP2 TOTAL ENERGY'); rows.append((R, A)); table.append([escf, escsmp2, edfmp2]). import pandas as pd; df = pd.DataFrame(table, columns = [""E(SCF)"", ""E(SCS)"", ""E(DFMP2)""], index=rows); print(df). # E(SCF) E(SCS) E(DFMP2); # (0.9, 100) -76.020680 -76.217006 -76.221189; # (0.9, 102) -76.021305 -76.217439 -76.22160",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psithoninput.html:11832,perform,performed,11832,psi4manual/1.7.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psithoninput.html,3,['perform'],['performed']
Performance,"list. However, because the Psithon preprocessor; wraps strings in quotes by default, we have to tell it that basis_set is a; Python variable, not a string, by prefixing it with a dollar sign.; The geometry specification supports delayed initialization of variable,; which permits potential energy scans. As an example, we can scan both the; angle and bond length in water:; molecule h2o{; O; H 1 R; H 1 R 2 A; }. Rvals = [0.9, 1.0, 1.1]; Avals = range(102, 106, 2). set basis cc-pvdz; set scf e_convergence=11; for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('scf'). The declarations of Rvals and Avals are both completely standard Python syntax.; Having named our molecule h2o we can then set the values of R and A within; the loops. Note that we do not need the dollar sign to access the Python; variable in this example; that is required only when using Python variables; with the set keyword.; Cartesian geometries, because of details of the geometry update process,; need to be specified within the loop(s) along with their basis set when; geometry scans are performed. See scf4 for analogous Z-matrix; and Cartiesian scans. Tables of Results¶; The results of computations can be compactly tabulated with the Table() Psithon; function. For example, in the following potential energy surface scan for water; molecule h2o {; O; H 1 R; H 1 R 2 A; }. Rvals=[0.9,1.0,1.1]; Avals=range(100,102,2). table=Table(rows=[""R"",""A""], cols=[""E(SCF)"",""E(SCS)"",""E(DFMP2)""]). set basis cc-pvdz. for R in Rvals:; h2o.R = R; for A in Avals:; h2o.A = A; energy('mp2'); escf = get_variable('SCF TOTAL ENERGY'); edfmp2 = get_variable('MP2 TOTAL ENERGY'); escsmp2 = get_variable('SCS-MP2 TOTAL ENERGY'); table[R][A] = [escf, escsmp2, edfmp2]. print table; relative=table.copy(); relative.absolute_to_relative(); print relative. we first define a table (on line 10) with two row indices and three column; indices. As the potential energy scan is performed, the results are stored; (line 22) and the final ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:11832,perform,performed,11832,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,7,['perform'],['performed']
Performance,lize() (built-in function). psi4.Localizer.U() (built-in function). psi4.Matrix.accumulate_product() (built-in function). psi4.Matrix.add() (built-in function). psi4.Matrix.add_and_orthogonalize_row() (built-in function). psi4.Matrix.array_interfaces() (built-in function). psi4.Matrix.back_transform() (built-in function). psi4.Matrix.canonical_orthogonalization() (built-in function). psi4.Matrix.cholesky_factorize() (built-in function). psi4.Matrix.clone() (built-in function). psi4.Matrix.coldim() (built-in function). psi4.Matrix.cols() (built-in function). psi4.Matrix.copy_lower_to_upper() (built-in function). psi4.Matrix.copy_upper_to_lower() (built-in function). psi4.Matrix.diagonalize() (built-in function). psi4.Matrix.doublet() (built-in function). psi4.Matrix.from_array() (built-in function). psi4.Matrix.gemm() (built-in function). psi4.Matrix.get() (built-in function). psi4.Matrix.identity() (built-in function). psi4.Matrix.invert() (built-in function). psi4.Matrix.load() (built-in function). psi4.Matrix.load_mpqc() (built-in function). psi4.Matrix.name() (built-in function). psi4.Matrix.nirrep() (built-in function). psi4.Matrix.np() (built-in function). psi4.Matrix.partial_cholesky_factorize() (built-in function). psi4.Matrix.power() (built-in function). psi4.Matrix.print_out() (built-in function). psi4.Matrix.project_out() (built-in function). psi4.Matrix.remove_symmetry() (built-in function). psi4.Matrix.rms() (built-in function). psi4.Matrix.rowdim() (built-in function). psi4.Matrix.rows() (built-in function). psi4.Matrix.save() (built-in function). psi4.Matrix.scale() (built-in function). psi4.Matrix.scale_column() (built-in function). psi4.Matrix.scale_row() (built-in function). psi4.Matrix.schmidt() (built-in function). psi4.Matrix.set() (built-in function). psi4.Matrix.set_name() (built-in function). psi4.Matrix.shape() (built-in function). psi4.Matrix.subtract() (built-in function). psi4.Matrix.sum_of_squares() (built-in function). psi4.Matrix.symmetr,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/genindex.html:90998,load,load,90998,psi4manual/1.0.0/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/genindex.html,1,['load'],['load']
Performance,"lized data to the correct Psi4 data type; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; json_data (Dict[str, Any]) – Serialization of class. See to_serial() for data layout. Return type:; Matrix | Vector. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. init(self: psi4.core.Vector, arg0: psi4.core.Dimension) → None¶; Reallocate the data of the Vector. Consider making a new object. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the packed data for saving many matrices into the same file. Parameters:. self (Union[Matrix, Vector]) – Instance to be serialized.; filename (Optional[str]) – File name where the data will be saved.; prefix (str) – Name of instance prepared for NumPy. Returns:; When filename given, it and dict serialization passed to; numpy.savez(), so .npz file saved and None returned.; When filename None, dict serialization returned. Return type:; None or Dict[str, Any]. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self:",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:5459,load,load,5459,psi4manual/1.9.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html,2,['load'],['load']
Performance,"ll be an approximation to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization.; Hence, the references used might be considered CAS-CI references,; but not CASSCF references (CASSCF implies that the orbitals have been; optimized specifically to minimize the energy of the CAS-CI reference).; However, if one wishes to use two-configuration self-consistent-field; (TCSCF) orbitals, those can be obtained using the multi-configuration; self-consistent-field (MCSCF) component of PSIMRCC (specifying; REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use; RHF or ROHF orbitals as input to PSIMRCC. Due to a current limitation; in the code, one must obtain orbitals using PSIMRCC’s MCSCF module; regardless of what orbital type is chosen, twocon, rhf, or; rohf. An example of the MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin; states (e.g., triplets), but in general, not all the required matrix; elements have been coded for high-spin cases, meaning that results will; correspond to an approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T]. The CORR_MULTP option allows you to select the Slater determinants with a particular value. The WFN_SYM keyword is neccesary if you do not want to compute the energy of the all-symmetric state. The FOLLOW_ROOT option may be used to follow different roots of the effective Hamiltonian. A value of 1 instructs PSIMRCC to follow the solution with the lowest energy given a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc {; corr_wfn ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html:3296,perform,performing,3296,psi4manual/4.0b2/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psimrcc-1.html,2,['perform'],['performing']
Performance,"ll be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psimrcc-1.html:3981,perform,performing,3981,psi4manual/1.1.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psimrcc-1.html,6,['perform'],['performing']
Performance,"ll be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular \(M_s\) value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psimrcc-1.html:4023,perform,performing,4023,psi4manual/1.4.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psimrcc-1.html,5,['perform'],['performing']
Performance,"ll be an approximation; to the true Mk-MRCC procedure.; The PSIMRCC code itself does not perform orbital optimization. Hence, the; references used might be considered CAS-CI references, but not CASSCF; references (CASSCF implies that the orbitals have been optimized specifically; to minimize the energy of the CAS-CI reference). However, if one wishes to; use two-configuration self-consistent-field (TCSCF) orbitals, those can; be obtained using the multi-configuration self-consistent-field (MCSCF); component of PSIMRCC (specifying REFERENCE to be twocon).; This is suitable for describing diradicals. Otherwise, one may use RHF or; ROHF orbitals as input to PSIMRCC. Due to a current limitation in the code,; one must obtain orbitals using PSIMRCC’s MCSCF module regardless of what; orbital type is chosen, twocon, rhf, or rohf. An example of the; MCSCF input is given below.; PSIMRCC is most commonly used for low-spin cases (singlets or open-shell; singlets). It is capable of performing computations on higher spin states; (e.g., triplets), but in general, not all the required matrix elements have; been coded for high-spin cases, meaning that results will correspond to an; approximate Mk-MRCC computation for high-spin cases. A Simple Example¶; The CORR_WFN allows you to select one of three methods; Mk-MRPT2 [PT2], Mk-MRCCSD [CCSD], or Mk-MRCCSD(T) [CCSD_T].; The CORR_MULTP option allows you to select the Slater; determinants with a particular value. The WFN_SYM; keyword is neccesary if you do not want to compute the energy of the; totally-symmetric state. The FOLLOW_ROOT option may be used; to follow different roots of the effective Hamiltonian. A value of 1; instructs PSIMRCC to follow the solution with the lowest energy given; a certain set of determinants.; molecule o2 {; 0 3; O; O 1 2.265122720724; units au; }; set {; basis cc-pvtz; }; set mcscf {; reference rohf; docc [3,0,0,0,0,2,1,1] # Doubly occupied MOs; socc [0,0,1,1,0,0,0,0] # Singly occupied MOs; }; set psimrcc ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psimrcc-1.html:3330,perform,performing,3330,psi4manual/1.0.0/psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psimrcc-1.html,8,['perform'],['performing']
Performance,"ll cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }. set {; reference uhf; scf_type df; basis cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }. dimer = psi4.get_active_molecule(). set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_names",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/sapt-1.html:11154,perform,performing,11154,psi4manual/1.2.1/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/sapt-1.html,4,['perform'],['performing']
Performance,"ll cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }. set {; reference uhf; scf_type df; basis cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42; 43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }. dimer = psi4.get_active_molecule(). set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monom",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:11130,perform,performing,11130,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['perform'],['performing']
Performance,"ll interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING); OPTKING — Specify angles between atoms to be frozen. Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen. Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen. Type: string; Default: No Default. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_DOCC (PSIMRCC); PSIMRCC — The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FROZEN_UOCC (PSIMRCC); PSIMRCC — The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. FZC_A_FILE (TRANSQT); TRANSQT — Alpha-spin frozen-core file. Type: integer; Default: PSIF_OEI. FZC_B_FILE (TRANSQT); TRANSQT — Beta-spin frozen-core file. Type: integer; Default: PSIF_OEI. FZC_FILE (TRANSQT); TRANSQT — Frozen-core file. Type: integer; Default: PSIF_OEI. G_CONVERGENCE (OPTKING); O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:49798,optimiz,optimized,49798,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"ll not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently Quasy Newton-Raphson algorithm avaliable with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:12108,optimiz,optimize,12108,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimize']
Performance,"ll not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/occ-1.html:14960,optimiz,optimize,14960,psi4manual/1.3.2/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/occ-1.html,2,['optimiz'],['optimize']
Performance,"ll not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Basic DFOCC Keywords¶. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. Type: conv double; Default: 1e-3. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced DFOCC Keywords¶. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian options. Type: string; Possible Values: QNR; Default: QNR. HESS_TYPE¶. Type of the MO Hessian matrix. Type: string; Possible Values: APPROX_DIAG, APPROX_DIAG_EKT, APPROX_DIAG_HF, HF; Default: HF. MO_DIIS_NUM_VECS¶. Number of vectors used in orbital DIIS. Type: integer; Default: 6. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories¶; Non-orbital-optimized counterparts to higher order MPn methods are also; available. The following methods are available and can be controlled; through OCC (conventional integrals CONV) and DFOC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:14965,optimiz,optimize,14965,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,4,['optimiz'],['optimize']
Performance,"ll result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:2897,optimiz,optimization,2897,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['optimiz'],['optimization']
Performance,"ll result in the molecule being converted to a Cartesian representation. The ongoing development of optking is providing for unique treatment of; coordinates which connect distinct molecular fragments. Thus, several keywords; relate to “interfragment modes”, though many of these capabilities are; still under development. Presently by default, separate fragments are bonded by; nearest atoms, and the whole system is treated as if it were part of one; molecule. However, with the option FRAG_MODE, fragments; may instead be related by a unique set of interfragment coordinates defined by; reference points within each fragment. The reference points can be atomic; positions (current default), linear combinations of; atomic positions, or located on the principal axes (not yet working). Basic Keywords¶. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD; Default: RFO. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. FULL_HESS_EVERY¶. Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Opt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/optking-1.html:3242,optimiz,optimization,3242,psi4manual/4.0b3/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/optking-1.html,2,['optimiz'],['optimization']
Performance,"ll three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. INTS_TOLERANCE (SCF); SCF — Minimum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. IP_POLES (OCC); OCC — Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. IRC_DIRECTION (OPTKING); OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING); OPTKING — IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. IRC_STOP (OPTKING); OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISTOP (DETCI); DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. JOBTYPE (CCLAMBDA); CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. KEEP_INTCOS (OPTKING); OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. LEVEL_SHIFT (DFOCC); DFOCC — Level shift to aid convergence. Type: double; Default: 0.02. LEVEL_SHIFT (MCSCF); MCSCF — Level shift to aid convergence. Type: double; Default: 0.0. LEVEL_SHIFT (OCC); OCC — Level shift to aid convergence. Type: double; Default: 0.02. LINEAR (CCRESPONSE); CCRESPONSE — Do Bartlett size-extensive linear model?. Type: boolean; Default: false. LINEQ_SOLVER (DFOCC); DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINEQ_SOLVER (OCC); OCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINESEARCH_STATIC_MAX (OPTKING); OPTKING — If doing a static line search, this fixes the largest step, whose largest change in an internal c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:147823,perform,performed,147823,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['perform'],['performed']
Performance,"llation and Runtime Configuration. Obtaining PSI4¶. How to obtain Psi4: start with find-the-code quiz, end in {top-level-psi4-dir}¶; Take a quiz to find the best version of the codebase for; your needs, be it binary, tarball, or version-controlled repository. Or,; select outright among:. Binary Installer; faq:condapkg; Clone from GitHub Repository (read-only unless core developer); Fork from GitHub Repository; Tarball from GitHub Repository; Psi3 from SourceForge. Find-the-code Quiz¶. I just want to run the code. I may tweak the Python, but I’m not; developing anything to contribute back to the code base.; Provided I still get good, threaded BLAS/LAPACK, I’m willing to; sacrifice processor architecture fine tuning to avoid compiling it myself.; I’m on Linux or Mac or Windows with Ubuntu Bash Shell.; I’m familiar with conda and want to manage PSI4 as an; ordinary conda package. — Goto Binary-Package; I just want a PSI4 installer. — Goto; Binary-Installer. I want to compile it myself for best performance on my computer.; I’m willing to have minimal dealings with git (e.g., commands git; clone and git pull) in return for easy access in future to new; features and bug fixes. — Goto Clone-from-GitHub; I don’t want to deal with this newfangled git, just give me a; tarball of the source code — Goto Tarball-from-GitHub. I want to run and develop in PSI4.; In keeping with the open-source philosophy, I don’t mind my code being; as public as Psi4 itself during the development process. —; Goto Fork-from-GitHub; I want to develop using PSI4 infrastructure and libraries, not; on them; I think a plugin might do.; I’ve got a PSI4 compilation. Use it, then consult plugins; I’d rather not compile PSI4 or I don’t have compilers —; Goto Binary-Package then consult; plugins through conda. I really like parentheses and/or DBOC, so I want Psi3. —; Goto Psi3-from-SourceForge. Binary Installer¶. Get Initially; Just go to http://www.psicode.org/downloads.html and follow the; instructions ther",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_obtaining-1.html:1100,perform,performance,1100,psi4manual/1.2.1/build_obtaining-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_obtaining-1.html,2,['perform'],['performance']
Performance,"llects results into a dictionary; if (db_mode.lower() == 'continuous'):; exec banners; exec GEOS[rgt]; exec commands; #print 'MOLECULE LIVES %23s %8s %4d %4d %4s' % (rgt, PsiMod.get_option('REFERENCE'),; # molecule.molecular_charge(), molecule.multiplicity(), molecule.schoenflies_symbol()); PsiMod.set_variable('NATOM', molecule.natom()); ERGT[rgt] = call_function_in_1st_argument(func, **kwargs); #print ERGT[rgt]; PsiMod.print_variables(); exec actives; for envv in db_tabulate:; VRGT[rgt][envv] = PsiMod.get_variable(envv); PsiMod.set_global_option(""REFERENCE"", user_reference); PsiMod.clean(). elif (db_mode.lower() == 'sow'):; freagent = open('%s.in' % (rgt), 'w'); freagent.write('# This is a psi4 input file auto-generated from the database() wrapper.\n\n'); freagent.write(banners); freagent.write(GEOS[rgt]); freagent.write(commands); freagent.write('''\npickle_kw = (""""""'''); pickle.dump(kwargs, freagent); freagent.write('''"""""")\n'''); freagent.write(""""""\nkwargs = pickle.loads(pickle_kw)\n""""""); freagent.write(""""""electronic_energy = %s(**kwargs)\n\n"""""" % (func.__name__)); freagent.write(""""""PsiMod.print_variables()\n""""""); freagent.write(""""""PsiMod.print_out('\\nDATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields electronic energy %20.12f\\n' % (electronic_energy))\n\n""""""); freagent.write(""""""PsiMod.set_variable('NATOM', molecule.natom())\n""""""); for envv in db_tabulate:; freagent.write(""""""PsiMod.print_out('DATABASE RESULT: computation %d for reagent %s """"""; % (os.getpid(), rgt)); freagent.write(""""""yields variable value %20.12f for variable %s\\n' % (PsiMod.get_variable(""""""); freagent.write(""""""'%s'), '%s'))\n"""""" % (envv.upper(), envv.upper())); freagent.close(). elif (db_mode.lower() == 'reap'):; ERGT[rgt] = 0.0; for envv in db_tabulate:; VRGT[rgt][envv] = 0.0; exec banners; exec actives; try:; freagent = open('%s.out' % (rgt), 'r'); except IOError:; PsiMod.print_out('Warning: Output file \'%s.out\' not found.\n' % (rgt)); PsiM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:43500,load,loads,43500,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['load'],['loads']
Performance,"lled as part of any coupled cluster computation. General¶. ABCD¶. Type of ABCD algorithm will be used. Type: string; Possible Values: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BCCD_MAXITER¶. Convert ROHF MOs to semicanonical MOs. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. LOCAL¶. Do simu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html:1190,cache,cache,1190,psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__ccenergy-1.html,6,['cache'],['cache']
Performance,"ller-Plesset perturbation theory (MP2) computations. This code can compute RHF/ROHF/UHF energies, and RHF gradient/property computations. However, given the small errors introduced, we recommend using the new density fitted MP2 codes instead, which are much more efficient. General¶. CACHELEVEL¶. The amount of cacheing of data to perform. Type: integer; Default: 2. CACHETYPE¶. The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. MP2_OS_SCALE¶. The scale factor used for opposite-spin pairs in SCS computations. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. MP2_TYPE¶. What algorithm to use for the MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. OPDM¶. Do compute the one particle density matrix, for properties?. Type: boolean; Default: false. OPDM_RELAX¶. Do add relaxation terms to the one particle density matrix, for properties?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, UHF, ROHF; Default: RHF. SCS¶. Do perform a spin component scaled MP2 computation?. Type: boolean; Default: false. SCS_N¶. Do perform a spin component scaled (N) MP2 computation?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: SP. WFN¶. Wavefunction type. Type: string; Possible Values: MP2; Default: MP2. Table Of Contents. MP2; General; CACHELEVEL; CACHETYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_TYPE; OPDM; OPDM_RELAX; REFERENCE; SCS; SCS_N. Expert; JOBTYPE; WFN. Previous topic; OMEGA_ERF; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__mp2-1.html:1336,perform,perform,1336,psi4manual/4.0b3/autodir_options_c/module__mp2-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__mp2-1.html,18,"['CACHE', 'perform']","['CACHELEVEL', 'CACHETYPE', 'perform', 'performed']"
Performance,"llocation in bytes. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor (both as-is) or HTML table link (replace underscore in returned string by dash). sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/psi4api.html:19150,optimiz,optimize,19150,psi4manual/1.7.x/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/psi4api.html,3,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"lls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.optimize.html:16113,perform,perform,16113,psi4manual/1.7.x/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.optimize.html,15,"['Optimiz', 'optimiz', 'perform']","['OptimizationConvergenceError', 'optimization', 'optimize', 'perform']"
Performance,"lls; if (PsiMod.get_option('SCF','REFERENCE') != 'RHF' ):; raise ValidationError(""""""g2 computations require ""reference rhf"".""""""). # stash user options:; optstash = OptionsState(; ['FNOCC','COMPUTE_TRIPLES'],; ['FNOCC','COMPUTE_MP4_TRIPLES'],; ['FREEZE_CORE'],; ['SCF','SCF_TYPE']). # override default scf_type; PsiMod.set_local_option('SCF','SCF_TYPE','OUT_OF_CORE'). # optimize geometry at scf level; PsiMod.clean(); PsiMod.set_global_option('BASIS',""6-31G(D)""); optimize('scf'); PsiMod.clean(). # scf frequencies for zpe; frequency('scf'). # thermodynamic properties; du = PsiMod.get_variable('INTERNAL ENERGY CORRECTION'); dh = PsiMod.get_variable('ENTHALPY CORRECTION'); dg = PsiMod.get_variable('GIBBS FREE ENERGY CORRECTION'). ref = PsiMod.wavefunction(); freqs = ref.frequencies(); nfreq = freqs.dim(0); freqsum = 0.0; for i in range (0,nfreq):; freqsum += freqs.get(i); zpe = freqsum / psi_hartree2wavenumbers * 0.8929 * 0.5; PsiMod.clean(). # optimize geometry at mp2 (no frozen core) level; # note: freeze_core isn't an option in MP2; PsiMod.set_global_option('FREEZE_CORE',""FALSE""); optimize('conv-mp2'); PsiMod.clean(). # qcisd(t); PsiMod.set_local_option('FNOCC','COMPUTE_MP4_TRIPLES',""TRUE""); PsiMod.set_global_option('FREEZE_CORE',""TRUE""); PsiMod.set_global_option('BASIS',""6-311G(D_P)""); run_fnocc('qcisd(t)',**kwargs). # HLC: high-level correction based on number of valence electrons; ref = PsiMod.wavefunction(); nirrep = ref.nirrep(); frzcpi = ref.frzcpi(); nfzc = 0; for i in range (0,nirrep):; nfzc += frzcpi[i]; nalpha = ref.nalpha() - nfzc; nbeta = ref.nbeta() - nfzc; # hlc of gaussian-2; hlc = -0.00481 * nalpha -0.00019 * nbeta; # hlc of gaussian-1; hlc1 = -0.00614 * nalpha. eqci_6311gdp = PsiMod.get_variable(""QCISD(T) TOTAL ENERGY""); emp4_6311gd = PsiMod.get_variable(""MP4 TOTAL ENERGY""); emp2_6311gd = PsiMod.get_variable(""MP2 TOTAL ENERGY""); PsiMod.clean(). # correction for diffuse functions; PsiMod.set_global_option('BASIS',""6-311+G(D_P)""); energy('mp4'); emp4_6311p",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html:1408,optimiz,optimize,1408,psi4manual/4.0b4/_modules/gaussian_n.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/gaussian_n.html,2,['optimiz'],['optimize']
Performance,"lobal options (e.g., the local option set by set scf scf_type df will not be respected). Note; To access a database that is not embedded in a PSI4; distribution, add the path to the directory containing the database; to the environment variable PYTHONPATH. Parameters:; name (string) – 'scf' || 'sapt0' || 'ccsd(t)' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). db_name (string) – 'BASIC' || 'S22' || 'HTBH' || etc.; Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; psi4/share/databases or PYTHONPATH. Consult that; directory for available databases and literature citations. func (function) – \(\Rightarrow\) energy \(\Leftarrow\) || optimize || cbs; Indicates the type of calculation to be performed on each database; member. The default performs a single-point energy('name'), while; optimize perfoms a geometry optimization on each reagent, and; cbs performs a compound single-point energy. If a nested series; of python functions is intended (see Function Intercalls), use; keyword db_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; Indicates whether the calculations required to complete the; database are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. cp (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the cp(); function for BSSE correction in database(). Option available; (See Available Databases) only for databases of bimolecular complexes. rlxd (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicates whether correction for deformation energy is; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/db-1.html:1934,perform,performs,1934,psi4manual/1.2.1/db-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/db-1.html,24,"['optimiz', 'perform']","['optimization', 'optimize', 'performs']"
Performance,"local_option('SAPT', 'SAPT0_E10', True); core.set_local_option('SAPT', 'SAPT0_E20IND', True); core.set_local_option('SAPT', 'SAPT0_E20Disp', False). # raise Exception(""""). ri = core.get_global_option('SCF_TYPE'); df_ints_io = core.get_option('SCF', 'DF_INTS_IO'); # inquire if above at all applies to dfmp2. core.IO.set_default_namespace('dimer'); core.print_out('\n'); p4util.banner('Dimer HF'); core.print_out('\n'). # Compute dimer wavefunction. if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'SAVE'). optstash2 = p4util.OptionsState(['NUM_FROZEN_DOCC']); core.set_global_option(""NUM_FROZEN_DOCC"", nfc_ab); core.timer_on(""SAPT: Dimer SCF""); dimer_wfn = scf_helper('RHF', molecule=sapt_dimer, **kwargs); core.timer_off(""SAPT: Dimer SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=dimer_wfn, **kwargs); mp2_corl_interaction_e = core.variable('MP2 CORRELATION ENERGY'). optstash2.restore(); if (sapt_basis == 'dimer') and (ri == 'DF'):; core.set_global_option('DF_INTS_IO', 'LOAD'). # Compute Monomer A wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'dimer', 'monomerA'). core.IO.set_default_namespace('monomerA'); core.print_out('\n'); p4util.banner('Monomer A HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer A SCF""); monomerA_wfn = scf_helper('RHF', molecule=monomerA, **kwargs); core.timer_off(""SAPT: Monomer A SCF""). if do_delta_mp2:; select_mp2(name, ref_wfn=monomerA_wfn, **kwargs); mp2_corl_interaction_e -= core.variable('MP2 CORRELATION ENERGY'). # Compute Monomer B wavefunction; if (sapt_basis == 'dimer') and (ri == 'DF'):; core.IO.change_file_namespace(97, 'monomerA', 'monomerB'); core.IO.set_default_namespace('monomerB'); core.print_out('\n'); p4util.banner('Monomer B HF'); core.print_out('\n'). core.timer_on(""SAPT: Monomer B SCF""); monomerB_wfn = scf_helper('RHF', molecule=monomerB, **kwargs); core.timer_off(""SAPT: Monomer B SCF""). # Delta MP2; if do_delta_mp2:; select_mp2(name, ref_w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html:137214,LOAD,LOAD,137214,psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/_modules/psi4/driver/procrouting/proc.html,2,['LOAD'],['LOAD']
Performance,"lone); optking_rval = core.optking(); moleculeclone = core.get_legacy_molecule(); moleculeclone.update_geometry(); if optking_rval == core.PsiReturnType.EndLoop:; # if this is the end of an IRC run, set wfn, energy, and molecule to that; # of the last optimized IRC point; if core.get_option('OPTKING', 'OPT_TYPE') == 'IRC':; thisenergy = old_thisenergy; print('Optimizer: Optimization complete!'); core.print_out('\n Final optimized geometry and variables:\n'); moleculeclone.print_in_input_format(); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); # Check if user wants to see the intcos; if so, don't delete them.; if not core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT'):; if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); # Changing environment to optimized geometry as expected by user; molecule.set_geometry(moleculeclone.geometry()); for postcallback in hooks['optimize']['post']:; postcallback(lowername, wfn=wfn, **kwargs); core.clean(). # Cleanup binary file 1; if custom_gradient or ('/' in lowername) or kwargs.get('bsse_type', None) is not None:; core.IOManager.shared_object().set_specific_retention(1, False). optstash.restore(). if return_history:; history = {; 'energy': step_energies,; 'gradient': step_gradients,; 'coordinates': step_coordinates,; }. if return_wfn and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if not core.get_option('OPTKING', 'KEEP_INTCOS'):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.re",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html:68002,optimiz,optimize,68002,psi4manual/1.6.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimize']
Performance,"long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 12. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. DIAG_METHOD¶. This specifies which method is to be used in diagonalizing the Hamiltonian. The valid options are: RSP, to form the entire H matrix and diagonalize using libciomr to obtain all eigenvalues (n.b. requires HUGE memory); OLSEN, to use Olsen’s preconditione",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/detci-1.html:6026,optimiz,optimized,6026,psi4manual/4.0b4/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/detci-1.html,4,['optimiz'],['optimized']
Performance,"lose_outfile() -> None :; Closes the output file.; ; C++ signature :; void close_outfile(); ; compute_shell(...); compute_shell( (TwoBodyAOInt)arg1, (int)arg2, (int)arg3, (int)arg4, (int)arg5) -> int :; docstring; ; C++ signature :; m compute_shell(N3psi12TwoBodyAOIntE {lvalue},i,i,i,i); ; dcft(...); dcft( (Wavefunction)arg1) -> Wavefunction :; Runs the density cumulant functional theory code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE dcft(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; detci(...); detci( (Wavefunction)arg1) -> Wavefunction :; Runs the determinant-based configuration interaction code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE detci(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; dfmp2(...); dfmp2( (Wavefunction)arg1) -> Wavefunction :; Runs the DF-MP2 code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE dfmp2(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; dfocc(...); dfocc( (Wavefunction)arg1) -> Wavefunction :; Runs the density-fitted orbital optimized CC codes.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE dfocc(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; displace_atom(...); displace_atom( (Matrix)arg1, (int)arg2, (int)arg3, (int)arg4, (float)arg5) -> Matrix :; Displaces one coordinate of single atom.; ; C++ signature :; N5boost10shared_ptrIN3psi6MatrixEEE displace_atom(N5boost10shared_ptrIN3psi6MatrixEEE,i,i,i,d); ; dmrg(...); dmrg( (Wavefunction)arg1) -> Wavefunction :; Runs the DMRG code.; ; C++ signature :; N5boost10shared_ptrIN3psi12WavefunctionEEE dmrg(N5boost10shared_ptrIN3psi12WavefunctionEEE); ; efp_init(...); efp_init() -> EFP :; Initializes the EFP library and returns an EFP object.; ; C++ signature :; N5boost10shared_ptrIN3psi3efp3EFPEEE efp_init(); ; efp_set_options(...); efp_set_options() -> None :; Set EFP options from environment options object.; ; C++ signature :; void efp_set_options(); ; fd_1_0(...); fd_1_0( (Molecule)arg1, (list)arg2) -> Matrix :; Perfo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:678900,optimiz,optimized,678900,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,2,['optimiz'],['optimized']
Performance,"low functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. opt2; SCF DZ allene geometry optimzation, with Cartesian input. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest state of H2O+ (A1 excitation). cc54; CCSD dipole with user-specified basis set. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. dft3; DFT integral algorithms test, performing w-B97 RKS and UKS computations on water and its cation, using all of the different integral algorithms. This tests both the ERI and ERF integrals. tu2-ch2-energy; Sample UHF/6-31G** CH2 computation. cc16; UHF-B-CCD(T)/cc-pVDZ CH2 single-point energy (fzc, MO-basis ). sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. scf3; are specified explicitly. dftd3-energy; Exercises the various DFT-D corrections, both through python directly and through c++. pywrap-db1; Database calculation, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cc52; CCSD Response for H2O2. pywrap-db2; Database calculation, run in sow/reap mode. cc50; EOM-CC3(ROHF) on CH radical with user-specified basis a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:10137,perform,performing,10137,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['perform'],['performing']
Performance,"lowoptexceeded', False); optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = core.get_datadir(); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' % (db_name)); else:; ACTV = database.ACTV_SA; # Force open-shell if needed; openshell_override = 0; if user_reference in ['RHF', 'RKS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html:9886,load,load,9886,psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/wrapper_database.html,1,['load'],['load']
Performance,"loyed, due to cancellations of errors. Thanks to; natural orbital methods [Parrish:2013:174102], the SAPT code in Psi; is able to include CCD dispersion with only a modest additional cost.; Computations employing CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the higly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:13340,perform,performed,13340,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performed']
Performance,"ls are neglected. Type: conv double; Default: 1e-14. INTS_TOLERANCE (TRANSQT2); TRANSQT2 — Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. IP_POLES (OCC); OCC — Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. IRC_DIRECTION (OPTKING); OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING); OPTKING — IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP (OPTKING); OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISTOP (DETCI); DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. IVO (TRANSQT); TRANSQT — Do form improved virtual orbitals (IVO)?. Type: boolean; Default: false. J_FILE (TRANSQT); TRANSQT — Half-transformed integrals. Type: integer; Default: 91. JOBTYPE (CCLAMBDA); CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. JOBTYPE (CPHF); CPHF (Expert) — Type of job being performed. Type: string; Default: SP. KEEP_INTCOS (OPTKING); OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. KEEP_J (TRANSQT); TRANSQT — Do keep half-transformed integrals?. Type: boolean; Default: false. KEEP_OEIFILE (CCSORT); CCSORT — Do retain the input one-electron integrals?. Type: boolean; Default: false. KEEP_PRESORT (TRANSQT); TRANSQT — Do keep presort file?. Type: boolean; Default: false. KEEP_TEIFILE (CCSORT); CCSORT — Do retain the input two-electron integrals?. Type: boolean; Default: false. LAG_IN_FILE (TRANSQT); TRANSQT — MO-basis MO-lagrangian file. Type: integer; Default: PSIF_MO_LAG. LAGRAN_DOUBLE (TRANSQT); TRANSQT — Do multiply the MO-lagrangian by 2.0?. Type: boolean; Default: false. LAGRAN_HALVE (TRANSQT); TRANSQT — Do divide the MO-lagrangian by 2.0?. Type: boolean; Default: false. LAMBDA_MAXITER (DCFT); DCFT — ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:62155,perform,performed,62155,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ls are neglected. Type: conv double; Default: 1e-14. INTS_TOLERANCE (TRANSQT2); TRANSQT2 — Minimum absolute value below which integrals are neglected. Type: conv double; Default: 1e-14. IP_POLES (OCC); OCC — Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. IRC_DIRECTION (OPTKING); OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING); OPTKING — IRC step size in bohr(amu). Type: double; Default: 0.2. IRC_STOP (OPTKING); OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISTOP (DETCI); DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. IVO (TRANSQT); TRANSQT — Do form improved virtual orbitals (IVO)?. Type: boolean; Default: false. J_FILE (TRANSQT); TRANSQT — Half-transformed integrals. Type: integer; Default: 91. JOBTYPE (CCLAMBDA); CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. KEEP_INTCOS (OPTKING); OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. KEEP_J (TRANSQT); TRANSQT — Do keep half-transformed integrals?. Type: boolean; Default: false. KEEP_OEIFILE (CCSORT); CCSORT — Do retain the input one-electron integrals?. Type: boolean; Default: false. KEEP_PRESORT (TRANSQT); TRANSQT — Do keep presort file?. Type: boolean; Default: false. KEEP_TEIFILE (CCSORT); CCSORT — Do retain the input two-electron integrals?. Type: boolean; Default: false. LAG_IN_FILE (TRANSQT); TRANSQT — MO-basis MO-lagrangian file. Type: integer; Default: PSIF_MO_LAG. LAGRAN_DOUBLE (TRANSQT); TRANSQT — Do multiply the MO-lagrangian by 2.0?. Type: boolean; Default: false. LAGRAN_HALVE (TRANSQT); TRANSQT — Do divide the MO-lagrangian by 2.0?. Type: boolean; Default: false. LAMBDA_MAXITER (DCFT); DCFT — Maximum number of density cumulant update micro-iterations per macro-iteration (for ALOG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:62134,perform,performed,62134,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"ls to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_CORE (SAPT); SAPT — The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE; Default: FALSE. FREEZE_INTERFRAG (OPTKING); OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING); OPTKING — Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_DOCC (PSIMRCC); PSIMRCC — The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FROZEN_UOCC (PSIMRCC); PSIMRCC — The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MA",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:49997,optimiz,optimized,49997,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"lse. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING); OPTKING — Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN (OPTKING); OPTKING — Specify atom and X, XY, XYZ, ... to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. GAUGE (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:130345,optimiz,optimized,130345,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimized']
Performance,"lse. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also possible to run a SAPT computation at any; level using only the monomer-centered basis. To do this, simply add; sapt_basis='monomer' to the energy function, such as",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:12633,perform,performs,12633,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['perform'],['performs']
Performance,"lsen et al., JCP 104, 8007 (1996). omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. mp2_5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the state of the CN radical, with Z-matrix input. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cepa1; cc-pvdz H2O Test CEPA(1) Energy. cc24; Single point gradient of 1-2B1 state of H2O+ with EOM-CCSD. dftd3-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN, calling Grimme’s dftd3 program for -D2 gradients. cc14; ROHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. ocepa3; OCEPA cc-pVDZ energy with ROHF initial guess for the NO radical. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cho",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:20578,perform,performed,20578,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance,"lt modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_fnocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module == 'DETCI':; raise UpgradeHelper(""energy('mp4')"", ""energy('zapt4')"", 1.7,; "" Replace method MP with method ZAPT for ROHF reference. DETCI is orders-of-magnitude inefficient for perturbation theory.""). if module == 'DETCI':; core.print_out(""""""\nDETCI is ill-advised for method MP4 as it is available inefficiently as a """"""; """"""byproduct of a CISDT computation.\n""""""). if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_remp2(name, **kwargs):; """"""Function selecting the algorithm for a REMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in [""RHF"", ""UHF""]:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccd(name, **kwargs):; """"""Function selecting the algorithm for a CCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option(""SCF"", ""REFERENCE""); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option(""QC_MODULE""). func = None; if reference in ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:31205,perform,performance,31205,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['perform'],['performance']
Performance,"lt) or separate.; The latter forces the separate handling of nuclear and electronic electrostatic potentials and; polarization charges. It is mainly useful for debugging.; For the calculation of vertical excitation energies with PCM non-equilibrium solvation should be included with:; pcm = {; Medium {; Nonequilibrium = True; }; }. Note; At present PCM can only be used for energy calculations with SCF; wavefunctions and CC wavefunctions in the PTE approximation [Cammi:2009:164104].; All ERI algorithms (PK, OUT_OF_CORE, DIRECT, DF, CD) are supported. Note; linear response calculations (static polarisabilities, TD-SCF) are supported for RHF/UHF if available. Warning; The PCMSolver library cannot exploit molecular point group symmetry. Warning; ROHF with PCM is known not to work. See issue #999 on GitHub.; For the adventurous, a fix is available in pull request #953 on GitHub. Warning; Analytic gradients and Hessians are not available with PCM. Finite differences will be used; regardless of the dertype passed to the optimize function.; See pcmsolver/opt-fd for a sample input. The PCM model and molecular cavity are specified in a pcm section that has; to be explicitly typed in by the user. This additional section follows a syntax; that is slightly different from that of PSI4 and is fully documented; here; A typical input for a Hartree–Fock calculation with PCM would look like the following:; molecule NH3 {; symmetry c1; N -0.0000000001 -0.1040380466 0.0000000000; H -0.9015844116 0.4818470201 -1.5615900098; H -0.9015844116 0.4818470201 1.5615900098; H 1.8031688251 0.4818470204 0.0000000000; units bohr; no_reorient; no_com; }. set {; basis STO-3G; scf_type pk; pcm true; pcm_scf_type total; }. pcm = {; Units = Angstrom; Medium {; SolverType = IEFPCM; Solvent = Water; }. Cavity {; RadiiSet = UFF; Type = GePol; Scaling = False; Area = 0.3; Mode = Implicit; }; }. More examples can be found in the directories with PCM tests; pcmsolver/ccsd-pte,; pcmsolver/scf,; pcmsolver/opt-fd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/pcmsolver-1.html:2829,optimiz,optimize,2829,psi4manual/1.4.0/pcmsolver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/pcmsolver-1.html,9,['optimiz'],['optimize']
Performance,"lt. FROZEN_CARTESIAN (OPTKING); OPTKING — Specify atom and X, XY, XYZ, ... to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. GAUGE (CCDENSITY); CCDENSITY — The type of gauge to use for properties. Type: string; Default: LENGTH. GAUGE (CCRESPONSE); CCRESPONSE — Specifies the choice of representation of the electric dipole operator. Acceptable values are L",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:130542,optimiz,optimization,130542,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,4,['optimiz'],['optimization']
Performance,"lt: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT); CCTRANSORT — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC proced",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:9005,cache,cache,9005,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"lt: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:8880,cache,cache,8880,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"lt: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC pr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:8434,cache,cache,8434,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"lt: 2. CACHELEVEL (CCHBAR); CCHBAR — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all q",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html:9075,cache,cache,9075,psi4manual/4.0b4/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"lt: 302. DFT_SPHERICAL_SCHEME¶. Spherical Scheme. Type: string; Possible Values: LEBEDEV; Default: LEBEDEV. Expert General Wavefunction Info¶. WFN¶. Wavefunction type. Type: string; Possible Values: SCF; Default: SCF. Expert Parallel Runtime¶. DISTRIBUTED_MATRIX¶. The dimension sizes of the distributed matrix. Type: array; Default: No Default. PARALLEL¶. Do run in parallel?. Type: boolean; Default: false. PROCESS_GRID¶. The dimension sizes of the processor grid. Type: array; Default: No Default. TILE_SZ¶. The tile size for the distributed matrices. Type: integer; Default: 512. Expert Misc.¶. SAPT¶. Are going to do SAPT? If so, what part?. Type: string; Possible Values: FALSE, 2-DIMER, 2-MONOMER_A, 2-MONOMER_B, 3-TRIMER, 3-DIMER_AB, 3-DIMER_BC, 3-DIMER_AC, 3-MONOMER_A, 3-MONOMER_B, 3-MONOMER_C; Default: FALSE. Expert DFSCF Algorithm¶. DF_FITTING_CONDITION¶. Fitting Condition. Type: double; Default: 1.0e-12. DF_INTS_IO¶. IO caching for CP corrections, etc. Type: string; Possible Values: NONE, SAVE, LOAD; Default: NONE. Expert SAD Guess Algorithm¶. SAD_CHOL_TOLERANCE¶. SAD Guess Cholesky Cutoff (for eliminating redundancies). Type: conv double; Default: 1e-7. SAD_F_MIX_START¶. SAD Guess F-mix Iteration Start. Type: integer; Default: 50. SAD_MAXITER¶. Maximum number of SAD guess iterations. Type: integer; Default: 50. SAD_PRINT¶. The amount of SAD information to print to the output. Type: integer; Default: 0. Expert DFT¶. DFT_BLOCK_MAX_POINTS¶. The maximum number of grid points per evaluation block. Type: integer; Default: 5000. DFT_BLOCK_MAX_RADIUS¶. The maximum radius to terminate subdivision of an octree block [au]. Type: double; Default: 3.0. DFT_BLOCK_MIN_POINTS¶. The minimum number of grid points per evaluation block. Type: integer; Default: 1000. DFT_BLOCK_SCHEME¶. The blocking scheme for DFT. Type: string; Possible Values: NAIVE, OCTREE; Default: OCTREE. DFT_GRID_NAME¶. The DFT grid specification, such as SG1. Type: string; Possible Values: SG1; Default: No Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__scf-1.html:6693,LOAD,LOAD,6693,psi4manual/4.0b2/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__scf-1.html,2,['LOAD'],['LOAD']
Performance,"lt: JACOBI. SOLVER_PRECONDITION_MAXITER (CPHF)¶CPHF — Solver precondition max steps. Type: integer; Default: 1. SOLVER_PRECONDITION_STEPS (CPHF)¶CPHF — Solver precondition step type. Type: string; Possible Values: CONSTANT, TRIANGULAR; Default: TRIANGULAR. SOLVER_QUANTITY (CPHF)¶CPHF — Solver residue or eigenvector delta. Type: string; Possible Values: EIGENVECTOR, RESIDUAL; Default: RESIDUAL. SOLVER_TYPE (CPHF)¶CPHF — Solver type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SOS_TYPE (DFOCC)¶DFOCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC)¶OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF)¶SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF)¶SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF)¶SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF)¶SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF)¶SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF)¶SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPIN_SCALE_TYPE (OCC)¶OCC (Expert) — Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. SPINADAPT_ENERGIES (CCENERGY)¶CCENERGY — Do print spin-adapted pair energies?. Type: boolean; Default: false. SS_E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:218374,perform,perform,218374,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance,"lt: JACOBI. SOLVER_PRECONDITION_MAXITER (CPHF)¶CPHF — Solver precondition max steps. Type: integer; Default: 1. SOLVER_PRECONDITION_STEPS (CPHF)¶CPHF — Solver precondition step type. Type: string; Possible Values: CONSTANT, TRIANGULAR; Default: TRIANGULAR. SOLVER_QUANTITY (CPHF)¶CPHF — Solver residue or eigenvector delta. Type: string; Possible Values: EIGENVECTOR, RESIDUAL; Default: RESIDUAL. SOLVER_TYPE (CPHF)¶CPHF — Solver type (for interchangeable solvers). Type: string; Possible Values: DL, RAYLEIGH; Default: DL. SOS_TYPE (DFOCC)¶DFOCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOS_TYPE (OCC)¶OCC — Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. SOSCF (SCF)¶SCF — Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV (SCF)¶SCF — Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER (SCF)¶SCF — Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER (SCF)¶SCF — Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT (SCF)¶SCF — Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE (SCF)¶SCF — When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. SPIN_SCALE_TYPE (OCC)¶OCC (Expert) — Controls the spin scaling set to current energy. This is set by Psi internally. Type: string; Possible Values: NONE, CUSTOM, SCS, SCSN, SCSVDW, SOS, SOSPI; Default: NONE. SS_E_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for excitation energy (change) in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SCALE (OCC)¶OCC — A cu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:222846,perform,perform,222846,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['perform'],['perform']
Performance,"lt: PK. SCHMIDT_ADD_RESIDUAL_TOLERANCE (CCEOM); CCEOM — Minimum absolute value above which a guess vector to a root is added to the Davidson algorithm in the EOM-CC iterative procedure. Type: conv double; Default: 1e-3. SCHWARZ_CUTOFF (CPHF); CPHF — The schwarz cutoff value. Type: double; Default: 1.0e-12. SCREEN_INTS (LMP2); LMP2 — Do screen integrals?. Type: boolean; Default: false. SCS (LMP2); LMP2 — Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS (MP2); MP2 — Do perform a spin component scaled MP2 computation?. Type: boolean; Default: false. SCS_CCSD (CCENERGY); CCENERGY — Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_CEPA (CEPA); CEPA — Perform SCS-CEPA? If true, note that the default values for the spin component scaling factors are optimized for the CCSD method. Type: boolean; Default: false. SCS_MP2 (CCENERGY); CCENERGY — Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCS_N (LMP2); LMP2 — Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_N (MP2); MP2 — Do perform a spin component scaled (N) MP2 computation?. Type: boolean; Default: false. SCS_TYPE (OMP2); OMP2 — Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SCS_TYPE (OMP3); OMP3 — Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SCSN_MP2 (CCENERGY); CCENERGY — Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SEKINO (CCLAMBDA); CCLAMBDA — Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. SEKINO (CCRESPONSE); CCRESPONSE — Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. SEM_MAXITER (ADC); ADC — Maximum iteration number in simultaneous expansion method. Type: integer; Default: 30. SEMICANONICAL (CCENERGY); CCENERGY — Convert ROHF MOs to semicanonical MOs. Type: boolean; Default: true. SEMICANONICAL (CCEOM); CCEOM",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:112820,optimiz,optimized,112820,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"lt_xtpl(nbasis, xtpl_type)[source]¶; A helper function to determine default extrapolation type. Parameters. nbasis (int) – Number of basis sets; xtpl_type (str) – {‘scf’, ‘corl’}; Extrapolation type: ‘scf’ for the total energy, ‘corl’ for just the; correlation component. Returns; Extrapolation function to be used. Return type; Callable. Aliases¶; When a particular composite method or its functional form is going to be; reused often, it is convenient to define an alias to it. A convenient; place for such Python code to reside is in psi4/psi4/driver/aliases.py; (source location) or psi4/lib/psi4/driver/aliases.py (installed; location). No recompilation is necessary after defining an alias. Some; existing examples are below. psi4.driver.aliases.sherrill_gold_standard(func, label, **kwargs)[source]¶; Function to call the quantum chemical method known as ‘Gold Standard’; in the Sherrill group. Uses cbs() to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to corl_xtpl_helgaker_2(). \[E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}\]; >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). psi4.driver.aliases.allen_focal_point(func, label, **kwargs)[source]¶; Function to call Wes Allen-style Focal; Point Analysis. JCP 127 014306. Uses; cbs() to evaluate the following; expression. SCF employs a three-point extrapolation according; to scf_xtpl_helgaker_3(). MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; corl_xtpl_helg",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cbs-1.html:26542,perform,performed,26542,psi4manual/1.4.0/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cbs-1.html,4,['perform'],['performed']
Performance,"lta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} {drms:10.2e} {conv_drms} ~')). if return_history:; step_energies.append(optimizer.E); step_coordinates.append(core.Matrix.from_array(optimizer.X.reshape(-1,3))); step_gradients.append(core.Matrix.from_array(optimizer.gradx.reshape(-1,3))). return_energy = optimizer.E; opt_geometry = core.Matrix.from_array(optimizer.X.reshape(-1,3)); molecule.set_g",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57537,optimiz,optimizer,57537,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['optimiz'],['optimizer']
Performance,"ltiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING (CFOUR); CFOUR — Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL (CFOUR); CFOUR — Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM (CFOUR); CFOUR — All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF (CFOUR); CFOUR — Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equations or not. Usually there is no need to set this parameter (OFF = 0 and ON =1), since standard non-HF reference functions (QRHF and ROHF) set this flag automatically. Type: boolean; Default: false. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:57653,optimiz,optimization,57653,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,['optimiz'],['optimization']
Performance,"ltistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequency-1.html:2805,optimiz,optimize,2805,psi4manual/1.4.0/api/psi4.driver.frequency-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.frequency-1.html,4,['optimiz'],['optimize']
Performance,"ltistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequency-1.html:2805,optimiz,optimize,2805,psi4manual/1.5.0/api/psi4.driver.frequency-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.frequency-1.html,4,['optimiz'],['optimize']
Performance,"ltonian is the target state?. Type: integer; Default: 1. FROZEN_DOCC¶. The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC¶. The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. HEFF4¶. Do include the fourth-order contributions to the effective Hamiltonian?. Type: boolean; Default: true. HEFF_PRINT¶. Do print the effective Hamiltonian?. Type: boolean; Default: false. LOCK_SINGLET¶. Do lock onto a singlet root?. Type: boolean; Default: false. MAXITER¶. Maximum number of iterations to determine the amplitudes. Type: integer; Default: 100. MP2_CCSD_METHOD¶. How to perform MP2_CCSD computations. Type: string; Possible Values: I, IA, II; Default: II. MP2_GUESS¶. Do start from a MP2 guess?. Type: boolean; Default: true. NO_SINGLES¶. Do ?. Type: boolean; Default: false. OFFDIAGONAL_CCSD_T¶. Do include the off-diagonal corrections in (T) computations?. Type: boolean; Default: true. PT_ENERGY¶. The type of perturbation theory computation to perform. Type: string; Possible Values: SECOND_ORDER, SCS_SECOND_ORDER, PSEUDO_SECOND_ORDER, SCS_PSEUDO_SECOND_ORDER; Default: SECOND_ORDER. RESTRICTED_DOCC¶. The number of doubly occupied orbitals per irrep. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-9. SMALL_CUTOFF¶. Type: integer; Default: 0. TIKHONOW_MAX¶. The cycle after which Tikhonow regularization is stopped. Set to zero to allow regularization in all iterations. Type: integer; Default: 5. TIKHONOW_OMEGA¶. The shift to apply to the denominators, {it c.f.} Taube and Bartlett, JCP, 130, 144112 (2009). Type: double; Default: 0.0. TRIPLES_ALGORITHM¶. The type of algorithm to use for (T) computations. Type: string; Possible Values: SPIN_ADAPTED, RESTRICTED, UNRESTRICTED; Default: RESTRICTED. TRIPLES_DIIS¶. Do use DIIS extrapolation to accelerate convergence for iterative triples excitations?. Type: boolean; Default: false. USE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html:3539,perform,perform,3539,psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodir_options_c/module__psimrcc-1.html,4,['perform'],['perform']
Performance,"lue of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM —. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 —. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM —. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for exper",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:7109,cache,cache,7109,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"lueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.optimize.ParseConstraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:55747,optimiz,optimizer,55747,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,6,['optimiz'],['optimizer']
Performance,"lueError(""Coordinate scans are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / qcel.constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:57498,optimiz,optimizer,57498,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimizer']
Performance,"lues due to new BraggSlater radii. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. sapt-compare; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. dfomp3-2; DF-OMP3 cc-pVDZ energy for the H2O+ cation. cc7; Tests CCENERGY’s CCSD gradient in the presence of a dipole field. ghosts; Density fitted MP2 cc-PVDZ/cc-pVDZ-RI computation of formic acid dimer binding energy using explicit specification of ghost atoms. This is equivalent to the dfmp2_1 sample but uses both (equivalent) specifications of ghost atoms in a manual counterpoise correction. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. opt5; 6-31G** UHF CH2 3B1 optimization. Uses a Z-Matrix with dummy atoms, just for demo and testing purposes. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc26; Single-point gradient, analytic and via finite-differences of 2-1A1 state of H2O with EOM-CCSD. mp2p5-grad1; MP2.5 cc-pVDZ gradient for the H2O molecule. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. adc1; ADC(2)/6-31G** on H2O using builtin ADC module. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. cc2; 6-31G** H2O CCSD optimization by energies, with Z-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:23451,optimiz,optimization,23451,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"lues()):; nbody_results[""intermediates_hessian""] = trove[""hessian""]. debug = False; if debug:; for k, v in nbody_results.items():; if isinstance(v, np.ndarray):; print(f""CLS-prepared results >>> {k} {v.size}""); elif isinstance(v, dict):; print(f""CLS-prepared results >>> {k} {len(v)}""); for k2, v2 in v.items():; if isinstance(v2, np.ndarray):; print(f""CLS-prepared results >>> {k2} {v2.size}""); else:; print(f""CLS-prepared results >>> {k2} {v2}""); else:; print(f""CLS-prepared results >>> {k} {v}""). return nbody_results. [docs] def get_results(self, client: Optional[""qcportal.FractalClient""] = None) -> AtomicResult:; """"""Return results as ManyBody-flavored QCSchema."""""". info = ""\n"" + p4util.banner(f"" ManyBody Results "", strNotOutfile=True) + ""\n""; core.print_out(info); logger.info(info). results = self.prepare_results(client=client); ret_energy = results.pop(""ret_energy""); ret_ptype = results.pop(""ret_ptype""); ret_gradient = results.pop(""ret_gradient"", None). # load QCVariables; qcvars = {; 'NUCLEAR REPULSION ENERGY': self.molecule.nuclear_repulsion_energy(),; 'NBODY NUMBER': len(self.task_list),; }. properties = {; ""calcinfo_natom"": self.molecule.natom(),; ""nuclear_repulsion_energy"": self.molecule.nuclear_repulsion_energy(),; ""return_energy"": ret_energy,; }. for k, val in results.items():; qcvars[k] = val. qcvars['CURRENT ENERGY'] = ret_energy; if self.driver == 'gradient':; qcvars['CURRENT GRADIENT'] = ret_ptype; properties[""return_gradient""] = ret_ptype; elif self.driver == 'hessian':; qcvars['CURRENT GRADIENT'] = ret_gradient; qcvars['CURRENT HESSIAN'] = ret_ptype; properties[""return_gradient""] = ret_gradient; properties[""return_hessian""] = ret_ptype. component_results = self.dict()['task_list']; for k, val in component_results.items():; val['molecule'] = val['molecule'].to_schema(dtype=2). nbody_model = AtomicResult(; **{; 'driver': self.driver,; 'model': {; 'method': self.method,; 'basis': self.basis,; },; 'molecule': self.molecule.to_schema(dtype=2),; 'properties':",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html:89801,load,load,89801,psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_nbody.html,2,['load'],['load']
Performance,"lues, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of PSI4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in PSI4 are; nbody(),; database(), and; cbs(); read their respective sections; for details, but an overview is provided here. nbody(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set basis aug-cc-pVDZ. for R in Rvals:; dimer.R = R; ecp = cp('c4-mp2'); print_stdout('R [A] = %.1f IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp)). yields; R [A] = 2.5 IE [kcal/mol] = 0.804; R [A] = 3.0 IE [kcal/mol] = 0.030; R [A] = 4.0 IE [kcal/mol] = -0.014. Next, the database() wrapper allows any computational; model chemistry to be applied a predefined collection of molecules. Thus; an input; set {; basis jun-cc-pvdz; d_convergence 9; }. database('c4-mp2','nbc10',cp='on',subset='MeMe'). yields the counterpoise-corrected inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/cfour.html:12522,optimiz,optimization,12522,psi4manual/1.6.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/cfour.html,5,['optimiz'],['optimization']
Performance,"lues, the interface will complain.; memory 2 gb. molecule CH2F2 {; units au; C 0.0000000000 -0.0000000000 1.0890958457; F 0.0000000000 -2.1223155812 -0.4598161475; F -0.0000000000 2.1223155812 -0.4598161475; H 1.7084139850 0.0000000000 2.1841068002; H -1.7084139850 -0.0000000000 2.1841068002; }. set basis aug-cc-pvdz; set rms_force_g_convergence 6; set cfour_abcdtype aobasis; set cfour_scf_conv 12; set cfour_cc_conv 12; set cfour_lineq_conv 12. optimize('c4-ccsd(t)'). The utility of this method specification is that examination can be made; of the reference, the derivative level, the excitation level, etc. and; some options can be set according to best practices. Practically speaking,; CFOUR_CC_PROGRAM (and eventually CFOUR_ABCDTYPE) will; always be set to the fastest safe value.; For example, the input above will run with CFOUR_CC_PROGRAM=ECC; unless explicitly set to VCC.; An advantage of PSI4‘s Python driver is that any number of common; work-up procedures can be automated and wrapped around the; conventional single-point and optimization procedures at the heart of all; quantum chemistry codes. Three core “wrappers” available in PSI4 are; nbody_gufunc(),; database(), and; cbs(); read their respective sections; for details, but an overview is provided here. nbody_gufunc(); computes the interaction energy of a bimolecular complex (counterpoise-corrected,; not, or both).; molecule dimer {; Ne; --; Ne 1 R; symmetry c1; }. Rvals=[2.5, 3.0, 4.0]; set basis aug-cc-pVDZ. for R in Rvals:; dimer.R = R; ecp = cp('c4-mp2'); print_stdout('R [A] = %.1f IE [kcal/mol] = %.3f\n' % (R, psi_hartree2kcalmol * ecp)). yields; R [A] = 2.5 IE [kcal/mol] = 0.804; R [A] = 3.0 IE [kcal/mol] = 0.030; R [A] = 4.0 IE [kcal/mol] = -0.014. Next, the database() wrapper allows any computational; model chemistry to be applied a predefined collection of molecules. Thus; an input; set {; basis jun-cc-pvdz; d_convergence 9; }. database('c4-mp2','nbc10',cp='on',subset='MeMe'). yields the counterpoise-",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:12522,optimiz,optimization,12522,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,4,['optimiz'],['optimization']
Performance,"lues: NEW, OLD; Default: NEW. ANALYZE¶. Do analyze T2 amplitudes. Type: boolean; Default: false. BCCD_MAXITER¶. Maximum number of iterations for Brueckner CCD. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CC_NUM_THREADS¶. Number of threads. Type: integer; Default: 1. CC_OS_SCALE¶. Coupled-cluster opposite-spin scaling value. Type: double; Default: 1.27. CC_SS_SCALE¶. Coupled-cluster same-spin scaling value. Type: double; Default: 1.13. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. LOCAL¶. Do simulate the effects of local correlation techniques?. Type: boolean; Default: false. LOCAL_CPHF_CUTOFF¶. Cutoff value for l",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html:1316,cache,cache,1316,psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__ccenergy-1.html,18,['cache'],['cache']
Performance,"lugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Installation and Runtime Configuration; Build & Run FAQ. © Copyright 2021, The Psi4 Project.; Last ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/build_faq-1.html:3536,queue,queue,3536,psi4manual/1.4.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/build_faq-1.html,2,['queue'],['queue']
Performance,"lugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Installation and Runtime Configuration; Build & Run FAQ. © Copyright 2021, The Psi4 Project.; Last ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/build_faq-1.html:3536,queue,queue,3536,psi4manual/1.5.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/build_faq-1.html,2,['queue'],['queue']
Performance,"lugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”; How to fix error “RuntimeError: value for ERI”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Installation and Runtime Configuration. © Copyrig",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_faq-1.html:3488,queue,queue,3488,psi4manual/1.3.2/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_faq-1.html,2,['queue'],['queue']
Performance,"luster Theory¶; This DETCI-based version of this feature is not yet released. However,; the current version of the code does include an interface to; Kallay’s MRCC code.; The DETCI module is also capable of computing arbitrary-order; coupled-cluster energies, using an approach similar to that of Hirata; and Bartlett [Hirata:2000:216], or of Olsen [Olsen:2000:7140].; Notably, the approach in DETCI also allows arbitrary-order; active space coupled-cluster procedures. The general algorithm; for doing this in DETCI is inefficient compared to optimized; lower-order coupled-cluster codes and should not be used for CCSD,; where the CCENERGY module is much more efficient. For higher-order; CC (like CCSDT and beyond), the code is also not as efficient as the; MRCC code by Kállay, to which PSI4 can interface (see Section; Interface to MRCC by M. Kállay); however, it may allow certain truncations of the model; space that might not be available presently in MRCC. For very small; systems, the code can be useful for testing of, for example, CCSDTQ or; its active-space CCSDtq analog [Piecuch:1999:6103].; To perform arbitrary-order coupled-cluster, set the DETCI; option CC to TRUE, and set; CC_EX_LEVEL (note: not EX_LEVEL); to the desired coupled-cluster excitation level, and invoke; energy('detci'). Various other DETCI options have a similar; option for coupled-cluster, usually named beginning with CC. The full; list of options is given in Appendix DETCI. table of contents. CI: Configuration Interaction; Basic DETCI Keywords; REFERENCE; R_CONVERGENCE; EX_LEVEL; FCI; FROZEN_DOCC; RESTRICTED_DOCC; RESTRICTED_UOCC; FROZEN_UOCC; CI_MAXITER; NUM_ROOTS; ICORE; DIAG_METHOD; OPDM; TDM; DIPMOM; MPN. Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/detci-1.html:12671,perform,perform,12671,psi4manual/1.1.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/detci-1.html,2,['perform'],['perform']
Performance,"luster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). «; hide menu. menu; sidebar; »; . Navi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:17113,optimiz,optimization,17113,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,4,['optimiz'],['optimization']
Performance,"lution exists while respecting the constraints of the original; solution; this is an internal instability. If one or more constraints have to be relaxed to reach; a lower-energy solution, there is an external instability. In Psi4, the only external instability; that can be checked at present is the RHF->UHF one.; Currently, two algorithms exist in Psi4 for stability analysis: the original; Direct Inversion and the newly implemented Davidson algorithms. We will first describe; options common to both algorithms. To request a stability analysis at the end of the SCF,; set the keyword STABILITY_ANALYSIS:; set stability_analysis check. to only compute the electronic Hessian eigenvalue and check if an actual SCF minimum; has been found, or:; set stability_analysis follow. to rotate the converged orbitals along the lowest eigenvector, then invoke the SCF; procedure again to lower the energy. In case the minimization does not succeed; or ends up on the same unstable solution, you can tune the scale factor for the orbital; rotation through the keyword FOLLOW_STEP_SCALE:; set follow_step_scale 0.5. The rotation angle is (FOLLOW_STEP_SCALE). The default value of; 0.5 usually provides a good guess and modification is only recommended in difficult cases.; The default behavior for the stability code is to stop after trying to reoptimize the orbitals once; if the instability still exists. For more attempts, set MAX_ATTEMPTS:; set max_attempts 1. the default value of 1 is recommended. In case the SCF ends up in the same minimum, modification; of FOLLOW_STEP_SCALE is recommended over increasing MAX_ATTEMPTS.; The main algorithm available in Psi4 is the Direct Inversion algorithm. It can only; work with SCF_TYPE PK, and it explicitly builds the full electronic Hessian; matrix before explicitly inverting it. As such, this algorithm is very slow and it should; be avoided whenever possible. Direct Inversion is automatically invoked if the newer algorithm; is not available.; The Davidson",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:25339,tune,tune,25339,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['tune'],['tune']
Performance,"ly DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:112423,perform,perform,112423,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"ly cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. PRINT_OPT_PARAMS¶. Print all optking parameters. Type: boolean; Default: false. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX¶. Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RSRFO_ALPHA_MAX¶. Absolute maximum value of RS-RFO. Type: double; Default: 1e8. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum energy change. Type: conv double; Default: 1.0e-6. MAX_FORCE_G_CONVERGE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html:3572,optimiz,optimization,3572,psi4manual/1.0.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__optking-1.html,2,['optimiz'],['optimization']
Performance,"ly cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. PRINT_OPT_PARAMS¶. Print all optking parameters. Type: boolean; Default: false. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX¶. Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RSRFO_ALPHA_MAX¶. Absolute maximum value of RS-RFO. Type: double; Default: 1e8. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. SYMM_TOL¶. Symmetry tolerance for testing whether a mode is symmetric. Type: conv double; Default: 0.05. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Convergence criterion ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html:3528,optimiz,optimization,3528,psi4manual/1.1.0/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__optking-1.html,2,['optimiz'],['optimization']
Performance,"ly cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_TYPE¶. Specifies minimum search, transition-state search, or IRC following. Type: string; Possible Values: MIN, TS, IRC; Default: MIN. PRINT_OPT_PARAMS¶. Print all optking parameters. Type: boolean; Default: false. PRINT_TRAJECTORY_XYZ_FILE¶. Should an xyz trajectory file be kept (useful for visualization)?. Type: boolean; Default: false. RFO_FOLLOW_ROOT¶. Do follow the initial RFO vector after the first step?. Type: boolean; Default: false. RFO_NORMALIZATION_MAX¶. Eigenvectors of RFO matrix whose final column is smaller than this are ignored. Type: double; Default: 100. RFO_ROOT¶. Root for RFO to follow, 0 being lowest (for a minimum). Type: integer; Default: 0. RSRFO_ALPHA_MAX¶. Absolute maximum value of RS-RFO. Type: double; Default: 1e8. STEP_TYPE¶. Geometry optimization step type, either Newton-Raphson or Rational Function Optimization. Type: string; Possible Values: RFO, NR, SD, LINESEARCH_STATIC; Default: RFO. SYMM_TOL¶. Symmetry tolerance for testing whether a mode is symmetric. Type: conv double; Default: 0.05. Convergence Control¶. FLEXIBLE_G_CONVERGENCE¶. Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. G_CONVERGENCE¶. Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite the criteria set here unless FLEXIBLE_G_CONVERGENCE is also on. See Table Geometry Convergence for details. Type: string; Possible Values: QCHEM, MOLPRO, GAU, GAU_LOOSE, GAU_TIGHT, INTERFRAG_TIGHT, GAU_VERYTIGHT, TURBOMOLE, CFOUR, NWCHEM_LOOSE; Default: QCHEM. MAX_DISP_G_CONVERGENCE¶. Convergence criterion for geometry optmization: maximum displacement (internal coordinates, atomic units). Type: conv double; Default: 1.2e-3. MAX_ENERGY_G_CONVERGENCE¶. Conve",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__optking-1.html:3528,optimiz,optimization,3528,psi4manual/1.3.2/autodir_options_c/module__optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__optking-1.html,19,"['Optimiz', 'optimiz']","['Optimization', 'optimization']"
Performance,"ly compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dforemp-grad2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. olccd1; OLCCD cc-pVDZ energy for the H2O molecule. mp2-h; check that methods can act on single atom. fnocc3; Test FNO-QCISD(T) computation. dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. fnocc4; Test FNO-DF-CCSD(T) energy. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. cc52; CCSD Response for H2O2. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. fnocc2; Test G2 method for H2O. dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. scf-cholesky-basis; incremental Cholesky filtered SCF. matrix2; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). ddd-deriv; Sample HF/cc-pVDZ H2O computation all derivatives. cc51; EOM-CC3/cc-pVTZ on H2O. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. molden1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:37638,optimiz,optimization,37638,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. This becomes the; default for the second and later iterations of geometry optimizations. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on the orbital gradient to produce an informed; estimate of the next Fock Matrix. DIIS is almost always necessary to converge; the SCF procedure and is therefore turned on by default. In rare cases, the; DIIS algorithm may need to be modified or turned off altogether, which may be; accomplished via the options detailed below.; MOM [Off by Default]; MOM was developed to combat a particular class of convergence failure:; occupation flipping. In some cases, midway though the SCF procedure,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:15765,perform,performing,15765,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,6,['perform'],['performing']
Performance,"ly; parallel mode of operation. In Psithon, these have been dubbed sow/reap; procedures and have the following general structure. Prepare an input file, simply adding mode='sow' to the; argument list of an available Python function. Run this quick job to; produce input files for lengthier calculations.; According to the instructions in the output file of the above step,; run the generated input files in any order on any variety of computers; and architectures. This is the time-intensive portion of the; calculation.; The ‘sow’ stage also produces a master input file (with a; mode='reap' directive). When all the jobs in the above step are; completed, place their output files in the same location as the; master input, and run this last, quick job to collect the results. Sow/reap procedures are governed by the mode keyword, choices being; 'continuous', 'sow', and 'reap'. Only 'sow' is likely to; be used by the user, as 'continuous' is always the default, and; input files with 'reap' are autogenerated.; Embarrassingly parallel algorithm available at present for:; Database — database(); finite difference operation of Geometry Optimization — optimize() and gradient(); finite difference of energies of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); finite difference of gradients of Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(). Caution; Some features are not yet implemented. Buy a developer a coffee. Local options (e.g., set scf e_convergence 9) will not get transmitted to the child jobs.; Array options (e.g., set states_per_irrep [2, 1]) will not get transmitted to the child jobs.; Function intercalls (e.g., db(opt())) are not tested with sow/reap procedures. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Psithon Functions: Invoking a Calculation. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sowreap-1.html:1459,optimiz,optimize,1459,psi4manual/1.1.0/sowreap-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sowreap-1.html,2,['optimiz'],['optimize']
Performance,"m IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # IP fitting must be run in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; dft_functional wb97; }. # Arguments are molecule object, minimum omega, maximum omega; ip_fitting(h2o, 0.4, 2.0). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of , though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; . The procedure can also be assisted by providing a tighter guess; for the bounds of . This small test case has a tuned; of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized ; between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. Psi4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional occupations, this; code is able to perform fractional occupation curves for systems with up to 60; atoms, across a wide range of the particle number .; Two python macros exist for this code. The first is frac_traverse(), which is; used to investigate the fractional occupation behavior within one electron above; and below the neutral. An example is:; memory 512 MB; from frac import *. molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; symmetry c1 # FRAC jobs must be run in C1 symmetry; }. set {; reference uks # UKS, as we need",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/dft-1.html:20177,optimiz,optimized,20177,psi4manual/1.0.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/dft-1.html,2,['optimiz'],['optimized']
Performance,ma() psi4.core.Molecule method. to_serial() psi4.core.Matrix method. psi4.core.Vector method. to_string() psi4.core.Molecule method. to_tuple() psi4.core.Dimension method. tocclean() psi4.core.IO method. tocentry_exists() psi4.core.IO method. tocprint() psi4.core.IO method. tocscan() psi4.core.IO method. tocwrite() psi4.core.IO method. total_index() psi4.core.CCWavefunction method. TPDM (DETCI). tpdm() psi4.core.CIWavefunction method. TPDM_ABCD_TYPE (OCC). trace() psi4.core.Matrix method. psi4.core.SymmetryOperation method. TracelessQuadrupoleInt class in psi4.core. transform() psi4.core.DFHelper method. psi4.core.Matrix method. psi4.core.SymmetryOperation method. transform_ci_integrals() psi4.core.CIWavefunction method. transform_mcscf_integrals() psi4.core.CIWavefunction method. transform_tei() psi4.core.IntegralTransform method. transform_tei_first_half() psi4.core.IntegralTransform method. transform_tei_second_half() psi4.core.IntegralTransform method. transition state. ; geometry optimization. translate() psi4.core.Molecule method. TRANSLATE_PSI4 (CFOUR). transpose() psi4.core.DFHelper method. psi4.core.Matrix method. psi4.core.SymmetryOperation method. transpose_this() psi4.core.Matrix method. TREE_EXPANSION_ORDER (PE). TREE_THETA (PE). TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). triplet() in module psi4.core. psi4.core.Matrix static method. trove psi4.driver.driver_cbs.CompositeComputer attribute. true_atomic_number() psi4.core.Molecule method. tstart() in module psi4.core. tstop() in module psi4.core. TURN_ON_ACTV (MCSCF). TWO-ELECTRON ENERGY. TwoBodyAOInt class in psi4.core. twoel_Hx() psi4.core.HF method. TwoElectronInt class in psi4.core. U. U psi4.core.Localizer attribute. UHF class in psi4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() psi4.core.FISAPT method. unit() psi4.core.SymmetryOperation method. units. ; molecule. units() psi4,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/genindex.html:123157,optimiz,optimization,123157,psi4manual/1.7.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/genindex.html,1,['optimiz'],['optimization']
Performance,ma() psi4.core.Molecule method. to_serial() psi4.core.Matrix method. psi4.core.Vector method. to_string() psi4.core.Molecule method. to_tuple() psi4.core.Dimension method. tocclean() psi4.core.IO method. tocentry_exists() psi4.core.IO method. tocprint() psi4.core.IO method. tocscan() psi4.core.IO method. tocwrite() psi4.core.IO method. total_index() psi4.core.CCWavefunction method. TPDM (DETCI). tpdm() psi4.core.CIWavefunction method. TPDM_ABCD_TYPE (OCC). trace() psi4.core.Matrix method. psi4.core.SymmetryOperation method. TracelessQuadrupoleInt class in psi4.core. transform() psi4.core.DFHelper method. psi4.core.Matrix method. psi4.core.SymmetryOperation method. transform_ci_integrals() psi4.core.CIWavefunction method. transform_mcscf_integrals() psi4.core.CIWavefunction method. transform_tei() psi4.core.IntegralTransform method. transform_tei_first_half() psi4.core.IntegralTransform method. transform_tei_second_half() psi4.core.IntegralTransform method. transition state. ; geometry optimization. translate() psi4.core.Molecule method. TRANSLATE_PSI4 (CFOUR). transpose() psi4.core.DFHelper method. psi4.core.Matrix method. psi4.core.SymmetryOperation method. transpose_this() psi4.core.Matrix method. TREE_EXPANSION_ORDER (PE). TREE_THETA (PE). TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). triplet() in module psi4.core. psi4.core.Matrix static method. trove psi4.driver.driver_cbs.CompositeComputer attribute. true_atomic_number() psi4.core.Molecule method. tstart() in module psi4.core. tstop() in module psi4.core. TURN_ON_ACTV (MCSCF). TWO-ELECTRON ENERGY. TwoBodyAOInt class in psi4.core. twoel_Hx() psi4.core.HF method. twoel_Hx_full() psi4.core.RHF method. TwoElectronInt class in psi4.core. U. U psi4.core.Localizer attribute. UHF class in psi4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify() psi4.core.FISAPT method. unify_part2() psi4.core.FISAPT metho,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/genindex.html:123762,optimiz,optimization,123762,psi4manual/1.8.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/genindex.html,1,['optimiz'],['optimization']
Performance,ma() psi4.core.Molecule method. to_serial() psi4.core.Matrix method. psi4.core.Vector method. to_string() psi4.core.Molecule method. to_tuple() psi4.core.Dimension method. tocclean() psi4.core.IO method. tocentry_exists() psi4.core.IO method. tocprint() psi4.core.IO method. tocscan() psi4.core.IO method. tocwrite() psi4.core.IO method. total_index() psi4.core.CCWavefunction method. TPDM (DETCI). tpdm() psi4.core.CIWavefunction method. TPDM_ABCD_TYPE (OCC). trace() psi4.core.Matrix method. psi4.core.SymmetryOperation method. TracelessQuadrupoleInt class in psi4.core. transform() psi4.core.DFHelper method. psi4.core.Matrix method. psi4.core.SymmetryOperation method. transform_ci_integrals() psi4.core.CIWavefunction method. transform_mcscf_integrals() psi4.core.CIWavefunction method. transform_tei() psi4.core.IntegralTransform method. transform_tei_first_half() psi4.core.IntegralTransform method. transform_tei_second_half() psi4.core.IntegralTransform method. transition state. ; geometry optimization. translate() psi4.core.Molecule method. TRANSLATE_PSI4 (CFOUR). transpose() psi4.core.DFHelper method. psi4.core.Matrix method. psi4.core.SymmetryOperation method. transpose_this() psi4.core.Matrix method. TREE_EXPANSION_ORDER (PE). TREE_THETA (PE). TRIPLES_ALGORITHM (PSIMRCC). TRIPLES_DIIS (PSIMRCC). TRIPLES_IABC_TYPE (DFOCC). TRIPLES_LOW_MEMORY (FNOCC). triplet() in module psi4.core. psi4.core.Matrix static method. true_atomic_number() psi4.core.Molecule method. tstart() in module psi4.core. tstop() in module psi4.core. TURN_ON_ACTV (MCSCF). TWO-ELECTRON ENERGY. TwoBodyAOInt class in psi4.core. twoel_Hx() psi4.core.CUHF method. psi4.core.HF method. psi4.core.RHF method. psi4.core.ROHF method. psi4.core.UHF method. TwoElectronInt class in psi4.core. U. U psi4.core.BoysLocalizer attribute. psi4.core.Localizer attribute. psi4.core.PMLocalizer attribute. UHF class in psi4.core. UHF_NOONS (SCF). UKSFunctions class in psi4.core. UNCP-CORRECTED 2-BODY INTERACTION ENERGY. unify(),MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/genindex.html:151254,optimiz,optimization,151254,psi4manual/1.6.x/genindex.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/genindex.html,1,['optimiz'],['optimization']
Performance,"machines (see Sec. Threading).; An advanced parser written in Python allows the user; input to have a very simple style for routine computations, but it can also; automate very complex tasks with ease.; In this section, we provide an overview of some of the features of; PSI4 along with the prerequisite steps for running calculations.; Sec. Tutorial provides a brief tutorial to help new users; get started. Section Psithon offers further details into the; structure of PSI4 input files, and how Python can be mixed with; quantum chemistry directives in PSI4. Section Psithon Functions; provides more detail on the Python functions provided by PSI4; and discusses some of the higher-level functions such as counterpoise; correction, complete-basis-set extrapolation, and running computations; on an entire database of molecules at a time. Later sections deal with; the different types of computations which can be done using PSI4; (e.g., Hartree–Fock, MP2, coupled-cluster) and general procedures; such as geometry optimization and vibrational frequency analysis.; The Appendix includes a complete description of all possible input; keywords for each module, as well as tables of available basis sets and; a listing of the sample input files available under psi4/samples.; The user is urged to examine this directory of sample inputs, as; most common types of computations are represented there.; For the latest PSI4 documentation, check; www.psicode.org. Citing PSI4¶; The following citation should be used in any publication utilizing the; PSI4 program package:; PSI4. “Psi4: an open-source ab initio electronic structure program,”; J. M. Turney, A. C. Simmonett, R. M. Parrish, E. G. Hohenstein, F.; Evangelista, J. T. Fermann, B. J. Mintz, L. A. Burns, J. J. Wilke, M. L.; Abrams, N. J. Russ, M. L. Leininger, C. L. Janssen, E. T. Seidl, W. D.; Allen, H. F. Schaefer, R. A. King, E. F. Valeev, C. D. Sherrill, and T.; D. Crawford, WIREs Comput. Mol. Sci., (2011) (doi: 10.1002/wcms.93). Depending",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/introduction-1.html:1369,optimiz,optimization,1369,psi4manual/4.0b2/introduction-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/introduction-1.html,4,['optimiz'],['optimization']
Performance,"maining virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. pywrap_cbs1; Various basis set extrapolation tests. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. psimrcc-sp1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. cc13; UHF-CCSD/cc-pVDZ CH2 geometry optimization via analytic gradients. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. mrcc1; CCSDT cc-pVDZ energy for the H2O molecule using MRCC. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pVDZ-JKFIT RI basis for SCF and cc-pVDZ-RI for SAPT. Monomer geometries are specified using Cartesian coordinates. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. cisd-h2o+-2; 6-31G** H2O+ Test CISD Energy Point. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html:4264,optimiz,optimization,4264,psi4manual/4.0b2/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"make sure to fill in the list up to the highest atomic number included in any calculations. This option is only used if FREEZE_CORE is set to POLICY. Type: array; Default: No Default. FREEZE_INTERFRAG (OPTKING)¶OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING)¶OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_BEND (OPTKING)¶OPTKING — Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN (OPTKING)¶OPTKING — Specify atom and X, XY, XYZ, … to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL (OPTKING)¶OPTKING — Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE (OPTKING)¶OPTKING — Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DOCC (GLOBALS)¶GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_OOFP (OPTKING)¶OPTKING — Specify out-of-plane angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_UOCC (GLOBALS)¶GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING)¶OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM)¶CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. G_CONV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:140431,optimiz,optimized,140431,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['optimiz'],['optimized']
Performance,"mation requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals, evects = np.linalg.eigh(H_block); # Get our eigenvalues and eigenvectors in descending order.; idx = evals.argsort()[::-1]; evals = evals[idx]; evects = evects[:, idx]. normal_irr = np.dot((B_block * massweighter).T, evects). if print_lvl >= 2:; core.print_out(""\n Normal coordinates (non-mass-weighted) for irrep {}:\n"".format(irrep)); core.print_out(""\n{}\n"".format(nppp10(normal_irr))). return H_block. def _process_hessian(H_blocks: List[np.ndarray], B_blocks: List[np.ndarray], massweighter: np.ndarray, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for the Hessian.; Statements need to be printed, and the Hessian must be transformed. Parameters; ----------; H_blocks; A list of blocks of the Hessian per irrep, in mass-weighted salcs.; Each is (nsalc_in_irrep, nsalc_in_irrep); B_blocks; A block of the B matrix per irrep, which transforms CdSalcs to Cartesians.; Each is (nsalc_in_irrep, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; print_lvl; The level of printing information requested by the user. Returns; -------; Hx; The Hessian in non-mass weighted cartesians.; """""". # Handle empty case (atom); if not H_blocks and not B_blocks:; nat3 = massweighter.size; return np.zeros((nat3, nat3), dtype=np.float64). # We have the Hessian in each irrep! The final task is to perform coordinate transforms.; H = p4util.block_diagonal_array(*H_blocks); B = np.vstack(B_blocks). if print_lvl >= 3:; core.print_out(""\n Force constant matrix for al",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:24721,Perform,Perform,24721,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Perform'],['Perform']
Performance,"max']). # By default, DIIS in FRAC (1.0 occupation is always DIIS'd); frac_diis = True; if kwargs.has_key('frac_diis'):; frac_diis = kwargs['frac_diis']. # By default, drop the files to the molecule's name; root = mol.name(); if kwargs.has_key('filename'):; root = kwargs['filename']; traverse_filename = root + '.traverse.dat'; stats_filename = root + '.stats.dat'. # => Traverse <= #; psi4.set_global_option(""DF_INTS_IO"", ""SAVE""). Ns = []; energies = []; potentials = []; convs = []; stats = []. # Run one SCF to burn things in; energy('scf'). # Determine HOMO; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)]; E_b = eps_b[int(Nb - 1)]; if (E_a >= E_b):; HOMO = Na; else:; HOMO = -Nb. stats.append('\t%6d %6d %6d %6d %6d %6d\n' %(N, Na, Nb, charge, mult, HOMO)). if (HOMO > 0):; Na = Na - 1; else:; Nb = Nb - 1; charge = charge + 1; mult = Na - Nb + 1. psi4.set_global_option(""DF_INTS_IO"", ""LOAD""); psi4.set_global_option(""FRAC_START"", frac_start); psi4.set_global_option(""FRAC_RENORMALIZE"", True). # Nuke 'em Rico!; for Nintegral in range(N,Nmin,-1):. # Nuke the current HOMO; for occ in foccs:. psi4.set_global_option(""FRAC_OCC"", [HOMO]); psi4.set_global_option(""FRAC_VAL"", [occ]). E = energy('scf'); C = 1; if (E == 0.0):; E = psi4.get_variable('SCF ITERATION ENERGY'); C = 0. if (HOMO > 0):; ref = psi4.wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[HOMO-1]); else:; ref = psi4.wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-HOMO-1]). Ns.append(Nintegral + occ - 1.0); energies.append(E); convs.append(C). psi4.set_global_option(""FRAC_START"", 2); psi4.set_global_option(""FRAC_LOAD"", True); psi4.set_global_option(""FRAC_DIIS"", frac_diis); psi4.set_global_option(""GUESS"", ""READ""). # Set the next charge/mult; mol.set_molecular_charge(charge); mol.set_multiplicity(mult). # Determine HOMO; ref = psi4.wavefunction(); eps_a = ref.epsilon_a(); eps_b = r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/frac.html:8988,LOAD,LOAD,8988,psi4manual/4.0b5/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/frac.html,1,['LOAD'],['LOAD']
Performance,"max_disp + 1):; energy_string = f""Energy(-{i}) "" + energy_string + f""Energy(+{i}) ""; info = ""\n Coord "" + energy_string + "" Force""; for salc in range(data[""n_salc""]):; print_str = ""\n {:5d}"" + "" {:17.10f}"" * (e_per_salc) + "" {force:17.10f}""; energies = E[salc]; info += print_str.format(salc, force=g_q[salc], *energies); core.print_out(info); logger.info(info). # Transform the gradient from mass-weighted SALCs to non-mass-weighted Cartesians; B = data[""salc_list""].matrix(); g_cart = np.dot(g_q, B); g_cart = g_cart.reshape(data[""n_atom""], 3); massweighter = np.array([mol.mass(a) for a in range(data[""n_atom""])])**(0.5); g_cart = (g_cart.T * massweighter).T. if data[""print_lvl""]:; info = ""\n -------------------------------------------------------------\n""; core.print_out(info); logger.info(info). return g_cart. def _process_hessian_symmetry_block(H_block: np.ndarray, B_block: np.ndarray, massweighter: np.ndarray, irrep: str, print_lvl: int) -> np.ndarray:; """"""Perform post-construction processing for a symmetry block of the Hessian.; Statements need to be printed, and the Hessian must be made orthogonal. Parameters; ----------; H_block; A block of the Hessian for an irrep, in mass-weighted salcs.; (nsalc, nsalc); B_block; A block of the B matrix for an irrep, which transforms CdSalcs to Cartesians.; (nsalc, 3 * nat); massweighter; The mass associated with each atomic coordinate.; (3 * nat, ) Due to x, y, z, values appear in groups of three.; irrep; A string identifying the irrep H_block and B_block are of.; print_lvl; The level of printing information requested by the user. Returns; -------; H_block; H_block, but made into an orthogonal array.; """""". # Symmetrize our Hessian block.; # The symmetric structure is lost due to errors in the computation; H_block = (H_block + H_block.T) / 2.0. if print_lvl >= 3:; core.print_out(f""Force Constants for irrep {irrep} in mass-weighted, symmetry-adapted Cartesian coordinates.""); core.print_out(""\n{}\n"".format(nppp10(H_block))). evals",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html:23145,Perform,Perform,23145,psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver_findif.html,4,['Perform'],['Perform']
Performance,"may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR)¶CCHBAR — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA)¶CCLAMBDA — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE)¶CCRESPONSE — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCTRANSORT)¶CCTRANSORT — Caching level for libdpd. Type: integer; Default: 2. CACHELEVEL (DCT)¶DCT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC)¶OCC — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:10099,cache,cache,10099,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,18,['cache'],['cache']
Performance,"mber of CPHF iterations. Type: integer; Default: 50. PRINT¶. The amount of information to print to the output file for the sapt module. For 0, only the header and final results are printed. For 1, (recommended for large calculations) some intermediate quantities are also printed. Type: integer; Default: 1. Advanced SAPT0 Keywords¶. AIO_CPHF¶. Do use asynchronous disk I/O in the solution of the CPHF equations? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. AIO_DF_INTS¶. Do use asynchronous disk I/O in the formation of the DF integrals? Use may speed up the computation slightly at the cost of spawning an additional thread. Type: boolean; Default: false. NO_RESPONSE¶. Don’t solve the CPHF equations? Evaluate and instead of their response-including coupterparts. Only turn on this option if the induction energy is not going to be used. Type: boolean; Default: false. EXCH_SCALE_ALPHA¶. Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with . If set to a value , performs scaling with . Type: string; Default: FALSE. INTS_TOLERANCE¶. Minimum absolute value below which all three-index DF integrals and those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. DENOMINATOR_DELTA¶. Maximum error allowed (Max error norm in Delta tensor) in the approximate energy denominators employed for most of the and evaluation. Type: double; Default: 1.0e-6. DENOMINATOR_ALGORITHM¶. Denominator algorithm for PT methods. Laplace transformations are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Higher-Order SAPT¶; For smaller systems (up to the size of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:10517,perform,perform,10517,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['perform']
Performance,"mber of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. FREEZE_CORE (SAPT); SAPT — The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. FREEZE_INTERFRAG (OPTKING); OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_DOCC (PSIMRCC); PSIMRCC — The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_UOCC (PSIMRCC); PSIMRCC — The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do ?. Type: boolean; Default: false. FZC_A_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_OEI. FZC_B_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_OEI. FZC_FILE (TRANSQT); TRANSQT —. Type: integer; Default: PSIF_OEI. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization criteria. Specification of any MAX_*_G_CONVERGENCE or RMS_*_G_CONVERGENCE options will append to overwrite th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:37734,optimiz,optimized,37734,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"mber of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. FREEZE_CORE (SAPT); SAPT — The scope of core orbitals to freeze in evaluation of SAPT and terms. Recommended true for all SAPT computations. Type: string; Possible Values: FALSE, TRUE, SMALL, LARGE; Default: FALSE. FREEZE_INTERFRAG (OPTKING); OPTKING — Do freeze all interfragment modes?. Type: boolean; Default: false. FREEZE_INTRAFRAG (OPTKING); OPTKING — Do freeze all fragments rigid?. Type: boolean; Default: false. FROZEN_DOCC (GLOBALS); GLOBALS — An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_DOCC (PSIMRCC); PSIMRCC — The number of frozen occupied orbitals per irrep. Type: array; Default: No Default. FROZEN_UOCC (GLOBALS); GLOBALS — An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. Type: array; Default: No Default. FROZEN_UOCC (PSIMRCC); PSIMRCC — The number of frozen virtual orbitals per irrep. Type: array; Default: No Default. FULL_HESS_EVERY (OPTKING); OPTKING — Frequency with which to compute the full Hessian in the course of a geometry optimization. 0 means to compute the initial Hessian only, 1 means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. FULL_MATRIX (CCEOM); CCEOM — Do use full effective Hamiltonian matrix?. Type: boolean; Default: false. FZC_A_FILE (TRANSQT); TRANSQT — Alpha-spin frozen-core file. Type: integer; Default: PSIF_OEI. FZC_B_FILE (TRANSQT); TRANSQT — Beta-spin frozen-core file. Type: integer; Default: PSIF_OEI. FZC_FILE (TRANSQT); TRANSQT — Frozen-core file. Type: integer; Default: PSIF_OEI. G_CONVERGENCE (OPTKING); OPTKING — Set of optimization ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:46599,optimiz,optimized,46599,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimized']
Performance,"mbination of the ODC-13 method with a three-particle energy correction; [\(\mbox{ODC-13$(\lambda_3)$}\)] can be used (see below).; For the detailed comparison of the quality of these methods, we refer; users to our publications.; The DCT functional can be specified by the DCT_FUNCTIONAL option. The; default choice is the ODC-12 functional. The DCT code can also be used to; compute the \((\lambda_3)\) energy correction that perturbatively accounts; for three-particle correlation effects, similarly to the (T) correction in coupled; cluster theory. Computation of the \((\lambda_3)\) correction can be; requested by setting the THREE_PARTICLE option to PERTURBATIVE. A; combination of the ODC-13 functional with the \((\lambda_3)\) correction; [denoted as \(\mbox{ODC-13$(\lambda_3)$}\)] has been shown to provide highly; accurate results for open-shell molecules near equilibrium geometries.; At the present moment, all of the DCT methods support unrestricted reference; orbitals (REFERENCE UHF), which can be used to perform energy and; gradient computations for both closed- and open-shell molecules. In addition,; the ODC-06 and ODC-12 methods support restricted reference orbitals; (REFERENCE RHF) for the energy and gradient computations of; closed-shell molecules. Note that in this case restricted reference orbitals; are only available for ALGORITHM SIMULTANEOUS. Iterative Algorithms¶; As explained in the Theory section, in order to obtain the DCT energy one; needs to solve a system of coupled equations for orbitals and density; cumulant. At the present moment three iterative algorithms for the solution of the; equations are available. The choice of the algorithm is controlled using the; ALGORITHM option. SIMULTANEOUS [Default]In the simultaneous algorithm the DCT equations are solved in macroiterations.; Each macroiteration consists of a single iteration of the cumulant update; followed by a single iteration of the orbital update and orbital transformation; of the integrals. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dct-1.html:7333,perform,perform,7333,psi4manual/1.4.0/dct-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dct-1.html,9,['perform'],['perform']
Performance,"mbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:3135,Queue,Queue,3135,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,1,['Queue'],['Queue']
Performance,"mbol = range(numatoms); X = [0.0] * numatoms; Y = [0.0] * numatoms; Z = [0.0] * numatoms; ; Queue = []; White = []; Black = []; F = geom.split('\n'); for f in range(0, numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwar",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:3160,Queue,Queue,3160,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['Queue'],['Queue']
Performance,"mcscf(...); mcscf() -> float :; Runs the MCSCF code, (N.B. restricted to certain active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mp2(...); mp2() -> float :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:110732,optimiz,optimized,110732,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['optimiz'],['optimized']
Performance,"me function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV¶. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC¶. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP¶. Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD¶. Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html:30377,optimiz,optimizations,30377,psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__cfour-1.html,2,['optimiz'],['optimizations']
Performance,"me manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__ccresponse.html:3783,CACHE,CACHELEVEL,3783,psi4manual/1.8.x/autodir_options_c/module__ccresponse.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__ccresponse.html,1,['CACHE'],['CACHELEVEL']
Performance,"me manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations to converge perturbed amplitude equations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 5. OMEGA¶. Array that specifies the desired frequencies of the incident radiation field in CCLR calculations. If only one element is given, the units will be assumed to be atomic units. If more than one element is given, then the units must be specified as the final element of the array. Acceptable units are HZ, NM, EV, and AU. Type: array; Default: No Default. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity (ROA_TENSOR for each displacement), and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, ROA, ROA_TENSOR, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Default: RHF. RESTART¶. Do restart from on-disk amplitudes?. Type: boolean; Default: true. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in perturbed CC equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. Expert¶. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCRESPONSE; General; ABCD; ANALYZE; CACHELEVEL; DIIS; GAUGE; LINEAR; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; OMEGA; PROPERTY; REFERENCE; RESTART; R_CONVERGENCE; SEKINO. Expert; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Keywords by Module; CCRESPONSE. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__ccresponse.html:3783,CACHE,CACHELEVEL,3783,psi4manual/1.9.x/autodir_options_c/module__ccresponse.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__ccresponse.html,1,['CACHE'],['CACHELEVEL']
Performance,"me, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_changed(""MP_TYPE"") else ""DF""; module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE') if core.has_global_option_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:14466,perform,performance,14466,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,6,['perform'],['performance']
Performance,"me, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp3_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP3 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp3_gradient', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_mp2p5', name, 'MP_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func =",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:11595,perform,performance,11595,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"me__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2p5_gradient(name, **kwargs):; """"""Function selecting the algorithm for a MP2.5 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2p5(name, **kwargs):; """"""Function selecting the algorithm for an OMP2.5 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:15860,perform,performance,15860,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['perform'],['performance']
Performance,"means rebuild every N SCF iterations to avoid accumulating error from the incremental procedure. Type: integer; Default: 5. LEVEL_SHIFT¶. Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF¶. DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. MAXITER¶. Maximum number of iterations. Cfour Interface: Keyword translates into CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html:7078,perform,perform,7078,psi4manual/1.5.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__scf-1.html,4,['perform'],['perform']
Performance,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:. set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:4721,optimiz,optimize,4721,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimize']
Performance,"means recompute every step, and N means recompute every N steps. The default (-1) is to never compute the full Hessian. Type: integer; Default: -1. INTCOS_GENERATE_EXIT¶. Do only generate the internal coordinates and then stop?. Type: boolean; Default: false. Optimizing Minima¶; First, define the molecule and basis in the input.; molecule h2o {; O; H 1 1.0; H 1 1.0 2 105.0; }. set basis dz. Then the following are examples of various types of calculations that can be completed. Optimize a geometry using default methods (RFO step):; optimize('scf'). Optimize using Newton-Raphson steps instead of RFO steps:; set step_type nr; optimize('scf'). Optimize using energy points instead of gradients:; optimize('scf', dertype='energy'). Optimize while limiting the initial step size to 0.1 au:; set intrafrag_step_limit 0.1; optimize('scf'). Optimize while always limiting the step size to 0.1 au:; set {; intrafrag_step_limit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:4733,optimiz,optimize,4733,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,10,['optimiz'],['optimize']
Performance,"mega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dft1; DFT Functional Test all values update for new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. mints3; Test individual integral objects for correctness. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposition. These operations are performed on vectors and matrices provided from the Psi library. fci-coverage; 6-31G H2O Test for c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:23842,optimiz,optimization,23842,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"memcmd, memkw = '', {}; else:; memcmd, memkw = qcdb.cfour.muster_memory(mem). # Handle molecule and basis set; if molecule.name() == 'blank_molecule_psi4_yo':; molcmd, molkw = '', {}; bascmd, baskw = '', {}; core.set_local_option('CFOUR', 'TRANSLATE_PSI4', False); else:; molecule.update_geometry(); #print(molecule.create_psi4_string_from_molecule()); qcdbmolecule = qcdb.Molecule(molecule.create_psi4_string_from_molecule()); qcdbmolecule.tagline = molecule.name(); molcmd, molkw = qcdbmolecule.format_molecule_for_cfour(). if core.get_global_option('BASIS') in ["""", ""(AUTO)""]:; bascmd, baskw = '', {}; else:; user_pg = molecule.schoenflies_symbol(); molecule.reset_point_group('c1') # need basis printed for *every* atom; qbs = core.BasisSet.build(molecule, ""BASIS"", core.get_global_option('BASIS')); if qbs.has_ECP():; raise ValidationError(""""""ECPs not hooked up for Cfour""""""); with open('GENBAS', 'w') as cfour_basfile:; cfour_basfile.write(qbs.genbas()); core.print_out(' GENBAS loaded from Psi4 LibMints for basis %s\n' % (core.get_global_option('BASIS'))); molecule.reset_point_group(user_pg); molecule.update_geometry(); bascmd, baskw = qcdbmolecule.format_basis_for_cfour(qbs.has_puream()). # Handle psi4 keywords implying cfour keyword values; if core.get_option('CFOUR', 'TRANSLATE_PSI4'):; psicmd, psikw = qcdb.cfour.muster_psi4options(p4util.prepare_options_for_modules(changedOnly=True)); else:; psicmd, psikw = '', {}. # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle calc type and quantum chemical method; mdccmd, mdckw = qcdb.cfour.muster_modelchem(name, dertype). # Handle driver vs input/default keyword reconciliation; userkw = p4util.prepare_options_for_modules(); userkw = qcdb.options.reconcile_options(userkw, memkw); userkw = qcdb.options.reconcile_options(userkw, molkw); userkw = qcdb.options.reconcile_options(userkw, baskw); userkw = qcdb.options.reconcile_options(userkw, psikw); userkw = qcdb.options.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html:15982,load,loaded,15982,psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/interface_cfour.html,8,['load'],['loaded']
Performance,"memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. table of contents. DCT: Density Cumulant Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Theoretical Methods: SCF to FCI; DCT: Density Cumulant Theory. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/dct.html:15375,perform,performing,15375,psi4manual/1.7.x/dct.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/dct.html,1,['perform'],['performing']
Performance,"mension.; dim2 (Optional[Dimension]) – Same as dim1 only if using a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). classmethod from_list(x)¶. classmethod from_serial(json_data)¶; Converts serialized data to the correct Psi4 data type. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html:4011,load,load,4011,psi4manual/1.6.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html,2,['load'],['load']
Performance,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:10817,load,load,10817,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,6,['load'],['load']
Performance,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_wr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11160,load,load,11160,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11225,load,load,11225,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Uni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11174,load,load,11174,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11154,load,load,11154,psi4manual/1.8.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the sam",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:135407,load,load,135407,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['load'],['load']
Performance,"ment beta Prefactor for the resulting matrix. general_invert(self: psi4.core.Matrix) → None¶; Computes the inverse of any nonsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:10620,load,load,10620,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"mentation (available pre-built at psicode.org/psi4manual/master/index.html). Sphinx (3.5+) http://sphinx-doc.org; Perl (for some auto-documentation scripts) https://www.perl.org/; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/; sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] :source:`doc/sphinxman/CMakeLists.txt for advice on obtaining docs dependencies; See psi4/.github/workflows/docs.yml for full docs building procedure to follow. Ambit — https://github.com/jturney/ambit; CheMPS2 — [what is CheMPS2?] [CheMPS2 min version]. HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. ecpint — [what is ecpint?] [ecpint min version]; dkh — [what is dkh?] [dkh min version]. Fortran Compiler. gdma — [what is gdma?] [gdma min version]. Fortran Compiler. PCMSolver — [what is PCMSolver?]. Fortran Compiler; zlib http://www.zlib.net/. simint — [what is simint?] [simint min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is LibEFP?] [LibEFP min version]; cfour — [what is CFOUR?]; dftd3 — [what is DFTD3?]; gcp — [what is gCP?]; mrcc — [what is MPCC?]; v2rdm_casscf — [what is v2rdm_casscf?]; sns-mp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion; cppe — https://github.com/maxscheurer/cppe; mp2d — https://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC — https://www.brianqc.com/; i-PI — http://ipi-code.org/; psixas — https://github.com/Masterluke87/psixas; MDI — https://github.com/MolSSI-MDI/MDI_Library. How to use conda to get a Psi4 development environment¶; PSI4 has a lot of dependencies, some of which are complicated; to build. Fortunately,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_planning.html:7758,load,loaded,7758,psi4manual/1.6.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_planning.html,1,['load'],['loaded']
Performance,"mentation (available pre-built at psicode.org/psi4manual/master/index.html). Sphinx (3.5+) http://sphinx-doc.org; Perl (for some auto-documentation scripts) https://www.perl.org/; nbsphinx (for converting Jupyter notebooks) http://nbsphinx.readthedocs.io/en/jupyter-theme/; sphinx-psi-theme https://github.com/psi4/sphinx-psi-theme; See [“message” lines] :source:`doc/sphinxman/CMakeLists.txt for advice on obtaining docs dependencies; See psi4/.github/workflows/docs.yml for full docs building procedure to follow. Ambit — https://github.com/jturney/ambit; CheMPS2 — [what is CheMPS2?] [CheMPS2 min version]. HDF5 https://support.hdfgroup.org/HDF5/; zlib http://www.zlib.net/. ecpint — [what is ecpint?] [ecpint min version]; dkh — [what is dkh?] [dkh min version]. Fortran Compiler. gdma — [what is gdma?] [gdma min version]. Fortran Compiler. PCMSolver — [what is PCMSolver?]. Fortran Compiler; zlib http://www.zlib.net/. simint — [what is simint?] [simint min version]. Additionally, there are runtime-loaded capabilities:. PylibEFP & libefp — [what is LibEFP?] [LibEFP min version]; cfour — [what is CFOUR?]; dftd3 — [what is DFTD3?]; simple-dftd3 — [what is DFTD3?] (Nov 2022; added by v1.7) preferred alternative to dftd3 https://github.com/dftd3/simple-dftd3; gcp — [what is gCP?]; mctc-gcp — [what is gCP?] (Nov 2022; added by v1.7) preferred alternative to gcp https://github.com/grimme-lab/gcp; dftd4 — <sec:dftd3> https://github.com/dftd4/dftd4; mrcc — [what is MPCC?]; v2rdm_casscf — [what is v2rdm_casscf?]; sns-mp2 — https://github.com/DEShawResearch/sns-mp2/commits/master; resp — https://github.com/cdsgroup/resp; gpu_dfcc — https://github.com/edeprince3/gpu_dfcc/commits/master; OpenFermion-Psi4 — https://github.com/quantumlib/OpenFermion; cppe — https://github.com/maxscheurer/cppe; mp2d — https://github.com/Chandemonium/MP2D; FockCI — https://github.com/shannonhouck/psi4fockci; cct3 — https://github.com/piecuch-group/cct3; adcc — https://github.com/adc-connect/adcc; BrianQC —",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_planning.html:8026,load,loaded,8026,psi4manual/1.7.x/build_planning.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_planning.html,1,['load'],['loaded']
Performance,"ments. From this, it can obtain the harmonic vibrational; frequencies, given below (roundoff errors of around 0.1 cm-1; may exist):; 1; 2; 3; 4; 5; 6; 7 Irrep Harmonic Frequency; (cm-1); -----------------------------------------------; A1 1775.6480; A1 4113.3794; B2 4212.1826; -----------------------------------------------. Notice that the symmetry type of the normal modes is specified (A1, A1,; B2). The program also prints out the normal modes in terms of Cartesian; coordinates of each atom. For example, the normal mode at 1776 cm-1; is:; 1; 2; 3; 4; 5; 6 Frequency: 1775.65; Force constant: 0.1193; X Y Z mass; O 0.000 0.000 -0.270 15.994915; H 0.000 0.417 0.538 1.007825; H 0.000 -0.417 0.538 1.007825. where the table shows the displacements in the X, Y, and Z dimensions for; each atom along the normal mode coordinate. (This information could be used; to animate the vibrational frequency using visualization software.); Because the vibrational frequencies are available, a thermodynamics; analysis is automatically performed at the end of the computation.; You can see this in the next section of the output file. The vibrational; frequencies are sufficient to obtain vibrational contributions to; enthalpy (H), entropy (S), and Gibbs free energy (G). Similarly, the; molecular geometry is used to obtain rotational constants, which are; then used to obtain rotational contributions to H, S, and G. Analysis of Intermolecular Interactions¶; Now let’s consider something a little more interesting. PSI4; contains code to analyze the nature of intermolecular interactions; between two molecules, via symmetry-adapted perturbation theory; (SAPT) [Jeziorski:1994:1887]. This kind of analysis gives a lot; of insight into the nature of intermolecular interactions, and PSI4; makes these computations easier than ever.; For a SAPT computation, the input needs to provide information on two; distinct molecules. This is very easy, we just give a Z-matrix or set of; Cartesian coordinates for e",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:9704,perform,performed,9704,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['perform'],['performed']
Performance,"mer'). This procedure leads to faster compuations, but it converges more slowly; towards the complete basis set limit than the default procedure, which uses; the dimer-centered basis set. Hence, monomer-centered basis SAPT; computations are not recommended. The open-shell SAPT0 code is not; compatible yet with monomer-centered computations. Computations with Mid-bonds¶; SAPT computations with midbonds can be accomplished by adding a third ghost; monomer to the computation. For example; molecule dimer {; 0 1; He 0 0 5; --; 0 1; He 0 0 -5; --; 0 1; @He 0 0 0; }. Here the functions of the third monomer will be added to the virtual space of; the entire computation. Note that an error will be thrown if each atom in the; third monomer is not a ghost to prevent confusion with three-body SAPT which is; not currently supported by Psi4. Interpreting SAPT Results¶; We will examine the results of a SAPT2+3/aug-cc-pVDZ computation on the; water dimer. This computation can be performed with the following; input:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561; units angstrom; }. set globals {; basis aug-cc-pvdz; guess sad; scf_type df; }. set sapt {; print 1; nat_orbs_t2 true; freeze_core true; }. energy('sapt2+3'). To reiterate some of the options mentioned above: the; NAT_ORBS_T2 option will compute MP2 natural orbitals and use; them in the evaluation of the triples correction to dispersion, and the; FREEZE_CORE option will freeze the core throughout the SAPT; computation. This SAPT2+3/aug-cc-pVDZ computation produces the following; results:; SAPT Results; --------------------------------------------------------------------------------------------------------; Electrostatics -13.06509118 [mEh] -8.19846883 [kcal/mol] -34.30239689 [kJ/mol]; Elst10,r -13.37542977 [mEh] -8.39320925 [kcal/mol] -35.11719087 [kJ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:33262,perform,performed,33262,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['perform'],['performed']
Performance,"message to the output file when the solver is converged.""""""; if verbose < 1:; # no printing; return; if verbose > 1:; # print values summary + number of iterations + # of ""big"" product evals; core.print_out("" Root # eigenvalue\n""); for (i, vi) in enumerate(vals):; core.print_out(f"" {i+1:^6} {vi:20.12f}\n""); max_nvec = max(istat['nvec'] for istat in stats); core.print_out(f""\n {solver_name} converged in {stats[-1]['count']} iterations\n""); core.print_out(f"" Computed a total of {stats[-1]['product_count']} large products\n\n""). def _print_array(name, arr, verbose):; """"""print a subspace quantity (numpy array) to the output file. Parameters; ----------; name : str; The name to print above the array; arr : :py:class:`np.ndarray`; The array to print; verbose : int; The amount of information to print. Only prints for verbose > 2; """"""; if verbose > 2:; core.print_out(f""\n\n{name}:\n{str(arr)}\n""). def _gs_orth(engine, U, V, thresh: float = 1.0e-8):; """"""Perform Gram-Schmidt orthonormalization of a set V against a previously orthonormalized set U. Parameters; ----------; engine : object; The engine passed to the solver, required to define vector algebraic operations needed; U : list of `vector`; A set of orthonormal vectors, len(U) = l; satisfies ||I^{lxl}-U^tU|| < thresh; V : list of `vectors`; The vectors used to augment U; thresh; If the orthogonalized vector has a norm smaller than this value it is considered LD to the set. Returns; -------; U_aug : list of `vector`; The orthonormal set of vectors U' with span(U') = span(U) + span(V), len(U) <= len(U_aug) <= len(U) + len(V); """"""; for vi in V:; for j in range(len(U)):; dij = engine.vector_dot(vi, U[j]); Vi = engine.vector_axpy(-1.0 * dij, U[j], vi); norm_vi = np.sqrt(engine.vector_dot(vi, vi)); if norm_vi >= thresh:; U.append(engine.vector_scale(1.0 / norm_vi, vi)); return U. def _best_vectors(engine, ss_vectors: np.ndarray, basis_vectors: List) -> List:; r""""""Compute the best approximation of the true eigenvectors as a line",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:11776,Perform,Perform,11776,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,4,['Perform'],['Perform']
Performance,"meters, VWN1 Spin Polarization. vwn5rpa_c; VWN5 LSDA Correlation, RPA Parameters, VWN5 Spin Polarization. vwn5_c; VWN5 LSDA Correlation, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. 1; 2>>> # [1] Analytic hf optimization; >>> optimize('hf'). 1; 2; 3; 4>>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). 1; 2; 3>>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). 1; 2>>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). 1; 2; 3; 4>>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). Navigation. Index. modules    .    .  · ; 1.1;  · . PSI4. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html:7063,optimiz,optimization,7063,psi4manual/1.1.0/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/api/psi4.driver.opt.html,18,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"methanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or. molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Sec. Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html:9344,optimiz,optimized,9344,psi4manual/4.0b2/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/psithoninput-1.html,8,['optimiz'],['optimized']
Performance,"methanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or; molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, PSI4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Molecule Keywords, can be; used in conjunction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, PSI4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly, a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in PSI4¶. Point Group; 1; 2; 3; 4; 5; 6; 7; 8. \(C_1\); \(A\). \(C_i",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html:9832,optimiz,optimized,9832,psi4manual/1.4.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithonmol-1.html,9,['optimiz'],['optimized']
Performance,"methanol; 727 1,2,3,4,5,6-hexachlorocyclohexane; 240 benzaldehyde; 65723 benzenesulfonohydrazide; 74296 N-phenylbenzenesulfonamide; 289 benzene-1,2-diol; 243 benzoic acid; 7370 benzenesulfonamide; 636822 1,2,4-trimethoxy-5-[(E)-prop-1-enyl]benzene; 7369 benzenesulfonyl chloride; 12932 N-[2-di(propan-2-yloxy)phosphinothioylsulfanylethyl]benzenesulfonamide; 7505 benzonitrile; 78438 N-[anilino(phenyl)phosphoryl]aniline; 12581 3-phenylpropanenitrile; 517327 sodium benzenesulfonate; 637563 1-methoxy-4-[(E)-prop-1-enyl]benzene; 252325 [(E)-prop-1-enyl]benzene. Note that some of these results do not contain the string “benzene”; these; compounds have synonyms containing that text. We can now replace the; “benzene*” in the input file with one of the above compounds using either the; IUPAC name or the CID provided in the list, viz:; molecule benzene {; pubchem:637563; }. or; molecule benzene {; pubchem:1-methoxy-4-[(E)-prop-1-enyl]benzene; }. Some of the structures in the database are quite loosely optimized and do not; have the correct symmetry. Before starting the computation, Psi4 will; check to see if the molecule is close to having each of the possible; symmetries, and will adjust the structure accordingly so that the maximum; symmetry is utilized.; The standard keywords, described in Molecule Keywords, can be; used in conjuction to specify charge, multiplicity, symmetry to use, etc. . Symmetry¶; For efficiency, Psi4 can utilize the largest Abelian subgroup of the full; point group of the molecule. Concomitantly, a number of quantities, such as; SOCC and DOCC, are arrays whose entries pertain to irreducible; representations (irreps) of the molecular point group. Ordering of irreps; follows the convention used in Cotton’s Chemical Applications of Group; Theory, as detailed in Table Irreps. We refer to this; convention as “Cotton Ordering” hereafter. Ordering of irreducible representations (irreps) used in Psi4¶. Point Group; 1; 2; 3; 4; 5; 6; 7; 8.  ;  ;  ;  ;  ;  ;  .  ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html:9838,optimiz,optimized,9838,psi4manual/1.0.0/psithonmol-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithonmol-1.html,2,['optimiz'],['optimized']
Performance,"method gemm; gemm(...) unbound psi4.Matrix method. gemm( (Matrix)arg1, (bool)arg2, (bool)arg3, (float)arg4, (Matrix)arg5, (Matrix)arg6, (float)arg7) -> None :. docstring; C++ signature :. void gemm(N3psi6MatrixE {lvalue},b,b,d,N5boost10shared_ptrIN3psi6MatrixEEE,N5boost10shared_ptrIN3psi6MatrixEEE,d). psi4.Matrix.get()¶; Python Library Documentation: method get; get(...) unbound psi4.Matrix method. get( (Matrix)arg1, (int)arg2, (int)arg3 [, (int)arg4]) -> float :. docstring; C++ signature :. d get(N3psi6MatrixE {lvalue},i,i [,i]). psi4.Matrix.identity()¶; Python Library Documentation: method identity; identity(...) unbound psi4.Matrix method. identity( (Matrix)arg1) -> None :. docstring; C++ signature :. void identity(N3psi6MatrixE {lvalue}). psi4.Matrix.invert()¶; Python Library Documentation: method invert; invert(...) unbound psi4.Matrix method. invert( (Matrix)arg1) -> None :. docstring; C++ signature :. void invert(N3psi6MatrixE {lvalue}). psi4.Matrix.load()¶; Python Library Documentation: method load; load(...) unbound psi4.Matrix method. load( (Matrix)arg1, (str)arg2) -> None :. docstring; C++ signature :. void load(N3psi6MatrixE {lvalue},Ss). psi4.Matrix.load_mpqc()¶; Python Library Documentation: method load_mpqc; load_mpqc(...) unbound psi4.Matrix method. load_mpqc( (Matrix)arg1, (str)arg2) -> None :. docstring; C++ signature :. void load_mpqc(N3psi6MatrixE {lvalue},Ss). psi4.Matrix.name()¶; Python Library Documentation: method name; name(...) unbound psi4.Matrix method. name( (Matrix)arg1) -> str :. docstring; C++ signature :. Ss name(N3psi6MatrixE {lvalue}). psi4.Matrix.nirrep()¶; Python Library Documentation: method nirrep; nirrep(...) unbound psi4.Matrix method. nirrep( (Matrix)arg1) -> int :. docstring; C++ signature :. i nirrep(N3psi6MatrixE {lvalue}). psi4.Matrix.np()¶; Python Library Documentation: property. psi4.Matrix.partial_cholesky_factorize()¶; Python Library Documentation: method partial_cholesky_factorize; partial_cholesky_factorize(...) un",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html:208810,load,load,208810,psi4manual/1.0.0/autodoc_psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_psimod-1.html,6,['load'],['load']
Performance,"method, [1], [2]. set_units() psi4.core.Molecule method, [1], [2]. set_variable() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.Molecule method, [1], [2]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. set_vv10_b() psi4.core.SuperFunctional method, [1], [2]. set_vv10_c() psi4.core.SuperFunctional method, [1], [2]. set_write_dpd_so_tpdm() psi4.core.IntegralTransform method, [1], [2]. set_x_alpha() psi4.core.SuperFunctional method, [1], [2]. set_x_beta() psi4.core.SuperFunctional method, [1], [2]. set_x_omega() psi4.core.SuperFunctional method, [1], [2]. setName() psi4.core.ExternalPotential method, [1], [2]. setting. ; keywords anharmonicity(). keywords cbs(). keywords cp. keywords database(). keywords energy(). keywords frequency(). keywords general. keywords molecule. keywords optimize(). keywords properties(). keywords vmfc. SF_RESTRICT (DETCI). shallow_copy() psi4.core.CCWavefunction method, [1]. psi4.core.CIWavefunction method, [1]. psi4.core.CUHF method, [1]. psi4.core.DFEP2Wavefunction method, [1]. psi4.core.HF method, [1]. psi4.core.RHF method, [1]. psi4.core.ROHF method, [1]. psi4.core.UHF method, [1]. psi4.core.Wavefunction method, [1], [2]. shape psi4.core.Matrix attribute, [1], [2]. psi4.core.Vector attribute, [1], [2]. shared_object() psi4.core.IO method, [1], [2]. psi4.core.IOManager method, [1], [2]. shell() psi4.core.BasisSet method, [1], [2]. shell_extents() psi4.core.BasisExtents method, [1], [2]. shell_to_ao_function() psi4.core.BasisSet method, [1], [2]. shell_to_basis_function() psi4.core.BasisSet method, [1], [2]. shell_to_center() psi4.core.BasisSet method, [1], [2]. ShellInfo class in psi4.core, [1]. shells_iterator() psi4.core.IntegralFactory method, [1], [2]. shells_local_to_global() psi4.core.BlockOPoints method, [1], [2]. sherrill_go",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/genindex-1.html:136327,optimiz,optimize,136327,psi4manual/1.3.2/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/genindex-1.html,2,['optimiz'],['optimize']
Performance,"metry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct10; The multiple guesses for DCT amplitudes for ODC-12. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. mom-h2o-4; MOM excitation from LUMO HOMO+4. fci-h2o; 6-31G H2O Test FCI Energy Point. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. frac-ip-fitting; Omega optimization for LRC functional wB97 on water. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. fsapt-ext-abc-au; analog of fsapt-ext-abc with molecule and external potentials in Bohr. sapt-exch-ind30-inf; SAPT2+3 with S^inf exch-ind30 Geometries taken from the S66x10 database, the shortest-range point (R = 0.7 R_e). dlpnomp2-2; comparison of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. stability3; Test LDA stability analysis against QChem. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:40539,perform,performs,40539,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"metry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR)¶CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR)¶CFOUR — Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD (CFOUR)¶CFOUR — Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are marked to be optimized). Type: string; Possible Values: NR, RFA, TS, MANR, SINGLE_POINT, ENERONLY; Default: SINGLE_POINT. CFOUR_GIAO (CFOUR)¶CFOUR — Specifies whether gauge-including atomic o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:49027,optimiz,optimization,49027,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['optimiz'],['optimization']
Performance,"metry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. dcft8; DCFT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. fci-h2o; 6-31G H2O Test FCI Energy Point. opt2-fd; SCF DZ allene geometry optimzation, with Cartesian input. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. fnocc4; Test FNO-DF-CCSD(T) energy. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. dcft5; DC-06 calculation for the O2 molecule (triplet ground state). This performs geometry optimization using two-step and simultaneous solution of the response equations for the analytic gradient. stability2; ROHF stability analysis check for CN with cc-pVDZ. This test corresponds to the rohf-stab test from Psi3. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). scf2; RI-SCF cc-pVTZ energy of water, with Z-matrix input and cc-pVTZ-RI auxilliary basis. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cbs-xtpl-wrapper; RHF aug-cc-pVQZ energy for the BH molecule, with Cartesian input. Various gradients for a strained helium d",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:3078,optimiz,optimization,3078,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"mintsMolecule method. O. OCC_ORBS_PRINT (OCC). OCC_TOLERANCE (FNOCC). (SAPT). OCEPA; . setting keywords. theory. OCEPA(0)CORRELATIONENERGY. OCEPA(0)TOTALENERGY. OEI_A_FILE (TRANSQT). OEI_B_FILE (TRANSQT). OEI_FILE (TRANSQT). OEProp. theory. oeprop() in module util. OFFDIAGONAL_CCSD_T (PSIMRCC). OMEGA (CCRESPONSE). (CCSORT). (RESPONSE). OMEGA_ERF (MINTS). OMP2; . setting keywords. theory. OMP2.5; . setting keywords. OMP2CORRELATIONENERGY. OMP2TOTALENERGY. OMP3; . setting keywords. theory. OMP3CORRELATIONENERGY. OMP3TOTALENERGY. OMP_N_THREAD (CPHF). OMP_NESTED, [1]. OMP_NUM_THREADS, [1], [2], [3], [4]. ONE-ELECTRONENERGY. ONEPDM (CCDENSITY). (DFMP2). ONEPDM_GRID_CUTOFF (CCDENSITY). ONEPDM_GRID_DUMP (CCDENSITY). ONEPDM_GRID_STEPSIZE (CCDENSITY). ONEPOT_GRID_READ (SCF). OPDM (DETCI). OPDM_AVG (DETCI). OPDM_IN_FILE (TRANSQT). OPDM_KE (DETCI). OPDM_OUT_FILE (TRANSQT). OPDM_PRINT (DETCI). OPDM_RELAX (CCDENSITY). (DFMP2). opt(); . see optimize(); . OPT_METHOD (OCC). OPT_TYPE (OPTKING). optimization; . see geometry optimization; . optimize(); . setting keywords. optimize() in module driver. OptionsState class in optproc. OptionState class in optproc. optproc module. ORB_OPT (OCC). ORB_RESP_SOLVER (OCC). Orbital-Optimized Methods; . theory. Orbital-Optimized Methods, OCEPA. Orbital-Optimized Methods, OMP2. Orbital-Optimized Methods, OMP2.5. Orbital-Optimized Methods, OMP3. orientation_fixed() LibmintsMolecule method. ORTH_TYPE (OCC). output; . SAPT. cbs(). database(). geometry optimization. P. P (THERMO). PAIR_ENERGIES_PRINT (CCENERGY). PARALLEL (SCF). parallel operation. parse_arbitrary_order() in module driver. parse_cotton_irreps() in module driver. parse_multiline_array() in module input. PATH, [1], [2], [3], [4]. PB_LAMBDA (DFTSAPT). PCG_BETA_TYPE (OCC). PCG_CONVERGENCE (OCC). PCG_MAXITER (OCC). PEP1. perp_unit() in module qcdb.vecutil. PERTURB_CBS (PSIMRCC). PERTURB_CBS_COUPLING (PSIMRCC). PERTURB_H (SCF). PERTURB_MAGNITUDE (DETCI). (SCF). PERTURB_WITH (SCF). PHI_POINTS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/genindex.html:31291,optimiz,optimization,31291,psi4manual/4.0b4/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/genindex.html,1,['optimiz'],['optimization']
Performance,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:. set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:5575,optimiz,optimize,5575,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,5,['optimiz'],['optimize']
Performance,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the file “intco.dat”. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragme",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/optking-1.html:5329,optimiz,optimize,5329,psi4manual/4.0b2/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/optking-1.html,4,['optimiz'],['optimize']
Performance,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:5535,optimiz,optimize,5535,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['optimiz'],['optimize']
Performance,"mit 0.1; intrafrag_step_limit_min 0.1; intrafrag_step_limit_max 0.1; }. optimize('scf'). Optimize while calculating the Hessian at every step:; set full_hess_every 1; optimize('scf'). Hessian¶; If Cartesian second derivatives are available, optking can read them; and transform them into internal coordinates to make an initial Hessian in; internal coordinates. Otherwise, several empirical Hessians are available,; including those of Schlegel [Schlegel:1984:333] and Fischer and Almlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States, Reaction Paths, and Constrained Optimizations¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2; freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesia",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/optking-1.html:5587,optimiz,optimize,5587,psi4manual/1.0.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/optking-1.html,2,['optimiz'],['optimize']
Performance,"mixed double derivatives with; respect to both center A and B. The old code only provided the double; derivative with respect to center A, leaving the caller to determine the other; values. The Libint2 engine instead provides all integrals, so the caller; simply needs to loop over all of the buffers provided in the appropriate order. Changes to External Potential Engines¶; Benchmarking showed that early versions of the old code spent a non-negligible; amount of time performing the Cartesian to spherical harmonic transformation of; the integrals, which is needed for most modern basis sets. To improve; performance, we instead backtransformed the density to the Cartesian; representation (denoted “CartAO”) and computed / contracted all integrals in; this Cartesian basis, eliminating the need to transform to spherical harmonics; as the integrals are computed. This bottleneck no longer exists, so these; extra transformation steps have been removed as part of the switch to Libint2,; and the affected codes (PCM and CPPE interfaces) now compute the potential and; field integrals in the representation required by the basis set.; Also, note that the way external point charges are specified has changed.; Previously, a set of N external point charges would be specified by passing a; matrix with dimensions N rows and 4 columns – corresponding to charge, x, y, z; – to the set_charge_field() member of the potential integral class. The; same information is now passed using the more verbose; std::vector<std::pair<double, std::array<double, 3>>> type instead, to be; consistent with Libint2’s convention. New Operators Available¶; Libint2 provides a range of integrals that were previously not available in; PSI4, such as the Erfc attenuated nuclear potential integrals needed for; Ewald methods. If new integrals are added to Libint2 but are not yet; interfaced to PSI4, please open an issue on the PSI4 GitHub page to; alert the developers, who will be able to add the appropriate code.; Avai",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/prog_integrals.html:15414,bottleneck,bottleneck,15414,psi4manual/1.6.x/prog_integrals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/prog_integrals.html,5,['bottleneck'],['bottleneck']
Performance,"mize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Generate the internal coordinates and then stop:; set intcos_generate_exit true; optimize('scf'). The coordinates may then be found in the “intco” file. In this case, the file contains:; F 1 3; R 1 2; R 1 3; B 2 1 3. The first line indicates a fragment containing atoms 1-3. The following lines define; two distance coordinates (bonds) and one bend coordinate. This file can be modified, and if present,; is used in subsequent optimizations. Since the multiple-fragment coordinates are still under; development, they are not documented here. However, if desired, one can change the value; of FRAG_MODE, generate the internal coordinates, and see how multiple; fragment systems are defined.; Coordinates may be frozen or fixed by adding an asterisk after the letter of the coordinate.; To optimize with the bond lengths fixed at their initial values, it is currently necessary to; generate and then modify the internal coordinate definitions as follows:; F 1 3; R* 1 2; R* 1 3; B 2 1 3. Convergence Criteria¶; Optking monitors five quantities to evaluate the progress of a geometry; optimization. These are (with their keywords) the change in energy; (MAX_ENERGY_G_CONVERGENCE), the maximum element of; the gradient (MAX_FORCE_G_CONVERGENCE), the root-mean-square; of the gradient (RMS_FORCE_G_CONVERGENCE), the maximum element; of displacement (MAX_DISP_G_CONVERGENCE), and the; root-mean-square of di",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/optking-1.html:6566,optimiz,optimizations,6566,psi4manual/4.0b4/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/optking-1.html,4,['optimiz'],['optimizations']
Performance,"mize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; ranged_distance = (""; 1 3 0.949 0.95; 2 4 0.949 0.95; ""); }. Note; The effect of the frozen and ranged keywords is generally independent of; how the geometry of the molecule was input (whether Z-matrix or Cartesian, etc.)..; At this time; however, enforcing Cartesian constraints when using a zmatrix for; molecular input is not supported. Freezing or constraining Cartesian coordinates; requires Cartesian molecule input. If numerical errors results in symmetry; breaking, while Cartesian constraints are active, symmetrization cannot occur and; an error will be raised, prompting you to restart the job. As a shortcut, the entire set of dihedral angles can be frozen. A subset can then be unfrozen if desired. set {; freeze_all_dihedrals true; unfreeze_dihedrals ""1 2 3 4""; }. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/optking.html:6444,optimiz,optimize,6444,psi4manual/master/optking.html,https://psicode.org,https://psicode.org/psi4manual/master/optking.html,1,['optimiz'],['optimize']
Performance,"mize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; ranged_distance = (""; 1 3 0.949 0.95; 2 4 0.949 0.95; ""); }. Note; The effect of the frozen and ranged keywords is generally independent of; how the geometry of the molecule was input (whether Z-matrix or Cartesian, etc.)..; At this time; however, enforcing Cartesian constraints when using a zmatrix for; molecular input is not supported. Freezing or constraining Cartesian coordinates; requires Cartesian molecule input. If numerical errors results in symmetry; breaking, while Cartesian constraints are active, symmetrization cannot occur and; an error will be raised, prompting you to restart the job. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH. molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pv",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:6222,optimiz,optimize,6222,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimize']
Performance,"mizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57054,optimiz,optimizer,57054,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['optimiz'],['optimizer']
Performance,"mlof; [Fischer:1992:9770].; Either of these or a simple diagonal Hessian may be selected using the; INTRAFRAG_HESS keyword.; All the common Hessian update schemes are available. For formulas, see; Schlegel [Schlegel:1987:AIMQC] and Bofill [Bofill:1994:1].; The Hessian may be computed during an optimization using the; FULL_HESS_EVERY keyword. Transition States and Reaction Paths¶. Calculate a starting Hessian and optimize the “transition state” of; linear water (note that without a reasonable starting geometry and; Hessian, such a straightforward search often fails):; molecule h2o {; O; H 1 1.0; H 1 1.0 2 160.0; }. set {; basis dz; full_hess_every 0; opt_type ts; }. optimize('scf'). At a transition state (planar HOOH), compute the second derivative, and; then follow the intrinsic reaction path to the minimum:; molecule hooh {; symmetry c1; H; O 1 0.946347; O 2 1.397780 1 107.243777; H 3 0.946347 2 107.243777 1 0.0; }. set {; basis dzp; opt_type irc; geom_maxiter 50; }. frequencies('scf'); optimize('scf'). Constrained Optimizations¶. Optimize a geometry (HOOH) at a frozen dihedral angle of 90 degrees.; molecule {; H; O 1 0.90; O 2 1.40 1 100.0; H 3 0.90 2 100.0 1 90.0; }. set optking {; frozen_dihedral = (""; 1 2 3 4; ""); }; optimize('scf'). To instead freeze the two O-H bond distances; set optking {; frozen_distance = (""; 1 2; 3 4; ""); }. For bends, the corresponding keyword is “frozen_bend”. To freeze the cartesian coordinates of atom 2. freeze_list = """"""; 2 xyz; """"""; set optking frozen_cartesian $freeze_list. To freeze only the y coordinates of atoms 2 and 3. freeze_list = """"""; 2 y; 3 y; """"""; set optking frozen_cartesian $freeze_list. To optimize toward a value of 0.95 Angstroms for the distance between; atoms 1 and 3, as well as that between 2 and 4. set optking {; ranged_distance = (""; 1 3 0.949 0.95; 2 4 0.949 0.95; ""); }. Note; The effect of the frozen and ranged keywords is generally independent of; how the geometry of the molecule was input (whether Z-matrix or",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/optking.html:5559,optimiz,optimize,5559,psi4manual/1.7.x/optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/optking.html,3,['optimiz'],['optimize']
Performance,"mobj:; # print('matched dft-d2'); # psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); # psivar['DISPERSION CORRECTION ENERGY'] = mobj.group(2); # psivar['DFT TOTAL ENERGY'] = mobj.group(3); # psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(3) - mboj.group(2). # Process DFT-D3 UNTESTED; # mobj = re.search(; # r'(?:grimme3)' + r'\s*' +; # r'(?:.*?)' +; # r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; # r'(?:.*?)' +; # r'(?:HF-DFT SCF calculation)' +; # r'(?:.*?)' +; # r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*$',; # outtext, re.MULTILINE | re.DOTALL); # if mobj:; # print('matched dft-d3'); # psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); # psivar['DISPERSION CORRECTION ENERGY'] = None; # psivar['DFT TOTAL ENERGY'] = mobj.group(2); # psivar['DFT FUNCTIONAL TOTAL ENERGY'] = None. # /^((?!PART).)*$/. # Process DFT no-D or internal-D; mobj = re.search(; # r'((?!grimme3).)*' + r'\s*' + # severe negative performance impact; # r'(?:.*?)' +; r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; r'(?:.*?)' +; r'(?:HF-DFT SCF calculation)' +; r'(?:.*?)' +; r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergence criterion met' + r'\s*$',; outtext, re.MULTILINE | re.DOTALL | re.IGNORECASE); if mobj:; print('matched dft'); psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(1); #psivar['DFT TOTAL ENERGY'] = mobj.group(2); psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(2); # with negative lookahead; #psivar['NUCLEAR REPULSION ENERGY'] = mobj.group(2); #psivar['DFT TOTAL ENERGY'] = mobj.group(3); #psivar['DFT FUNCTIONAL TOTAL ENERGY'] = mobj.group(3). # Process DHDFT no-D or internal-D; mobj = re.search(; # negative grimme3 lookahead goes here; #r'^\s+' + r'(?:Nuclear Repulsion Energy =)' + r'\s+' + NUMBER + r'\s+hartrees\s*' +; #r'(?:.*?)' +; r'(?:HF-DFT SCF calculation)' +; r'(?:.*?)' +; #r'^\s+\d+\s+' + NUMBER + r'\s+' + NUMBER + r'\s+' + 'Convergenc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html:3643,perform,performance,3643,psi4manual/1.0.0/_modules/qcdb/qchem.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/qchem.html,1,['perform'],['performance']
Performance,"modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Test Suite and Sample Inputs. Input File; Description. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. nbody-vmfc-gradient; Computation of VMFC-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. dfmp2-freq1; DF-MP2 frequency by difference of energies for H2O. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:1041,optimiz,optimization,1041,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,2,['optimiz'],['optimization']
Performance,"module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. mrcc3; CCSD(T) cc-pVDZ geometry optimization for the H2O molecule using MRCC. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. cc51; EOM-CC3/cc-pVTZ on H2O. fci-h2o-2; 6-31G H2O Test FCI Energy Point. cc31; CCSD/sto-3g optical rotation calculation (both gauges) at two frequencies on methyloxirane. psimrcc-ccsd_t-1; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. cc11; Frozen-core CCSD(ROHF)/cc-pVDZ on CN radical with disk-based AO algorithm. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. cc33; CC3(UHF)/cc-pVDZ H2O geom from Olsen et al., JCP 104, 8007 (1996). dft-grad; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN. tu6-cp-ne2; Example potential energy surface scan and CP-correction for Ne2. cc30; CCSD/sto-3g optical rotation calculation",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html:14215,optimiz,optimization,14215,psi4manual/4.0b3/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_testsuite-1.html,4,['optimiz'],['optimization']
Performance,"molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to frequency().""""""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); frequ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:47632,Perform,Perform,47632,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Perform'],['Perform']
Performance,"molecule. dft-pruning; Tests all grid pruning options available and screening of small weights. Check against grid size. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. dft-smoke; DFT Functional Smoke Test. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. fsapt-d; Tests SAPT0-D corrections, with a variety of damping functions/parameters. mbis-4; MBIS calculation on NaCl. lccd-grad1; LCCD cc-pVDZ gradient for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). nbody-multi-level; Multilevel computation of water trimer energy (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct10; The multiple guesses for DCT amplitudes for ODC-12. nbody-vmfc-hessian; Computation of VMFC-corrected water trimer Hessian (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. scf-hess3; CONV SCF 6-31G analytical vs finite-difference tests Tests UHF hessian code for Ca != Cb. mom-h2o-4; MOM excitation from LUMO HOMO+4. fci-h2o; 6-31G H2O Test FCI Energy Point. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cbs-xtpl-energy-conv; Extrapolated water energies - conventional integrals version. cc10; ROHF-C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html:39876,perform,performs,39876,psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (O",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:23352,Optimiz,Optimize,23352,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:25821,Optimiz,Optimize,25821,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"molecules. [5]; (1,2); a-CCSD(T) also known as CCSD(aT), Lambda-CCSD(T), and CCSD(T)_L. Basic Keywords¶; A complete list of keywords related to coupled-cluster computations is; provided in the appendices, with the majority of the relevant; keywords appearing in Appendix CCENERGY. For a standard ground-state; CCSD or CCSD(T) computation, the following keywords are common:. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. MAXITER¶. Maximum number of iterations to solve the CC equations. Type: integer; Default: 50. BRUECKNER_ORBS_R_CONVERGENCE¶. Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. RESTART¶. Do restart the coupled-cluster iterations from old \(t_1\) and \(t_2\) amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. CACHELEVEL¶. Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHETYPE¶. Selects the priority type for maintaining the automatic memory cache used by the libdpd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/cc.html:7151,optimiz,optimizations,7151,psi4manual/1.8.x/cc.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/cc.html,3,['optimiz'],['optimizations']
Performance,"mong recognized ({valid_kinds})""). # Validate output units; out_units = out_units.lower(); valid_out_units = [""au"", ""eh"", ""ev"", ""nm"", ""thz""]; if out_units not in valid_out_units:; raise ValueError(f""Output units {out_units} not among recognized ({valid_out_units})""). c = constants.get(""speed of light in vacuum""); c_nm = c * constants.conversion_factor(""m"", ""nm""); hbar = constants.get(""Planck constant over 2 pi""); h = constants.get(""Planck constant""); Eh = constants.get(""Hartree energy""); au_to_nm = 2.0 * np.pi * c_nm * hbar / Eh; au_to_THz = (Eh / h) * constants.conversion_factor(""Hz"", ""THz""); au_to_eV = constants.get(""Hartree energy in eV""). converters = {; ""au"": lambda x: x, # Angular frequency in atomic units; ""eh"": lambda x: x, # Energy in atomic units; ""ev"": lambda x: x * au_to_eV, # Energy in electronvolts; ""nm"": lambda x: au_to_nm / x, # Wavelength in nanometers; ""thz"": lambda x: x * au_to_THz, # Frequency in terahertz; }. # Perform conversion of poles from au of angular frequency to output units; poles = converters[out_units](poles). # Broadening functions; gammas = {; ""au"": lambda x_0: gamma, # Angular frequency in atomic units; ""eh"": lambda x_0: gamma, # Energy in atomic units; ""ev"": lambda x_0: gamma * au_to_eV, # Energy in electronvolts; ""nm"": lambda x_0: ((x_0**2 * gamma * (Eh / hbar)) / (2 * np.pi * c_nm)), # Wavelength in nanometers; ""thz"": lambda x_0: gamma * au_to_THz, # Frequency in terahertz; }. # Generate x axis; # Add a fifth of the range on each side; expand_side = (np.max(poles) - np.min(poles)) / 5; x = np.linspace(np.min(poles) - expand_side, np.max(poles) + expand_side, npoints). # Validate lineshape; lineshape = lineshape.lower(); valid_lineshapes = [""gaussian"", ""lorentzian""]; if lineshape not in valid_lineshapes:; raise ValueError(f""Lineshape {lineshape} not among recognized ({valid_lineshapes})""). # Obtain lineshape function; shape = Gaussian(x, gammas[out_units]) if lineshape == ""gaussian"" else Lorentzian(x, gammas[out_units]). # Genera",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html:11366,Perform,Perform,11366,psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/spectrum.html,4,['Perform'],['Perform']
Performance,"mory.; if filename is None and not v.flags['OWNDATA']:; v = np.copy(v); ret[prefix + ""IrrepData"" + str(h)] = v. if isinstance(self, core.Matrix):; ret[prefix + ""Dim1""] = self.rowdim().to_tuple(); ret[prefix + ""Dim2""] = self.coldim().to_tuple(); if isinstance(self, core.Vector):; ret[prefix + ""Dim""] = [self.dim(x) for x in range(self.nirrep())]. if filename is None:; return ret. np.savez(filename, **ret). def _np_read(; self: Union[core.Matrix, core.Vector],; filename: str,; prefix: str = """",; ) -> Union[core.Matrix, core.Vector]:; """"""Reads the data from a NumPy compressed or uncompressed file using :func:`numpy.load`. Parameters; ----------; self; Pointer to which class to be constructed.; filename; File name to read.; prefix; Name under which array was saved for NumPy.; """""". if isinstance(filename, np.lib.npyio.NpzFile):; data = filename; elif isinstance(filename, str):; if not filename.endswith('.npz'):; filename = filename + '.npz'. data = np.load(filename); else:; raise Exception(""Filename not understood: %s"" % filename). ret_data = []. if ((prefix + ""Irreps"") not in data.keys()) or ((prefix + ""Name"") not in data.keys()):; raise ValidationError(""File %s does not appear to be a numpyz save"" % filename). for h in range(data[prefix + ""Irreps""]):; ret_data.append(data[prefix + ""IrrepData"" + str(h)]). arr_type = self.__mro__[0]; if arr_type == core.Matrix:; dim1 = core.Dimension.from_list(data[prefix + ""Dim1""]); dim2 = core.Dimension.from_list(data[prefix + ""Dim2""]); ret = self(str(data[prefix + ""Name""]), dim1, dim2); elif arr_type == core.Vector:; dim1 = core.Dimension.from_list(data[prefix + ""Dim""]); ret = self(str(data[prefix + ""Name""]), dim1). for h in range(data[prefix + ""Irreps""]):; ret.nph[h][:] = ret_data[h]. return ret. def _to_serial(self: Union[core.Matrix, core.Vector]) -> Dict[str, Any]:; """"""; Converts an object with a ``.nph`` accessor to a serialized dictionary. Parameters; ----------; self; Matrix or Vector instance. Returns; -------; ~typing.Dict[str,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html:10985,load,load,10985,psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/p4util/numpy_helper.html,4,['load'],['load']
Performance,"mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; cbs. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:14574,optimiz,optimize,14574,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,8,['optimiz'],['optimize']
Performance,"mp2 correlation energy atop a T-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy(cbs, corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; cbs. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.cbs-1.html:14574,optimiz,optimize,14574,psi4manual/1.5.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.cbs-1.html,8,['optimiz'],['optimize']
Performance,"mp2', 'mp2.5', 'mp3', 'lccd', 'ccd', 'ccsd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2', 'omp2.5', 'omp3', 'olccd']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_global_option('DERTYPE', 'FIRST'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; psi4.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if psi4.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'OEPROP', 'TRUE'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:38945,optimiz,optimized,38945,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['optimiz'],['optimized']
Performance,"mp3] , [Bozkaya:2013:omp3], [Bozkaya:2013:omp3grad], [Bozkaya:2016:dfomp3], and [Bozkaya:2018:dfomp3grad]; MP2.5 [Bozkaya:2011:omp3], [Bozkaya:2016:dfomp3], and [Bozkaya:2018:dfomp3grad]; REMP [Behnle:2019:REMP], [Behnle:2022:OREMP]; LCCD [Bozkaya:2013:ocepa] and [Bozkaya:2016:dfolccd]; CCD [Bozkaya:2020:dfoccd]; CCSD [Bozkaya:2016:dfccsdgrad]; CCSD(T) [Bozkaya:2017:dfccsdtgrad]; CCSD(AT) [Bozkaya:2016:dfccsdat]. Non-OO theoretical methods accessible through OCC/DFOCC¶. name; calls method; plain; FNO. mp2; second-order MP perturbation theory; E/G; n/a. mp2.5; average of MP2 and MP3; E/G. mp3; third-order MP perturbation theory; E/G. remp2; second-order retaining-the-excitation-degree MP hybrid PT; E. lccd; linear coupled cluster doubles; E/G. ccd; coupled cluster doubles; E/G. ccsd; coupled cluster singles and doubles; E/G. ccsd(t); coupled cluster singles and doubles with perturbative triples; E/G. a-ccsd(t); CCSD with asymmetric perturbative triples; E. Detailed non-orbital-optimized capabilities of the OCC module. “✓” runs analytically. Single underline “✓̲” is default module when QC_MODULE unspecified. Double underline “✓̳” is default algorithm type when type selector (e.g., CC_TYPE) unspecified.¶. ◻; ◻; name ↓ →; ◻; ◻. ◻; REFERENCE →; ◻; type[5] ↓ →; FREEZE_CORE[6]→. QC_MODULE=OCC Capabilities. Restricted (RHF); Unrestricted (UHF); Restricted Open (ROHF). energy(); gradient()[7]; energy(); gradient()[7]; energy(); gradient()[7]. CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD; CV; DF; CD. A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F; A; F. mp2; MP2_TYPE; ✓̲; ✓̲; ✓; ✓; ✓̲; ✓̲; ✓̲. ✓; ✓. ✓̲; ✓̲; ✓; ✓; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓; ✓; ✓̲; ✓̲. mp2.5; MP_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. mp3; MP_TYPE; ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. ✓̲; ✓̲; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳. remp2; CC_TYPE; ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. ✓̳; ✓̳; ✓̲; ✓̲; ✓̲; ✓̲. lccd; CC_TYPE; ✓; ✓; ✓",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:19763,optimiz,optimized,19763,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,4,['optimiz'],['optimized']
Performance,"mpare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print ""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print ""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print ""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep()); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print ""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry()); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmetry(); for irrep in range(nirreps):; if(expected.rows(irrep) != computed.rows(irrep)):; print ""\t%s has %d rows in irrep %d, but %s has %d\n."" % (expected.name(), expected.rows(irrep), irrep, computed.name(), computed.rows(irrep)); sys.exit(1); if(expected.cols(irrep ^ symmetry) != computed.cols(irrep ^ symmetry)):; print ""\t%s has %d columns in irrep, but %s has %d\n."" % (expected.name(), expected.cols(irrep), irrep, computed.name(), computed.cols(irrep)); sys.exit(1); rows = ex",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/util.html:2458,Perform,Performs,2458,psi4manual/4.0b2/_modules/util.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/util.html,1,['Perform'],['Performs']
Performance,"mpare_integers; from psi4 import core; from .exceptions import ValidationError. __all__ = ['fchkfile_to_string','compare_fchkfiles', ""compare_moldenfiles""]. def _consume_fchk_section(input_list, index):; """"""compare a float or integer matrix section"""""". n = int(input_list[index].split()[-1]); kind = input_list[index].split()[-3]. if ""R"" in kind:; dtype = np.float64; format_counter = 5; elif ""I"" in kind:; dtype = np.float64; format_counter = 6; else:; raise ValidationError('Unknow field type in FCHK reader\n'). extra = 0 if n <= format_counter else n % format_counter; lines = 1 if n <= format_counter else int(n / format_counter); offset = lines + 1 if extra > 0 else lines; string = ''; for j in range(lines):; string += """".join(str(x) for x in input_list[index + 1 + j]); if extra > 0:; string += """".join(str(x) for x in input_list[index + 1 + lines]); field = np.fromiter(string.split(), dtype=dtype); return offset + 1, field. [docs]def fchkfile_to_string(fname):; """""" Load FCHK file into a string""""""; with open(fname, 'r') as handle:; fchk_string = handle.read(); return fchk_string. [docs]def compare_fchkfiles(expected, computed, atol_exponent, label):; """"""Comparison function for output data in FCHK (formatted checkpoint) file format.; Compares many fields including number of electrons, highest angular momentum, basis; set exponents, densities, final gradient. Note only Psi4-style signature (``(expected, computed, atol_exponent, label)``) available. An older format description can be found here; http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; It lists more fields (logical, character) that are not included in this; test function. They should be covered by the string comparison.; This function is only meant to work with PSI4's FCHK files. Parameters; ----------; expected : file; Reference FCHK file against which `computed` is compared.; computed : file; Input FCHK file to compare against `expected`.; atol_exponent : int or float; Absolute tolerance for h",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html:2256,Load,Load,2256,psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/p4util/fchk.html,1,['Load'],['Load']
Performance,"mple, (1, 2)@(1, 2, 3, 4) indicates that the; fragments 1 and 2 are explicitly included in the energy computation,; with basis functions from each of fragments 1, 2, 3, & 4 included in; the basis set. Therefore, the basis functions from fragments 3 and 4; are included as ghost functions within the energy computation. NUCLEAR REPULSION ENERGY¶; The nuclear repulsion energy contribution [Eh] to the total SCF energy.; Quantity \(E_{NN}\) in Eq. (4). (3)¶\[E_{NN} = \sum_{i, j<i}^{N_{atom}}\frac{Z_i Z_j}{|\mathbf{R}_i - \mathbf{R}_j|}\]. OCEPA(0) TOTAL ENERGY¶. OCEPA(0) CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized CEPA(0) level of theory. OLCCD TOTAL ENERGY¶. OLCCD CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OLCCD REFERENCE CORRECTION ENERGY¶; The additional correction to the SCF reference energy [Eh]; for the orbital-optimized linearized coupled cluster doubles level of theory. OMP2 TOTAL ENERGY¶. OMP2 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2 level of theory. OMP2.5 TOTAL ENERGY¶. OMP2.5 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP2.5 level of theory. OMP3 TOTAL ENERGY¶. OMP3 CORRELATION ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the orbital-optimized MP3 level of theory. ONE-ELECTRON ENERGY¶; The one-electron energy contribution [Eh] to the total SCF energy.; Quantity \(E_{1e^-}\) in Eq. (4). PCM POLARIZATION ENERGY¶; The energy contribution [Eh] from the polarizable continuum model for solvation. PE ENERGY¶; The energy contribution [Eh] from the polarizable embedding model for solvation. QCISD TOTAL ENERGY¶. QCISD CORRELATION ENERGY¶; The total electronic energy [Eh] and co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:33537,optimiz,optimized,33537,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,5,['optimiz'],['optimized']
Performance,"mples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, first we must set up an input; using the OPTIMIZED GEOMETRY. We can easily get the optimized geometry; from the previous computation. Looking at",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/tutorial-1.html:5119,optimiz,optimizer,5119,psi4manual/4.0b4/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/tutorial-1.html,4,['optimiz'],['optimizer']
Performance,"mples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. memory 250 mb. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.027022668419 -0.000389933562 0.00178749 0.00142923 0.01007985 0.00594840 ~; 3 -76.027032729361 -0.000010060942 0.00014016 0.00008485 0.00077279 0.00044621 ~; --------------------------------------------------------------------------------------------------------------- ~. To get harmonic vibrational frequencies, it’s important to keep in mind that; the values of the vibrational frequencies are a function of the molecular; geometry. Therefore, it’s import",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:5769,optimiz,optimizer,5769,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['optimiz'],['optimizer']
Performance,"mples.; The equivalent Python PsiAPI syntax is shown alongside the Psithon code snippets.; When using the Python API, one must import the PSI4 module with:; import psi4. No such directive is neccesary when using Psithon, which is run using the psi4; executable. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; # all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:1810,load,loaded,1810,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['load'],['loaded']
Performance,"mplete-basis-set extrapolation (and; automatically sets up the computations with different basis sets required to; do the extrapolation). For example,:; # all equivalent. energy('mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). energy('mp2/cc-pv[dt]z'). will compute a 2-point Helgaker extrapolation of the correlation energy; using the cc-pVDZ and cc-pVTZ basis sets (with method MP2) and add this; extrapolated correlation energy to the Hartree–Fock energy in the; largest basis (cc-pVTZ). cbs() can; be configured behind-the-scenes with explicit arguments, as in the; first example, or the convenience syntax of the equivalent second; example can be used.; Another very useful and powerful feature of PSI4 is the ability; to compute results on entire databases of molecules at a time,; as provided by the database() wrapper. For example,:; database('mp2', 'S22', cp=1, benchmark='S22B'). will perform DF-MP2 counterpoise-corrected interaction energies; (cp=1) on all members of Hobza’s S22 database set of van der Waals; dimers, and then compare the results against the S22B benchmark energies.; Built-in databases include S22, A24, HTBH, HBC6, HSG, S22by5, S66, JSCH,; NCB31, S66by8, and NBC10, among others.; These wrapper functions are discussed separately in; Psithon Functions: Invoking a Calculation. Note that the options documented for Python; functions are placed as arguments in the command that calls the function,; not in the set {...} block or with any other set command. table of contents. Psithon: Structuring an Input File; Physical Constants; Memory Specification; Molecule and Geometry Specification; Job Control Keywords; Basis Sets; PSI Variables; Return Values; Loops; Tables of Results; Python Wrappers. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Psithon: Structuring an Input File. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/psithoninput.html:14684,perform,perform,14684,psi4manual/1.6.x/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/psithoninput.html,1,['perform'],['perform']
Performance,"mplitudes. The DIRECT option means compute amplitudes on the fly * whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradient method. If this keyword is not set by the user, DFOCC will estimate and use a value required to achieve R_CONVERGENCE residual converge",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html:4393,optimiz,optimize,4393,psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__dfocc-1.html,18,['optimiz'],['optimize']
Performance,"mplitudes. The DIRECT option means compute amplitudes on the fly * whenever they are necessary. Type: string; Possible Values: DIRECT, CONV; Default: DIRECT. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0. MP2_SOS_SCALE¶. MP2 Spin-opposite scaling (SOS) value. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OO_SCALE¶. OO scaling factor used in MSD. Type: double; Default: 0.01. OPT_METHOD¶. The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. ORB_RESP_SOLVER¶. The algorithm will be used for solving the orbital-response equations. The LINEQ option create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradient method. Type: conv double; Default: 1e-6. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html:4194,optimiz,optimize,4194,psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,2,['optimiz'],['optimize']
Performance,"mploying CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; 1; 2; 3energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; 1; 2; 3; 4; 5; 6energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE or 1 will default to freezing the previous noble gas shell on each atom. In case of positive charges on fragments, an additional shell may be unfrozen, to ensure there are valence electrons in each fragment. With FALSE or 0, no electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this cas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/sapt-1.html:20820,optimiz,optimized,20820,psi4manual/1.3.2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/sapt-1.html,2,['optimiz'],['optimized']
Performance,"mploying CCD dispersion should cite [Parrish:2013:174102].; To request CCD dispersion treatment in a SAPT computation, simply append; (ccd) to the name of the method, as in the following examples; 1; 2; 3energy('sapt2+(ccd)'); energy('sapt2+(3)(ccd)'); energy('sapt2+3(ccd)'). The \(\delta_{MP2}\) corrections can also be computed automatically; by appending dmp2 to the name of the method, with or without CCD dispersion; 1; 2; 3; 4; 5; 6energy('sapt2+dmp2'); energy('sapt2+(3)dmp2'); energy('sapt2+3dmp2'); energy('sapt2+(ccd)dmp2'); energy('sapt2+(3)(ccd)dmp2'); energy('sapt2+3(ccd)dmp2'). A brief note on memory usage: the higher-order SAPT code assumes that; certain quantities can be held in core. This code requires sufficient; memory to hold \(3o^2v^2+v^2N_{aux}\) arrays in core. With this; requirement computations on the adenine-thymine complex can be performed; with an aug-cc-pVTZ basis in less than 64GB of memory.; Higher-order SAPT is treated separately from the highly optimized SAPT0; code, therefore, higher-order SAPT uses a separate set of keywords.; The following keywords are relevant for higher-order SAPT. Basic Keywords for Higher-order SAPT¶. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. FREEZE_CORE¶. Specifies how many core orbitals to freeze in correlated computations. TRUE will default to freezing the standard default number of core orbitals. For PSI, the standard number of core orbitals is the number of orbitals in the nearest previous noble gas atom. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze pe",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:20484,optimiz,optimized,20484,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,4,['optimiz'],['optimized']
Performance,"mponent-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OMP3); OMP3 — Do perform spin-component-scaled OMP3 (SCS-OMP3)? In all computation, SCS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP3, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OMP2); OMP2 — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OMP3); OMP3 — Do perform spin-opposite-scaled OMP3 (SOS-OMP3)? In all computation, SOS-OMP3 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP3, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CIS); CIS — Do print the domains?. Type: boolean; Default: false. DOMAIN_PRINT_EXIT (LMP2); LMP2 — Do exit after printing the domains?. Type: boolean; Default: false. DOMAINS (CIS); CIS —. Type: array; Default: No Default. E3_SCALE (OMP3); OMP3 — Scaling value for 3rd order energy correction (S. Grimme, V",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html:34454,perform,perform,34454,psi4manual/4.0b3/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"mputations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step (in; principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ --------------------------------------------------------------------------------------------------------------- ~     1     -76.026632734908    -76.026632734908      0.01523518      0.01245755      0.02742222      0.02277530  ~     2     -76.027022666011     -0.000389931104      0.00178779      0.00142946     ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psiapi-1.html:7599,optimiz,optimizer,7599,psi4manual/1.3.2/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psiapi-1.html,9,['optimiz'],['optimizer']
Performance,"mputations to perform, such as geometry optimizations and vibrational frequency computations. These can be specified by replacing psi4.energy() API with; psi4.optimize() API or psi4.frequency() API, respectively.; Let’s take a look at an example of optimizing the H\(_2\)O molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above, when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we defined the Psi4 molecule object h2o. Since we’re still in the Python shell, as long as you executed that block of code, we can reuse the h2o molecule object in our optimization without redefining it, by adding the molecule=h2o argument to the psi4.optimize(); API function:. [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. [5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient points which way is downhill in energy, and the optimizer then modifies the geometry to follow the gradient. After a few cycles, the geometry should converge with a message like Optimization complete!. As indicated in the following table (printed by the optimizer at the end of the computation and grep-able with ~), the energy decreases with each step, and the maximum force on each atom also decreases with each step; (in principle, these numbers could increase in some iterations, but here they do not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734908 -76.026632734908 0.01523518 0.01245755 0.02742222 0.02277530 ~; 2 -76.027022666011 -0.000389931104 0.00178779 0.00142946 0.01008137 0.00594928 ~; 3 -76.027032729374 -0.000010063363 0.00014019 0.00008488 0.00077463 0.0004473",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/psiapi.html:7473,optimiz,optimizer,7473,psi4manual/1.9.x/psiapi.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/psiapi.html,2,['optimiz'],['optimizer']
Performance,"ms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Convergence_gmax:10.2e} {params.Convergence_grms:10.2e} ""; f""{params.Convergence_dmax:10.2e} {params.Convergence_drms:10.2e} ~"")); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""). core.print_out((f""\n {optimizer.Iteration:4d} {optimizer.E:16.8e} -------- ""; f""{gmax:10.2e} {conv_gmax} {grms:10.2e} {conv_grms} -------- -------- ~"")); while True:; if optimizer.state == geometric.optimize.OPT_STATE.CONVERGED:; core.print_out(""\n\n Optimization converged! ~\n""); break; elif optimizer.state == geometric.optimize.OPT_STATE.FAILED:; core.print_out(""\n\n Optimization failed to converge! ~\n""); break; optimizer.step(); optimizer.calcEnergyForce(); optimizer.evaluateStep(); grms, gmax = optimizer.calcGradNorm(); drms, dmax = geometric.optimize.calc_drms_dmax(optimizer.X, optimizer.Xprev); conv_energy = '*' if np.abs(optimizer.E - optimizer.Eprev) < params.Convergence_energy else ' '; conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; conv_dmax = '*' if dmax < params.Convergence_dmax else ' '; conv_drms = '*' if drms < params.Convergence_drms else ' '; core.print_out((f'\n {optimizer.Iteration:4d} {optimizer.E:16.8e} '; f'{optimizer.E-optimizer.Eprev:10.2e} {conv_energy} {gmax:10.2e} {conv_gmax} '; f'{grms:10.2e} {conv_grms} {dmax:10.2e} {conv_dmax} ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:57202,optimiz,optimizer,57202,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,14,['optimiz'],['optimizer']
Performance,"ms from; HDF5 file at path/dbse_project.h5 . If path not given, looks in; qcdb/data. This file is written by reap-DB and so has been largely; validated. """"""; for db, odb in self.dbdict.items():; odb.load_qcdata_hdf5_trusted(project, path=path); self._intersect_modelchems(). [docs] def load_qcdata_hrxn_byproject(self, project, path=None):; for db, odb in self.dbdict.items():; odb.load_qcdata_hrxn_byproject(project, path=path); self._intersect_modelchems(). [docs] def available_projects(self, path=None):; """"""""""""; import glob. if path is None:; path = os.path.dirname(__file__) + '/../data'. projects = []; for pjfn in glob.glob(path + '/*_hrxn_*.pickle'):; pj = pjfn[:-7].split('_')[-1]; projects.append(pj). complete_projects = []; for pj in set(projects):; if all([os.path.isfile(path + '/' + db + '_hrxn_' + pj + '.pickle') for db in self.dbdict.keys()]):; complete_projects.append(pj). return complete_projects. [docs] def load_subsets(self, modname='subsetgenerator', pythonpath=None):; """"""For each component database, loads subsets from all functions; in module *modname*. Default *modname* usues standard generators. """"""; for db, odb in self.dbdict.items():; odb.load_subsets(modname=modname, pythonpath=pythonpath); self._intersect_subsets(). [docs] def add_Subset(self, name, func):; """"""Define a new subset labeled *name* by providing a database; *func* whose keys are the keys of dbdict and whose values are a; function that filters each WrappedDatabase's *self.hrxn*. """"""; label = name.lower(); merged = []; for db, odb in self.dbdict.iteritems():; if callable(func[db]):; ssfunc = func[db]; else:; ssfunc = lambda x: func[db]; odb.add_Subset(name=name, func=ssfunc); if name in odb.sset:; merged.append(name); else:; merged.append(None); if any(merged):; self.sset[label] = merged; print(""""""Database %s: Subset %s formed: %s"""""" % (self.dbse, label, self.sset[label])); else:; print(""""""Database %s: Subset %s NOT formed: empty"""""" % (self.dbse, label)). [docs] def add_Subset_union(self,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:52536,load,loads,52536,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loads']
Performance,ms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3opatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exch,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html:3467,optimiz,optimized,3467,psi4manual/1.8.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.opt.html,5,['optimiz'],['optimized']
Performance,ms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbjatm. b3lyp-d3mzero2b. b3lyp-d3mzeroatm. b3lyp-d3zero2b. b3lyp-d3zeroatm. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlatio,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:3465,optimiz,optimized,3465,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,15,['optimiz'],['optimized']
Performance,"ms. READ becomes the default for the second and later iterations; of geometry optimizations.; SAD; Superposition of Atomic Densities. Builds the initial density as the; spin-averaged sum of atomic UHF computations in the current basis. If an; open-shell system, uniform scaling of the spin-averaged density matrices is; performed. If orbitals are needed (e.g., in density fitting), a partial; Cholesky factorization of the density matrices is used. Often extremely; accurate, particularly for closed-shell systems.; GWH; Generalized Wolfsberg-Helmholtz, a simple Huckel-Theory-like method based on; the overlap and core Hamiltonian matrices. May be useful in open-shell systems.; READ; Read the previous orbitals from a checkpoint file, casting from one basis to; another if needed. Useful for starting anion computations from neutral; orbitals, or after small geometry changes. At present, casting from a; different molecular point group is not supported. This becomes the; default for the second and later iterations of geometry optimizations. These are all set by the GUESS keyword. Also, an automatic Python; procedure has been developed for converging the SCF in a small basis, and then; casting up to the true basis. This can be done by adding; BASIS_GUESS = SMALL_BASIS to the options list. We recommend the; 3-21G basis for the small basis due to its efficient mix of flexibility and; compactness. An example of performing an RHF solution of water by SAD guessing; in a 3-21G basis and then casting up to cc-pVTZ is shown below:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvtz; basis_guess 3-21G; guess sad; }. energy('scf'). With regard to convergence stabilization, Pulay’s Direct Inversion of the; Iterative Subspace (DIIS) extrapolation, Gill’s Maximum Overlap Method (MOM),; and damping are all implemented. A summary of each is presented below,. DIIS [On by Default]; DIIS uses previous iterates of the Fock Matrix together; with an error criterion based on th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:15376,optimiz,optimizations,15376,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,6,['optimiz'],['optimizations']
Performance,"mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp2_property(name, **kwargs):; """"""Function selecting the algorithm for a MP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only dfmp2 for now. func = None; if reference == 'RHF':; if mtd_type == 'DF':; #if module == 'OCC':; # func = run_dfocc_property; if module in ['', 'DFMP2']:; func = run_dfmp2_property; #elif reference == 'UHF':; # if mtd_type == 'DF':; # if module in ['', 'OCC']:; # func = run_dfocc_property. if func is None:; raise ManagedMethodError(['select_mp2_property', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:5508,perform,performance,5508,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,3,['perform'],['performance']
Performance,"mulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. cc6; Frozen-core CCSD(T)/cc-pVDZ on C4H4N anion with disk ao algorithm. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. omp2-3; OMP2 cc-pVDZ energy for the NO radical. cc49; EOM-CC3(UHF) on CH radical with user-specified basis and properties for particular root. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). tu4-h2o-freq; Optimization followed by frequencies H2O HF/cc-pVDZ. dcft2; DC-06 calculation for the He dimer. This performs a two-step update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. x2c3; Test of SFX2C-1e on Water uncontracted cc-pVDZ The reference numbers are from Lan Cheng’s implementation in Cfour. scf11-freq-from-energies; Test frequencies by finite differences of energies for planar C4NH4 TS. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. mcscf1; ROHF 6-31G** energy of the state of CH2, with Z-matrix input. The occupations are specified explicitly. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. cc1; RHF-CCSD 6-31G** all-electron optimization of the H2O molecule. dfomp2-4; OMP2 cc-pVDZ ene",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:23426,perform,performs,23426,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"multiplicity. Psi4 Interface: Keyword set from active molecule. Type: integer; Default: 1. CFOUR_NACOUPLING (CFOUR)¶CFOUR — Calculation of non-adiabatic coupling. In case of ON (=1) the method by Ichino, Gauss, Stanton is used to obtain the lambda coupling, while in case of LVC (=3) the lambda coupling is computed by means of the algorithm by Tajti and Szalay. Furthermore, NACV (=2) requests the computation of the full non-adiabatic coupling. Note that for calculations using LVC or NACV options the multiroot diagonalization has to be used, as requested via the keyword CFOUR_EOM_NSTATES (dne?) =MULTIROOT. Type: string; Possible Values: ON, NACV, LVC; Default: OFF. CFOUR_NEGEVAL (CFOUR)¶CFOUR — Specifies what to do if negative eigenvalues are encountered in the totally symmetric Hessian during an NR or MANR geometry-optimization search. If ABORT (=0), the job will terminate with an error message; if SWITCH (=1) the program will just switch the eigenvalue to its absolute value and keep plugging away (this is strongly discouraged!); and if RFA (=2), the keyword CFOUR_GEO_METHOD is switched to RFA internally and the optimization is continued. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead. Type: string; Possible Values: ABORT, SWITCH, RFA; Default: ABORT. CFOUR_NEWNORM (CFOUR)¶CFOUR — All components of spherical AO’s are normalized to 1. This feature can help with numerical convergence issues if AO integrals are involved. Currently only working for single-point energy calculations. Type: boolean; Default: false. CFOUR_NONHF (CFOUR)¶CFOUR — Specifies whether the reference function used in the correlation energy calculation satisfies the (spin-orbital) HF equations or not. Usually there is no need to set this parameter (OFF = 0 and ON =1), since standard non-HF reference functions (QRHF and ROHF) set this flag automatically. Type: boolean; Default: false. CF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:58325,optimiz,optimization,58325,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['optimiz'],['optimization']
Performance,"must be set to NONE; (default). Evaluation of the analytic gradients requires the solution of the; coupled response equations. Two algorithms are available for their iterative; solution: two-step (default) and simultaneous. These algorithms are similar to those; described for the orbital and cumulant updates in the Iterative Algorithms; section and usually exhibit the similar efficiency. The choice of the algorithm can; be made using the RESPONSE_ALGORITHM option. For the DC-12 method the; analytic gradients are not yet available, one has to use numerical gradients to; perform the geometry optimizations. Minimal Input¶; Minimal input for the DCFT single-point computation looks like this:; molecule {; H; H 1 1.0; }. set basis 3-21G. energy('dcft'). The energy('dcft') call to energy() executes the DCFT module, which will first call the SCF module and perform the SCF computation with UHF reference to obtain the guess for the DCFT orbitals. After the SCF is converged, the program will perform the energy computation using the DC-06 method. By default, the two-step algorithm will be used for the solution of the equations. Note that while the default value for the option REFERENCE is RHF, this option is set to UHF before the DCFT module is executed. For the DC-06 method one can also request to perform the geometry optimization following the example below:; molecule {; H; H 1 1.0; }. set basis 3-21G. optimize('dcft'). The optimize('dcft') call will first perform all of the procedures; described above to obtain the DC-06 energy. After that the DC-06 analytic; gradients code will be executed to perform the solution of the DCFT response; equations, compute the analytic gradients of the DCFT energy and perform the; geometry optimization. Recommendations¶; Here is the list of the recommendations for the DCFT module:. For the computations of small systems (less than 150 basis; functions and high symmetry) the use of the default parameters is recommended,; including the choice of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/dcft-1.html:10327,perform,perform,10327,psi4manual/4.0b4/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/dcft-1.html,2,['perform'],['perform']
Performance,"n 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. LINEQ_SOLVER¶. The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MOGRAD_DAMPING¶. Damping factor for the orbital gradient (Rendell et al., JCP, vol. 87, pp. 5976, 1987). Type: double; Default: 1.0. MO_DIIS_NUM_VECS¶. Removed in 1.4. Will raise an error in 1.5. Type: integer; Default: 6. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. MO_READ¶. Do read coefficient matrices from external files of a previous OMP2 or OMP3 computation?. Type: boolean; Default: false. MO_STEP_MAX¶. Maximum step size in orbital-optimization procedure. Type: double; Default: 0.5. MO_WRITE¶. Do write coefficient matrices to external files for direct reading MOs in a subsequent job?. Type: boolean; Default: false. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. NAT_ORBS¶. Do compute natural orbitals?. Type: boolean; Default: false. OCC_ORBS_PRINT¶. Do print OCC orbital energies?. Type: boolean; Default: false. OEPROP¶. Do compute one electron properties?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation paramete",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html:4416,optimiz,optimization,4416,psi4manual/1.4.0/autodir_options_c/module__occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__occ-1.html,8,['optimiz'],['optimization']
Performance,"n = None. #: dict of reagents/geometries; #:; #: >>> print asdf.hrgt.keys(); #: ['NBC1-BzBz_PD32-0.8-monoA-CP', 'NBC1-BzBz_PD34-0.6-dimer', ... 'NBC1-BzBz_PD34-1.7-dimer']; self.hrgt = None. #: dict of defined reaction subsets.; #: Note that self.sset['default'] contains all the nonredundant information.; #:; #: >>> print asdf.sset.keys(); #: ['meme', 'mxddpp', '5min', ... 'small']; self.sset = None. # Removing hrxn, hrgt etc. do not reduce the size of the object.; # These attributes are stored for ease of access for adding qc info, etc. #: object of defined reaction subsets.; self.oss = None. # load database; if pythonpath is not None:; sys.path.insert(1, pythonpath); else:; sys.path.append(os.path.dirname(__file__) + '/../databases'); database = psiutil.import_ignorecase(dbname); if not database:; print('\nPython module for database %s failed to load\n\n' % (dbname)); print('\nSearch path that was tried:\n'); print("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(dbname)). # gross validation of database; for item in ['dbse', 'GEOS', 'HRXN', 'ACTV', 'RXNM']:; try:; getattr(database, item); except AttributeError:; raise ValidationError(""""""Database %s severely deformed with %s missing."""""" % (database.__name__, item)); for item in ['TAGL', 'BIND']:; try:; getattr(database, item); except AttributeError:; print(""""""Warning: Database %s possibly deformed with %s missing.\n"""""" % (database.__name__, item)). # form database name; self.dbse = database.dbse; try:; self.tagl = database.TAGL['dbse']; except KeyError:; print(""""""Warning: TAGL missing for database %s"""""" % (self.dbse)). # form array of database contents to process through; pieces = []; for item in dir(database):; if item in ['qcdb', 'rxn', 'dbse', 'TAGL']:; pass; elif item.startswith('__'):; pass; else:; pieces.append(item). # form qcdb.Reagent objects from all defined geometries, GEOS; oHRGT = {}; for rgt, mol in database.GEOS.iteritems():; mol.update_geometr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:22204,load,loading,22204,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,1,['load'],['loading']
Performance,"n Hartrees. :returns: (*float*, :ref:`Wavefunction<sec:psimod_Wavefunction>`) |w--w| energy and wavefunction when **return_wfn** specified. :PSI variables:. .. hlist::; :columns: 1. * :psivar:`CURRENT ENERGY <CURRENTENERGY>`. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :ref:`Wavefunction<sec:psimod_Wavefunction>`; calculation result as the second element (after *float* energy) of a tuple. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. For maximum; flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:48939,perform,performed,48939,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['performed']
Performance,"n RAS III. Type: integer; Default: -1. B_RAS3_MAX¶. maximum number of beta electrons in RAS III. Type: integer; Default: -1. CALC_S_SQUARED¶. Do calculate the value of \(\langle S^2\rangle\) for each root? Only supported for ICORE = 1. Type: boolean; Default: false. CIBLKS_PRINT¶. Do print a summary of the CI blocks?. Type: boolean; Default: false. CI_MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 24. DETCI_FREEZE_CORE¶. Do freeze core orbitals?. Type: boolean; Default: true. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. E_CONVERGENCE¶. Convergence criterion for energy. See Table Post-SCF Convergence for default convergence criteria for different calculation types. Type: conv double; Default: 1e-6. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of the C vector when constructing H in the iterative subspace if DIAG_METHOD = SEM), but require less core memory. Type: integer; Default: 1. ISTOP¶. Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. MS0¶. Do use the \(M_s = 0\) component of the state? Defaults to TRUE if closed-shell and FALSE otherwise. Related to the S option. Type: boolean; Default: false. NUM_DETS_PRINT¶. Number of important determinants to print. Type: integer; Default: 20. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. RAS34_MAX¶. maximum number of electrons in RAS III + IV. Type: integer; Default: -1. RAS3_MAX¶. maximum number of electrons in RAS III. Type: integer; Default: -1. RAS4_MAX¶. maximum number of electrons in RAS IV. Type: integer; Default: -1. REFERENCE¶. Reference wavef",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html:1821,perform,perform,1821,psi4manual/1.3.2/autodir_options_c/module__detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__detci-1.html,24,['perform'],['perform']
Performance,"n active spaces).; ; me(...); me() -> int :; Returns the current process ID in a MADNESS parallel run.; ; mints(...); mints() -> int :; Runs mints, which generate molecular integrals on disk.; ; mp2(...); mp2() -> float :; Runs the conventional (slow) MP2 code.; ; mrcc_generate_input(...); mrcc_generate_input( (dict)arg1) -> PsiReturnType :; Generates an input for Kallay's MRCC code.; ; mrcc_load_densities(...); mrcc_load_densities( (dict)arg1) -> PsiReturnType :; Reads in the density matrices from Kallay's MRCC code.; ; nproc(...); nproc() -> int :; Returns the number of processors being used in a MADNESS parallel run.; ; nthread(...); nthread() -> int :; Returns the number of threads to use in SMP parallel computations.; ; nuclear_dipole(...); nuclear_dipole( (Molecule)arg1) -> Vector :; docstring; ; omp2(...); omp2() -> float :; Runs the orbital optimized MP2 code.; ; omp3(...); omp3() -> float :; Runs the orbital optimized MP3 code.; ; opt_clean(...); opt_clean() -> None :; Cleans up the optimizer's scratch files.; ; optking(...); optking() -> int :; Runs the geometry optimization / frequency analysis code.; ; outfile_name(...); outfile_name() -> str :; Returns the name of the output file.; ; plugin(...); plugin( (str)arg1) -> int :; docstring; ; plugin_close(...); plugin_close( (str)arg1) -> None :; docstring; ; plugin_close_all(...); plugin_close_all() -> None :; docstring; ; plugin_load(...); plugin_load( (str)arg1) -> int :; docstring; ; prepare_options_for_module(...); prepare_options_for_module( (str)arg1) -> None :; Sets the options module up to return options pertaining to the named argument (e.g. SCF).; ; print_global_options(...); print_global_options() -> None :; Prints the currently set global (all modules) options to the output file.; ; print_options(...); print_options() -> None :; Prints the currently set options (to the output file) for the current module.; ; print_out(...); print_out( (str)arg1) -> None :; Prints a string (using sprintf-like not",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/psimod-1.html:110808,optimiz,optimizer,110808,psi4manual/4.0b3/psimod-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/psimod-1.html,2,['optimiz'],['optimizer']
Performance,"n and return_history:; return (thisenergy, wfn, history); elif return_wfn and not return_history:; return (thisenergy, wfn); elif return_history and not return_wfn:; return (thisenergy, history); else:; return thisenergy. elif optking_rval == core.PsiReturnType.Failure:; print('Optimizer: Optimization failed!'); # Mark the optimization data as disposable now that the optimization is done.; core.IOManager.shared_object().set_specific_retention(1, False); if (core.get_option('OPTKING', 'KEEP_INTCOS') == False):; core.opt_clean(); molecule.set_geometry(moleculeclone.geometry()); core.clean(); optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn); return thisenergy. core.print_out('\n Structure for next step:\n'); moleculeclone.print_in_input_format(). n += 1. if core.get_option('OPTKING', 'INTCOS_GENERATE_EXIT') == False:; if core.get_option('OPTKING', 'KEEP_INTCOS') == False:; core.opt_clean(). optstash.restore(); raise OptimizationConvergenceError(""""""geometry optimization"""""", n - 1, wfn). [docs]def hessian(name, **kwargs):; r""""""Function complementary to :py:func:`~frequency`. Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. :returns: :py:class:`~psi4.core.Matrix` |w--w| Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. :returns: (:py:class:`~psi4.core.Matrix`, :py:class:`~psi4.core.Wavefunction`) |w--w| Hessian and wavefunction when **return_wfn** specified. :examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). """"""; kwargs = p4util.kwargs_lower(kwargs). # Figure out what kind of gradient this is; if hasattr(name, '__call__'):; if name.__name__ in ['cbs', 'complete_basis_set']",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:61527,optimiz,optimization,61527,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,7,"['Optimiz', 'optimiz']","['OptimizationConvergenceError', 'optimization']"
Performance,"n appealing option for conventional SCF calculations, where the ERIs are stored; in core or on disk. However, even when using DF, I/O becomes a significant bottleneck for systems of a sufficient size when performing conventional SCF; calculations. In principle, though, DF approaches can be utilized in an integral-direct context, gaining the benefits of DF methods without suffering the; I/O bottlenecks that conventional DF methods will eventually run into. One such approach, outlined by Weigend in [Weigend:2002:4285],; is available for use in Psi4 for the separate construction of the Coulomb contribution to the Fock matrix. This implementation can be used alongside; Psi4’s separate Exchange construction algorithms for composite Fock matrix construction by using the keyword DFDIRJ as the Coulomb construction; algorithm when specifying SCF_TYPE to use a composite algorithm combination (DFDIRJ+K_alg in general,; or DFDIRJ for DFT with non-hybrid functionals).; DFDIRJ supports multiple capabilities to improve performance. Specifically, DFDIRJ allows for a combination of density-matrix based ERI; screening (set SCREENING to DENSITY) and incremental Fock matrix construction (set INCFOCK to TRUE). These two, when combined,; enable more aggressive screening of ERI contributions to the Coulomb matrix and thus greatly improve performance. COSX Exchange¶; The semi-numerical COSX algorithm described in [Neese:2009:98] evaluates; two-electron ERIs analytically over one electron coordinate and numerically; over the other electron coordinate, and belongs to the family of pseudospectral; methods originally suggested by Friesner. In COSX, numerical integration is performed on standard; DFT quadrature grids, which are described in DFT: Density Functional Theory.; Both the accuracy of the COSX algorithm and also the computational; cost are directly determined by the size of the integration grid, so selection; of the grid is important. This COSX implementation uses two separate grids.; B",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/scf.html:35556,perform,performance,35556,psi4manual/1.9.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/scf.html,2,['perform'],['performance']
Performance,"n appendix ADC; and many more sample input files can be found in the adc and adcc; subfolders of psi4/samples.; Note, that not all keywords are supported by all backends. Interface to adcc¶; Code author: Michael F. Herbst; Section author: Michael F. Herbst; For most implemented ADC methods PSI4 relies; on an interface to the adcc python package.; The approach of adcc is to directly diagonalise the; ADC matrix \(\mathbf{A}\) in an iterative diagonalisation; procedure, usually a Jacobi-preconditioned Davidson. Expensive parts; of the ADC matrix-vector product are precomputed and stored; in memory. This approach is general in the sense; that it can be applied to a large range of ADC methods and variants.; So far levels up to ADC(3) and CVS-ADC(3) are available; and additional approximations such as; FREEZE_CORE and NUM_FROZEN_UOCC; are supported with all ADC methods using the adcc backend.; Currently adcc is only capable of performing in-core calculations,; for which, however, permutational symmetry and spin symmetry is taken; into account for both tensor computations and tensor storage.; Inside adcc some heuristic checks for overly excessive memory requirements; are implemented, resulting in a warning in case a; successful execution is unlikely. There are no guarantees for the memory; to be sufficient in case such a warning is not displayed.; More detailed documentation about adcc and its features can be found; at https://adc-connect.org,; especially the theory section.; If you are using adcc from PSI4 for your calculations,; please cite both PSI4 as well as adcc [Herbst2020]; in your published work.; The ADC wavefunction object.; After running the ADC calculation in adcc, the interface code sets; a number of variables in the returned Wavefunction; in case they are computed.; In the following the <method> prefix refers to the ADC method (such as adc(1),; adc(3), cvs-adc(2)-x). Ground state energy terms like MP2 correlation energy, MP3 correlation energy,; MP2 total en",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/adc.html:8812,perform,performing,8812,psi4manual/1.7.x/adc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/adc.html,4,['perform'],['performing']
Performance,"n are provided below.; Sample inputs accessible through interfaced executables are bulleted below. CFOUR; CHEMPS2; COOKBOOK; DFTD3; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cc46; EOM-CC2/cc-pVDZ on H2O2 with two excited states in each irrep. opt11; Transition-state optimizations of HOOH to both torsional transition states. dfomp2p5-grad1; DF-OMP2.5 cc-pVDZ gradients for the H2O molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. cc40; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = length, omega = (589 355 nm). dft-custom-dhdf; DSD-PBEP86 S22 Ammonia test. cc25; Single point gradient of 1-2B2 state of H2O+ with EOM-CCSD. dfomp2-grad3; Tests OMP2 gradient in the presence of a dipole field. casscf-sp; CASSCF/6-31G** energy point. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dcft-grad4; Unrestricted DF-DCFT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. fd-freq-gradient; STO-3G frequencies for H2O by finite-differences of gradients. sapt-exch-ind-inf; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. ocepa-grad2; OCEPA cc-pVDZ gradient for the NO radical. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cc8a; ROHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\)",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/testsuite-1.html:1530,optimiz,optimization,1530,psi4manual/1.2.1/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/testsuite-1.html,2,['optimiz'],['optimization']
Performance,"n au for finite-differences. Type: double; Default: 0.005. DISTANT_PAIR_CUTOFF (CCENERGY); CCENERGY — Distant pair cutoff. Type: double; Default: 8.0. DISTRIBUTED_MATRIX (SCF); SCF (Expert) — The dimension sizes of the distributed matrix. Type: array; Default: No Default. DO_ALL_TEI (TRANSQT); TRANSQT — Do transform all TEIs. Type: boolean; Default: false. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF); MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DOMAIN_PRINT (CCENERGY); CCENERGY — Do print the domains?. Type: boole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:35739,perform,perform,35739,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"n by running ctest in the compilation; directory. More info on ctest options can be found; here. Sample input files; can be found in the psi4/samples subdirectory of the top-level Psi; directory. The samples and a brief description are provided below.; Sample inputs accessible through interfaced executables are bulleted below. BRIANQC; CFOUR; CHEMPS2; COOKBOOK; DFTD3; DFTD4; DKH; LIBEFP; ERD; GCP; GDMA; GPU_DFCC; JSON; MRCC; PCMSOLVER; PSI4NUMPY; PYTHON; SIMINT; SNSMP2; V2RDM_CASSCF. Sample inputs for PSI4 as distributed are below. Input File; Description. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. nbody-freq; Vibrational and thermo analysis of water trimer (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. dfmp2-grad3; DF-MP2 cc-pVDZ gradients for the H2O molecule. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). mp2-1; All-electron MP2 6-31G** geometry optimization of water. mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. pubchem2; Superficial test of PubChem interface. cisd-opt-fd; H2O CISD/6-31G** Optimize Geometry by Energies. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. cc48; reproduces dipole moments in J.F. Stanton’s “biorthogonal” JCP paper. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. aediis-1; ADIIS test case, from 10.1063/1.3304922. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. scf-hess2; UHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. This test should match RHF values exactly. sapt1; SAPT0 cc-pVDZ computation of the ethene-ethyne interaction energy, using the cc-pV",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/testsuite.html:1331,optimiz,optimization,1331,psi4manual/1.7.x/testsuite.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/testsuite.html,1,['optimiz'],['optimization']
Performance,"n can use it to simplify tasks by; modifying some of the example input files supplied with Psi4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. Most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) corrected energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, Psi4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in Psi4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/tutorial-1.html:16433,perform,perform,16433,psi4manual/1.0.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/tutorial-1.html,2,['perform'],['perform']
Performance,"n cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. table of contents. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dcft-1.html:15938,perform,performing,15938,psi4manual/1.2.1/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dcft-1.html,2,['perform'],['performing']
Performance,"n create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradient method. Type: conv double; Default: 1e-6. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; Default: 50. PPL_TYPE¶. Type of the CCSD PPL term. Type: string; Possible Values: LOW_MEM, HIGH_MEM, CD, AUTO; Default: AUTO. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. READ_SCF_3INDEX¶. Do read 3-index integrals from SCF files?. Type: boolean; Default: true. REGULARIZATION¶. Do use regularized denominators?. Type: boolean; Default: false. REG_PARAM¶. Regularization parameter. Type: double; Default: 0.4. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. TRIPLES_IABC_TYPE¶. The algorithm to handle (ia|bc) type integrals that used for (T) correction. Type: string; Possible Values: INCORE, AUTO, DIRECT, DISK; Default: DISK. WFN_TYPE¶. Type of the wavefunction. Type: string; Default: DF-OMP2. table of contents. DFOCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html:5340,perform,perform,5340,psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dfocc-1.html,2,['perform'],['perform']
Performance,"n create the MO Hessian and solve the simultaneous linear equations with method choosen by the LINEQ_SOLVER option. The PCG option does not create the MO Hessian explicitly, instead it solves the simultaneous equations iteratively with the preconditioned conjugate gradient method. Type: string; Possible Values: PCG, LINEQ; Default: PCG. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. PCG_BETA_TYPE¶. CEPA type such as CEPA0, CEPA1 etc. currently we have only CEPA0. Type: string; Possible Values: FLETCHER_REEVES, POLAK_RIBIERE; Default: FLETCHER_REEVES. PCG_CONVERGENCE¶. Convergence criterion for residual vector of preconditioned conjugate gradient method. Type: conv double; Default: 1e-6. PCG_MAXITER¶. Maximum number of preconditioned conjugate gradient iterations. Type: integer; Default: 50. PPL_TYPE¶. Type of the CCSD PPL term. Type: string; Possible Values: LOW_MEM, HIGH_MEM, CD, AUTO; Default: AUTO. QCHF¶. Do perform a QCHF computation?. Type: boolean; Default: false. READ_SCF_3INDEX¶. Do read 3-index integrals from SCF files?. Type: boolean; Default: true. REGULARIZATION¶. Do use regularized denominators?. Type: boolean; Default: false. REG_PARAM¶. Regularization parameter. Type: double; Default: 0.4. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. TRIPLES_IABC_TYPE¶. The algorithm to handle (ia|bc) type integrals that used for (T) correction. Type: string; Possible Values: INCORE, AUTO, DIRECT, DISK; Default: DISK. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: DF-OMP2, DF-OMP3, DF-OLCC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html:5371,perform,perform,5371,psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__dfocc-1.html,6,['perform'],['perform']
Performance,"n either specify a basis known to CFOUR or via BASIS=SPECIAL (=0) requests an arbitrary basis (see non-standard basis-set input). However, the latter must be available in the supplied GENBAS file. As standard basis sets, currently the following are available. Psi4 Interface: Recommended to use instead BASIS for larger basis set selection and greater flexibility. When BASIS used, CFOUR_SPHERICAL is set appropriately. Type: string; Default: SPECIAL. CFOUR_BRUCK_CONV (CFOUR)¶CFOUR — experimental use. Type: integer; Default: 4. CFOUR_BRUECKNER (CFOUR)¶CFOUR — Specifies whether Brueckner orbitals are to be determined for the specified CC method. OFF(=0) Brueckner orbitals are not to be determined, ON (=1) they are to be determined. Type: boolean; Default: false. CFOUR_CACHE_RECS (CFOUR)¶CFOUR — The number of records held in the i/o cache used by the post-SCF programs. The maximum number of records which can be held is 100. Type: integer; Default: 10. CFOUR_CALC_LEVEL (CFOUR)¶CFOUR — Defines the level of calculation to be performed. Psi4 Interface: Keyword set from argument of computation command: CCSD if energy('c4-ccsd'), etc. See Energy (CFOUR) and Gradient (CFOUR). for all available. Type: string; Default: SCF. CFOUR_CC_CONV (CFOUR)¶CFOUR — Specifies the convergence criterion for the CC amplitude equations. The amplitudes are considered to be converged when the maximum of all (absolute) changes in the amplitudes is less than \(10^N\), where \(N\) is the value associated with the keyword. Type: integer; Default: 7. CFOUR_CC_EXPORDER (CFOUR)¶CFOUR — Specifies the maximum number of expansion vectors used in the iterative subspace to enhance convergence in the solution of the CC equations. Type: integer; Default: 5. CFOUR_CC_EXTRAPOLATION (CFOUR)¶CFOUR — Specifies the type of convergence acceleration used to solve the CC equations. RLE (=0) uses the RLE methods of Purvis and Bartlett, DIIS (=1) uses the DIIS approach by Pulay, NOJACOBI (=2) uses RLE with continuous extrapo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:25695,perform,performed,25695,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,9,['perform'],['performed']
Performance,"n enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule (xyz coordinates only); molecule.set_geometry(displacement). # Perform the gradient calculation; func(lowername, **kwargs). # Save the gradient; G = PsiMod.get_gradient(); gradients.append(G). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). PsiMod.fd_freq_1(gradients, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:46728,perform,perform,46728,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,3,"['Perform', 'perform']","['Performing', 'perform']"
Performance,"n error will be reported.; To preferentially use a particular dftd3 compilation, simply adjust its; position in the path environment variables. Theory¶; The local or semilocal character of conventional density functionals; necessarily leads to neglect of the long-range correlation interactions; which capture attractive van der Waals forces. Initially proposed by Yang; [Wu:2002:515] and assiduously developed by Grimme, [Grimme:2004:1463]; [Grimme:2006:1787] [Grimme:2010:154104] the DFT+Dispersion method; appends to the base functional a scaled, damped, and fitted leading term; to the well-known dispersion energy series, \(E_{disp} = -C_6/R^6; -C_8/R^8 -C_{10}/R^{10}-\cdots\). The DFT-D2 [Grimme:2006:1787] variant; takes the explicit form below. Here, dispersion coefficients,; \(C_6^{ij}\), obtained from the geometric mean of tabulated elemental; values, are summed over interatomic distances, \(R_{ij}\), modulated; by a damping function, \(f_{damp}(R_{ij})\), that gradually activates; the dispersion correction (at a rate characterized by \(\alpha_6\)); over a distance characterized by the sum of the two atomic vdW radii,; \(R_{vdW}\), while an overall scaling term, \(s_6\), is optimized; to be unique to each \(E_{xc}\) functional. (\(\alpha_6\) is; sometimes allowed to vary as well.). (1)¶\[E_{disp}^{\text{D2}}=-s_6 \sum_{i,j>i}^{N_{at}} \frac{C_6^{ij}}{(R_{ij})^6} f_{damp}(R_{ij})\]. \[f_{damp}(R_{ij}) = \frac{1}{1 + e^{- \alpha_6 (R_{ij}/R_{vdW} - 1)}}\]; Grimme recently presented a refined method, DFT-D3, [Grimme:2010:154104]; which incorporates an additional \(R^{-8}\) term in the dispersion; series and adjusts the \(C_{6}^{ij}\) combination formula and damping; function. The individual atomic \(C_6^i\) are interpolated from; several reference values based upon coordination numbers extracted from; the molecular structure, rather than assigned solely by atomic identity as; in DFT-D2, and thereby incorporate some awareness of the chemical; environment into an otherwi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/dftd3-1.html:2629,optimiz,optimized,2629,psi4manual/1.2.1/dftd3-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/dftd3-1.html,15,['optimiz'],['optimized']
Performance,"n in; Psi4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been included in the output file as; the sSAPT0 interaction energy. sSAPT0 is a free by-product and is automatically; computed when SAPT0 is requested (see above for more details).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 basis functions; this code should be scalable to 4000; basis functions. Publications resulting from the use of the SAPT0 code; should cite the following publications: [Hohenstein:2010:184111] and; [Hohenstein:2011:174107]. Basic SAPT0 Keywords¶. SAPT_LEVEL¶. The level of theory for SAPT. Type: string; Possible Values: SAPT0, SAPT2, SAPT2+, SAPT2+3; Default: SAPT0. BASIS¶. Primary basis set, describes the monomer molecular orbitals. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_SAPT¶. Auxiliary basis set for SAPT density fitting computations. Defaults to a RI basis. Type: string; Possible Values: basis string; Default: No Default. DF_BASIS_ELST¶. Auxiliary basis set for SAPT Els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:7854,perform,performance,7854,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performance']
Performance,"n information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, …); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:311732,optimiz,optimize,311732,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['optimiz'],['optimize']
Performance,"n is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). scf_aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_SCF"",; core.get_option(""SCF"", ""DF_BASIS_SCF""),; ""JKFIT"", core.get_global_option('BASIS'),; puream=ref_wfn.basisset().has_puream()); ref_wfn.set_basisset(""DF_BASIS_SCF"", scf_aux_basis). aux_basis = core.BasisSet.build(ref_wfn.molecule(), ""DF_BASIS_CC"",; core.get_global_option(""DF_BASIS_CC""),; ""RIFIT"", core.get_global_option(""BASIS"")); ref_wfn.set_basisset(""DF_BASIS_CC"", aux_basis). if core.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = core.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. def run_dfocc_property(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'OEPROP']). if name in ['mp2', 'omp2']:; core.set_local_option('DFOCC', 'WFN_TYPE', 'DF-OMP2'); else:; raise ValidationError('Unidentified method ' % (name)). # Alter default algorithm; if not core.has_option_changed('SCF', 'SCF_TYPE'):; core.set_global_option('SCF_TYPE', 'DF'); core.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""). if core.get_option('SCF', 'SCF_TYPE') != 'DF':; raise ValidationError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; core.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). core.set_local_option('DFOCC', 'OEPROP', 'TRUE'); core.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); core.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); core.set_local_op",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html:48154,optimiz,optimized,48154,psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/procrouting/proc.html,1,['optimiz'],['optimized']
Performance,"n is recommended (set by default).; In cases when available memory is insufficient, the use of the AO_BASIS DISK option; is recommended. This will significantly reduce the memory requirements. However, when; used together with the two-step algorithm, this option can significantly; increase the cost of the energy computation.; In cases when the oscillatory convergence is observed before the DIIS; extrapolation is initialized, it is recommended to increase the threshold for; the RMS of the density cumulant or orbital update residual, below which the; DIIS extrapolation starts. This can be done by setting the; DIIS_START_CONVERGENCE option to the value greater than; \(10^{-3}\) by one or two orders of magnitude (e.g. \(10^{-2}\) or; \(10^{-1}\)). This can be particularly useful for computations using the; ODC methods, because it can greatly reduce the number of iterations.; If oscillatory convergence is observed for atoms or molecules with high; symmetry, it is recommended to use the quadratically-convergent algorithm.; When using the quadratically-convergent algorithm for the closed-shell molecules, it; is recommended to set the QC_COUPLING option to FALSE for efficiency; reasons (set by default).; For the ODC computations, the user has a choice of performing the computation of the guess orbitals and cumulants; using the corresponding DC method (set ODC_GUESS to TRUE). This can often lead to; significant computational savings, since the orbital update step in the DC methods is cheap.; Convergence of the guess orbitals and cumulants can be controlled using the; GUESS_R_CONVERGENCE option. table of contents. DCFT: Density Cumulant Functional Theory; Theory; Methods; Iterative Algorithms; Analytic Gradients; Methods Summary; Minimal Input; Recommendations. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Theoretical Methods: SCF to FCI. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 2017 05:47AM.; Created using Sphinx 1.5.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/dcft-1.html:15936,perform,performing,15936,psi4manual/1.1.0/dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/dcft-1.html,2,['perform'],['performing']
Performance,"n linger, so, unless you’ve; deliberately constructed it, be sure to clear it out before starting a; new optimization. Warning; Optimizations where the molecule is specified in Z-matrix format ; with dummy atoms will result in the geometry being converted to a Cartesian representation. Parameters:; name (string) – 'scf' || 'df-mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; driver.energy(). func (function) – gradient || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses``’gradient’`` or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. Examples :. >>> # [1] Analytic scf optimization; >>> optimize('scf'). >>> # [2] Finite difference mp3 optimization; >>> opt('mp3'). >>> # [3] Forced finite difference ccsd optimization; >>> optimize('ccsd', dertype=1). For further discussion of geometry optimization, see; Sec. Geometry Optimization. Previous topic; Counterpoise Correct; Next topic; Frequency; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/opt-1.html:7688,optimiz,optimization,7688,psi4manual/4.0b3/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/opt-1.html,4,['optimiz'],['optimization']
Performance,"n module. psi4.optimize(name[, molecule, return_wfn, func, mode, dertype, hessian_with])[source]¶; Function to perform a geometry optimization. Aliases:opt(). Returns:float – Total electronic energy of optimized structure in Hartrees. Returns:(float, Wavefunction) – energy and wavefunction when return_wfn specified. Raises:psi4.ConvergenceError if GEOM_MAXITER exceeded without reaching geometry convergence. PSI variables:. CURRENT ENERGY. Parameters:; name (string) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; energy(). molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the comp",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:1734,perform,performed,1734,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,2,['perform'],['performed']
Performance,"n of DF-MP2 and DLPNO-MP2 with a CBS extrapolation. cepa2; cc-pvdz H2O Test ACPF Energy/Properties. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. fnocc2; Test G2 method for H2O. dfomp3-1; DF-OMP3 cc-pVDZ energy for the H2O molecule. sapt4; SAPT2+(3) aug-cc-pVDZ computation of the formamide dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. This example uses frozen core as well as MP2 natural orbital approximations. omp3-grad1; OMP3 cc-pVDZ gradient for the H2O molecule. opt14; 6-31G(d) optimization of SF4 starting from linear bond angle that is not linear in the optimized structure but is in a symmetry plane of the molecule. opt-irc-1; Compute the IRC for HOOH torsional rotation at the RHF/DZP level of theory. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). sapt10; usapt example with empty beta due to frozen core. dct3; DC-06 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the AO Basis, using integrals stored on disk. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. dfomp2-grad1; DF-OMP2 cc-pVDZ gradients for the H2O molecule. explicit-am-basis; Check that basis sets can be input with explicit angular momentum format. scf-guess-read2; Test if the the guess read in the same basis converges. dfmp2-4; conventional and density-fitting mp2 test of mp2 itself and setting scs-mp2. pywrap-checkrun-rhf; This checks that all energy methods can run with a minimal input and set symmetry. cbs-xtpl-nbody; RHF interaction energies using nbody and cbs parts of the driver Ne dimer with mp2/v[dt]z + d:ccsd(t)/vdz. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. mints8; Patch of a glycine with a methyl group, to make alanine, then DF-SCF energy calculation with the cc-pVDZ basis set. cc44; Tes",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:2284,perform,performs,2284,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"n of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKING', 'FULL_HESS_EVERY'):; raise ValidationError(""Optimize: Does not support custom Hessian's yet.""); else:; hessian_with_method = kwargs.get('hessian_with', lowername). # are we in sow/reap mode?; opt_mode = kwargs.get('mode', 'continuous').lower(); if ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:56640,optimiz,optimize,56640,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"n of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS wrapper, need to set retention on INTCO file; if custom_gradien",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:58238,optimiz,optimize,58238,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"n of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; \(C_{2v}\) water is; actually,:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3, 0, 1, 1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but it will suffer non-physical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the GUESS_MIX; keyword to true:; 1; 2; 3set reference uhf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In PSI4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:11290,perform,perform,11290,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['perform'],['perform']
Performance,"n options (scf_type) being set global or local. This input uses global. sapt-ecp; sapt0 of charged system in ECP basis set. ci-property; CI/MCSCF cc-pvDZ properties for Potassium nitrate (rocket fuel!). sapt10; usapt example with empty beta due to frozen core. scf-hess1; RHF STO-3G (Cartesian) and cc-pVDZ (spherical) water Hessian test, against Psi3 reference values. fnocc2; Test G2 method for H2O. olccd3; OLCCD cc-pVDZ energy with ROHF initial guess for the NO radical. freq-isotope2; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures, pressures, and isotopologs. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. props3; DF-SCF cc-pVDZ multipole moments of benzene, up to 7th order and electrostatic potentials evaluated at the nuclear coordinates. mints15; check SP basis Fortran exponent parsing. dct1; DC-06, DC-12, ODC-06 and ODC-12 calculation for the He dimer. This performs a simultaneous update of the orbitals and cumulant, using DIIS extrapolation. Four-virtual integrals are handled in the MO Basis. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-pbe0-2; Internal match to psi4, test to match to literature values in litref.in/litref.out. dft-dsd; DSD S22 Ammonia test. cc35; CC3(ROHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). casscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule see C. D. Sherrill and P. Piecuch, J. Chem. Phys. 122, 124104 (2005). tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\) ). dft-vv10; He Dimer VV10 functional test. notes: DFT_VV10_B/C overwrites the NL_DISPERSION_PARAMETERS tuple updated ‘bench’ reference values for new BraggSlater radii. scf-auto-cholesky; Cholesky ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:35315,perform,performs,35315,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performs']
Performance,"n pairs in SCS computations. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. The scale factor used for same-spin pairs in SCS computations. Type: double; Default: 1.0/3.0. NEGLECT_DISTANT_PAIR¶. Do neglect distant pairs?. Type: boolean; Default: true. NEW_TRIPLES¶. Do use new triples?. Type: boolean; Default: true. NUM_AMPS_PRINT¶. Number of important and amplitudes to print. Type: integer; Default: 10. PAIR_ENERGIES_PRINT¶. Do print MP2 and CCSD pair energies for RHF references?. Type: boolean; Default: false. PROPERTY¶. The response property desired. Acceptable values are POLARIZABILITY (default) for dipole-polarizabilities, ROTATION for specific rotations, ROA for Raman Optical Activity, and ALL for all of the above. Type: string; Possible Values: POLARIZABILITY, ROTATION, MAGNETIZABILITY, ROA, ALL; Default: POLARIZABILITY. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF; Default: RHF. RESTART¶. Do restart the coupled-cluster iterations from old and amplitudes? For geometry optimizations, Brueckner calculations, etc. the iterative solution of the CC amplitude equations may benefit considerably by reusing old vectors as initial guesses. Assuming that the MO phases remain the same between updates, the CC codes will, by default, re-use old vectors, unless the user sets RESTART = false. Type: boolean; Default: true. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible// representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for T2 amplitudes (RMS change). Type: conv double; Default: 1e-5. SCREEN_INTS¶. Do screen integrals?. Type: boolean; Default: false. SCS¶. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SCSN_MP2¶. Do SCS-MP2 with parameters optimized for nucleic acids?. Type: boolean; Default: false. SCS_CCSD¶. Do spin-component-scaled CCSD. Type: boolean; Default: false. SCS_MP2¶. Do spin-component-scaled MP2 (SCS-MP2)?. Type: boolean; Default: false. SC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html:5700,optimiz,optimizations,5700,psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodir_options_c/module__ccenergy-1.html,4,['optimiz'],['optimizations']
Performance,"n range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]; def sherrill_gold_standard(**kwargs) -> CBSMetadata:; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses the composite wrapper to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs_helper.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; scf = {; 'wfn': 'hf',; 'basis': kwargs.pop('scf_basis', 'aug-cc-pVQZ'),; 'scheme': kwargs.pop('scf_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('scf_options', {}),; }; corl = {; 'wfn': kwargs.pop('corl_wfn', 'mp2'),; 'basis': kwargs.pop('corl_basis', 'aug-cc-pV[TQ]Z'),; 'scheme': kwargs.pop('corl_scheme', 'corl_xtpl_helgaker_2'),; 'options': kwargs.pop('corl_options', {}),; 'options_lo': kwargs.pop('corl_options_lo', {}),; }; delta = {; 'wfn': kwargs.pop('delta_wfn', 'ccsd(t)'),; 'wfn_lesser': kwargs.pop('delta_wfn_lesser', 'mp2'),; 'basis': kwargs.pop('delta_basis', 'aug-cc-pVTZ'),; 'scheme': kwargs.pop('delta_scheme', 'xtpl_highest_1'),; 'options': kwargs.pop('delta_options', {}),; 'options_lo': kwargs.pop('delta_options_lo', {}),; }. return [scf, corl, delta]. [docs]; def allen_focal_point(**kwargs) -> CBSMetadata:; r""""""Function to call Wes Allen-style Focal; Point Analysis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html:3474,optimiz,optimization,3474,psi4manual/1.8.x/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/aliases.html,12,['optimiz'],"['optimization', 'optimize']"
Performance,"n special steps are taken to get; the scf to converge in an explicit preceeding scf step. :examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into requested basis; >>> energy('sapt0-ct',cast_up=True). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp4'). """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(). # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. try:; return procedures['energy'][lowername](lowername, **kwargs); except KeyError:; raise ValidationError('Energy method %s not available.' % (lowername)). [docs]def gradient(name, **kwargs):; r""""""Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. if (PsiMod.get_global_option('REFERENCE').lower() == 'rks') or (PsiMod.get_global_option('REFERENCE').lower() == 'uks'):; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if input.der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:20418,optimiz,optimize,20418,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['optimiz'],['optimize']
Performance,"n the EP2 method, overrides EP2_NUM_IP and EP2_NUM_EA options. Input array should be [[orb1, orb2], [], …] for each irrep. Type: array; Default: No Default. EP_EA_POLES (OCC)¶OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC)¶OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC)¶OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI)¶DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI)¶DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT)¶SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM)¶CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF)¶CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXTERN (SCF)¶SCF — An ExternalPotential (built by Python or nullptr/None). Type: boolean; Default: false. EXTERNAL_POTENTIAL_SYMMETRY (GLOBALS)¶GLOBALS (Expert) — Assume external fields are arranged so that they have symmetry. It is up to the user to know what to do here. The code does NOT help you out in any way!. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:123536,perform,performs,123536,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,5,['perform'],['performs']
Performance,"n the EP2 method, overrides EP2_NUM_IP and EP2_NUM_EA options. Input array should be [[orb1, orb2], [], …] for each irrep. Type: array; Default: No Default. EP_EA_POLES (OCC)¶OCC — Do compute EP-OCC poles for electron affinities? Only valid for OMP2. Type: boolean; Default: false. EP_IP_POLES (OCC)¶OCC — Do compute EP-OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. EP_MAXITER (OCC)¶OCC — Maximum number of electron propagator iterations. Type: integer; Default: 30. EX_ALLOW (DETCI)¶DETCI (Expert) — An array of length EX_LEVEL specifying whether each excitation type (S,D,T, etc.) is allowed (1 is allowed, 0 is disallowed). Used to specify non-standard CI spaces such as CIST. Type: array; Default: No Default. EX_LEVEL (DETCI)¶DETCI — The CI excitation level. Type: integer; Default: 2. EXCH_SCALE_ALPHA (SAPT)¶SAPT — Whether or not to perform exchange scaling for SAPT exchange components. Default is false, i.e. no scaling. If set to true, performs scaling with \(Exch10 / Exch10(S^2)\). If set to a value \(\alpha\), performs scaling with \((Exch10 / Exch10(S^2))^{\alpha}\). Type: string; Default: FALSE. EXCITATION_RANGE (CCEOM)¶CCEOM (Expert) — The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. EXPLICIT_HAMILTONIAN (CPHF)¶CPHF — Do explicit hamiltonian only?. Type: boolean; Default: false. EXT_FORCE_BEND (OPTKING)¶OPTKING — Specify formula for external forces for angles between atoms. Type: string; Default: No Default. EXT_FORCE_CARTESIAN (OPTKING)¶OPTKING — Symmetry formula for external forces for cartesian coordinates on atoms . Type: string; Default: No Default. EXT_FORCE_DIHEDRAL (OPTKING)¶OPTKING — Specify formula ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:127951,perform,performs,127951,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['perform'],['performs']
Performance,"n the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. freq-isotope1; Vibrational and thermo analysis of several water isotopologs. Demonstrates Hessian reuse for different temperatures and pressures but not for different isotopologs. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. fd-gradient; SCF STO-3G finite-difference tests. options1; check all variety of options parsing. tdscf-4; td-wb97x singlet excitation energies of methylene (tda). omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. scf7; Tests SCF gradient in the presence of a dipole field. fnocc3; Test FNO-QCISD(T) computation. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. mints9; A test of the basis specification. Various basis sets are specified outright and in blocks, both orbital and auxiliary. Constructs libmints BasisSet objects through the constructor that calls qcdb.BasisSet infrastructure. Checks that the resulting bases are of the right size and checks that symmetry of the Molecule observes the basis assignment to atoms. cc39; RHF-CC2-LR/cc-pVDZ dynamic polarizabilities of HOF molecule. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. omp3-5; SOS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. dfomp2-3; OMP2 cc-pVDZ energy for the H2O molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. scf-hess4; DF SCF 6-31G UHFl vs RHF t",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:30034,optimiz,optimizations,30034,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimizations']
Performance,"n the iterative subspace that will; be stored before a collapse is done.; maxiter (int) – The maximum number of iterations; verbose (int) – The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns:. best_values (numpy.ndarray) – (nroots, ) The best approximation of the eigenvalues of w, computed on the last iteration of the solver; best_R (List[vector]) – (nroots) The best approximation of the right hand eigenvectors, \(X+Y\), computed on the last iteration of the solver.; best_L (List[vector]) – (nroots) The best approximation of the left hand eigenvectors, \(X-Y\), computed on the last iteration of the solver.; stats (List[Dict]) – Statistics collected on each iteration. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged. Notes; The solution vector is normalized to 1/2; The solver will return even when maxiter iterations are performed without convergence.; The caller must check stats[-1]['done'] for failure and handle each case accordingly.; References; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, “An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules.” J. Chem. Phys.,; 109, 8218 (1998). table of contents. hamiltonian_solver; hamiltonian_solver(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; hamiltonian_solver. © Copyright 2007-2023, The Psi4 Project.; Last updated on Wednesday, 04 October 2023 01:57AM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.hamiltonian_solver.html:2989,perform,performed,2989,psi4manual/1.8.x/api/psi4.driver.p4util.hamiltonian_solver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.p4util.hamiltonian_solver.html,6,['perform'],['performed']
Performance,"n the iterative subspace that will; be stored before a collapse is done.; maxiter (int) – The maximum number of iterations; verbose (int) – The amount of logging info to print (0 -> none, 1 -> some, 2 -> all but matrices, >2 -> everything). Returns:. best_values (numpy.ndarray) – (nroots, ) The best approximation of the eigenvalues of w, computed on the last iteration of the solver; best_R (List[vector]) – (nroots) The best approximation of the right hand eigenvectors, \(X+Y\), computed on the last iteration of the solver.; best_L (List[vector]) – (nroots) The best approximation of the left hand eigenvectors, \(X-Y\), computed on the last iteration of the solver.; stats (List[Dict]) – Statistics collected on each iteration. count : int, iteration number; res_norm : np.ndarray (nroots, ), the norm of residual vector for each roots; val : np.ndarray (nroots, ), the eigenvalue corresponding to each root; delta_val : np.ndarray (nroots, ), the change in eigenvalue from the last iteration to this ones; collapse : bool, if a subspace collapse was performed; product_count : int, the running total of product evaluations that was performed; done : bool, if all roots were converged. Notes; The solution vector is normalized to 1/2; The solver will return even when maxiter iterations are performed without convergence.; The caller must check stats[-1]['done'] for failure and handle each case accordingly.; References; R. Eric Stratmann, G. E. Scuseria, and M. J. Frisch, “An efficient; implementation of time-dependent density-functional theory for the; calculation of excitation energies of large molecules.” J. Chem. Phys.,; 109, 8218 (1998). table of contents. hamiltonian_solver; hamiltonian_solver(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; hamiltonian_solver. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.hamiltonian_solver.html:2989,perform,performed,2989,psi4manual/1.9.x/api/psi4.driver.p4util.hamiltonian_solver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.p4util.hamiltonian_solver.html,6,['perform'],['performed']
Performance,"n theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]; Function complementary to optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:; Matrix – Total electronic gradient in Hartrees/Bohr. Returns:; (Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, core.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/opt.html:16960,optimiz,optimize,16960,psi4manual/1.7.x/opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/opt.html,4,['optimiz'],['optimize']
Performance,"n theory; Supported methods; Basic FNOCC Keywords; Advanced FNOCC Keywords. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic OCC Keywords; Advanced OCC Keywords; Basic DFOCC Keywords; Advanced DFOCC Keywords; Conventional (Non-OO) Coupled-Cluster and Møller–Plesset Perturbation Theories. PSIMRCC Implementation of Mk-MRCC Theory; A Simple Example; Orbital ordering and selection of the model space. CI: Configuration Interaction; Basic DETCI Keywords; Arbitrary Order Perturbation Theory; Arbitrary Order Coupled-Cluster Theory. SAPT: Symmetry-Adapted Perturbation Theory; The S2 approximation and scaling; A First Example; Advanced example; SAPT0; Higher-Order SAPT; MP2 Natural Orbitals; Charge-Transfer in SAPT; Monomer-Centered Basis Computations; Computations with Mid-bonds; Interpreting SAPT Results; Spin-Flip SAPT. F/I-SAPT: Functional Group and/or Intramolecular SAPT; F-SAPT: A Representative Example; Order-1 Visualization with PyMol; Difference F-SAPT Analysis; I-SAPT: A Representative Example; Cube File Visualization with PyMol; F/I-SAPT Keywords; Additional Notes. ADC: Ab Initio Polarization Propagator; Partial Renormalization Scheme; Using the ADC(2) code; Theory. Scalar relativistic Hamiltonians; A First Example; Basis sets options; Theory. Geometry Optimization; Basic Keywords; Optimizing Minima; Hessian; Transition States, Reaction Paths, and Constrained Optimizations; Dealing with problematic optimizations; Direct manipulation of the optmization coordinates; Convergence Criteria; Output. Evaluation of One-Electron Properties — oeprop(); Basic Keywords; Properties evaluated on a grid. Vibrational and Thermochemical Analysis; Keywords; Examples; Output. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/methods-1.html:3353,optimiz,optimizations,3353,psi4manual/1.2.1/methods-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/methods-1.html,2,['optimiz'],['optimizations']
Performance,"n to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/opt-1.html:2720,perform,perform,2720,psi4manual/1.1.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/opt-1.html,20,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"n to create a molecule object of name name from the geometry in string geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or jus",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261298,perform,perform,261298,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,4,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"n type. Type: string; Possible Values: RHF, ROHF, UHF, TWOCON, MCSCF, GENERAL; Default: RHF. REFERENCE (SCF); SCF — Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. REFERENCE (STABILITY); STABILITY — Reference wavefunction type. Type: string; Possible Values: RHF, UHF, ROHF; Default: RHF. REFERENCE (TRANSQT); TRANSQT — Reference wavefunction type. Type: string; Default: RHF. REFERENCE (TRANSQT2); TRANSQT2 — Reference wavefunction type. Type: string; Default: RHF. REFERENCE_SYM (DETCI); DETCI (Expert) — Irrep for CI vectors; -1 = find automatically. This option allows the user to look for CI vectors of a different irrep than the reference. This probably only makes sense for Full CI, and it would probably not work with unit vector guesses. Numbering starts from zero for the totally-symmetric irrep. Type: integer; Default: -1. RELAX_GUESS_ORBITALS (DCFT); DCFT (Expert) — Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. RELAX_TAU (DCFT); DCFT (Expert) — Controls whether to relax tau during the cumulant updates or not. Type: boolean; Default: true. REORDER (TRANSQT); TRANSQT — Do reorder MOs?. Type: boolean; Default: false. REPL_OTF (DETCI); DETCI (Expert) — Do string replacements on the fly in DETCI? Can save a gigantic amount of memory (especially for truncated CI’s) but is somewhat flaky and hasn’t been tested for a while. It may work only works for certain classes of RAS calculations. The current code is very slow with this option turned on. Type: boolean; Default: false. RESPONSE_ALGORITHM (DCFT); DCFT — The algorithm to use for the solution of the response equations for the analytic gradients and properties. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: TWOSTEP. RESTART (CCENERGY); CCENERGY — Do restart the coupled-cluster iterations from old",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:106240,perform,performing,106240,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,2,['perform'],['performing']
Performance,"n use it to simplify tasks by; modifying some of the example input files supplied with PSI4; in the psi4/samples directory.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; create separate input files for each distance to be studied. But most of; these input files are identical, except that the interatomic distance is; different. Psithon lets you specify all this in a single input file,; looping over the different distances with an array like this:; Rvals=[2.5, 3.0, 4.0].; Let’s also suppose you want to do counterpoise (CP) corrected energies.; Counterpoise correction involves computing the dimer energy and then; subtracting out the energies of the two monomers, each evaluated in the; dimer basis. Again, each of these computations could be run in a separate; input file, but because counterpoise correction is a fairly standard; procedure for intermolecular interactions, PSI4 knows about it and has; a built-in routine to perform counterpoise correction. It only needs to; know what method you want to do the counterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s monomer; B. This last issue of specifying the monomers separately was already dealt; with in the previous SAPT example, where we saw that two dashes in the; molecule block can be used to separate monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for Ne2 at; a series of different interatomic distances. And let’s print out a table; of the interatomic distances we’ve considered, and the CP-corrected CCSD(T); interaction energies (in kcal mol-1) at each geometry. Doing all this; in a single input is surprisingly easy in PSI4. Here’s the input; (available as tu6-cp-ne2).; #! Example potential energy surface scan and CP-correction for Ne2. memory 250 mb. molecule dimer {; Ne; --; N",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/tutorial-1.html:15322,perform,perform,15322,psi4manual/4.0b2/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/tutorial-1.html,8,['perform'],['perform']
Performance,"n water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ao; single-point CCSD(T)/qz2p on water with aobasis. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-rohf-ccsd; single-point CCSD/qz2p on NH2. cfour/sp-uhf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/kw-2; testing best practices options, part ii. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/kw-8; Translating psi4 options to cfour, part ii. cfour/sp-rhf-ccsd_t_; single-point CCSD(T)/qz2p on water. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rohf-ccsd_t_-ao-ecc; sing",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html:3514,optimiz,optimization,3514,psi4manual/1.8.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"n which a full CI is performed in some smaller; set of active orbitals; it is equivalent to CASSCF except without; any orbital optimization. It can be invoked via energy('fci'); with appropriate values selected for FROZEN_DOCC and; ACTIVE. For CI computations, there is no difference between; FROZEN_DOCC and RESTRICTED_DOCC, or between; FROZEN_UOCC and RESTRICTED_UOCC. There are; differences between these keywords for sec:mcscf. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. CI_MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 24. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. ICORE¶. Specifies how to han",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:6995,optimiz,optimized,6995,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['optimiz'],['optimized']
Performance,"n ». Optimize¶. optimize(name[, func, mode, dertype, molecule])[source]¶; Function to perform a geometry optimization. Aliases :opt(). Returns:(float) Total electronic energy of optimized structure in Hartrees. Psi variables:. CURRENT ENERGY. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual]. df-mp2; MP2 with density fitting [manual]. conv-mp2; conventional MP2 (non-density-fitting) [manual]. mp2.5; MP2.5 [manual]. mp3; third-order MP perturbation theory [manual]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. ocepa; orbital-optimized coupled electron pair approximation [manual]. cepa0; coupled electron pair approximation(0) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b3lyp; B3LYP Hybrid-GGA Exchange-Correlation Functional. b3lyp-chg; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Chai and Head-Gordon Dispersion Correction. b3lyp-d; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D2 Dispersion Correction. b3lyp-d1; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D1 Dispersion Correction. b3lyp-d3; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (zero-damping) Dispersion Correction. b3lyp-d3bj; B3LYP Hybrid-GGA Exchange-Correlation Functional w/ Grimme’s -D3 (BJ-damping) Dispersion Correction. b3_x; Becke88 GGA Exchange (B3LYP weighting). b88_x; Becke88 GGA Exchange. b97-0; B97-0 Hybrid-GGA Exchange-Correlation F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/opt-1.html:1145,optimiz,optimized,1145,psi4manual/4.0b4/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/opt-1.html,4,['optimiz'],['optimized']
Performance,"n'). # Drop the files out; with open(traverse_filename, 'w') as fh:; fh.write("""""" %-11s %-24s %-24s %11s\n"""""" % ('N', 'Energy', 'HOMO Energy', 'Converged')); for k in range(len(Ns)):; fh.write("""""" %11.3E %24.16E %24.16E %11d\n"""""" % (Ns[k], energies[k], potentials[k], convs[k])). with open(stats_filename, 'w') as fh:; fh.write("""""" %6s %6s %6s %6s %6s %6s\n"""""" % ('N', 'Na', 'Nb', 'Charge', 'Mult', 'HOMO')); for line in stats:; fh.write(line). optstash.restore(); return E. [docs]def ip_fitting(name: Union[str, Callable], omega_l: float = 0.05, omega_r: float = 2.5, omega_convergence: float = 1.0e-3, maxiter: int = 20, **kwargs) -> float:; """"""Optimize DFT omega parameter for molecular system. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; omega_l; Minimum omega to be considered during fitting.; omega_r; Maximum omega to be considered during fitting.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; omega_convergence; Threshold below which to consider omega converged. (formerly omega_tolerance); maxiter; Maximum number of iterations towards omega convergence. Returns; -------; float; Optimal omega parameter. """"""; optstash = p4util.OptionsState(; ['SCF', 'REFERENCE'],; ['SCF', 'GUESS'],; ['SCF', 'DF_INTS_IO'],; ['SCF', 'DFT_OMEGA'],; ['DOCC'],; ['SOCC']). kwargs = p4util.kwargs_lower(kwargs). # By default, do not read previous 180 orbitals file; read = False; read180 = ''; if 'read' in kwargs:; read = True; read180 = kwargs['read']. if core.get_option('SCF', 'REFERENCE') != 'UKS':; core.print_out("""""" Requested procedure `ip_fitting` runs further calculations with UKS reference.\n""""""); core.set_local_option('SCF', 'REFERENCE', 'UKS'). # Make sure the molecule the user provided is the active one, and neutral; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). if molecule.molec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:14979,tune,tuned,14979,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,2,['tune'],['tuned']
Performance,"n', 'w'); fmaster.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); fmaster.write(format_molecule_for_input(molecule)); fmaster.write(format_options_for_input()); format_kwargs_for_input(fmaster, 2, **kwargs); fmaster.write(""""""%s('%s', **kwargs)\n\n"""""" % (optimize.__name__, lowername)); fmaster.write(instructionsM); fmaster.close(). for n, displacement in enumerate(displacements):; rfile = 'OPT-%s-%s' % (opt_iter, n + 1); #rfile = 'OPT-fd-%s' % (n + 1). # Build string of title banner; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' Gradient %d Computation: Displacement %d')\n"""""" % (opt_iter, n + 1); banners += """"""PsiMod.print_out('\\n')\n\n"""""". if (opt_mode.lower() == 'continuous'):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; PsiMod.get_active_molecule().set_geometry(displacement). # Perform the energy calculation; #E = func(lowername, **kwargs); func(lowername, **kwargs); E = PsiMod.get_variable('CURRENT ENERGY'); #E = func(**kwargs). # Save the energy; energies.append(E). # S/R: Write each displaced geometry to an input file; elif (opt_mode.lower() == 'sow'):; PsiMod.get_active_molecule().set_geometry(displacement). # S/R: Prepare molecule, options, and kwargs; freagent = open('%s.in' % (rfile), 'w'); freagent.write('# This is a psi4 input file auto-generated from the gradient() wrapper.\n\n'); freagent.write(format_molecule_for_input(molecule)); freagent.write(format_options_for_input()); format_kwargs_for_input(freagent, **kwargs). # S/R: Prepare function call and energy save; freagent.write(""""""electronic_energy = %s('%s', **kwargs)\n\n"""""" % (func.__name__, lowername)); freagent.write(""""""PsiMod.print_out('\\nGRADIENT RESULT: computation %d for item %d """""" % (os.getpid(), n + 1)); fr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:27416,Load,Load,27416,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Load'],['Load']
Performance,"n'. if shortlong:; for at in range(nat):; text += """"""{:{presp}}{:5d} {:{width}}"""""".format('',; at + 1,; atom_lbl[at],; width=prewidth - 8,; presp=presp); for vib in row:; if vib is None:; break; text += (""""""{:^{width}.{prec}f}"""""" * 3).format(*(vibinfo[normco].data[:, vib].reshape(nat, 3)[at]),; width=int(width / 3),; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'; else:; for at in range(nat):; for xyz in range(3):; text += """"""{:{presp}}{:5d} {} {:{width}}"""""".format('',; at + 1,; 'XYZ' [xyz],; atom_lbl[at],; width=prewidth - 14,; presp=presp); for vib in row:; if vib is None:; break; text += """"""{:^{width}.{prec}f}"""""".format((vibinfo[normco].data[3 * at + xyz, vib]),; width=width,; prec=ncprec); text += """"""{:{colsp}}"""""".format('', colsp=colsp); text += '\n'. return text. [docs]; def thermo(vibinfo, T: float, P: float, multiplicity: int, molecular_mass: float, E0: float, sigma: int, rot_const: np.ndarray, rotor_type: str = None) -> Tuple[Dict[str, Datum], str]:; """"""Perform thermochemical analysis from vibrational output. Parameters; ----------; E0; Electronic energy [Eh] at well bottom at 0 [K], :psivar:`CURRENT ENERGY`.; molecular_mass; Mass in [u] of molecule under analysis.; multiplicity; Spin multiplicity of molecule under analysis.; rot_const; (3,) rotational constants in [cm^-1] of molecule under analysis.; sigma; The rotational or external symmetry number determined from the point group.; rotor_type; The rotor type for rotational stat mech purposes: RT_ATOM, RT_LINEAR, other.; T; Temperature in [K]. Psi default 298.15. Note that 273.15 is IUPAC STP.; P; Pressure in [Pa]. Psi default 101325. Note that 100000 is IUPAC STP. Returns; -------; dict, str; First is every thermochemistry component in atomic units along with input conditions.; Second is formatted presentation of analysis. """"""; sm = collections.defaultdict(float). # conditions; therminfo = {}; therminfo['E0'] = Datum('E0', 'Eh', E0); therminfo['B'] = Datum('rotational constan",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html:30816,Perform,Perform,30816,psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/qcdb/vib.html,3,['Perform'],['Perform']
Performance,"n(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print info. # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed.' % ndisp; energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print ' %d' % (n + 1),; if (n + 1) == ndisp:; print '\n',. # Load in displacement into the active molecule; molecule.set_geometry(displacement); ; # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print ' Computation complete.'; ; # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute force constants. Presently identical to fre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:47544,Load,Load,47544,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,1,['Load'],['Load']
Performance,"n); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section as modeled in; psi4/tests/plugin_libcim/__init__.py).; """"""Plugin docstring. """"""; __version__ = '0.1'; __author__ = 'Psi4 Developer'. # Load Python modules; from pymodule import *. # Load C++ plugin; import os; import psi4; plugdir = os.path.split(os.path.abspath(__file__))[0]; sofile = plugdir + '/' + os.path.split(plugdir)[1] + '.so'; psi4.plugin_load(sofile). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Documentation; for building documentation and Available Plugins; for this file’s final destination. To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. Table Of Contents. Plugins: Adding New Functionality to PSI4; Modular Approach to Development; Creating a New Plugin; Files in a Plugin Directory. Previous topic; Contributions: Intro to Programming in PSI4; Next topic; Best Practices for Python Functions; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta5] » ; Contributions: Intro to Programming in PSI4 ». © Copyright 2013, The Psi4 Project.; Last updated on Jul 08, 2013.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/plugins-1.html:7154,load,loading,7154,psi4manual/4.0b5/plugins-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/plugins-1.html,4,['load'],['loading']
Performance,"n, QMC Parameters, VWN5 Spin Polarization. dldf; Dispersionless Hybrid Meta-GGA XC Functional. dldf+d; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. dldf+d09; Dispersionless Hybrid Meta-GGA XC Functional w/ Podeszwa and Szalewicz Dispersion Correction. name; calls method in Stanton and Gauss’s CFOUR program [manual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Moller-Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Moller-Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matrix – Total electronic gradient in Hartrees/Bohr. Returns:(Matrix, Wavefunction) – gradient and wavefunction when return_wfn specified. Examples:. >>> # [1] Single-point dft gradient getting the gradient; >>> # in file, psi4.Matrix, and np.array forms; >>> set gradient_write on; >>> G, wfn = gradient('b3lyp-d', return_wfn=True); >>> wfn.gradient().print_out(); >>> np.array(G). Previous topic; Counterpoise Correct; Next topic; Harmonic Vibrational Analy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:12046,optimiz,optimization,12046,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"n, and ZAPTn. run_detci_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a configuration interaction calculation, namely FCI,; CIn, MPn, and ZAPTn, computing properties. run_dfmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted MP2 calculation. run_dfmp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 gradient calculation. run_dfmp2_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a DFMP2 property calculation. run_dfocc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. run_dfocc_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. run_dfocc_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-fitted (non-)orbital-optimized MPN or CC computation. run_dft(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory calculation. run_dft_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a density-functional-theory gradient calculation. run_dft_property(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; DFT calculations. This is a simple alias to run_scf(); since DFT properties all handled through oeprop. run_dmrgci(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an DMRG calculation. run_dmrgscf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an DMRG calculation. run_efp(name, **kwargs)[source]¶; Function encoding sequence of module calls for a pure EFP; computation (ignore any QM atoms). run_eom_cc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an EOM-CC ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html:162573,optimiz,optimized,162573,psi4manual/1.0.0/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"n, so no molecule section in input file. Portions of the full databases, restricted by subset keyword, are computed by sapt0 and dfmp2 methods. cfour/sp-rohf-ccsdt; single-point CCSDT/qz2p on NH2. cfour/sp-rohf-ccsd_t_-fc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis, frozen-core. cfour/psi-rhf-scsmp2; MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-a24-grad; geometry after three optimization cycles on A24 database, cfour matches psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-rhf-mp2; single-point MP2/qz2p on water. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/psi-mp4; MP4 energy components. Checks that computed identically between cfour and psi4. cfour/mints5-grad; geometry after three optimization cycles for a variety of input formats, references from psi4. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/sp-rhf-ccsd; single point CCSD/qz2p on water. cfour/sp-rhf-ccsd_t_-fc; single-point CCSD(T)/qz2p on water with ecc, aobasis, and frozen-core. cfour/sp-rohf-mp2-sc; single-point MP2/qz2p on NH2. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/sp-uhf-ccsd_t_; single-point CCSD(T)/qz2p. cfour/opt-rhf-ccsd_t_; optimization CCSD(T)/dzp on water. cfour/kw-7; Translating psi4 options to cfour, part i. cfour/sp-uhf-scf; single-point HF/qz2p on NH2. cfour/sp-rhf-ccsdt; single-point CCSDT/qz2p on water. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-rohf-scf; single-point HF/qz2p on NH2. cfour/kw-4; Basis set spherical/Cartesian with basis and puream. cfour/psi-r",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html:1432,optimiz,optimization,1432,psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_cfour-1.html,2,['optimiz'],['optimization']
Performance,"n, filename, *[, debug, strict_label]); Function to write wavefunction information in wfn to filename in Gaussian FCHK format. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis with A. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Return the total memory allocation in bytes. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **k",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:18260,optimiz,optimize,18260,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,1,['optimiz'],['optimize']
Performance,"n-Core Operator'; moH = core.Matrix(PSIF_MO_FZC, wfn.nmopi(), wfn.nmopi()); moH.load(core.IO.shared_object(), constants.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC = moH.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = mo_idx(il[0][index] + offset); col = mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), constants.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), constants.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tole",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:5994,load,load,5994,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['load'],['load']
Performance,"n-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc42; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = length, omega = (589 355 nm). opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. cc3; cc3: RHF-CCSD/6-31G** H2O geometry optimization and vibrational frequency analysis by finite-differences of gradients. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc23; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}B_1\) state of H2O+ (A1 excitation). fnocc3; Test FNO-QCISD(T) computation. scf3; File retention, docc, socc, and bond distances specified explicitly. adc2; ADC/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. dfcasscf-sp; CASSCF/6-31G** energy point. opt10; 6-31G MP2 transition-state optimization with initial, computed Hessian. scf1; RHF cc-pVQZ energy for the BH molecule, with Cartesian input. pubchem2; Superficial test of PubChem interface. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. ao-dfcasscf-sp; CASSCF/6-31G** energy point. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:21464,optimiz,optimization,21464,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"n-source quantum chemistry software package; #; # Copyright (c) 2007-2022 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Dict, Optional, Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and syst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:1201,optimiz,optimizations,1201,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizations']
Performance,"n-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import copy; import json; import logging; import os; import re; import shutil; from typing import Dict, Optional, Union. import numpy as np. from psi4 import core # for typing. from . import driver_cbs, driver_findif, driver_nbody, driver_util, p4util, qcdb, task_planner; from .constants import constants, nppp, nppp10, pp; from .mdi_engine import mdi_run; from .p4util.exceptions import *; from .procrouting import *; from .task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_pres",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:1203,optimiz,optimizations,1203,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizations']
Performance,"n-source quantum chemistry software package; #; # Copyright (c) 2007-2023 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import json; import os; import re; import copy; import shutil; import sys; import logging; from typing import Dict, Optional, Union; import logging. import numpy as np. from psi4 import core # for typing; from psi4.driver import driver_util; from psi4.driver import driver_cbs; from psi4.driver import driver_nbody; from psi4.driver import driver_findif; from psi4.driver import task_planner; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import pp, nppp, nppp10; from psi4.driver.p4util.exceptions import *; from psi4.driver.procrouting import *; from psi4.driver.mdi_engine import mdi_run; from psi4.driver.task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and syst",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html:1203,optimiz,optimizations,1203,psi4manual/1.8.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizations']
Performance,"n-source quantum chemistry software package; #; # Copyright (c) 2007-2024 The Psi4 Developers.; #; # The copyrights for code used from other parties are included in; # the corresponding files.; #; # This file is part of Psi4.; #; # Psi4 is free software; you can redistribute it and/or modify; # it under the terms of the GNU Lesser General Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #; """"""; Nexus of psi4.driver module with primary user-facing functions, including; single-point energies, geometry optimizations, properties, and vibrational; frequency calculations. """"""; import copy; import json; import logging; import os; import re; import shutil; from typing import Dict, Optional, Union. import numpy as np. from psi4 import core # for typing. from . import driver_cbs, driver_findif, driver_nbody, driver_util, p4util, qcdb, task_planner; from .constants import constants, nppp, nppp10, pp; from .mdi_engine import mdi_run; from .p4util.exceptions import *; from .procrouting import *; from .task_base import AtomicComputer. # never import wrappers or aliases into this file. logger = logging.getLogger(__name__). def _energy_is_invariant(gradient_rms, stationary_criterion=1.e-2):; """"""Polls options and probes `gradient` to return whether current method; and system expected to be invariant to translations and rotations of; the coordinate system. """"""; stationary_point = gradient_rms < stationary_criterion # 1.e-2 pulled out of a hat. mol = core.get_active_molecule(); efp_pres",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html:1210,optimiz,optimizations,1210,psi4manual/master/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/master/_modules/psi4/driver/driver.html,2,['optimiz'],['optimizations']
Performance,"n/aliases.py.; The rationale for the changes is indicated in the comments below.; def run_mp2_5(name, **kwargs):; lowername = name.lower() # handy variable with name keyword in lowercase; kwargs = kwargs_lower(kwargs) # removes case sensitivity in keyword names. # Run detci calculation and collect conventional quantities; energy('mp3', **kwargs); e_scf = PsiMod.get_variable('SCF TOTAL ENERGY'); ce_mp2 = PsiMod.get_variable('MP2 CORRELATION ENERGY'); ce_mp3 = PsiMod.get_variable('MP3 CORRELATION ENERGY'); e_mp2 = e_scf + ce_mp2 # reform mp2 and mp3 total energies for printing; e_mp3 = e_scf + ce_mp3. # Compute quantities particular to MP2.5; ce_mp25 = 0.5 * (ce_mp2 + ce_mp3); e_mp25 = e_scf + ce_mp25; PsiMod.set_variable('MP2.5 CORRELATION ENERGY', ce_mp25) # add new method's important results; PsiMod.set_variable('MP2.5 TOTAL ENERGY', e_mp25) # to PSI variable repository; PsiMod.set_variable('CURRENT CORRELATION ENERGY', ce_mp25); PsiMod.set_variable('CURRENT ENERGY', e_mp25) # geometry optimizer tracks this variable, permits; # MP2.5 finite difference optimizations; # build string of title banner and print results; banners = ''; banners += """"""PsiMod.print_out('\\n')\n""""""; banners += """"""banner(' MP2.5 ')\n""""""; banners += """"""PsiMod.print_out('\\n')\n\n""""""; exec banners. tables = ''; tables += """""" SCF total energy: %16.8f\n"""""" % (e_scf); tables += """""" MP2 total energy: %16.8f\n"""""" % (e_mp2); tables += """""" MP2.5 total energy: %16.8f\n"""""" % (e_mp25); tables += """""" MP3 total energy: %16.8f\n\n"""""" % (e_mp3); tables += """""" MP2 correlation energy: %16.8f\n"""""" % (ce_mp2); tables += """""" MP2.5 correlation energy: %16.8f\n"""""" % (ce_mp25); tables += """""" MP3 correlation energy: %16.8f\n"""""" % (ce_mp3); PsiMod.print_out(tables) # prints nice header and table of all involved quantities to output file. return e_mp25. One final step is necessary. At the end of the aliases.py file, add; the following line.; procedures['energy']['mp2.5'] = run_mp2_5. This permits the newly defined MP2.5 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html:2405,optimiz,optimizer,2405,psi4manual/4.0b2/quickaddalias-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/quickaddalias-1.html,6,['optimiz'],['optimizer']
Performance,"n; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:112292,perform,perform,112292,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"n; Default: false. PRINT_MOS¶. Flag to print the molecular orbitals. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, PK, OUT_OF_CORE, PS; Default: PK. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 100.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the cc-pVDZ-RI basis set (when availab",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html:1992,perform,performing,1992,psi4manual/4.0b3/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__scf-1.html,4,['perform'],['performing']
Performance,"n; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SINGLETS (CPHF)¶CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF)¶CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA opposite-spin scaling value from SCS-CCSD. Type: double; Default: 0.25. E3_SCALE (OCC)¶OCC — Scaling value for 3rd order energy corre",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:115391,perform,perform,115391,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"n?. Type: boolean; Default: false. REFERENCE¶. Reference wavefunction type. Cfour Interface: Keyword translates into CFOUR_REFERENCE. Type: string; Possible Values: RHF, ROHF, UHF, CUHF, RKS, UKS; Default: RHF. SAVE_JK¶. Keep JK object for later use?. Type: boolean; Default: false. SCF_MEM_SAFETY_FACTOR¶. Memory safety factor for allocating JK. Type: double; Default: 0.75. S_ORTHOGONALIZATION¶. SO orthogonalization: symmetric or canonical?. Type: string; Possible Values: SYMMETRIC, CANONICAL; Default: SYMMETRIC. S_TOLERANCE¶. Minimum S matrix eigenvalue to be used before compensating for linear dependencies. Type: conv double; Default: 1e-7. Convergence Control/Stabilization¶. BASIS_GUESS¶. Accelerate convergence by performing a preliminary scf with this small basis set followed by projection into the full target basis. A value of TRUE turns on projection using the 3-21G small basis set. Type: string; Default: FALSE. DAMPING_CONVERGENCE¶. The density convergence threshold after which damping is no longer performed, if it is enabled. It is recommended to leave damping on until convergence, which is the default. Cfour Interface: Keyword translates into CFOUR_SCF_DAMPING. Type: conv double; Default: 1.0e-18. DAMPING_PERCENTAGE¶. The amount (percentage) of damping to apply to the early density updates. 0 will result in a full update, 100 will completely stall the update. A value around 20 (which corresponds to 20% of the previous iteration’s density being mixed into the current density) could help to solve problems with oscillatory convergence. Type: double; Default: 0.0. DF_BASIS_GUESS¶. When BASIS_GUESS is active, run the preliminary scf in density-fitted mode with this as fitting basis for the small basis set. A value of TRUE turns on density fitting with the default basis, otherwise the specified basis is used. Type: string; Possible Values: basis string; Default: FALSE. DIIS¶. Do use DIIS extrapolation to accelerate convergence?. Type: boolean; Default: true. DIIS_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html:3156,perform,performed,3156,psi4manual/1.2.1/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__scf-1.html,2,['perform'],['performed']
Performance,"n?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Defa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:113547,perform,perform,113547,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"n?. Type: boolean; Default: true. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_QQR_SIEVE (CPHF); CPHF — Do we do the QQR integral sieve of Maurer et al. When false, just uses * the Schwarz sieve. Type: boolean; Default: false. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT); SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF); CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS); GLOBALS — An ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:111264,perform,perform,111264,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,8,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"nError('DFOCC gradients need DF-HF reference, for now.'). if name in ['mp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'FALSE'); elif name in ['omp2']:; psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'). psi4.set_local_option('DFOCC', 'OEPROP', 'TRUE'); psi4.set_local_option('DFOCC', 'DO_SCS', 'FALSE'); psi4.set_local_option('DFOCC', 'DO_SOS', 'FALSE'); psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" DFOCC does not make use of molecular symmetry: """"""; """"""reference wavefunction must be C1.\n""""""). if psi4.get_option('SCF', 'REFERENCE') == 'ROHF':; ref_wfn.semicanonicalize(); dfocc_wfn = psi4.dfocc(ref_wfn). optstash.restore(); return dfocc_wfn. [docs]def run_qchf(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; an density-fitted orbital-optimized MP2 computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'DF_INTS_IO'],; ['DF_BASIS_SCF'],; ['DIE_IF_NOT_CONVERGED'],; ['MAXITER'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'QCHF'],; ['DFOCC', 'E_CONVERGENCE']). psi4.set_local_option('DFOCC', 'ORB_OPT', 'TRUE'); psi4.set_local_option('DFOCC', 'WFN_TYPE', 'QCHF'); psi4.set_local_option('DFOCC', 'QCHF', 'TRUE'); psi4.set_local_option('DFOCC', 'E_CONVERGENCE', 8). psi4.set_local_option('SCF', 'DF_INTS_IO', 'SAVE'); psi4.set_local_option('SCF', 'DIE_IF_NOT_CONVERGED', 'FALSE'); psi4.set_local_option('SCF', 'MAXITER', 1). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, use_c1=True, **kwargs) # C1 certified; else:; if ref_wfn.molecule().schoenflies_symbol() != 'c1':; raise ValidationError("""""" QCHF does not make use of molecular symmetry: """"""; """"""reference wavefunctio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:40569,optimiz,optimized,40569,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['optimiz'],['optimized']
Performance,n_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj. b3lyp-d3mbj. b3lyp-nl; B3LYP-nl Hyb-GGA Exchange-Correlation Functional. b3lyp5; B3LYP5 Hyb-GGA Exchange-Correlation Functional. b3lyps; B3LYPs Hyb-GGA Exchange-Correlation Functional. b3p86; B3P86 Hyb-GGA Exchange-Correlation Functional. b3p86-d3bj. b3pw91; B3PW91 Hyb-GGA Exchange-Correlation Functional. b3pw91-d3bj. b3pw91-nl; B3PW91-n,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html:3082,optimiz,optimized,3082,psi4manual/1.4.0/api/psi4.driver.opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.opt-1.html,25,['optimiz'],['optimized']
Performance,"nagedMethodError(['select_olccd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_olccd_gradient', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd(name, **kwargs):; """"""Function selecting the algorithm for a CCSD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('CC_TYPE'); module = core.get_global_option('QC_MODULE'); #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:17990,perform,performance,17990,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,9,['perform'],['performance']
Performance,"nal Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; --------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ~; 2 -76.0270226684",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/tutorial-1.html:6052,optimiz,optimize,6052,psi4manual/1.4.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/tutorial-1.html,9,['optimiz'],['optimize']
Performance,"nal Energy: -38.92533462456894. Notice we added a new keyword, set reference uhf, to the input. For; open-shell molecules, we have a choice of unrestricted orbitals; (unrestricted Hartree–Fock, or UHF), or restricted orbitals (restricted; open-shell Hartree–Fock, or ROHF). Usually, UHF is a little easier to; converge (although it may be more susceptible to spin contamination than; ROHF). Geometry Optimization and Vibrational Frequency Analysis¶; The above examples were simple single-point energy computations; (as specified by the energy() function). Of course there are other; kinds of computations to perform, such as geometry optimizations and; vibrational frequency computations. These can be specified by replacing; energy() with optimize() or frequency(), respectively.; Here’s an example of optimizing the H2O molecule using Hartree–Fock with; a cc-pVDZ basis set (located in; tu3-h2o-opt).; #! Optimize H2O HF/cc-pVDZ. molecule h2o {; O ; H 1 0.96; H 1 0.96 2 104.5; }. set basis cc-pVDZ; optimize('scf'). This should perform a series of gradient computations. The gradient points; which way is downhill in energy, and the optimizer then modifies the; geometry to follow the gradient. After a few cycles, the geometry should; converge with a message like Optimization is complete!. As indicated; in the following table (printed by the optimizer at the end of the; computation and grep-able with ~), the energy decreases with each step,; and the maximum force on each atom also decreases with each step (in; principle these numbers could increase in some iterations, but here they do; not).; 1; 2; 3; 4; 5; 6; 7--------------------------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------------------------- ~; 1 -76.026632734857 -76.026632734857 0.01523505 0.01245744 0.02742199 0.02277500 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/tutorial-1.html:6015,optimiz,optimize,6015,psi4manual/1.1.0/tutorial-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/tutorial-1.html,6,['optimiz'],['optimize']
Performance,"nal Frequency Analysis¶; The above examples were simple single-point energy computations (as; specified by the psi4.energy(); API; function). Of course there are other kinds of computations to perform,; such as geometry optimizations and vibrational frequency computations.; These can be specified by replacing psi4.energy(); API; with psi4.optimize(); API; or psi4.frequency(); API,; respectively.; Let’s take a look at an example of optimizing the H\(_2\)O; molecule using Hartree-Fock with a cc-pVDZ basis set.; Now, here comes the real beauty of running Psi4 interactively: above,; when we computed the energy of H\(_2\)O with HF/cc-pVDZ, we; defined the Psi4 molecule object h2o. Since we’re still in the; Python shell, as long as you executed that block of code, we can reuse; the h2o molecule object in our optimization without redefining it,; by adding the molecule=h2o argument to the psi4.optimize(); API; function:. In [5]:. psi4.set_options({'reference': 'rhf'}); psi4.optimize('scf/cc-pvdz', molecule=h2o). Optimizer: Optimization complete!. Out[5]:. -76.02703272937504. This should perform a series of gradient computations. The gradient; points which way is downhill in energy, and the optimizer then modifies; the geometry to follow the gradient. After a few cycles, the geometry; should converge with a message like Optimization complete!. As; indicated in the following table (printed by the optimizer at the end of; the computation and grep-able with ~), the energy decreases with; each step, and the maximum force on each atom also decreases with each; step (in principle, these numbers could increase in some iterations, but; here they do not).; --------------------------------------------------------------------------------------------------------------- ~  Step         Total Energy             Delta E       MAX Force       RMS Force        MAX Disp        RMS Disp  ~ ---------------------------------------------------------------------------------------------------------",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:7364,optimiz,optimize,7364,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['optimiz'],['optimize']
Performance,"nal expense and completeness of the; model space are nontrivial. Hence, the user is advised to develop; a good working knowledge of multi-reference and RAS CI methods before; attempting to use the program for a production-level project. This user’s; manual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. Higher order; single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. [1]FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CAS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/detci-1.html:4902,perform,performed,4902,psi4manual/1.2.1/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/detci-1.html,6,['perform'],['performed']
Performance,"nal frequency analysis by finite-differences of gradients. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cbs-parser; mtd/basis syntax examples. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. dct7; DCT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. fci-dipole; 6-31G H2O Test FCI Energy Point. scf-response3; UHF Dipole Polarizability Test. opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For “fixed” coordinates, the final value is provided by the user. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. fsapt2; A very quick correctness test of F-SAPT (see fsapt1 for a real example). pubchem1; Benzene vertical singlet-triplet energy difference computation, using the PubChem database to obtain the initial geometry, which is optimized at the HF/STO-3G level, before computing single point energies at the RHF, UHF and ROHF levels of theory. opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. frac-traverse; Scan fractional occupation of electrons updated values due to new BraggSlater radii. nbody-convergence; Convergence of many-body gradients of different BSSE schemes. cbs-xtpl-alpha; Extrapolated water energies. extern3; External potential calculation with one Ghost atom and one point charge at the same position. sapt-exch-disp-inf; SAPT0 with S^inf exch-disp20. cbs-delta-energy; Extrapolated energies with delta correction. dft1; DFT Functional Test all values update for new BraggSlater radii. scf-coverage; Lithium test for coverage. soscf-dft; Triple and Singlet Oxygen energy SOSCF, also tests non-symmetric density matrices. dft-custom-mgga; updated dldf reference to new BraggSlater radii Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been don",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html:35566,optimiz,optimized,35566,psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimized']
Performance,"nal theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual]. ccd; coupled cluster doubles (CCD) [manual]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). psi4.gradient(name[, molecule, return_wfn, func, dertype])[source]¶; Function complementary to :py:func:~driver.optimize(). Carries out one gradient pass,; deciding analytic or finite difference. Returns:Matri",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/opt-1.html:4010,perform,perform,4010,psi4manual/1.3.2/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/opt-1.html,4,"['optimiz', 'perform']","['optimize', 'perform']"
Performance,"nal theory calculation. """""". if (psi4.get_global_option('FREEZE_CORE') == 'TRUE'):; raise ValidationError('Frozen core is not available for DCFT.'). # Bypass the scf call if a reference wavefunction is given; ref_wfn = kwargs.get('ref_wfn', None); if ref_wfn is None:; ref_wfn = scf_helper(name, **kwargs). # Ensure IWL files have been written; proc_util.check_iwl_file_from_scf_type(psi4.get_option('SCF', 'SCF_TYPE'), ref_wfn). dcft_wfn = psi4.dcft(ref_wfn); return dcft_wfn. [docs]def run_dcft_gradient(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; DCFT gradient calculation. """"""; optstash = p4util.OptionsState(; ['GLOBALS', 'DERTYPE']). psi4.set_global_option('DERTYPE', 'FIRST'); dcft_wfn = run_dcft(name, **kwargs). derivobj = psi4.Deriv(dcft_wfn); derivobj.set_tpdm_presorted(True); grad = derivobj.compute(). dcft_wfn.set_gradient(grad). optstash.restore(); return dcft_wfn. [docs]def run_dfocc(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a density-fitted or Cholesky-decomposed; (non-)orbital-optimized MPN or CC computation. """"""; optstash = p4util.OptionsState(; ['SCF', 'SCF_TYPE'],; ['SCF', 'DF_INTS_IO'],; ['DFOCC', 'WFN_TYPE'],; ['DFOCC', 'ORB_OPT'],; ['DFOCC', 'DO_SCS'],; ['DFOCC', 'DO_SOS'],; ['DFOCC', 'READ_SCF_3INDEX'],; ['DFOCC', 'CHOLESKY'],; ['DFOCC', 'CC_LAMBDA']). def set_cholesky_from(mtd_type):; type_val = psi4.get_global_option(mtd_type); if type_val == 'DF':; psi4.set_local_option('DFOCC', 'CHOLESKY', 'FALSE'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'DF'); psi4.print_out("""""" SCF Algorithm Type (re)set to DF.\n""""""); elif type_val == 'CD':; psi4.set_local_option('DFOCC', 'CHOLESKY', 'TRUE'); # Alter default algorithm; if not psi4.has_option_changed('SCF', 'SCF_TYPE'):; psi4.set_global_option('SCF_TYPE', 'CD'); psi4.print_out("""""" SCF Algorithm Type (re)set to CD.\n""""""); if psi4.get_option('SCF', 'SCF_TYPE') != 'CD':; psi4.set_local",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:33465,optimiz,optimized,33465,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['optimiz'],['optimized']
Performance,"nalysis. JCP 127 014306. Uses; :py:func:`~psi4.driver.cbs` to evaluate the following; expression. SCF employs a three-point extrapolation according; to :py:func:`~psi4.driver.driver_cbs.scf_xtpl_helgaker_3`. MP2, CCSD, and; CCSD(T) employ two-point extrapolation performed according to; :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. CCSDT and CCSDT(Q); are plain deltas. This wrapper requires :ref:`Kallay's MRCC code <sec:mrcc>`. .. math:: E_{total}^{\text{FPA}} = E_{total,\; \text{SCF}}^{\text{cc-pV[Q56]Z}} \; + E_{corl,\; \text{MP2}}^{\text{cc-pV[56]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD}}^{\text{CCSD(T)}}\big\vert_{\text{cc-pV[56]Z}} \; + \delta_{\text{CCSD(T)}}^{\text{CCSDT}}\big\vert_{\text{cc-pVTZ}} \; + \delta_{\text{CCSDT}}^{\text{CCSDT(Q)}}\big\vert_{\text{cc-pVDZ}}. >>> # [1] single-point energy by this composite method; >>> energy('allen_focal_point'). >>> # [2] finite-difference geometry optimization embarrasingly parallel; >>> optimize('allen_focal_point', mode='sow'). """""". # SCF; kwargs['scf_basis'] = kwargs.get('scf_basis', 'cc-pV[Q56]Z'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.scf_xtpl_helgaker_3). # delta MP2 - SCF; kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'cc-pV[56]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD - MP2; kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'mrccsd'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'cc-pV[56]Z'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.corl_xtpl_helgaker_2). # delta CCSD(T) - CCSD; kwargs['delta2_wfn'] = kwargs.get('delta2_wfn', 'mrccsd(t)'); kwargs['delta2_wfn_lesser'] = kwargs.get('delta2_wfn_lesser', 'mrccsd'); kwargs['delta2_basis'] = kwargs.get('delta2_basis', 'cc-pV[56]Z'); kwargs['delta2_scheme'] = kwargs.get('delta2",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:5416,optimiz,optimization,5416,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,"name() == 'stdout':; retcode = subprocess.call('dmrcc', shell=True); else:; retcode = subprocess.call('dmrcc >> ' + current_directory + '/' + PsiMod.outfile_name(), shell=True). if retcode < 0:; print('MRCC was terminated by signal %d' % -retcode, file=sys.stderr); exit(1); elif retcode > 0:; print('MRCC errored %d' % retcode, file=sys.stderr); exit(1). except OSError as e:; print('Execution failed: %s' % e, file=sys.stderr); exit(1). # Restore the OMP_NUM_THREADS that the user set.; if omp_num_threads_found == True:; if PsiMod.has_option_changed('MRCC', 'MRCC_OMP_NUM_THREADS') == True:; os.environ['OMP_NUM_THREADS'] = omp_num_threads_user. # Scan iface file and grab the file energy.; e = 0.0; for line in file('iface'):; fields = line.split(); m = fields[1]; try:; e = float(fields[5]); PsiMod.set_variable(m + ' ENERGY', e); except ValueError:; continue. # The last 'e' in iface is the one the user requested.; PsiMod.set_variable('CURRENT ENERGY', e). # Load the iface file; iface = open('iface', 'r'); iface_contents = iface.read(). # Delete mrcc tempdir; os.chdir('..'); try:; # Delete unless we're told not to; if (keep == False and not('path' in kwargs)):; shutil.rmtree(mrcc_tmpdir); except OSerror as e:; print('Unable to remove MRCC temporary directory %s' % e, file=sys.stderr); exit(1). # Revert to previous current directory location; os.chdir(current_directory). # Reopen output file; PsiMod.reopen_outfile(). # If we're told to keep the files or the user provided a path, do nothing.; if (keep != False or ('path' in kwargs)):; PsiMod.print_out('\nMRCC scratch files have been kept.\n'); PsiMod.print_out('They can be found in ' + mrcc_tmpdir). # Dump iface contents to output; PsiMod.print_out('\n'); banner('Full results from MRCC'); PsiMod.print_out('\n'); PsiMod.print_out(iface_contents). return e. [docs]def run_cepa(name, **kwargs):; """"""Function encoding sequence of PSI module calls for; a cepa-like calculation. >>> energy('cepa(1)'). """"""; lowername = name.lower(); kw",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/proc.html:44451,Load,Load,44451,psi4manual/4.0b3/_modules/proc.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/proc.html,1,['Load'],['Load']
Performance,"name); Load FCHK file into a string. fcidump(wfn[, fname, oe_ints]); Save integrals to file in FCIDUMP format as defined in Comp. fcidump_from_file(fname); Function to read in a FCIDUMP file. find_approximate_string_matches(seq1, ...); Find list of approximate (within max_distance) matches to string seq1 among options. free_atom_volumes(wfn, **kwargs); Computes free-atom volumes using MBIS density partitioning. freq(name, **kwargs); Function to compute harmonic vibrational frequencies. frequencies(name, **kwargs); Function to compute harmonic vibrational frequencies. frequency(name, **kwargs); Function to compute harmonic vibrational frequencies. gdma(wfn[, datafile]); Function to use wavefunction information in wfn and, if specified, additional commands in filename to run GDMA analysis. geometry(geom[, name]); Function to create a molecule object of name name from the geometry in string geom. get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Run IPIBroker to connect to i-pi. join_path(prefix, *args). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. mdi_run(scf_method, **kwargs); Begin functioning as an MDI engine. message_box([message, max_width, min_width]); put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/psi4api-1.html:19018,optimiz,optimize,19018,psi4manual/1.5.0/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/psi4api-1.html,3,['optimiz'],['optimize']
Performance,"name* values of the energy(), optimize(),; response(), and frequency() function. *name* can be assumed lowercase by here. """"""; import os; import sys; import shutil; import subprocess; import warnings. import numpy as np; from qcelemental import constants. from psi4 import extras; from psi4 import core; from psi4.driver import p4util; from psi4.driver import qcdb; from psi4.driver import psifiles as psif; from psi4.driver.p4util.exceptions import ManagedMethodError, PastureRequiredError, ValidationError; #from psi4.driver.molutil import *; from psi4.driver.qcdb.basislist import corresponding_basis; # never import driver, wrappers, or aliases into this file. from .roa import run_roa; from . import proc_util; from . import empirical_dispersion; from . import dft; from . import mcscf; from . import response; from . import solvent. # ATTN NEW ADDITIONS!; # consult http://psicode.org/psi4manual/master/proc_py.html. def select_mp2(name, **kwargs):; """"""Function selecting the algorithm for a MP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ/dfmp2/detci/fnocc. # MP2_TYPE exists largely for py-side reasoning, so must manage it; # here rather than passing to c-side unprepared for validation. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'DFMP2']:; func = run_dfmp2; elif mtd_type == 'CD",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:2257,perform,performance,2257,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,4,['perform'],['performance']
Performance,"name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError(['select_fnoccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('CC_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/ccenergy/fnocc. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference in ['UHF', 'ROHF']:; if mtd_type == 'CONV':; if module in ['', 'CCENERGY']:; func = run_ccenergy. if func is None:; raise ManagedMethodError(['select_ccsd_t_', name, 'CC_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). [docs]def select_ccsd_t__gradient(name, *",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html:21977,perform,performance,21977,psi4manual/1.0.0/_modules/procedures/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/procedures/proc.html,1,['perform'],['performance']
Performance,"name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError(['select_omp2', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Considering only [df]occ. func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError(['select_omp2_gradient', name, 'MP2_TYPE', mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_omp2_property(name, **kwargs):; """"""Function selecting the algorithm for an OMP2 property call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); mtd_type = core.get_global_option('MP2_TYPE'); module = core.get_global_option('QC_MODULE'); # Consi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html:6310,perform,performance,6310,psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/procrouting/proc.html,9,['perform'],['performance']
Performance,"name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_lccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for a LCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'); all_electron = (core.get_global_option('FREEZE_CORE') == ""FALSE""). func = None; if reference in ['RHF', 'UHF']:; if mtd_type == 'CONV':; if all_electron:; if module in ['', 'OCC']:; func = run_occ_gradient; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc_gradient. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module, all_electron]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference in ['RHF', 'UHF', 'ROHF', 'RKS', 'UKS']:; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_olccd_gradient(name, **kwargs):; """"""Function selecting the algorithm for an OLCCD gradient call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_M",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:19943,perform,performance,19943,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['perform'],['performance']
Performance,"namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True). monomerB = dimer.extract_subsets(2,1); psi4.IO.change_file_namespace(97, 'monomerA', 'monomerB'); psi4.IO.set_default_namespace('monomerB'); set {; stability_analysis none; }; EmonB, wfn_monB = energy('scf',molecule=monomerB,return_wfn=True). psi4.IO.change_file_namespace(97, 'monomerB', 'dimer'); psi4.IO.set_default_namespace('dimer'). psi4.sapt(wfn_dimer,wfn_monA,wfn_monB). In this way, any of the SCF options can be tweaked for individual fragments.; For optimal efficiency, the example uses set df_ints_io save to keep file 97,; which contains the three-index integrals for density fitting. set df_ints_io load; then instructs the program to read these integrals from disk instead of recomputing; them. For each SCF computation, we use psi4.IO.set_default_namespace to uniquely; name scratch files. In the following SCF step, only file 97 is renamed using; psi4.IO.change_file_namespace so that integrals can be read from it.; For more information on stability analysis, see the stability; documentation. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of closed-shell SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of the accuracy of closed-shell SAPT0 and other SAPT; truncations, using different basis sets, is reported in; [Parker:2014:094106]. In particular, an empirical recipe for scaled SAPT0; can yield improved performance and has been inclu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/sapt-1.html:12891,load,load,12891,psi4manual/1.1.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/sapt-1.html,2,['load'],['load']
Performance,"natural orbitals for CCSD(T), QCISD(T), CEPA, and MP4; Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Interface to gau2grid by D. G. A. Smith; Interface to gCP by S. Grimme; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Index; PSI Variables by Alpha; PSI4: Open-Source Quantum Chemistry; A PSI4 Tutorial; Function Intercalls; Interfaces: Enhancing PSI4 Capabilities; Introduction; Interface to LIBEFP by I. Kaliman; Interface to Libint by E. Valeev; Interface to Libxc by M. A. L. Marques; Adding Add-Ons; Git, Versioning; Managing: Git, Conda, CMake and all that; Release Procedures; MCSCF: Multi-Configurational Self-Consistent-Field; Theoretical Methods: SCF to FCI; Interface to Molden — molden(); Interface to MRCC by M. Kállay; <no title>; Basis Set Superposition Corrections; Notes on Options; Notes on Options; Interface to NumPy; OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Evaluation of One-Electron Properties — oeprop(); Geometry Optimization — optimize() and gradient(); LibOptions: globals, locals, has_changed and all that; Geometry Optimization; Interface to PCMSolver by R. Di Remigio; PEP1: Proposing PsiPEP for PSI4; Psi4FockCI: A General Fock-Space CI For Spin-Flip And IP/EA; Spin-Network-Scaled MP2 (SNS-MP2) by D. E. Shaw; Plugin v2rdm_casscf by A. E. DePrince; Creating New Plugins; Adding Methods to Driver; Linear Algebra in PSI4; Community Code of Conduct; Programming with the Core Libraries; Debugging and Profiling; Programmers FAQ; Integrating New Features into PSI4; Where to Get Help; Integrals in PSI4; Introduction to Programming in PSI4; Adding New Code to PSI4; Setting Up Your Development Environment; C++ Style; Python Style; General layout of the core: where new C++ code should live; Ways to Add Code: Psi4NumPy, Plugins, Full Integration; Welcome to New Programmers; Property; PSI4 API: Linking C++ and Python; PsiAPI Tutorial: Using Psi4 as a Pyt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/index-wcopy.html:785841,optimiz,optimize,785841,index-wcopy.html,https://psicode.org,https://psicode.org/index-wcopy.html,7,['optimiz'],['optimize']
Performance,"nc = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == ""UHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif mtd_type == ""DF"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif mtd_type == ""CD"":; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == ""ROHF"":; if mtd_type == 'CONV':; if module in ['', 'MRCC'] and which(""dmrcc"", return_bool=True):; func = run_mrcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_cisd(name, **kwargs):; """"""Function selecting the algorithm for a CISD energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module in ['', 'FNOCC']:; func = run_cepa; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['', 'DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_mp4(name, **kwargs):; """"""Function selecting the algorithm for a MP4 energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:29402,perform,performance,29402,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['perform'],['performance']
Performance,"nce = (""; 1 3 0.95; 2 4 0.95; ""); }. Note that the effect of the frozen and fixed keywords is independent of; how the geometry of the molecule was input (whether Z-matrix or cartesian, etc.).. To scan the potential energy surface by optimizing at several fixed values; of the dihedral angle of HOOH.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24; 25molecule hooh {; 0 1; H 0.850718 0.772960 0.563468; O 0.120432 0.684669 -0.035503; O -0.120432 -0.684669 -0.035503; H -0.850718 -0.772960 0.563468; }. set {; basis cc-pvdz; intrafrag_step_limit 0.1; }. dihedrals = [100,110,120,130,140,150]; PES = []. for phi in dihedrals:; my_string = ""1 2 3 4 "" + str(phi); set optking fixed_dihedral = $my_string; E = optimize('scf'); PES.append((phi, E)). print ""\n\tcc-pVDZ SCF energy as a function of phi\n""; for point in PES:; print ""\t%5.1f%20.10f"" % (point[0], point[1]). Dealing with problematic optimizations¶; Although optking is continuously improved with robustness in mind, some; attempted optimizations will inevitably fail to converge to the desired minima.; For difficult cases, the following suggestions are made. As for any optimizer, computing the Hessian and limiting the step size will; successfully converge a higher percentage of cases. The default settings have; been chosen because they perform efficiently for common, representative test sets.; More restrictive, cautious steps are sometimes necessary.; DYNAMIC_LEVEL allows optking to change the method of optimization; toward algorithms that, while often less efficient, may help to converge difficult; cases. If this is initially set to 1, then optking, as poor steps are detected,; will increase the level through several forms of more robust and cautious algorithms.; The changes will reduce the trust radius, allow backward steps (partial line; searching), add cartesian coordinates, switch to cartesian coordinates, and take; steepest-descent steps.; The developers have found the OPT_COORDIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/optking-1.html:8070,optimiz,optimizations,8070,psi4manual/1.1.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/optking-1.html,12,['optimiz'],['optimizations']
Performance,"nce criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. SS vectors stored per root. Type: integer; Default: 5. T3_WS_INCORE¶. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. VECS_CC3¶. Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT¶. Vectors stored per root. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. table of contents. CCEOM; General; ABCD; CACHELEVEL; CACHETYPE; CC3_FOLLOW_ROOT; CC_NUM_THREADS; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; EOM_GUESS; EOM_REFERENCE; E_CONVERGENCE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; R_CONVERGENCE; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT. Expert; EXCITATION_RANGE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cceom-1.html:7188,CACHE,CACHELEVEL,7188,psi4manual/1.4.0/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__cceom-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"nce criterion for norm of the residual vector in the Davidson algorithm for the CIS guess to CC-EOM. Type: conv double; Default: 1e-6. SS_SKIP_DIAG¶. Do skip diagonalization of Hbar SS block?. Type: boolean; Default: false. SS_VECS_PER_ROOT¶. SS vectors stored per root. Type: integer; Default: 5. T3_WS_INCORE¶. Do build W intermediates required for eom_cc3 in core memory?. Type: boolean; Default: false. VECS_CC3¶. Vectors stored in CC3 computations. Type: integer; Default: 10. VECS_PER_ROOT¶. Vectors stored per root. Type: integer; Default: 12. Expert¶. EXCITATION_RANGE¶. The depth into the occupied and valence spaces from which one-electron excitations are seeded into the Davidson guess to the CIS (the default of 2 includes all single excitations between HOMO-1, HOMO, LUMO, and LUMO+1). This CIS is in turn the Davidson guess to the EOM-CC. Expand to capture more exotic excited states in the EOM-CC calculation. Type: integer; Default: 2. WFN¶. Wavefunction type. Type: string; Possible Values: EOM_CCSD, EOM_CC2, EOM_CC3; Default: EOM_CCSD. table of contents. CCEOM; General; ABCD; CACHELEVEL; CACHETYPE; CC3_FOLLOW_ROOT; CC_NUM_THREADS; COLLAPSE_WITH_LAST; COLLAPSE_WITH_LAST_CC3; COMPLEX_TOLERANCE; EOM_GUESS; EOM_REFERENCE; E_CONVERGENCE; FULL_MATRIX; LOCAL; LOCAL_CUTOFF; LOCAL_DO_SINGLES; LOCAL_FILTER_SINGLES; LOCAL_GHOST; LOCAL_METHOD; LOCAL_PRECONDITIONER; LOCAL_WEAKP; MAXITER; NEW_TRIPLES; NUM_AMPS_PRINT; OVERLAP_CHECK; PROP_ROOT; PROP_SYM; REFERENCE; RESTART_EOM_CC3; RHF_TRIPLETS; ROOTS_PER_IRREP; R_CONVERGENCE; SCHMIDT_ADD_RESIDUAL_TOLERANCE; SEMICANONICAL; SINGLES_PRINT; SS_E_CONVERGENCE; SS_R_CONVERGENCE; SS_SKIP_DIAG; SS_VECS_PER_ROOT; T3_WS_INCORE; VECS_CC3; VECS_PER_ROOT. Expert; EXCITATION_RANGE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. Appendices; Keywords by Module; CCEOM. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__cceom-1.html:7188,CACHE,CACHELEVEL,7188,psi4manual/1.5.0/autodir_options_c/module__cceom-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodir_options_c/module__cceom-1.html,4,['CACHE'],"['CACHELEVEL', 'CACHETYPE']"
Performance,"nce opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; # print(""about to generate displacements""); displacements = core.fd_geoms_1_0(moleculeclone); # print(displacements); ndisp = len(displacements); # print(""generated displacments""). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:38153,perform,perform,38153,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['perform'],['perform']
Performance,"nce opt run in one job or files farmed out; opt_mode = kwargs.get('mode', 'continuous').lower(); if opt_mode == 'continuous':; pass; elif opt_mode == 'sow':; if dertype == 1:; raise ValidationError(""""""Optimize execution mode 'sow' not valid for analytic gradient calculation.""""""); elif opt_mode == 'reap':; opt_linkage = kwargs.get('linkage', None); if opt_linkage is None:; raise ValidationError(""""""Optimize execution mode 'reap' requires a linkage option.""""""); else:; raise ValidationError(""""""Optimize execution mode '%s' not valid."""""" % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; psi4.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). optstash.restore(); if return_wfn:; return (wfn.gradient(), wfn); else:; return wfn.gradient(). else:; psi4.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Shifting the geometry so need to copy the active molecule; moleculeclone = molecule.clone(). # Obtain list of displacements; displacements = psi4.fd_geoms_1_0(moleculeclone); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print("""""" %d displacements needed ..."""""" % (ndisp), end=''); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if opt_mode == 'sow':; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/driver.html:36922,perform,perform,36922,psi4manual/1.0.0/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/driver.html,1,['perform'],['perform']
Performance,nce; optimization is to be performed. hessian_with (str) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual] [details]. hf; HF self consistent field (SCF) [manual] [details]. dct; density cumulant (functional) theory [manual]. mp2; 2nd-order Møller–Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Møller–Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual] [details]. omp3; orbital-optimized third-order MP perturbation theory [manual] [details]. omp2.5; orbital-optimized MP2.5 [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. eom-ccsd; equation of motion (EOM) CCSD [manual]. name; calls method DFT [manual]. b1lyp; B1LYP Hyb-GGA Exchange-Correlation Functional. b1lyp-d3bj2b. b1lyp-d3bjatm. b1lyp-d3zero2b. b1lyp-d3zeroatm. b1pw91; B1PW91 Hyb-GGA Exchange-Correlation Functional. b1wc; B1WC Hyb-GGA Exchange-Correlation Functional. b3lyp; B3LYP Hyb-GGA Exchange-Correlation Functional. b3lyp-d3bj2b. b3lyp-d3bjatm. b3lyp-d3mbj2b. b3lyp-d3mbj,MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html:3164,optimiz,optimized,3164,psi4manual/1.7.x/api/psi4.driver.opt.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.opt.html,20,['optimiz'],['optimized']
Performance,"ncies. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html:1055,perform,performed,1055,psi4manual/1.8.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequencies.html,2,['perform'],['performed']
Performance,"ncies. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; frequencies. frequencies¶. psi4.driver.frequencies(name, **kwargs)¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequencies.html:1055,perform,performed,1055,psi4manual/1.9.x/api/psi4.driver.frequencies.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequencies.html,2,['perform'],['performed']
Performance,"nction) → psi4.core.Matrix¶; Returns the Alpha Density Matrix. Da_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Alpha Density subset. Db(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Density Matrix. Db_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the requested Beta Density subset. Fa(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix. Fa_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the Alpha Fock Matrix in the requested basis (AO,SO). Fb(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Beta Fock Matrix. Fb_subset(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns the Beta Fock Matrix in the requested basis (AO,SO). H(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the ‘Core’ Matrix (Potential + Kinetic) Integrals. MOM_excited_; Are we to do excited-state MOM?. MOM_performed_; MOM performed current iteration?. PCM_enabled(self: psi4.core.Wavefunction) → bool¶; Whether running a PCM calculation. S(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the One-electron Overlap Matrix. V_potential(self: psi4.core.HF) → psi4.core.VBase; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix; Returns the Beta Kohn-Sham Potential Matrix. X(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Lagrangian Matrix. alpha_orbital_space(self: psi4.core.Wavefunction, arg0: str, arg1: str, arg2: str) → psi4.core.OrbitalSpace¶; docstring. aotoso(self: psi4.core.Wavefunction) → psi4.core.Matrix¶; Returns the Atomic Orbital to Symmetry Orbital transformer. array_variable(self: psi4.core.Wavefunction, arg0: str) → psi4.core.Matrix¶; Returns copy of the requested (case-insensitive) Matrix QC variable. array_variables(self: psi4.core.Wavefunction) → Dict[str, psi4",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html:11137,perform,performed,11137,psi4manual/1.3.2/api/psi4.core.hf.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.hf.html,1,['perform'],['performed']
Performance,"nction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. mode (string) – \(\Rightarrow\) 'continuous' \(\Leftarrow\) || 'sow' || 'reap'; For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file ('continuous') or are to be farmed out in an; embarrassingly parallel fashion ('sow'/'reap')/ For the latter,; run an initial job with 'sow' and follow instructions in its output file.; For maximum flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or string) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. 1; 2>>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). 1; 2; 3; 4; 5>>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, ir",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/freq-1.html:2628,perform,performed,2628,psi4manual/1.1.0/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/freq-1.html,13,['perform'],['performed']
Performance,"ncy. Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html:1055,perform,performed,1055,psi4manual/1.8.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.driver.frequency.html,2,['perform'],['performed']
Performance,"ncy. Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. PSI4 API: Linking C++ and Python; frequency. frequency¶. psi4.driver.frequency(name, **kwargs)[source]¶; Function to compute harmonic vibrational frequencies. Aliases:; frequencies(), freq(). Returns:; float – Total electronic energy in Hartrees. Returns:; (float, Wavefunction) – energy and wavefunction when return_wfn specified. Parameters:. name (str) – 'scf' || 'mp2' || 'ci5' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. molecule (molecule) – h2o || etc.; The target molecule, if not the last molecule defined. return_wfn (boolean) – 'on' || \(\Rightarrow\) 'off' \(\Leftarrow\); Indicate to additionally return the Wavefunction; calculation result as the second element (after float energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. func (function) – \(\Rightarrow\) gradient \(\Leftarrow\) || energy || cbs; Indicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword freq_func instead of func. dertype (dertype) – \(\Rightarrow\) 'hessian' \(\Leftarrow\) || 'gradient' || 'energy'; Indicates whether analytic (if available- they’re not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. irrep (int or str) – \(\Rightarrow\) -1 \(\Leftarrow\) || 1 || 'b2' || 'App' || etc.; Indicates which symmetry block (Cotton ordering) of vibrational; frequencies to be computed. 1, '1', or 'a1' represents; \(a_1\), requesting only the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF and UHF. For all other methods, Frequencies will; proceed through finite differences acc",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequency.html:1055,perform,performed,1055,psi4manual/1.9.x/api/psi4.driver.frequency.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.driver.frequency.html,2,['perform'],['performed']
Performance,"nd CPHF coefficients. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dft-omega; Test omega is setable updated wb97x_20,wb97x_03 to account for new BraggSlater radii. dfomp3-grad1; DF-OMP3 cc-pVDZ gradients for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. cc5a; RHF CCSD(T) STO-3G frozen-core energy of C4NH4 Anion. omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. dft1; DFT Functional Test all values update for new BraggSlater radii. opt-full-hess-every; SCF/sto-3g optimization with a hessian every step. mints3; Test individual integral objects for correctness. mp2-1; All-electron MP2 6-31G** geometry optimization of water. sapt8; SAPT0(ROHF) open-shell computation of CN - Ne interaction energy First with jun-cc-pVDZ and density fitted integrals with ROHF Then with cc-pVDZ and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with ROHF. cc28; CCSD/cc-pVDZ optical rotation calculation (length gauge only) on Z-mat H2O2. fd-freq-gradient; SCF STO-3G finite-differences frequencies from gradients for H2O. dct-grad4; Unrestricted DF-DCT ODC-12 gradient for O2 with cc-pVTZ/cc-pVTZ-RI standard/auxiliary basis set. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. matrix1; An example of using BLAS and LAPACK calls directly from the Psi input file, demonstrating matrix multiplication, eigendecomposition, Cholesky decomposition and LU decomposi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:23703,optimiz,optimization,23703,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"nd DIRECT algorithms. The use of DF is highly recommended for KS-DFT, as the; errors incurred by the density fitting approximation (in a proper -JKFIT; auxiliary basis) are orders of magnitude smaller than the accuracy of any known; functional. IP Fitting¶; In collaboration with the Bredas group, we have developed an automatic procedure; for IP fitting of LRC functionals, based on a modified Regula-Falsi method. To; perform IP fitting, one simply calls the ip_fitting() Python macro, after; setting up a standard LRC UKS computation. A representative example is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18memory 512 MB. molecule h2o {; 0 1 # must be neutral; O; H 1 1.0; H 1 1.0 2 104.5; # IP fitting runs in C1 symmetry; }. set {; reference uks # UKS, as we need to do neutral/cation; basis cc-pvdz; scf_type df; }. # Optional arguments are minimum omega, maximum omega, molecule object; omega = ip_fitting('wb97', 0.4, 2.0, molecule=h2o). This performs IP fitting on water for wB97/cc-pVDZ with density fitting. A; number of neutral and cation single-point computations are run at various values; of \(\omega\), though the later iterations are much faster due to reuse of; the DF tensors, and starting from the neutral/cation orbitals of the previous; \(\omega\). The procedure can also be assisted by providing a tighter guess; for the bounds of \(\omega\). This small test case has a tuned; \(\omega\) of 1.700, hence the bounds of 0.4 and 2.0. Larger systems,; particularly conjugated systems, will typically have an optimized \(\omega\); between 0.1 and 0.5. Fractional Particle Curves¶; The behavior of the electronic energy and HOMO energy across fractional numbers; of electrons is extremely useful for elucidating the MSIE behavior of various; functional technologies. PSI4 features an efficient fractional-particle DFT; code, written into the UKS spin specialization. Due to a combination of DIIS and; reuse of integrals/guess orbitals across a range of fractional o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/dft-1.html:23181,perform,performs,23181,psi4manual/1.3.2/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/dft-1.html,2,['perform'],['performs']
Performance,"nd Psi_a_6_4-A1.cube. The subscript a in; Psi_a_5_1-B1.cube indicates an alpha orbital. The first number (5) is the index of the; orbital while 1-B1 indicates that this is the first orbital that belongs to the B1 irrep.; The file Psi_a_5_1-B1.cube begins with two comment lines:; 1; 2Psi4 Gaussian Cube File.; Property: Psi_a_5_1-B1. Isocontour range for 85% of the density: (0.0787495,-0.0787495). The second line reports the isocontour values that capture 85% of the probability density using; the least amount of grid points. This quantity is determined for orbitals and densities. The; fraction of the density captured by the isocontour values is by default 0.85, but can; be changed via the option |globals__cubeprop_isocontour_threshold|. Note; If your cube plots are too coarse, try to decrease the grid spacing via; the option CUBIC_GRID_SPACING. If the edges of your plot are cut then; increase the size of the grid via the option CUBIC_GRID_OVERAGE. Cubeprop Tasks¶; The cubeprop utility can be provided a list of tasks to perform.; Tasks are specified by the CUBEPROP_TASKS option, which is a list of strings; that identify the tasks. Several tasks are available. These include:. ORBITALS [Default if CUBEPROP_TASKS is not specified]; Produces cube representations of the molecular orbitals; \(\psi_q(\mathbf{r})\). Orbitals are sorted according to increasing; orbital energy ignoring symmetry.; DENSITY; This task can be used to obtain the alpha and beta electron densities,; \(\rho_\alpha(\mathbf{r})\) and \(\rho_\beta(\mathbf{r})\), together; with the total density; \(\rho(\mathbf{r}) = \rho_\alpha(\mathbf{r}) + \rho_\beta(\mathbf{r})\),; and the spin density; \(\rho(\mathbf{r}) = \rho_\alpha(\mathbf{r}) - \rho_\beta(\mathbf{r})\).; BASIS_FUNCTIONS; This task is useful to produce cube files of the atomic orbital basis; functions \(\chi_\mu(\mathbf{r})\).; ESP; Calculates the total (nuclear + electronic) electrostatic potential; \(V(\mathbf{r})\). Note; The ESP task requires th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html:3326,perform,perform,3326,psi4manual/1.2.1/cubeprop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/cubeprop-1.html,2,['perform'],['perform']
Performance,"nd Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → Annotated[List[Annotated[List[float], FixedSize(3)]], FixedSize(3)]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: floa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html:1103,Perform,Performs,1103,psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"nd Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → Annotated[list[Annotated[list[float], FixedSize(3)]], FixedSize(3)]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: floa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html:1110,Perform,Performs,1110,psi4manual/master/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.SymmetryOperation.html,1,['Perform'],['Performs']
Performance,"nd Python; SymmetryOperation. SymmetryOperation¶. class psi4.core.SymmetryOperation¶; Bases: pybind11_object; Class to provide a 3 by 3 matrix representation of a symmetry operation, such as a rotation or reflection.; Methods Summary. E(self); Set equal to E. c2_x(self); Set equal to C2 about the x axis. c2_y(self); Set equal to C2 about the y axis. c2_z(self); Set equal to C2 about the z axis. i(self); Set equal to an inversion. matrix(self); Return the matrix for the operation on Cartesians. operate(self, arg0); Performs the operation arg2 * arg1. rotate_n(self, arg0); Set equal to a clockwise rotation by 2pi/n. rotate_theta(self, arg0); Set equal to a clockwise rotation by theta. sigma_xy(self); Set equal to reflection in xy plane. sigma_xz(self); Set equal to reflection in xz plane. sigma_yz(self); Set equal to reflection in yz plane. trace(self); Returns trace of transformation matrix. transform(self, arg0); Performs the transform arg2 * arg1 * arg2~. transpose(self); Performs transposition of matrix operation. unit(self); Set equal to a unit matrix. zero(self); Zero out the symmetry operation. Methods Documentation. E(self: psi4.core.SymmetryOperation) → None¶; Set equal to E. c2_x(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the x axis. c2_y(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the y axis. c2_z(self: psi4.core.SymmetryOperation) → None¶; Set equal to C2 about the z axis. i(self: psi4.core.SymmetryOperation) → None¶; Set equal to an inversion. matrix(self: psi4.core.SymmetryOperation) → List[List[float[3]][3]]¶; Return the matrix for the operation on Cartesians. operate(self: psi4.core.SymmetryOperation, arg0: psi4.core.SymmetryOperation) → psi4.core.SymmetryOperation¶; Performs the operation arg2 * arg1. rotate_n(self: psi4.core.SymmetryOperation, arg0: int) → None¶; Set equal to a clockwise rotation by 2pi/n. rotate_theta(self: psi4.core.SymmetryOperation, arg0: float) → None¶; Set equal to a clockwise rotatio",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.SymmetryOperation.html:1101,Perform,Performs,1101,psi4manual/1.7.x/api/psi4.core.SymmetryOperation.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.SymmetryOperation.html,2,['Perform'],['Performs']
Performance,"nd Python; fchk. fchk¶. psi4.driver.fchk(wfn, filename, *, debug=False, strict_label=True)[source]¶; Function to write wavefunction information in wfn to filename in; Gaussian FCHK format. New in version 0.6. Returns; None. Parameters. wfn (Wavefunction) – set of molecule, basis, orbitals from which to generate fchk file; filename (str) – destination file name for FCHK file; debug (bool) – returns a dictionary to aid with debugging; strict_label (bool) – If true set a density label compliant with what Gaussian would write. A warning will be printed if this is not possible.; Otherwise set the density label according to the method name. Notes. A description of the FCHK format is http://wild.life.nctu.edu.tw/~jsyu/compchem/g09/g09ur/f_formchk.htm; The allowed headers for methods are general and limited, i.e., “Total SCF|MP2|CI|CC Density”,; PSI4 will try to find the right one for the current calculation. If strict_label=False the PSI4 method name will be used as label.; Not all theory modules in PSI4 are compatible with the FCHK writer.; A warning will be printed if a theory module is not supported.; Caution! For orbital-optimized correlated methods (e.g. DCT, OMP2) the ‘Orbital Energy’ field contains ambiguous data. Examples. Parameters. wfn (psi4.core.Wavefunction) – ; filename (str) – ; debug (bool) – ; strict_label (bool) – . >>> # [1] FCHK file for DFT calculation; >>> E, wfn = energy('b3lyp', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] FCHK file for correlated densities; >>> E, wfn = gradient('ccsd', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk'). >>> # [2] Write FCHK file with non-standard label.; >>> E, wfn = gradient('mp2.5', return_wfn=True); >>> fchk(wfn, 'mycalc.fchk', strict_label=False). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; fchk. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.fchk.html:1236,optimiz,optimized,1236,psi4manual/1.6.x/api/psi4.driver.fchk.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.fchk.html,2,['optimiz'],['optimized']
Performance,"nd any add-ons in working order: ctest -L smoke; Run tests matching by name: ctest -R testname; Run tests excluding those by name: ctest -E testname; Run tests matching by label: ctest -L testlabel; Run tests excluding those by label: ctest -LE testlabel. How to see CTest testing errors¶; 1; 2; 3; 4; 5; 6; 7>>> ctest; Test project /your/path/2/psi4/build/directory/tests; Start 248: tu1-h2o-energy; 1/2 Test #248: tu1-h2o-energy ................... Passed 1.73 sec; Start 6: cc1; 2/2 Test #6: cc1 ..............................***Failed 0.07 sec; ... When ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/tests/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a limited number of “smoke” tests are available to be; run via pytest. From the executable:; psi4 –test. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.):; python -c “import psi4; psi4.test()”. Output looks something like the below. PASSED in green is good; (means test ran correctly); SKIPPED in yellow is good (means that; not all software required for test is available); XPASS or XFAIL; in yellow is fine (unexpected pass or expected fail happens when we; include tests that need particular conditions (e.g., multiple cores); to run correctly); FAILED in red is bad.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19test_addons.py::test_gdma PASSED; test_addons.py::test_mrcc SKIPPED; test_addons.py::test_chemps2 PASSED; test_addons.py::test_dftd3 PASSED; test_ad",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:47349,perform,performed,47349,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['perform'],['performed']
Performance,"nd any add-ons in working order: ctest -L smoke; Run tests matching by name: ctest -R testname; Run tests excluding those by name: ctest -E testname; Run tests matching by label: ctest -L testlabel; Run tests excluding those by label: ctest -LE testlabel. How to see CTest testing errors¶; 1; 2; 3; 4; 5; 6; 7>>> ctest; Test project /your/path/2/psi4/build/directory/tests; Start 248: tu1-h2o-energy; 1/2 Test #248: tu1-h2o-energy ................... Passed 1.73 sec; Start 6: cc1; 2/2 Test #6: cc1 ..............................***Failed 0.07 sec; ... When ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/tests/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a limited number of “smoke” tests are available to be; run via pytest. From the executable:; psi4 –test. From the library (PSI4 must be detectable as a Python; module. See the setup note at How to run Psi4 as Python module after compilation; if needed.):; python -c “import psi4; psi4.test()”. How to refer to Psi4¶; Ways to refer to PSI4 in text, in order of decreasing goodness:. as Psi4 in Optima regular font with “si” in custom small caps; according to psi4/media/README.md.; html: <span style=""font-family: Optima, sans-serif; color: #273896;"">P<span style=""font-size: 82%;"">SI</span>4</span>. as Psi4 with “si” in generated small caps; html: <span style=""font-variant: small-caps;"">Psi4</span>. as Psi4 with “si” in lowercase; as psi4 in code; NOT PSI4 or PSI. table of contents. Compiling and Installing from Source; Planning: how to configure Psi4 an",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_planning-1.html:40849,perform,performed,40849,psi4manual/1.1.0/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_planning-1.html,2,['perform'],['performed']
Performance,"nd any add-ons in working order: ctest -L smoke; Run tests matching by name: ctest -R testname; Run tests excluding those by name: ctest -E testname; Run tests matching by label: ctest -L testlabel; Run tests excluding those by label: ctest -LE testlabel. How to see CTest testing errors¶; 1; 2; 3; 4; 5; 6; 7>>> ctest; Test project /your/path/2/psi4/build/directory/tests; Start 248: tu1-h2o-energy; 1/2 Test #248: tu1-h2o-energy ................... Passed 1.73 sec; Start 6: cc1; 2/2 Test #6: cc1 ..............................***Failed 0.07 sec; ... When ctest reports that some (or all) tests have failed, look in your; build directory for file; objdir/tests/Testing/Temporary/LastTest.log. It may have a; .tmp extension, depending on whether the last test was interrupted and; a few other factors. Either way, this file should contain CMake’s testing; output, as well as everything that was printed to the screen. How to test a Psi4 installation¶; ctest requires a connection to source files and cmake; machinery and so can only be performed from objdir; (staged installation). To test an installed PSI4 (full or staged; installation), a limited number of “smoke” tests are available to be; run via pytest. From the executable; psi4 --test. From the library (PSI4 must be detectable as a Python; module. See setup at How to configure paths for PsiAPI; if needed.); python -c ""import psi4; psi4.test()"". From pytest directly. If package pytest-xdist is installed,. can run in parallel, though final file cleanup may not exit cleanly. pytest {prefix}/lib/{PYMOD_INSTALL_LIBDIR}/psi4/tests/ -n`getconf _NPROCESSORS_ONLN`. Output looks something like the below. PASSED in green is good; (means test ran correctly); SKIPPED in yellow is good (means that; not all software required for test is available); XPASS or XFAIL; in yellow is fine (unexpected pass or expected fail happens when we; include tests that need particular conditions (e.g., multiple cores); to run correctly); FAILED in red is bad.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/build_planning-1.html:50298,perform,performed,50298,psi4manual/1.3.2/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/build_planning-1.html,2,['perform'],['performed']
Performance,"nd doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html:37197,perform,perform,37197,psi4manual/1.7.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html,4,['perform'],['perform']
Performance,"nd environment by merging PSIPATH and PATH environment variables; lenv = {; 'PATH': ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':') if x != '']) + \; ':' + os.environ.get('PATH') + \; ':' + core.get_datadir() + '/basis',; 'GENBAS_PATH': core.get_datadir() + '/basis',; 'CFOUR_NUM_CORES': os.environ.get('CFOUR_NUM_CORES'),; 'MKL_NUM_THREADS': os.environ.get('MKL_NUM_THREADS'),; 'OMP_NUM_THREADS': os.environ.get('OMP_NUM_THREADS'),; 'LD_LIBRARY_PATH': os.environ.get('LD_LIBRARY_PATH'); }. if 'path' in kwargs:; lenv['PATH'] = kwargs['path'] + ':' + lenv['PATH']; # Filter out None values as subprocess will fault on them; lenv = {k: v for k, v in lenv.items() if v is not None}. # Load the GENBAS file; genbas_path = qcdb.search_file('GENBAS', lenv['GENBAS_PATH']); if genbas_path:; try:; shutil.copy2(genbas_path, psioh.get_default_path() + cfour_tmpdir); except shutil.Error: # should only fail if src and dest equivalent; pass; core.print_out(""\n GENBAS loaded from %s\n"" % (genbas_path)); core.print_out("" CFOUR to be run from %s\n"" % (psioh.get_default_path() + cfour_tmpdir)); else:; message = """"""; GENBAS file for CFOUR interface not found. Either:; [1] Supply a GENBAS by placing it in PATH or PSIPATH; [1a] Use cfour {} block with molecule and basis directives.; [1b] Use molecule {} block and CFOUR_BASIS keyword.; [2] Allow Psi4's internal basis sets to convert to GENBAS; [2a] Use molecule {} block and BASIS keyword. """"""; core.print_out(message); core.print_out(' Search path that was tried:\n'); core.print_out(lenv['PATH'].replace(':', ', ')). # Generate the ZMAT input file in scratch; if 'path' in kwargs and os.path.isfile('ZMAT'):; core.print_out("" ZMAT loaded from %s\n"" % (psioh.get_default_path() + kwargs['path'] + '/ZMAT')); else:; with open('ZMAT', 'w') as cfour_infile:; cfour_infile.write(write_zmat(lowername, dertype, molecule)). internal_p4c4_info['zmat'] = open('ZMAT', 'r').read(); #core.print_out('\n====== Begin ZMAT input for CFOUR ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html:5880,load,loaded,5880,psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/interface_cfour.html,4,['load'],['loaded']
Performance,"nd not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # no analytic derivatives for scf_type cd; if psi4.get_option('SCF', 'SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError('No analytic derivatives for SCF_TYPE CD.'). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = psi4.get_active_molecule(); molecule.update_geometry(); psi4.set_global_option('BASIS', psi4.get_global_option('BASIS')). # S/R: Mode of operation- whether finite difference opt run in one job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Set method-dependent scf convergence criteria (test on procedures['energy'] since that's guaranteed); if not psi4.has_option_changed('SCF', 'E_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'E_CONVERGENCE', 10); if not psi4.has_option_changed('SCF', 'D_CONVERGENCE'):; if procedures['energy'][lowername] == run_scf or procedures['energy'][lowername] == run_dft:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 8); else:; psi4.set_local_option('SCF', 'D_CONVERGENCE', 10). # Set post-scf convergence criteria (global will cover all correlated modules); if not psi4.has_global_option_changed('E_CONVERGENCE'):; if not procedures['energy'][lowername] == run_scf and not procedu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:33859,Optimiz,Optimize,33859,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,1,['Optimiz'],['Optimize']
Performance,"nd on options (scf_type) being set global or local. This input uses global. cc10; ROHF-CCSD cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. nbody-cp-gradient; Computation of CP-corrected water trimer gradient (geometry from J. Chem. Theory Comput. 11, 2126-2136 (2015)). mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). sapt-sf1; Tests the Psi4 SF-SAPT code. cbs-delta-energy; Extrapolated energies with delta correction. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in \(^{3}B_1\) CH2. cc14; ROHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. mp2-1; All-electron MP2 6-31G** geometry optimization of water. cepa1; cc-pvdz H2O Test CEPA(1) Energy. casscf-fzc-sp; CASSCF/6-31G** energy point. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. opt9; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in internals. cc9a; ROHF-CCSD(T) cc-pVDZ energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mints1; Symmetry tests for a range of molecules. This doesn’t actually compute any energies, but serves as an example of the many ways to specify geometries in Psi4. dfmp2-grad5; Tests DF-MP2 gradient in the presence of a dipole field. pywrap-db3; Test that Python Molecule class processes geometry like psi4 Molecule class. fcidump; test FCIDUMP functionality for rhf/uhf. cc16; ROHF and UHF-B-CCD(T)/cc-pVDZ \(^{3}B_1\) CH2 single-point energy (fzc, MO-basis \(\langle ab|cd ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html:18829,optimiz,optimization,18829,psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"nd those contributing to four-index integrals are neglected. The default is conservative, but there isn’t much to be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. INTS_TOLERANCE (SCF); SCF — Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 0.0. IP_POLES (OCC); OCC — Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. IRC_DIRECTION (OPTKING); OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_STEP_SIZE (OPTKING); OPTKING — IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. IRC_STOP (OPTKING); OPTKING — Decide when to stop IRC calculations. Type: string; Possible Values: ASK, STOP, GO; Default: STOP. ISTOP (DETCI); DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. JOBTYPE (CCLAMBDA); CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. KEEP_INTCOS (OPTKING); OPTKING — Keep internal coordinate definition file. Type: boolean; Default: false. LEVEL_SHIFT (DFOCC); DFOCC — Level shift to aid convergence. Type: double; Default: 0.02. LEVEL_SHIFT (MCSCF); MCSCF — Level shift to aid convergence. Type: double; Default: 0.0. LEVEL_SHIFT (OCC); OCC — Level shift to aid convergence. Type: double; Default: 0.02. LINEAR (CCRESPONSE); CCRESPONSE — Do Bartlett size-extensive linear model?. Type: boolean; Default: false. LINEQ_SOLVER (DFOCC); DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINEQ_SOLVER (OCC); OCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINESEARCH_STATIC_MAX (OPTKING); OPTKING — If doing a static line search, this fixes the largest step, whose largest change in an internal c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:146926,perform,performed,146926,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['perform'],['performed']
Performance,"nd what are their dependencies; How to configure CheMPS2 for building Psi4; How to fix “plugin needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; How to set PSIDATADIR and why. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”; How to fix error “RuntimeError: value for ERI”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. Navigation. Index. modules    .    .    .    .  · ; 1.1;  · . PSI4. Installation and Runtime Configuration. © Copyright 2017, The Psi4 Project.; Last updated on Wednesday, 17 May 201",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/build_faq-1.html:3341,queue,queue,3341,psi4manual/1.1.0/build_faq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/build_faq-1.html,2,['queue'],['queue']
Performance,"nd; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and ""cvs"" not in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; adcc.set_n_threads(core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; f""{ex}""); except Exception as ex:; raise ValidationError(""Unknown exception occured while ""; f""running adcc: '{ex}' ({type(ex).__name__})""); core.print_out(""\n""). # TODO Should a non-converged calculation throw?. #; #",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html:116145,CACHE,CACHELEVEL,116145,psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/_modules/psi4/driver/procrouting/proc.html,1,['CACHE'],['CACHELEVEL']
Performance,"nd; kwargs[""max_iter""] = core.get_option(""ADC"", ""MAXITER""). #; # Determine ADC function method from adcc to run ADC; #; adcrunner = {; ""cvs-adc(1)"": adcc.cvs_adc1, ""cvs-adc(2)"": adcc.cvs_adc2,; ""cvs-adc(2)-x"": adcc.cvs_adc2x, ""cvs-adc(3)"": adcc.cvs_adc3,; ""adc(1)"": adcc.adc1, ""adc(2)"": adcc.adc2,; ""adc(2)-x"": adcc.adc2x, ""adc(3)"": adcc.adc3,; }; if name not in adcrunner:; raise ValidationError(f""Unsupported ADC method: {name}""); if ""cvs"" in name and ""core_orbitals"" not in kwargs:; raise ValidationError(""If a CVS-ADC method is requested, the NUM_CORE_ORBITALS option ""; ""needs to be set.""); if ""core_orbitals"" in kwargs and not ""cvs"" in name:; raise ValidationError(""The NUM_CORE_ORBITALS option needs to be set to '0' or absent ""; ""unless a CVS ADC method is requested.""); if ""cvs"" in name and kwargs[""kind""] in [""spin_flip""]:; raise ValidationError(""Spin-flip for CVS-ADC variants is not available.""). #; # Check for unsupported options; #; for option in [""PR"", ""NORM_TOLERANCE"", ""POLE_MAXITER"", ""SEM_MAXITER"",; ""NEWTON_CONVERGENCE"", ""MEMORY"", ""CACHELEVEL"", ""NUM_AMPS_PRINT""]:; if core.has_option_changed(""ADC"", option):; raise ValidationError(f""ADC backend adcc does not support option '{option}'""). #; # Launch the rocket; #; # Copy thread setup from psi4; try:; adcc.set_n_threads(core.get_num_threads()); except AttributeError:; # Before adcc 0.13.3:; adcc.thread_pool.reinit(core.get_num_threads(), core.get_num_threads()). # Hack to direct the stream-like interface adcc expects to the string interface of Psi4 core; class CoreStream:; def write(self, text):; core.print_out(text). core.print_out(""\n"" + adcc.banner(colour=False) + ""\n""); try:; state = adcrunner[name](ref_wfn, **kwargs, output=CoreStream()); except InvalidReference as ex:; raise ValidationError(""Cannot run adcc because the passed reference wavefunction is ""; ""not supported in adcc. Check Psi4 SCF parameters. adcc reports: ""; ""{}"".format(str(ex))); core.print_out(""\n""). # TODO Should a non-converged calculation thro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html:113860,CACHE,CACHELEVEL,113860,psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/procrouting/proc.html,2,['CACHE'],['CACHELEVEL']
Performance,"ndant quadrupole array [e a0^2] for the configuration interaction singles and doubles level of theory, (3, 3). CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [Eh] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [Eh] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [Eh] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html:23553,optimiz,optimizer,23553,psi4manual/1.6.x/glossary_psivariables.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/glossary_psivariables.html,1,['optimiz'],['optimizer']
Performance,"ndard guess. scf_wavefunction_factory(name, ref_wfn, …); Builds the correct wavefunction from the provided information. set_memory(inputval[, execute]); Function to reset the total memory allocation. set_module_options(module, options_dict); Sets Psi4 module options from a module specification and input dictionary. set_options(options_dict); Sets Psi4 global options from an input dictionary. success(label); Function to print a ‘label…PASSED’ line to screen. vibanal_wfn(wfn[, hess, irrep, molecule, …]). write_eigenvalues(eigs, mo_idx); Prepare multi-line string with one-particle eigenvalues to be written to the FCIDUMP file. xml2dict([filename]); Read XML filename into nested OrderedDict-s. Classes¶. CSXError(msg); Error called when CSX generation fails. ConvergenceError(eqn_description, maxit); Error called for problems with converging and iterative method. Dftd3Error(msg). EmpericalDispersion(alias, dtype, **kwargs). ManagedMethodError(circs). OptimizationConvergenceError(…); Error called for problems with geometry optimizer. ParsingError(msg); Error called for problems parsing a text file. PastureRequiredError(option); Error called when the specified value of option requires some module(s) from Psi4Pasture, but could not be imported. PsiException; Error class for Psi. PsiImportError(msg); Error called for problems import python dependencies. QMMM(). Table([rows, row_label_width, …]); Class defining a flexible Table object for storing data. TestComparisonError(msg); Error called when a test case fails due to a failed compare_values() call. ValidationError(msg); Error called for problems with the input file. datetime(year, month, day[, hour[, minute[, …); The year, month and day arguments are required. Class Inheritance Diagram¶. table of contents. PSI4 API: Linking C++ and Python; psi4.core Module; Functions; Classes; Class Inheritance Diagram. psi4.driver Package; Functions; Classes; Class Inheritance Diagram. «; hide menu. menu; sidebar; »; . Navigation. Index. m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:263349,optimiz,optimizer,263349,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,2,['optimiz'],['optimizer']
Performance,"ndent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; PsiMod.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:27364,optimiz,optimization,27364,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,4,['optimiz'],['optimization']
Performance,"ndent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n""""""; instructionsO += """""" These files may look very peculiar since they contain processed and pickled python\n""""""; instructionsO += """""" rather than normal input. Follow the instructions in OPT-master.in to continue.\n\n""""""; instructionsO += """""" Alternatively, a single-job execution of the gradient may be accessed through\n""""""; instructionsO += """""" the optimization wrapper option mode='continuous'.\n\n""""""; psi4.print_out(instructionsO). instructionsM = """"""\n# Follow the instructions below to carry out this optimization cycle.\n#\n""""""; instructionsM += """"""# (1) Run all of the OPT-%s-*.in input files on any variety of computer architecture.\n"""""" % (str(opt_iter)); instructionsM += """"""# The output file names must be as given below.\n#\n""""""; for rgt in range(ndisp):; pre = 'OPT-' + str(opt_iter) + '-' + str(rgt + 1); instructionsM += """"""# psi4 -i %-27s -o %-27s\n"""""" % (pre + '.in', pre + '.out'); instructionsM += """"""#\n# (2) Gather all the resulting output files in a directory. Place input file\n""""""; instructionsM += """"""# OPT-master.in into that directory and run it. The job will be minimal in\n""""""; instructionsM += """"""# length and give summary results for the gradient step in its output file.\n#\n""""""; if opt_iter == 1:; instructionsM += """"""# psi4 -i %-27s -o %-27s\n#\n"""""" % ('OPT-master.in',",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/driver.html:36798,optimiz,optimization,36798,psi4manual/4.0b5/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/driver.html,2,['optimiz'],['optimization']
Performance,"ndicates the type of calculation to be performed on the molecule.; The default dertype accesses 'gradient' or 'energy', while; 'cbs' performs a multistage finite difference calculation.; If a nested series of python functions is intended (see Function Intercalls),; use keyword opt_func instead of func. mode (string) – 'continuous' || 'sow' || 'reap'; For a finite difference of energies optimization, indicates whether; the calculations required to complete the; optimization are to be run in one file ('continuous') or are to be; farmed out in an embarrassingly parallel fashion; ('sow'/'reap'). For the latter, run an initial job with; 'sow' and follow instructions in its output file. For maximum; flexibility, return_wfn is always on in 'reap' mode. dertype (dertype) – 'gradient' || 'energy'; Indicates whether analytic (if available) or finite difference; optimization is to be performed. hessian_with (string) – 'scf' || 'mp2' || etc.; Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. Warning; Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. Note; Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. name; calls method. efp; efp-only optimizations. scf; Hartree–Fock (HF) or density functional theory (DFT) [manual]. hf; HF self consistent field (SCF) [manual]. dcft; density cumulant functional theory [manual]. mp2; 2nd-order Moller-Plesset perturbation theory (MP2) [manual] [details]. mp3; 3rd-order Moller-Plesset perturbation theory (MP3) [manual] [details]. mp2.5; average of MP2 and MP3 [manual] [details]. omp2; orbital-optimized second-order MP perturbation theory [manual]. omp3; orbital-optimized third-order MP perturbation theory [manual]. omp2.5; orbital-optimized MP2.5 [manual]. lccd; Linear CCD ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/opt-1.html:2578,perform,perform,2578,psi4manual/1.0.0/opt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/opt-1.html,4,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"ndices' : [0, 1],; 'value' : 2.0 },; {'type' : 'angle',; 'indices' : [1, 0, 2],; 'value' : 104.5 }]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Optimize the benzene/water dimer using GeomeTRIC, with the 6 carbon atoms of benzene frozen in; place:; molecule h2o {; C 0.833 1.221 -0.504; H 1.482 2.086 -0.518; C 1.379 -0.055 -0.486; H 2.453 -0.184 -0.483; C 0.546 -1.167 -0.474; H 0.971 -2.162 -0.466; C -0.833 -1.001 -0.475; H -1.482 -1.867 -0.468; C -1.379 0.275 -0.490; H -2.453 0.404 -0.491; C -0.546 1.386 -0.506; H -0.971 2.381 -0.524; --; O 0.000 0.147 3.265; H 0.000 -0.505 2.581; H 0.000 0.965 2.790; no_com; no_reorient; }. set {; maxiter 100; g_convergence gau; }. geometric_keywords = {; 'coordsys' : 'tric',; 'constraints' : {; 'freeze' : [{'type' : 'xyz',; 'indices' : [0, 2, 4, 6, 8, 10]}]; }; }. optimize('hf/cc-pvdz', engine='geometric', optimizer_keywords=geometric_keywords). Output¶; The progress of a geometry optimization can be monitored by grepping the output file for the; tilde character (~). This produces a table like the one below that shows; for each iteration the value for each of the five quantities and whether the criterion; is active and fulfilled (*), active and unfulfilled ( ), or inactive (o).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~; --------------------------------------------------------------------------------------------- ~; Convergence Criteria 1.00e-06 * 3.00e-04 * o 1.20e-03 * o ~; --------------------------------------------------------------------------------------------- ~; 1 -38.91591820 -3.89e+01 6.91e-02 5.72e-02 o 1.42e-01 1.19e-01 o ~; 2 -38.92529543 -9.38e-03 6.21e-03 3.91e-03 o 2.00e-02 1.18e-02 o ~; 3 -38.92540669 -1.11e-04 4.04e-03 2.46e-03 o 3.63e-02 2.12e-02 o ~; 4 -38.92548668 -8.00e-05 2.30e-04 * 1.92e-04 o 1.99e-03 1.17e-03 o ~; 5 -38.92548698 -2.98e-07 * 3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/optking-1.html:16211,optimiz,optimization,16211,psi4manual/1.4.0/optking-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/optking-1.html,9,['optimiz'],['optimization']
Performance,"ne dimer with user-combined reference points. gibbs; Test Gibbs free energies at 298 K of N2, H2O, and CH4. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. adc2; ADC(2)/aug-cc-pVDZ on two water molecules that are distant from 1000 angstroms from each other. cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. dft-reference; MP2 with a PBE0 reference computation. pywrap-bfs; apply linear fragmentation algorithm to a water cluster. castup1; Test of SAD/Cast-up (mainly not dying due to file weirdness). mcscf1; ROHF 6-31G** energy of the \(^{3}B_1\) state of CH2, with Z-matrix input. The occupations are specified explicitly. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. dft-jk; DFT JK on-disk test. sapt-dft-lrc; SAPT(DFT) aug-cc-pVDZ interaction energy between Ne and Ar atoms. cbs-xtpl-alpha; Extrapolated water energies. dft-dldf; Dispersionless density functional (dlDF+D) internal match to Psi4 Extensive testing has been done to match supplemental info of Szalewicz et. al., Phys. Rev. Lett., 103, 263201 (2009) and Szalewicz et. al., J. Phys. Chem. Lett., 1, 550-555 (2010). opt3; SCF cc-pVDZ geometry optimzation, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. scf-dipder; Test SCF dipole derivatives against old Psi3 reference values. dfccsdat1; DF-CCSD(AT) cc-pVDZ energy for the H2O molecule. pywrap-checkrun-rohf; This checks that all energy methods can run with a minimal input and set symmetry. cc4a; RHF-CCSD(T) cc-pVQZ frozen-core energy of the BH molecule, with Cartesian input. This version tests the FROZEN_DOCC option explicitly. dft-psivar; HF and DFT vari",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html:14266,optimiz,optimization,14266,psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"ne job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print 'Performing finite difference calculations'. # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print ' %d displacements needed ...' % (ndisp),; energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') command.\n",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/driver.html:23537,perform,perform,23537,psi4manual/4.0b2/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/driver.html,2,['perform'],['perform']
Performance,"ne job or files farmed out; opt_mode = 'continuous'; if ('mode' in kwargs) and (dertype == 0):; opt_mode = kwargs['mode']. if (opt_mode.lower() == 'continuous'):; pass; elif (opt_mode.lower() == 'sow'):; pass; elif (opt_mode.lower() == 'reap'):; if('linkage' in kwargs):; opt_linkage = kwargs['linkage']; else:; raise ValidationError('Optimize execution mode \'reap\' requires a linkage option.'); else:; raise ValidationError('Optimize execution mode \'%s\' not valid.' % (opt_mode)). # Does dertype indicate an analytic procedure both exists and is wanted?; if (dertype == 1):; # Nothing to it but to do it. Gradient information is saved; # into the current reference wavefunction; procedures['gradient'][lowername](lowername, **kwargs). if 'mode' in kwargs and kwargs['mode'].lower() == 'sow':; raise ValidationError('Optimize execution mode \'sow\' not valid for analytic gradient calculation.'); PsiMod.reference_wavefunction().energy(); return PsiMod.get_variable('CURRENT ENERGY'); else:; # If not, perform finite difference of energies. opt_iter = 1; if ('opt_iter' in kwargs):; opt_iter = kwargs['opt_iter']. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; displacements = PsiMod.fd_geoms_1_0(); ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed ...' % (ndisp), end=""""); energies = []. # S/R: Write instructions for sow/reap procedure to output file and reap input file; if (opt_mode.lower() == 'sow'):; instructionsO = """"""\n The optimization sow/reap procedure has been selected through mode='sow'. In addition\n""""""; instructionsO += """""" to this output file (which contains no quantum chemical calculations), this job\n""""""; instructionsO += """""" has produced a number of input files (OPT-%s-*.in) for individual components\n"""""" % (str(opt_iter)); instructionsO += """""" and a single input file (OPT-master.in) with an optimize(mode='reap') c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:26006,perform,perform,26006,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,2,['perform'],['perform']
Performance,"ne with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. dfrasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. sapt-dft2; SAPT(DFT) aug-cc-pVDZ computation for the water dimer interaction energy. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. dfccsdat2; DF-A-CCSD(T) cc-pVDZ energy for the NH molecule. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. dfccd-grad1; DF-CCSD cc-pVDZ gradients for the H2O molecule. dct9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. density-screen-1; RHF Density Matrix based-Integral Screening Test for water. omp2-5; SOS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. fd-freq-energy-large; SCF DZ finite difference frequencies by energies for C4NH4. scf5; Test of all different algorithms and reference types for SCF, on singlet and triplet O2, using the cc-pVTZ basis set. dfmp2-2; Density fitted MP2 energy of H2, using density fitted reference and automatic looping over cc-pVDZ and cc-pVTZ basis sets. Results are tabulated using the built in table functions by using the default options and by specifiying the format. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. mp3-grad2; MP3 cc-pVDZ gradient for the NO radical. dlpnomp2-1; comparison of DF-MP2 and DLPNO-MP2. scf-level-shift-rohf; SCF level shift on an ROHF computation. opt-irc-2; Compute the IRC for HCN <-> NCH interconversion at the RHF/DZP level of theory. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. dft-grad-lr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html:16250,optimiz,optimization,16250,psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"ne) is not None:; raise ValidationError(""""""Database: Cannot specify bsse_type for database. Use the cp keyword withing database instead.""""""). optstash = p4util.OptionsState(; ['WRITER_FILE_LABEL'],; ['SCF', 'REFERENCE']). # Wrapper wholly defines molecule. discard any passed-in; kwargs.pop('molecule', None). # Paths to search for database files: here + PSIPATH + library + PYTHONPATH; psidatadir = os.environ.get('PSIDATADIR', None); #nolongerpredictable psidatadir = __file__ + '/../..' if psidatadir is None else psidatadir; libraryPath = ':' + os.path.abspath(psidatadir) + '/databases'; driver_loc = os.path.dirname(os.path.abspath(__file__)); dbPath = os.path.abspath('.') + \; ':' + ':'.join([os.path.abspath(x) for x in os.environ.get('PSIPATH', '').split(':')]) + \; libraryPath + \; ':' + driver_loc # so the databases can ""import qcdb"". sys.path = [sys.path[0]] + dbPath.split(':') + sys.path[1:]; # TODO this should be modernized a la interface_cfour. # Define path and load module for requested database; database = p4util.import_ignorecase(db_name); if database is None:; core.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); core.print_out('\nSearch path that was tried:\n'); core.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. user_writer_file_label = core.get_global_option('WRITER_FILE_LABEL'); user_reference = core.get_global_option('REFERENCE'). # Configuration based upon e_name & db_name options; # Force non-supramolecular if needed; if not hasattr(lowername, '__call__') and re.match(r'^.*sapt', lowername):; try:; database.ACTV_SA; except AttributeError:; raise ValidationError('Database %s not suitable for non-supramolecular calculation.' %",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html:9671,load,load,9671,psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/wrapper_database.html,1,['load'],['load']
Performance,"ne-Electron Properties — oeprop(); Vibrational and Thermochemical Analysis. Interfaces: Enhancing PSI4 Capabilities; Interface to NumPy; Interface to CFOUR by J. Stanton & J. Gauss; Interface to CheMPS2 by S. Wouters; Interface to DFTD3 by S. Grimme; Interface to DKH by A. Wolf, M. Reiher, and B. A. Hess; Interface to LIBEFP by I. Kaliman; Interface to ERD by N. Flocke and V. Lotrich; Interface to programs through FCHK files — fchk(); Interface to gCP by S. Grimme; Interface to GDMA Distributed Multipole Analysis by A. J. Stone — gdma(); Interface to Libint by E. Valeev; Interface to Molden — molden(); Interface to MRCC by M. Kállay; Interface to PCMSolver by R. Di Remigio; Plugin v2rdm_casscf by A. E. DePrince; Interface to SIMINT by B. Pritchard. Psithon Functions: Invoking a Calculation; Notes on Options; Single-Point Energy — energy(); Property; Basis Set Superposition Corrections; Geometry Optimization — optimize() and gradient(); Harmonic Vibrational Analysis and Visualization of Normal Modes — frequency() and hessian(); Database — database(); Complete Basis Set; Spectroscopic Constants for Diatomics; Function Intercalls; Embarrassing Parallelism; Generation of Cube Files — cubeprop(); Orbital Visualization with VMD. Customization: Adding Simple Extensions; Defining a Method Alias; Creating a Database. Appendices; Keywords; Keywords by Alpha; Keywords by Module. Basis Sets; Basis Sets by Family; Basis Sets by Element; Auxiliary Basis Sets. PSI Variables; PSI Variables by Alpha; PSI Variables by Module. Miscellaneous; Test Suite and Sample Inputs; DFT Functionals; PSIOH Intermediate Files; Physical Constants; Bibliography. Programmers’ Manual¶. Contributions: Intro to Programming in PSI4; Plugins: Adding New Functionality to PSI4; Documentation; PsiPEP: Plans and Practices to Organize PSI4. Programming: Using the Core Libraries; LibOptions: globals, locals, has_changed and all that; Adding Methods to Driver. Managing: Git, Conda, CMake and all that; FAQ; Adding",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/index.html:2457,optimiz,optimize,2457,psi4manual/1.1.0/index.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/index.html,1,['optimiz'],['optimize']
Performance,"ne:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_fnoccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a FNO-CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module in ['', 'FNOCC']:; func = run_fnocc; elif mtd_type == 'DF':; if module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module in ['', 'FNOCC']:; func = run_fnodfcc. if func is None:; raise ManagedMethodError([__name__, name, type_var, mtd_type, reference, module]). if kwargs.pop('probe', False):; return; else:; return func(name, **kwargs). def select_ccsd_t_(name, **kwargs):; """"""Function selecting the algorithm for a CCSD(T) energy call; and directing to specified or best-performance default modules. """"""; reference = core.get_option('SCF', 'REFERENCE'); type_var, _, mtd_type = method_algorithm_type(name); module = core.get_global_option('QC_MODULE'). func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'FNOCC':; func = run_fnocc; elif module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type == 'DF':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif mtd_type == 'CD':; if module == 'OCC':; func = run_dfocc; elif module in ['', 'FNOCC']:; func = run_fnodfcc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module == 'MRCC' and which(""dmrcc"", return_bool=True):; func = run_mrcc; elif module in ['', 'CCENERGY']:; func = run_ccenergy; elif mtd_type in [""DF"", ""CD""]:; if module in [""OCC""]: # SOON """",; func = run_dfocc; elif reference == 'ROHF':; if mtd_ty",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html:25626,perform,performance,25626,psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/procrouting/proc.html,8,['perform'],['performance']
Performance,"need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; cbs() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of PSI4 and Cfour computational methods and PSI4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; properties() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR program [m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/cfour.html:26372,optimiz,optimize,26372,psi4manual/1.7.x/cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/cfour.html,4,['optimiz'],['optimize']
Performance,"need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into PSI4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; cbs() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of PSI4 and Cfour computational methods and PSI4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; properties() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gauss’s CFOUR pro",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:26249,optimiz,optimize,26249,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,5,['optimiz'],['optimize']
Performance,"need to be replaced by the text blankline. Functionality¶; Through clever use of the cfour {...} block, one could run most any; Cfour computation through the P4C4 interface. In contrast, enumerated; below are tested functionalities where results from Cfour are collected; into Psi4 data objects.; Implemented. Single-point energy() commands for ground state; methods. Examples:; cfour/sp-rhf-ccsd_t_-ao-ecc, cfour/scf4,; cfour/mints5.; Analytic gradient() and optimize(); commands for ground state methods. Real and; Ghost atoms permitted (though the latter will naturally collapse after; several cycles). Examples: cfour/opt-rhf-ccsd_t_,; cfour/mp2-1, and cfour/mints5-grad. Warning; There exist molecules (e.g., allene) where the; inertial frame is not unique (planes along atoms or between; atoms). The orientation reconciling machinery currently does not; handle these cases and will fail with “Axis unreconcilable between; QC programs”. I will get to this soon. Finite difference of energy gradient() and; optimize() for methods.; Force with gradient('name', dertype=0), etc..; _nbody_gufunc() for computation of interaction energies with or; without counterpoise correction. Example: cfour/dfmp2-1.; database() for computation of a collection of molecules in a; single input, with summarization of results. Examples:; cfour/pywrap-db1 and cfour/psi-a24-grad.; complete_basis_set() for computation of compound methods involving; basis set extrapolations and/or delta corrections with any combination; of Psi4 and Cfour computational methods and Psi4 basis sets.; Example: cfour/pywrap-cbs1. Not Yet Implemented. Ground state CI energies and optimizations; Excited state energies and optimizations; Properties are not yet regex-ed, transformed into input frame, and; stowed in PSI Variables.; Property calls that required extra computation not yet translated into; property() computation command; Frequencies. Energy methods available through P4C4 interface. name; calls method in Stanton and Gau",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:26260,optimiz,optimize,26260,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,2,['optimiz'],['optimize']
Performance,"needed to handle lto object” when building CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. Installation and Runtime Configuration; Buil",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/build_faq.html:3789,queue,queue,3789,psi4manual/master/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/master/build_faq.html,1,['queue'],['queue']
Performance,"neral Public License as published by; # the Free Software Foundation, version 3.; #; # Psi4 is distributed in the hope that it will be useful,; # but WITHOUT ANY WARRANTY; without even the implied warranty of; # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the; # GNU Lesser General Public License for more details.; #; # You should have received a copy of the GNU Lesser General Public License along; # with Psi4; if not, write to the Free Software Foundation, Inc.,; # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. __all__ = [; ""frac_nuke"",; ""frac_traverse"",; ""ip_fitting"",; ]. from typing import Callable, Dict, Union. from psi4 import core; from psi4.driver import p4util; from psi4.driver import driver; from psi4.driver.p4util.exceptions import *. [docs]def frac_traverse(name: Union[str, Callable], **kwargs) -> Dict[float, float]:; """"""Scan electron occupancy from +1 electron to -1. Parameters; ----------; name; DFT functional string name or function defining functional; whose omega is to be optimized.; molecule : :ref:`molecule <op_py_molecule>`, optional; Target molecule (neutral) for which omega is to be tuned, if not last defined.; cation_mult : Optional[int]; Multiplicity of cation, if not neutral multiplicity + 1.; anion_mult : Optional[int]; Multiplicity of anion, if not neutral multiplicity + 1.; frac_start : Optional[int]; Iteration at which to start frac procedure when not reading previous; guess. Defaults to 25.; HOMO_occs : Optional[List]; Occupations to step through for cation, by default `[1 - 0.1 * x for x in range(11)]`.; LUMO_occs : Optional[List]; Occupations to step through for anion, by default `[1 - 0.1 * x for x in range(11)]`.; HOMO : Optional[int]; Index of HOMO.; LUMO : Optional[int]; Index of LUMO.; frac_diis : Optional[bool]; Do use DIIS for non-1.0-occupied points?; neutral_guess : Optional[bool]; Do use neutral orbitals as guess for the anion?; hf_guess: Optional[bool]; Do use UHF guess before ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html:1568,optimiz,optimized,1568,psi4manual/1.7.x/_modules/psi4/driver/frac.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/frac.html,2,['optimiz'],['optimized']
Performance,"nergies for dissociation curves of bimolecular complexes.; Geometries and reference interaction energies from Grafova et al. JCTC 6 2365 (2010).; Note that the S22by5-N-1.0 members are essentially the same geometries as S22-N (there’s trivial round-off error) but the reference interaction energies for S22by5 are of lower quality than those of S22. cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'mol1' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 1; ...; 'mol22' five-point (0.9, 1.0, 1.2, 1.5, 2.0) dissociation curve for molecule 22. BENCH12¶. Database of <description of members and reference energy type>.; Geometries from <Reference>.; Reference interaction energies from <Reference>. benchmark; '<benchmark_name>' <Reference>.; '<default_benchmark_name>' <Reference>. subset; 'small'; 'large'; 'alkenes'; 'alkanes'; 'acenes'; 'thiophenes'; 'h2o_size'; 'h2o_shape'; 'atoms'; 'S22_HB'; 'S22_MX'; 'S22_DD'. BAKERJCC93¶. Database of molecules that are challenging to optimize.; Geometries from Baker J. Comput. Chem. 14 1085 (1993), as reported; in Bakken and Helgaker, J. Chem. Phys. 117, 9160 (2002), with a few; further corrections.; No reference energies defined. cp 'off'; rlxd 'off'; subset; 'small'; 'large'. RGC10¶. Database (Sherrill) of interaction energies for dissociation curves of rare-gas biatomic complexes.; Geometries and reference interaction energies from Tang et al. JCP 118 4976 (2003). cp 'off' || 'on'; rlxd 'off'; subset; 'small'; 'large'; 'equilibrium'; 'HeHe' 18-point dissociation curve for helium dimer; 'HeNe' 18-point dissociation curve for helium-neon complex; 'HeAr' 18-point dissociation curve for helium-argon complex; 'HeKr' 18-point dissociation curve for helium-krypton complex; 'NeNe' 18-point dissociation curve for neon dimer; 'NeAr' 18-point dissociation curve for neon-argon complex; 'NeKr' 18-point dissociation curve for neon-krypton complex; 'ArAr' 18-point dissociation curve for argon dimer; 'ArKr' 1",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodoc_available_databases-1.html:3196,optimiz,optimize,3196,psi4manual/4.0b3/autodoc_available_databases-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodoc_available_databases-1.html,4,['optimiz'],['optimize']
Performance,"nergy Point will default to only singles and doubles in the active space. dfep2-1; Compute three IP and 2 EA’s for the PH3 molecule. scf-response1; Compute the dipole, quadrupole, and traceless quadrupoles for water. basis-ecp; check mixing ECP and non-ECP orbital/fitting basis sets in a session. cc29; CCSD/cc-pVDZ optical rotation calculation (both gauges) on Cartesian H2O2. mints-benchmark; run some BLAS benchmarks. cc18; RHF-CCSD-LR/cc-pVDZ static polarizability of HOF. fd-freq-gradient-large; SCF DZ finite difference frequencies by gradients for C4NH4. linK-1; RHF Linear Exchange Algorithm test for water. fci-h2o-2; 6-31G H2O Test FCI Energy Point. dfmp2-grad4; DF-MP2 cc-pVDZ gradient for the NO molecule. psithon1; Spectroscopic constants of H2, and the full ci cc-pVTZ level of theory. cc27; Single point gradient of 1-1B2 state of H2O with EOM-CCSD. omp3-3; OMP3 cc-pCVDZ energy with B3LYP initial guess for the NO radical. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. omp2-grad1; OMP2 cc-pVDZ gradient for the H2O molecule. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. mom-h2o-4; MOM excitation from LUMO HOMO+4. dfcasscf-fzc-sp; CASSCF/6-31G** energy point. olccd-grad2; OLCCD cc-pVDZ gradient for the NO radical. scf-property; UFH and B3LYP cc-pVQZ properties for the CH2 molecule. olccd-freq1; OLCCD cc-pVDZ freqs for C2H2. omp3-grad2; OMP3 cc-pVDZ gradient for the NO radical. scf-response3; UHF Dipole Polarizability Test. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. sapt10; usapt example with empty beta due to frozen core. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. extern2; External potential calculation involving a TIP3P water and a QM water for DFMP2. Finite different test of the gradient is performed to validate forces. scf-guess; Test initial SCF guesses on FH and FH+ in cc-pVTZ basis. dct8; DCT calculation for the NH3",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:3721,perform,performed,3721,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['perform'],['performed']
Performance,"nergy atop a T-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme='corl_xtpl_helgaker_2'). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2'). >>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> energy('cbs', corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme='corl_xtpl_helgaker_2', delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). >>> # [7] a Q5-zeta MP2 calculation, corrected by CCSD(T) at the TQ-zeta extrapolated level, and all-electron CCSD(T) correlation at T-zeta level; >>> energy(cbs, cbs_metadata=[{""wfn"": ""hf"", ""basis"": ""cc-pv5z""}, {""wfn"": ""mp2"", ""basis"": ""cc-pv[q5]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pv[tq]z""}, {""wfn"": ""ccsd(t)"", ""basis"": ""cc-pvtz"", ""options"": {""freeze_core"": ""False""}}]). >>> # [8] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme='corl_xtpl_helgaker_2', delta_wfn='ccsd(t)', delta_basis='sto-3g'). >>> # [9] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme='corl_xtpl_helgaker_2', func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. PSI4 API: Linking C++ and Python; cbs. © Copyright 2022, The Psi4 Project.; Last updated on Thursday, 19 May 2022 08:57PM.; Created using Sphinx 4.5.0.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html:14604,optimiz,optimize,14604,psi4manual/1.6.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.driver.cbs.html,4,['optimiz'],['optimize']
Performance,"nergy for the BH molecule, with Cartesian input. pubchem2; Superficial test of PubChem interface. omp2p5-1; OMP2 cc-pVDZ energy for the H2O molecule. ao-dfcasscf-sp; CASSCF/6-31G** energy point. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dcft7; DCFT calculation for the triplet O2 using ODC-06 and ODC-12 functionals. Only simultaneous algorithm is tested. scf-guess-read1; Sample UHF/cc-pVDZ H2O computation on a doublet cation, using RHF/cc-pVDZ orbitals for the closed-shell neutral as a guess. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). cc41; RHF-CC2-LR/cc-pVDZ optical rotation of H2O2. gauge = both, omega = (589 355 nm). molden2; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. dfmp2-grad2; DF-MP2 cc-pVDZ gradient for the NO molecule. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. frac; Carbon/UHF Fractionally-Occupied SCF Test Case. cc34; RHF-CCSD/cc-pVDZ energy of H2O partitioned into pair energy contributions. sapt2; SAPT0 aug-cc-pVDZ computation of the benzene-methane interaction energy, using the aug-pVDZ-JKFIT DF basis for SCF, the aug-cc-pVDZ-RI DF basis for SAPT0 induction and dispersion, and the aug-pVDZ-JKFIT DF basis for SAPT0 electrostatics and induction. This example uses frozen core as well as asyncronous I/O while forming the DF integrals and CPHF coefficients. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy P",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:22517,perform,performed,22517,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['perform'],['performed']
Performance,"nergy functional (Lagrangian) as a function of . OMP2. OMP3. OLCCD. where subscript c means only connected diagrams are allowed, and; , , and defined as. where , and are the one- and two-electron components of normal-ordered Hamiltonian. Then,; first and second derivatives of the energy with respect to the parameter at . Then the energy can be expanded up to second-order as follows. where is the MO gradient vector, is the MO rotation vector,; and is the MO Hessian matrix. Therefore, minimizing the energy with respect to ; yields. This final equation corresponds to the usual Newton-Raphson step.; Publications resulting from the use of the orbital-optimized code should cite the following publications:. OMP2 [Bozkaya:2011:omp2] and [Bozkaya:2013:omp2grad]; OMP3 [Bozkaya:2011:omp3] , [Bozkaya:2013:omp3], and [Bozkaya:2013:omp3grad]; OMP2.5 [Bozkaya:2011:omp3]; OLCCD [Bozkaya:2013:ocepa]; LCCD [Bozkaya:2013:ocepa]. Convergence Problems¶; For problematic open-shell systems, we recommend to use the ROHF or DFT orbitals as an initial guess for orbital-optimized methods. Both ROHF and; DFT orbitals may provide better initial guesses than UHF orbitals, hence convergence may be significantly speeded up with ROHF or DFT orbitals.; In order to use ROHF orbitals we can simply use “reference rohf” option. For DFT orbitals one should use “reference uks” and “dft_functional b3lyp” options. Of; course users can use any DFT functional available in Psi4. Methods¶; The orbital-optimized MPn and OLCCD methods currently supported in; Psi4 are outlined in Table Orbital-Optimzed OCC/DFOCC; Methods. The following methods are available; and can be controlled through OCC (conventional integrals CONV); and DFOCC (density-fitted DF and Cholesky-decomposed CD); keywords. Switching between the integrals treatments is controlled; through ‘type select’ values; see rightmost Table column. Orbital-Optimized MP and LCCD capabilities of OCC/DFOCC modules¶. name; calls method; Energy; Gradient; type selec",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:5803,optimiz,optimized,5803,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimized']
Performance,"nergy of H2O partitioned into pair energy contributions. dft-grad1; DF-BP86-D2 cc-pVDZ frozen core gradient of S22 HCN update ref gradient due to new BraggSlater radii. sapt-ecp; sapt0 of charged system in ECP basis set. cc15; RHF-B-CCD(T)/6-31G** H2O single-point energy (fzc, MO-basis \(\langle ab|cd \rangle\)). scf-freq1; Analytic vs. finite difference DF-SCF frequency test for water. cbs-xtpl-alpha; Extrapolated water energies. sapt3; SAPT2+3(CCD) aug-cc-pVDZ+midbond computation of the water dimer interaction energy, using the aug-cc-pVDZ-JKFIT DF basis for SCF and aug-cc-pVDZ-RI for SAPT. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. dct8; DCT calculation for the NH3+ radical using the ODC-12 and ODC-13 functionals. This performs both simultaneous and QC update of the orbitals and cumulant using DIIS extrapolation. Four-virtual integrals are first handled in the MO Basis for the first two energy computations. In the next computation ao_basis=disk algorithm is used, where the transformation of integrals for four-virtual case is avoided. scf-bz2; Benzene Dimer Out-of-Core HF/cc-pVDZ. casscf-semi; CASSCF/6-31G** energy point. Check energy with frozen core/virtual orbs. after semicanonicalization. scf-cholesky-basis; incremental Cholesky filtered SCF. cc47; EOM-CCSD/cc-pVDZ on H2O2 with two excited states in each irrep. fci-h2o-fzcv; 6-31G H2O Test FCI Energy Point. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). cisd-sp; 6-31G** H2O Test CISD Energy Point. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. mp2-property; MP2 cc-pvDZ properties for Nitrogen oxide. cc30; CCSD/sto-3g optical rotation calculation (length gauge only) at two frequencies on methyloxirane. scf-hess2; U",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html:22599,perform,performs,22599,psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_corepsi4.html,2,['perform'],['performs']
Performance,"nergy', lowername, 8, 10, 8, 10, 8). # Commit to procedures[] call hereafter; return_wfn = kwargs.pop('return_wfn', False); core.clean_variables(). # no analytic derivatives for scf_type cd; if core.get_global_option('SCF_TYPE') == 'CD':; if (dertype == 1):; raise ValidationError(""""""No analytic derivatives for SCF_TYPE CD.""""""). # Make sure the molecule the user provided is the active one; molecule = kwargs.pop('molecule', core.get_active_molecule()); molecule.update_geometry(). # Does dertype indicate an analytic procedure both exists and is wanted?; if dertype == 1:; core.print_out(""""""gradient() will perform analytic gradient computation.\n""""""). # Perform the gradient calculation; wfn = procedures['gradient'][lowername](lowername, molecule=molecule, **kwargs). else:; core.print_out(""""""gradient() will perform gradient computation by finite difference of analytic energies.\n""""""). opt_iter = kwargs.get('opt_iter', 1); if opt_iter is True:; opt_iter = 1. if opt_iter == 1:; print('Performing finite difference calculations'). # Obtain list of displacements; findif_meta_dict = driver_findif.gradient_from_energies_geometries(molecule); ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed ..."""""" % (ndisp), end=''). wfn = _process_displacement(energy, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(); # ensure displacement calculations do not use restart_file orbitals.; kwargs.pop('restart_file', None). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; energy, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Compute the gradient; core.set_local_option('FINDIF', 'GRADIENT_WRITE', True); G = driver_findif.assemble_gradient_from_energies(findif_meta_dict); grad_psi_matrix = core.Matrix.from_array(G); grad_psi_matrix.print_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html:43083,Perform,Performing,43083,psi4manual/1.4.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/driver.html,2,['Perform'],['Performing']
Performance,"nergy('sapt(dft)'). As already mentioned above, the SAPT0 module for open-shell cases can also; use exact integrals for all terms except for dispersion. In practice,; density fitting is considerably faster and introduces negligible errors, thus; it is the preferred method for open-shell cases as well.; Below, you can find a minimum example of open-shell SAPT0 computation.; molecule {; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; --; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; units bohr; symmetry c1; no_reorient; no_com; }. set {; reference uhf; scf_type df; basis aug-cc-pVDZ; }. energy('sapt0'). REFERENCE needs to be UHF or ROHF for the open-shell computation to proceed. Advanced example¶; Open-shell computations can be difficult to converge in certain cases, thus you may; want to have more control over the SCF procedure. You have the option of; doing the driver job in the input file, by performing the dimer and monomer computations; yourself. In the example below, we do a stability analysis for the open-shell monomer only; molecule {; 0 2; O 0.000000 0.000000 0.000000; O 0.000000 2.503900 0.000000; H 0.000000 -0.424700 -1.839500; --; 0 1; O 0.000000 0.000000 6.000000; H 0.000000 1.431500 4.890600; H 0.000000 -1.431500 4.890600; units bohr; symmetry c1; no_reorient; no_com; }. dimer = psi4.get_active_molecule(). set {; reference uhf; scf_type df; basis cc-pVDZ; df_basis_sapt cc-pVDZ-ri; guess sad; }. dimer = psi4.get_active_molecule(). set df_ints_io save; psi4.IO.set_default_namespace('dimer'); Edim, wfn_dimer = energy('scf',molecule=dimer,return_wfn=True); set df_ints_io load. monomerA = dimer.extract_subsets(1,2); psi4.IO.change_file_namespace(97, 'dimer', 'monomerA'); psi4.IO.set_default_namespace('monomerA'); set {; stability_analysis follow; }; EmonA, wfn_monA = energy('scf',molecule=monomerA,return_wfn=True). monomerB = dimer.extract_subsets(2,1); psi4.IO.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:13692,perform,performing,13692,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['perform'],['performing']
Performance,"nergy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). 1; 2>>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). 1; 2>>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). 1; 2>>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). 1; 2; 3>>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference (both equivalent); >>> cbs(corl_wfn='mp2', corl_basis='aug-cc-pv[tq]z', delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z'); >>> cbs(energy, wfn='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2). 1; 2>>> # [6] a D-zeta ccsd(t) correction atop a DT-zeta extrapolated ccsd cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta reference; >>> cbs(name='mp2', corl_basis='aug-cc-pv[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd', delta_basis='aug-cc-pv[dt]z', delta_scheme=corl_xtpl_helgaker_2, delta2_wfn='ccsd(t)', delta2_wfn_lesser='ccsd', delta2_basis='aug-cc-pvdz'). 1; 2>>> # [7] cbs() coupled with database(); >>> TODO database('mp2', 'BASIC', subset=['h2o','nh3'], symm='on', func=cbs, corl_basis='cc-pV[tq]z', corl_scheme=corl_xtpl_helgaker_2, delta_wfn='ccsd(t)', delta_basis='sto-3g'). 1; 2>>> # [8] cbs() coupled with optimize(); >>> TODO optimize('mp2', corl_basis='cc-pV[DT]Z', corl_scheme=corl_xtpl_helgaker_2, func=cbs). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. PSI4 API: Linking C++ and Python. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.cbs-1.html:13982,optimiz,optimize,13982,psi4manual/1.2.1/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/api/psi4.driver.cbs-1.html,4,['optimiz'],['optimize']
Performance,"nergy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True); PsiMod.set_global_option(""FRAC_LOAD"", False). for occ in LUMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [LUMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(LUMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); potentials.append(eps[-int(LUMO)-1]). occs.append(occ); energies.append(E); convs.append(C). PsiMod.set_global_option(""FRAC_START"", 2); PsiMod.set_global_option(""FRAC_LOAD"", True); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_DIIS"", frac_diis); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # => Run the neutral next <= #. mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0). # Burn the neutral in with hf, if requested <= #. if (not continuous_guess):; PsiMod.set_global_option(""GUESS"", old_guess); if (hf_guess):; PsiMod.set_global_option(""FRAC_START"", 0); PsiMod.set_global_option(""REFERENCE"",""UHF""); energy('scf'); PsiMod.set_global_option(""REFERENCE"",""UKS""); PsiMod.set_global_option(""GUESS"", ""READ""); PsiMod.set_global_option(""FRAC_LOAD"", False). PsiMod.set_global_option(""FRAC_START"", frac_start); PsiMod.set_global_option(""FRAC_RENORMALIZE"", True). for occ in HOMO_occs:; ; PsiMod.set_global_option(""FRAC_OCC"", [HOMO]); PsiMod.set_global_option(""FRAC_VAL"", [occ]) . E = energy('scf'); C = 1; if (E == 0.0):; E = PsiMod.get_variable('SCF ITERATION ENERGY'); C = 0. if (LUMO > 0):; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_a(); potentials.append(eps[int(HOMO)-1]); else:; ref = PsiMod.reference_wavefunction(); eps = ref.epsilon_b(); pot",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:4205,LOAD,LOAD,4205,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,2,['LOAD'],['LOAD']
Performance,"nergy.; Defaults to :py:func:`~corl_xtpl_helgaker_2` if two valid basis sets; present in ``delta5_basis`` and :py:func:`~xtpl_highest_1` otherwise. :type scf_alpha: float. Overrides the default \alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including :py:func:`~xtpl_highest_1` and :py:func:`~scf_xtpl_helgaker_3`. .. hlist::; :columns: 1. * :py:func:`scf_xtpl_helgaker_2`; * :py:func:`scf_xtpl_truhlar_2`; * :py:func:`scf_xtpl_karton_2`. :type corl_alpha: float. Overrides the default \alpha parameter used in the listed :py:func:`corl_xtpl_helgaker_2` correlation; extrapolation to the corl stage. The supplied \alpha does not impact delta or any further stages. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type delta_alpha: float. Overrides the default \alpha parameter used in the listed; :py:func:`corl_xtpl_helgaker_2` correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different \alpha might; be more appropriate. .. hlist::; :columns: 1. * :py:func:`corl_xtpl_helgaker_2`. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :examples:. >>> # [1] replicates with cbs() the simple model chemistry scf/cc-pVDZ: set basis cc-pVDZ energy('scf'); >>> cbs(name='scf', scf_basis='cc-pVDZ'). >>> # [2] replicates with cbs() the simple model chemistry mp2/jun-cc-pVDZ: set basis jun-cc-pVDZ energy('mp2'); >>> cbs(name='mp2', corl_basis='jun-cc-pVDZ'). >>> # [3] DTQ-zeta extrapolated scf reference energy; >>> cbs(name='scf', scf_basis='cc-pV[DTQ]Z', scf_scheme=scf_xtpl_helgaker_3). >>> # [4] DT-zeta extrapolated mp2 correlation energy atop a T-zeta reference; >>> cbs(corl_wfn='mp2', corl_basis='cc-pv[dt]z', corl_scheme=corl_xtpl_helgaker_2). >>> # [5] a DT-zeta extrapolated coupled-cluster correction atop a TQ-zeta extrapolated mp2 correlation energy atop a Q-zeta ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html:35634,perform,performed,35634,psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver_cbs.html,1,['perform'],['performed']
Performance,"neticInt method, [1]. psi4.core.MultipoleInt method, [1]. psi4.core.NablaInt method, [1]. psi4.core.OneBodyAOInt method, [1], [2]. psi4.core.OverlapInt method, [1]. psi4.core.PotentialInt method, [1]. psi4.core.PseudospectralInt method, [1]. psi4.core.QuadrupoleInt method, [1]. psi4.core.ThreeCenterOverlapInt method, [1], [2]. psi4.core.TracelessQuadrupoleInt method, [1]. psi4.core.TwoBodyAOInt method, [1], [2]. psi4.core.TwoElectronInt method, [1], [2]. compute_state_transfer() psi4.core.CIWavefunction method, [1], [2]. COMPUTE_TRIPLES (FNOCC). compute_V() psi4.core.VBase method, [1], [2]. compute_Vx() psi4.core.VBase method, [1], [2]. computePotentialMatrix() psi4.core.ExternalPotential method, [1], [2]. CONDA_PREFIX, [1]. CONSECUTIVE_BACKSTEPS (OPTKING). construct_from_pydict() psi4.core.BasisSet method, [1], [2]. contact. converged psi4.core.BoysLocalizer attribute, [1]. psi4.core.Localizer attribute, [1], [2]. psi4.core.PMLocalizer attribute, [1]. convergence criteria. ; geometry optimization. ConvergenceError. copy() psi4.core.CIVector method, [1], [2]. psi4.core.Matrix method, [1], [2]. psi4.driver.Table method, [1]. copy_file_from_scratch() in module psi4.driver. copy_file_to_scratch() in module psi4.driver. copy_lower_to_upper() psi4.core.Matrix method, [1], [2]. copy_upper_to_lower() psi4.core.Matrix method, [1], [2]. CORE module, [1]. core_hamiltonian_grad() psi4.core.MintsHelper method, [1], [2]. corl_xtpl_helgaker_2() in module psi4.driver.driver_cbs. CORR_ANSATZ (PSIMRCC). CORR_CCSD_T (PSIMRCC). CORR_CHARGE (PSIMRCC). CORR_MULTP (PSIMRCC). CORR_WFN (PSIMRCC). CorrelationFactor class in psi4.core, [1]. CorrelationTable class in psi4.core, [1]. Cotton-ordering. count() psi4.core.BSVec method, [1], [2]. psi4.core.VectorMatrix method, [1], [2]. counterpoise correction. COUPLED_INDUCTION (SAPT). COUPLING (PSIMRCC). COUPLING_TERMS (PSIMRCC). COVALENT_CONNECT (OPTKING). cp. ; setting keywords. CP-CORRECTED2-BODYINTERACTIONENERGY. cphf_converged() psi4.core.CUH",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/genindex-1.html:31863,optimiz,optimization,31863,psi4manual/1.2.1/genindex-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/genindex-1.html,2,['optimiz'],['optimization']
Performance,"nfiguration interaction singles and doubles level of theory and root.; Deprecated in favor of CISD QUADRUPOLE. CISD TOTAL ENERGY¶. CISD CORRELATION ENERGY¶. CISDT TOTAL ENERGY¶. CISDT CORRELATION ENERGY¶. CISDTQ CORRELATION ENERGY¶. CISDTQ TOTAL ENERGY¶. CIn CORRELATION ENERGY¶. CIn TOTAL ENERGY¶; The total electronic energy [Eh] and correlation energy component [Eh]; for the labeled configuration interaction level of theory and root.; n is CI order for n > 4. CP-CORRECTED 2-BODY INTERACTION ENERGY¶; The interaction energy [Eh] considering only two-body interactions,; computed with counterpoise correction.; Related variable UNCP-CORRECTED 2-BODY INTERACTION ENERGY. \[E_{\text{IE}} = E_{dimer} - \sum_{monomer}^{n}{E_{monomer}^{\text{CP}}}\]. CURRENT CORRELATION ENERGY¶; The correlation energy [Eh] corresponding to the CURRENT ENERGY variable. CURRENT ENERGY¶; The total electronic energy [Eh] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer. CURRENT REFERENCE ENERGY¶; The total electronic energy [Eh] of the reference stage corresponding to; the CURRENT ENERGY variable. CURRENT DIPOLE¶; The total dipole [e a0] of the most recent stage of a calculation (frequently overwritten), (3,). CURRENT GRADIENT¶; The total electronic gradient [E_h/a0] of the most recent stage of a; calculation (frequently overwritten). This is the quantity tracked by; the geometry optimizer, ({nat}, 3). CURRENT DIPOLE GRADIENT¶; The derivative of the dipole with respect to nuclear perturbations [E_h a0/u] = [(e a0/a0)^2/u]; as a degree-of-freedom by dipole component array, (3 * {nat}, 3). CURRENT HESSIAN¶; The total electronic Hessian [E_h/a0/a0] of the most recent stage of a; calculation, (3 * {nat}, 3 * {nat}). CUSTOM SCS-MP2 TOTAL ENERGY¶. CUSTOM SCS-MP2 CORRELATION ENERGY¶; Changeable quantities based on options.; The total electronic energy [Eh] and correlation energy component [Eh]; for the MP2-like method formed by a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html:15024,optimiz,optimizer,15024,psi4manual/1.4.0/glossary_psivariables-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/glossary_psivariables-1.html,4,['optimiz'],['optimizer']
Performance,"nf}\) Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC)¶DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: boolean; Default: true. DO_MBPT_DISP (SAPT)¶SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC)¶DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_SINGLETS (CPHF)¶CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC)¶DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Pass the method name, like scs-mp2, to energy instead. Type: boolean; Default: false. DO_THIRD_ORDER (SAPT)¶SAPT (Expert) — Do compute third-order corrections?. Type: boolean; Default: false. DO_TRIPLETS (CPHF)¶CPHF — Do triplet states? Default true. Type: boolean; Default: true. DOCC (GLOBALS)¶GLOBALS — An array containing the number of doubly-occupied orbitals per irrep (in Cotton order). Type: array; Default: No Default. DOCC (MCSCF)¶MCSCF — The number of doubly occupied orbitals, per irrep. Type: array; Default: No Default. DYNAMIC_LEVEL (OPTKING)¶OPTKING — Starting level for dynamic optimization (0=nondynamic, higher=>more conservative). Type: integer; Default: 0. E3_SCALE (DFOCC)¶DFOCC — CEPA o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:115261,perform,perform,115261,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"ng CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.6;  · . PSI4. Installation and Runtime Configuration; Build & Run F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/build_faq.html:3536,queue,queue,3536,psi4manual/1.6.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/build_faq.html,1,['queue'],['queue']
Performance,"ng CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Installation and Runtime Configuration; Build & Run F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/build_faq.html:3536,queue,queue,3536,psi4manual/1.7.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/build_faq.html,1,['queue'],['queue']
Performance,"ng CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.8.2;  · . PSI4. Installation and Runtime Configuration; Build & Run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/build_faq.html:3822,queue,queue,3822,psi4manual/1.8.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/build_faq.html,1,['queue'],['queue']
Performance,"ng CheMPS2; How to configure dkh for building Psi4; How to configure libefp for building Psi4; How to configure erd for building Psi4; How to configure gdma for building Psi4; How to configure Libint for building Psi4; How to configure PCMSolver for building Psi4. Testing¶. How to see CTest testing errors; How to run a subset of tests; How to run a minute’s worth of tests; How to test a Psi4 installation. Runtime Setup¶. How to run Psi4 as executable after compilation; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; How to set up the scratch directory; Why not to set PSIDATADIR; How to configure paths for PsiAPI; How to solve ModuleNotFoundError: No module named 'psi4'. Running PSI4¶. What command line options does Psi4 have; What environment variables affect Psi4; What Python is Psi4 running; What Psi4 version is running; How to use Psi4 within a PBS queue; How do I retain specific Psi4 scratch files; How to use logging in Psi4; How to find the Psi4 module from the executable and vice versa. Runtime Errors and Debugging¶. How to use gdb and lldb with Psi4; How to compile for debugging; How to fix “undefined symbol: _Py_FalseStruct”. Managing Code¶. What is the directory layout of the installed or staged Psi4; What is the suggested GitHub workflow; How to highlight git merge conflicts in vi. Miscellaneous¶. How to refer to Psi4; How to get a Psi4 logo file. table of contents. Build & Run FAQ; Obtaining and Updating PSI4; Configuring and Installing PSI4 via Binary; Configuring, Building, and Installing PSI4 via Source; Non-QC Dependencies; QC Dependencies and Extensions; Testing; Runtime Setup; Running PSI4; Runtime Errors and Debugging; Managing Code; Miscellaneous. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Installation and Runtime Configuration; Build & Run",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/build_faq.html:3822,queue,queue,3822,psi4manual/1.9.x/build_faq.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/build_faq.html,1,['queue'],['queue']
Performance,"ng F-SAPT data within input file directory. Type: string; Default: s-fsapt/. FISAPT_LINK_ASSIGNMENT (FISAPT); FISAPT — Where do sigma links go (to C or to AB)?. Type: string; Possible Values: C, AB; Default: C. FISAPT_LINK_SELECTION (FISAPT); FISAPT — Specification algorithm for link bonds in ISAPT. Type: string; Possible Values: AUTOMATIC, MANUAL; Default: AUTOMATIC. FISAPT_MANUAL_LINKS (FISAPT); FISAPT — Manual link bond specification [[Atom1, Atom2], …]. Type: array; Default: No Default. FISAPT_MEM_SAFETY_FACTOR (FISAPT); FISAPT (Expert) — Memory safety factor for heavy FISAPT operations. Type: double; Default: 0.9. FISAPT_PLOT_FILEPATH (FISAPT); FISAPT — Filepath to drop scalar data within input file directory. Type: string; Default: plot/. FIXED_BEND (OPTKING); OPTKING — Specify angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_COORD_FORCE_CONSTANT (OPTKING); OPTKING — In constrained optimizations, for coordinates with user-specified equilibrium values, this is the initial force constant (in au) used to apply an additional force to each coordinate. Type: double; Default: 0.5. FIXED_DIHEDRAL (OPTKING); OPTKING — Specify dihedral angles between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FIXED_DISTANCE (OPTKING); OPTKING — Specify distances between atoms to be fixed (eq. value specified). Type: string; Default: No Default. FLEXIBLE_G_CONVERGENCE (OPTKING); OPTKING — Even if a user-defined threshold is set, allow for normal, flexible convergence criteria. Type: boolean; Default: false. FOLLOW_ROOT (DETCI); DETCI — The root to write out the two-particle density matrix for (the one-particle density matrices are written for all roots). Useful for a state-specific CASSCF or CI optimization on an excited state. Type: integer; Default: 0. FOLLOW_ROOT (MCSCF); MCSCF — Which solution of the SCF equations to find, where 1 is the SCF ground state. Type: integer; Default: 1. FOLLOW_ROOT (PSIMRCC); ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:127085,optimiz,optimizations,127085,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['optimiz'],['optimizations']
Performance,"ng a psi4.core.Dimension object. Returns; Returns the given Psi4 object. Return type; Matrix or Vector. Notes; This is a generalized function to convert a NumPy array to a Psi4 object; Examples; >>> data = np.random.rand(20,1); >>> vector = psi4.core.Matrix.from_array(data). >>> irrep_data = [np.random.rand(2, 2), np.empty(shape=(0,3)), np.random.rand(4, 4)]; >>> matrix = psi4.core.Matrix.from_array(irrep_data); >>> print(matrix.rowdim().to_tuple()); (2, 0, 4). classmethod from_list(x)¶. classmethod from_serial(json_data)¶; Converts serialized data to the correct Psi4 data type. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Vector, m: int) -> float. Returns a single element value located at m. get(self: psi4.core.Vector, h: int, m: int) -> float. Returns a single element value located at m in irrep h. get_block(self: psi4.core.Vector, slice: psi4.core.Slice) → psi4.core.Vector¶; Get a vector block. load(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Load the vector from disk. nirrep(self: psi4.core.Vector) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. print_out(self: psi4.core.Vector) → None¶; Prints the vector to the output file. save(self: psi4.core.Vector, psio: psi4.core.IO, file: int) → None¶; Save the vector to disk. scale(self: psi4.core.Vector, sc: float) → None¶; Scales the elements of a vector by sc. set(*args, **kwargs)¶; Overloaded function. set(self: psi4.core.Vector, m: int, val: float) -> None. Sets a single element value located at m. set(self: psi4.core.Vector, h: int, m: int, val: float) -> None. Sets a single element value located at m in irrep h. set_block(self: psi4.core.Vector, slice: psi4.core.Slice, block: psi4.core.Vector) → None¶; Set a vector block. to_array(copy=True, de",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html:4080,Load,Load,4080,psi4manual/1.6.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/api/psi4.core.Vector.html,1,['Load'],['Load']
Performance,"ng about the interaction between the two monomers. V. Potential Surface Scans and Counterpoise Correction Made Easy¶; Finally, let’s consider an example which highlights the advantages of; being able to interact with Psi4 directly with Python.; Suppose you want to do a limited potential energy surface scan, such as; computing the interaction energy between two neon atoms at various; interatomic distances. One simple but unappealing way to do this is to; generate separate geometries for each distance to be studied. Instead,; we can leverage Python loops and string formatting to make our lives; simpler. Additionally, let’s suppose you want to do counterpoise (CP); correction to compute interaction energies. Counterpoise correction; involves computing the dimer energy and then subtracting out the; energies of the two monomers, each evaluated in the dimer basis. Again,; each of these computations could be run in a separate input file, but; because counterpoise correction is a fairly standard procedure for; intermolecular interactions, Psi4 knows about it and has a built-in; routine to perform counterpoise correction. It only needs to know what; method you want to do the couterpoise correction on (here, let’s; consider CCSD(T)), and it needs to know what’s monomer A and what’s; monomer B. This last issue of specifying the monomers separately was; already dealt with in the previous SAPT example, where we saw that two; dashes in the psi4.geometry() string can be used to separate; monomers.; So, we’re going to do counterpoise-corrected CCSD(T) energies for; Ne\(_2\) at a series of different interatomic distances. And let’s; print out a table of the interatomic distances we’ve considered, and the; CP-corrected CCSD(T) interaction energies (in kcal/mol) at each; geometry:. In [9]:. #! Example potential energy surface scan and CP-correction for Ne2. ne2_geometry = """"""; Ne; --; Ne 1 {0}; """""". Rvals = [2.5, 3.0, 4.0]. psi4.set_options({'freeze_core': 'true'}). # Initialize a bla",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/psiapi-1.html:18116,perform,perform,18116,psi4manual/1.1.0/psiapi-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/psiapi-1.html,4,['perform'],['perform']
Performance,"ng geom. getFromDict(dataDict, mapList). get_memory(); Function to return the total memory allocation. gradient(name, **kwargs); Function complementary to :py:func:~driver.optimize(). hessian(name, **kwargs); Function complementary to frequency(). join_path(prefix, *args). levenshtein(seq1, seq2); Function to compute the Levenshtein distance between two strings. molden(wfn[, filename, density_a, …]); Function to write wavefunction information in wfn to filename in molden format. molecule_from_arrays; classmethod(function) -> method. molecule_from_schema; classmethod(function) -> method. molecule_from_string; classmethod(function) -> method. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. pcm_helper(block); Passes multiline string block to PCMSolver parser. print_stderr(stuff); Function to print stuff to standard error stream. print_stdout(stuff); Function to print stuff to standard output stream. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. process_pubchem_command(matchobj); Function to process match of pubchem in molecule block. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up or just run SCF with a standard guess. scf_wavefunction_factory(name, ref_w",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psi4api-1.html:261331,optimiz,optimize,261331,psi4manual/1.2.1/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psi4api-1.html,6,"['optimiz', 'perform']","['optimization', 'optimize', 'perform']"
Performance,"ng is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard PSI4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; PSI4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’).; The SAPT module has been used to perform SAPT0 computations with over; 200 atoms and 2800 bas",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/sapt-1.html:3398,perform,performing,3398,psi4manual/4.0b2/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/sapt-1.html,8,['perform'],['performing']
Performance,"ng is the simplest possible input that will perform all; available SAPT computations (normally, you would pick one of these methods).; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set globals {; basis aug-cc-pvdz; }. energy('sapt0'); energy('sapt2'); energy('sapt2+'); energy('sapt2+(3)'); energy('sapt2+3'). The SAPT module uses the standard Psi4 partitioning of the dimer; into monomers. SAPT does not use spatial symmetry and needs the geometry; of the system to remain fixed throughout monomer and dimer calculations.; These requirements are imposed whenever a SAPT calculation is requested; but can also be set explicitly with the no_reorient and symmetry; c1 molecule keywords, as in the example above. A final note is that the; SAPT module is only capable of performing SAPT computations for; interactions between closed-shell singlets.; The example input shown above would not be used in practice.; To exploit the efficiency of the density-fitted SAPT implementation in; Psi4, the SCF computations should also be performed with density-fitted; (DF) integrals.; set globals {; basis aug-cc-pvdz; df_basis_scf aug-cc-pvdz-jkfit; df_basis_sapt aug-cc-pvdz-ri; guess sad; scf_type df; }. set sapt {; print 1; }. These options will perform the SAPT computation with DF-HF and a; superposition-of-atomic-densities guess. This is the preferred method of; running the SAPT module. SAPT0¶; Generally speaking, SAPT0 should be applied to large systems or large data; sets. The performance of SAPT0 relies entirely on error cancellation, which; seems to be optimal with a truncated aug-cc-pVDZ basis, namely,; jun-cc-pVDZ (which we have referred to in previous work as; aug-cc-pVDZ’). We do not recommend using SAPT0 with large basis sets; like aug-cc-pVTZ. A systematic study of",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/sapt-1.html:6654,perform,performing,6654,psi4manual/1.0.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/sapt-1.html,2,['perform'],['performing']
Performance,"ng statistics across databases. >>> asdf = qcdb.Database(['s22', 'Nbc10', 'hbc6', 'HSG'], 'DB4'); >>> qwer = qcdb.Database('s22'); """""". def __init__(self, dbnamelist, dbse=None, pythonpath=None, loadfrompickle=False, path=None):; #: internal name of database collection; #:; #: >>> print asdf.dbse; #: 'DB4'; self.dbse = None. #: ordered component Database objects; #:; #: >>> print asdf.dbdict; #: XXXX; self.dbdict = OrderedDict(). #: subset assembly pattern; #:; #: >>> print asdf.sset.keys(); #: XXXX; self.sset = OrderedDict(). #: assembly pattern for transspecies modelchems; #:; #: >>> print asdf.mcs.keys(); #: XXXX; self.mcs = {}. self.benchmark = None. # slight validation, repackaging into dbnamelist; if isinstance(dbnamelist, basestring):; dbnamelist = [dbnamelist]; elif all(isinstance(item, basestring) for item in dbnamelist):; pass; else:; raise ValidationError('Database::constructor: Inappropriate configuration of constructor arguments'). # load databases; for db in dbnamelist:; if loadfrompickle:; tmp = WrappedDatabase.load_pickled(db, path=path); else:; tmp = WrappedDatabase(db, pythonpath=pythonpath); self.dbdict[tmp.dbse] = tmp. # slurp up the obvious overlaps; consolidated_bench = [odb.benchmark() for odb in self.dbdict.values()]; if len(set(consolidated_bench)) == 1:; self.benchmark = consolidated_bench[0]; else:; self.benchmark = ''.join(consolidated_bench); self.mcs[self.benchmark] = consolidated_bench. # methods[ref] = Method(name=ref); # bases[ref] = BasisSet(name=ref). self.mcs['default'] = consolidated_bench; # self.mcs['default'] = [odb.benchmark() for odb in self.dbdict.values()]; self._intersect_subsets(); self._intersect_modelchems(). # complex subsets; self.load_subsets(). # collection name; self.dbse = ''.join(self.dbdict.keys()) if dbse is None else dbse. # merge Reaction-s; self.hrxn = OrderedDict(); for db, odb in self.dbdict.iteritems():; for rxn, orxn in odb.hrxn.iteritems():; self.hrxn[orxn.dbrxn] = orxn. # merge Reagent-s; self.hrgt = ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html:47614,load,load,47614,psi4manual/1.0.0/_modules/qcdb/dbwrap.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/_modules/qcdb/dbwrap.html,2,['load'],"['load', 'loadfrompickle']"
Performance,"ng the algorithm for a MP2 gradient call; and directing toward the OCC (conv MP2) or the DFMP2 modules. run_mp2c(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a coupled MP2 calculation. run_mp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 calculation. run_mp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP3 gradient calculation. run_mrcc(name, **kwargs)[source]¶; Function that prepares environment and input files; for a calculation calling Kallay’s MRCC code. run_ocepa(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized CEPA computation. run_ocepa_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OCEPA gradient calculation. run_oldmp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; a MP2 calculation. run_omp2(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2 computation. run_omp2_5(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP2.5 computation. run_omp2_5_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2.5 gradient calculation. run_omp2_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP2 gradient calculation. run_omp3(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; an orbital-optimized MP3 computation. run_omp3_gradient(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for; OMP3 gradient calculation. run_psimrcc(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the MCSCF module. run_psimrcc_scf(name, **kwargs)[source]¶; Function encoding sequence of PSI module calls for a PSIMRCC computation; using a reference from the SCF module. ru",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html:10398,optimiz,optimized,10398,psi4manual/4.0b5/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_driver-1.html,2,['optimiz'],['optimized']
Performance,"ng to the quantum chemical method and so its default value is set; by each module individually. [7](1, 2, 3) For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is already quite flexible and powerful, with new features being; added weekly. We have tried as much as possible to keep the number of options to; a minimum, and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment. Also, the SAD; UHF guess is very slow in large basis sets, so you may want to cast up for; >TZ.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your primary basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). Table Of Contents. H",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:32944,perform,performing,32944,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,6,['perform'],['performing']
Performance,"ng. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self, arg0, arg1); docstring. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self, arg0); Sets the internal JK object !expert. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. iteration_energies = []¶. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_per",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html:4648,perform,performed,4648,psi4manual/1.9.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.HF.html,4,['perform'],['performed']
Performance,"ng. save_density_and_energy(self); docstring. scf_type(self); Return the value of scf_type used in the SCF computation. semicanonicalize(self); Semicanonicalizes the orbitals for ROHF. set_energies(self, arg0, arg1); docstring. set_external_cpscf_perturbation(self, name, ...); Add an external potential/perturbation to the private external_cpscf_perturbations map for CPSCF. set_jk(self, arg0); Sets the internal JK object !expert. set_sad_basissets(self, arg0); Sets the Superposition of Atomic Densities basisset. set_sad_fitting_basissets(self, arg0); Sets the Superposition of Atomic Densities density-fitted basisset. soscf_update(self, arg0, arg1, arg2, arg3); Computes a second-order SCF update. stability_analysis(self); Assess wfn stability and correct if requested. twoel_Hx(self, arg0, arg1, arg2); Two-electron Hessian-vector products. validate_diis(); Sanity-checks DIIS control options. Attributes Documentation. MOM_excited_¶; Are we to do excited-state MOM?. MOM_performed_¶; MOM performed current iteration?. attempt_number_¶; Current macroiteration (1-indexed) for stability analysis. diis_enabled_¶; docstring. diis_manager_¶; The DIIS object. diis_start_¶; docstring. frac_performed_¶; Frac performed current iteration?. initialized_diis_manager_¶; Has the DIIS object been initialized?. iteration_¶; Internal iterator for SCF cycles. After completion, this equals the number of iterations taken to converge the SCF equations. reset_occ_¶; Do reset the occupation after the guess to the inital occupation. sad_¶; Do assume a non-idempotent density matrix and no orbitals after the guess. Methods Documentation. V_potential(self: psi4.core.HF) → psi4.core.VBase¶; Returns the internal DFT V object. Va(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Alpha Kohn-Sham Potential Matrix. Vb(self: psi4.core.HF) → psi4.core.Matrix¶; Returns the Beta Kohn-Sham Potential Matrix. check_phases(self: psi4.core.HF) → None¶; docstring. clear_external_cpscf_perturbations(self: psi4.core",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html:4626,perform,performed,4626,psi4manual/1.7.x/api/psi4.core.HF.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.HF.html,4,['perform'],['performed']
Performance,"ng; Default: No Default. EXT_FORCE_DIHEDRAL¶. Specify formula for external forces for dihedral angles between atoms. Type: string; Default: No Default. EXT_FORCE_DISTANCE¶. Specify formula for external forces for the distance between atoms. Type: string; Default: No Default. EXT_FORCE_OOFP¶. Specify formula for external forces for out-of-plane angles between atoms. Type: string; Default: No Default. FROZEN_BEND¶. Specify angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_CARTESIAN¶. Specify atom and X, XY, XYZ, … to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DIHEDRAL¶. Specify dihedral angles between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_DISTANCE¶. Specify distances between atoms to be frozen (unchanged). Type: string; Default: No Default. FROZEN_OOFP¶. Specify out-of-plane angles between atoms to be frozen (unchanged). Type: string; Default: No Default. GEOM_MAXITER¶. Maximum number of geometry optimization steps. Type: integer; Default: 50. H_UPDATE_DEN_TOL¶. Denominator check for hessian update. Type: conv double; Default: 1e-7. INTERFRAG_STEP_LIMIT¶. Maximum step size in bohr or radian along an interfragment coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT¶. Initial maximum step size in bohr or radian along an internal coordinate. Type: double; Default: 0.5. INTRAFRAG_STEP_LIMIT_MAX¶. Upper bound for dynamic trust radius [au]. Type: double; Default: 1.0. INTRAFRAG_STEP_LIMIT_MIN¶. Lower bound for dynamic trust radius [au]. Type: double; Default: 0.001. IRC_DIRECTION¶. IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_POINTS¶. Maximum number of IRC points to collect before stopping. Type: integer; Default: 20. IRC_STEP_SIZE¶. IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. OPT_COORDINATES¶. Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. CARTESIAN us",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html:1982,optimiz,optimization,1982,psi4manual/1.7.x/autodir_options_c/module__optking.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__optking.html,6,['optimiz'],['optimization']
Performance,"ng; Default: WERNER. LOCAL_PAIRDEF¶. Definition of local pair domains. Type: string; Default: No Default. LOCAL_WEAKP¶. Desired treatment of “weak pairs” in the local-CCSD method. The value of NONE (unique available option) treats weak pairs in the same manner as strong pairs. Type: string; Default: NONE. MAXITER¶. Maximum number of iterations. Type: integer; Default: 50. NUM_AMPS_PRINT¶. Number of important CC amplitudes per excitation level to print. CC analog to NUM_DETS_PRINT. Type: integer; Default: 10. PROP_ALL¶. Compute unrelaxed properties for all excited states. Type: boolean; Default: true. PROP_ROOT¶. Root number (within its irrep) for computing properties. Type: integer; Default: 1. PROP_SYM¶. The symmetry of states. Type: integer; Default: 1. RESTART¶. Do restart the coupled-cluster iterations from old \(\lambda_1\) and \(\lambda_2\) amplitudes?. Type: boolean; Default: false. ROOTS_PER_IRREP¶. The number of electronic states to computed, per irreducible representation. Type: array; Default: No Default. R_CONVERGENCE¶. Convergence criterion for wavefunction (change) in CC lambda-amplitude equations. Type: conv double; Default: 1e-7. SEKINO¶. Do Sekino-Bartlett size-extensive model-III?. Type: boolean; Default: false. ZETA¶. Do use zeta?. Type: boolean; Default: false. Expert¶. JOBTYPE¶. Type of job being performed. Type: string; Default: No Default. WFN¶. Wavefunction type. Type: string; Default: SCF. table of contents. CCLAMBDA; General; ABCD; AO_BASIS; CACHELEVEL; DIIS; LOCAL; LOCAL_CPHF_CUTOFF; LOCAL_CUTOFF; LOCAL_FILTER_SINGLES; LOCAL_METHOD; LOCAL_PAIRDEF; LOCAL_WEAKP; MAXITER; NUM_AMPS_PRINT; PROP_ALL; PROP_ROOT; PROP_SYM; RESTART; ROOTS_PER_IRREP; R_CONVERGENCE; SEKINO; ZETA. Expert; JOBTYPE; WFN. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.3.2;  · . PSI4. Appendices; Keywords by Module. © Copyright 2019, The Psi4 Project.; Last updated on Wednesday, 15 May 2019 08:49PM.; Created using Sphinx 1.8.5.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cclambda-1.html:3258,perform,performed,3258,psi4manual/1.3.2/autodir_options_c/module__cclambda-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cclambda-1.html,2,['perform'],['performed']
Performance,"ng; Possible Values: REMOVE, REDIST; Default: REMOVE. BRIANQC_ENABLE (GLOBALS)¶GLOBALS — Whether to enable using the BrianQC GPU module. Type: boolean; Default: false. BRUECKNER_MAXITER (FNOCC)¶FNOCC — Maximum number of iterations for Brueckner orbitals optimization. Type: integer; Default: 20. BRUECKNER_ORBS_R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for Brueckner orbitals. The convergence is determined based on the largest \(T_1\) amplitude. Default adjusts depending on E_CONVERGENCE. Type: conv double; Default: 1e-5. CACHELEVEL (ADC)¶ADC — How to cache quantities within the DPD library. This option is only available for the built-in ADC backend. Type: integer; Default: 2. CACHELEVEL (CCDENSITY)¶CCDENSITY — The amount of caching of data to perform. Type: integer; Default: 2. CACHELEVEL (CCENERGY)¶CCENERGY — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\langle ij | ab \rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM)¶CCEOM — Caching level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantities with up to two virtual-orbital indices (e.g., \(\left\langle ij | ab \right\rangle\) integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCHBAR)¶CCHBAR — Caching level for libdpd governing the storage of amplitudes, inte",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:8451,cache,cache,8451,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,10,['cache'],['cache']
Performance,"nge(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (molecule.symbol(; at), molecule.x(at), molecule.y(at), molecule.z(at))). for at in range(molecule.natom()):; handle.write('%6s %16.8f %16.8f %16.8f\n' % (; '', gradient.get(at, 0), gradient.get(at, 1), gradient.get(at, 2))). [docs]def sherrill_gold_standard(func, label, **kwargs):; r""""""Function to call the quantum chemical method known as 'Gold Standard'; in the Sherrill group. Uses :py:func:`~psi4.driver.cbs` to evaluate; the following expression. Two-point extrapolation of the correlation energy; performed according to :py:func:`~psi4.driver.driver_cbs.corl_xtpl_helgaker_2`. .. math:: E_{total}^{\text{Au\_std}} = E_{total,\; \text{SCF}}^{\text{aug-cc-pVQZ}} \; + E_{corl,\; \text{MP2}}^{\text{aug-cc-pV[TQ]Z}} \; + \delta_{\text{MP2}}^{\text{CCSD(T)}}\big\vert_{\text{aug-cc-pVTZ}}. >>> # [1] single-point energy by this composite method; >>> energy('sherrill_gold_standard'). >>> # [2] finite-difference geometry optimization; >>> optimize('sherrill_gold_standard'). >>> # [3] finite-difference geometry optimization, overwriting some pre-defined sherrill_gold_standard options; >>> optimize('sherrill_gold_standard', corl_basis='cc-pV[DT]Z', delta_basis='3-21g'). """"""; kwargs['scf_basis'] = kwargs.get('scf_basis', 'aug-cc-pVQZ'); kwargs['scf_scheme'] = kwargs.get('scf_scheme', driver_cbs.xtpl_highest_1). kwargs['corl_wfn'] = kwargs.get('corl_wfn', 'mp2'); kwargs['corl_basis'] = kwargs.get('corl_basis', 'aug-cc-pV[TQ]Z'); kwargs['corl_scheme'] = kwargs.get('corl_scheme', driver_cbs.corl_xtpl_helgaker_2). kwargs['delta_wfn'] = kwargs.get('delta_wfn', 'ccsd(t)'); kwargs['delta_wfn_lesser'] = kwargs.get('delta_wfn_lesser', 'mp2'); kwargs['delta_basis'] = kwargs.get('delta_basis', 'aug-cc-pVTZ'); kwargs['delta_scheme'] = kwargs.get('delta_scheme', driver_cbs.xtpl_highest_1). if label == 'custom_function':; label = 'Sherrill Group Gold Standard'; return driver_cbs.cbs(func, label, **kwargs). [docs]def allen_foca",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html:3346,optimiz,optimization,3346,psi4manual/1.4.0/_modules/psi4/driver/aliases.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/aliases.html,8,['optimiz'],"['optimization', 'optimize']"
Performance,"nge¶. Warning; The LinK code is currently under development and should not be used. Large SCF calculations can benefit from specialized screening procedures that further reduce the scaling of the ERI contribution to the Fock matrix.; LinK, the linear-scaling exchange method described in [Ochsenfeld:1998:1663], is available with the direct SCF algorithm (SCF_TYPE set to DIRECT).; LinK achieves linear-scaling by exploiting shell pair sparsity in the density matrix and overlap sparsity between shell pairs.; This method is most competitive when used with non-diffuse orbital basis sets, since orbital and density overlaps decay slower with diffuse functions.; LinK is especially powerful when combined with density-matrix based ERI screening (set SCREENING to DENSITY) and incremental Fock builds (set INCFOCK to TRUE), which decrease the number of significant two-electron integrals to calculate.; NOTE: Turning on LinK is currently only recommended for research and development purposes, and not for performance,; since a fast J matrix build compatible to use with LinK has not been developed yet.; To turn on and control the LinK algorithm, here are the list of options provided. DO_LINK: Defaults to false. If turned on, the K matrix will be built using the algorithm described in [Ochsenfeld:1998:1663].; LINK_INTS_TOLERANCE: The integral screening tolerance used for sparsity-prep in the LinK algorithm. Defaults to the INTS_TOLERANCE option. Second-order Convergence¶; Second-order convergence takes into account both the gradient and Hessian to; take a full Newton step with respect to the orbital parameters. This results in; quadratic convergence with respect to density for SCF methods. For cases where; normal acceleration methods either fail or take many iterations to converge,; second-order can reduce the total time to solution.; Solving second-order (SO) methods exactly would require an inversion of the; orbital Hessian (an expensive \(\mathbb{N}^6\) operation); however, these; ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/scf.html:33613,perform,performance,33613,psi4manual/1.6.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/scf.html,1,['perform'],['performance']
Performance,"ngine.vector_dot(vecs[i], H2x[j]). _print_array(""Subspace Transformed (A+B)"", H1_ss, verbose); _print_array(""Subspace Transformed (A-B)"", H2_ss, verbose). # Diagonalize H2 in the subspace (eigen-decomposition to compute H2^(1/2)); H2_ss_val, H2_ss_vec = np.linalg.eigh(H2_ss); _print_array(""eigenvalues H2_ss"", H2_ss_val, verbose); _print_array(""eigenvectors H2_ss"", H2_ss_vec, verbose). # Check H2 is PD; # NOTE: If this triggers failure the SCF solution is not stable. A few ways to handle this; # 1. Use davidson solver where product function evaluates (H2 * (H1 * X)); # - Poor convergence; # 2. Switch to CIS/TDA; # - User would probably not expect this; # 3. Perform Stability update and restart with new reference; if np.any(H2_ss_val < 0.0):; msg = (""The H2 matrix is not Positive Definite. "" ""This means the reference state is not stable.""); raise RuntimeError(msg). # Build H2^(1/2); H2_ss_half = np.einsum(""ik,k,jk->ij"", H2_ss_vec, np.sqrt(H2_ss_val), H2_ss_vec, optimize=True); _print_array(""SS Transformed (A-B)^(1/2)"", H2_ss_half, verbose). # Build Hermitian SS product (H2)^(1/2)(H1)(H2)^(1/2); Hss = np.einsum('ij,jk,km->im', H2_ss_half, H1_ss, H2_ss_half, optimize=True); _print_array(""(H2)^(1/2)(H1)(H2)^(1/2)"", Hss, verbose). #diagonalize Hss -> w^2, Tss; w2, Tss = np.linalg.eigh(Hss); _print_array(""Eigenvalues (A-B)^(1/2)(A+B)(A-B)^(1/2)"", w2, verbose); _print_array(""Eigvectors (A-B)^(1/2)(A+B)(A-B)^(1/2)"", Tss, verbose). # pick positive roots; Tss = Tss[:, w2 > 1.0e-10]; w2 = w2[w2 > 1.0e-10]. # check for invalid eigvals; with np.errstate(invalid='raise'):; w = np.sqrt(w2). # sort roots; idx = w.argsort()[:nk]; Tss = Tss[:, idx]; w = w[idx]. # Extract Rss = H2^{1/2}Tss; Rss = np.dot(H2_ss_half, Tss). # Extract Lss = (H1 R)/ w; Lss = np.dot(H1_ss, Rss).dot(np.diag(1.0 / w)). # Biorthonormalize R/L solution vectors; inners = np.einsum(""ix,ix->x"", Rss, Lss, optimize=True); Rss = np.einsum(""x,ix->ix"", 1. / np.sqrt(inners), Rss, optimize=True); Lss = np.einsum(""x,ix->ix",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html:29625,optimiz,optimize,29625,psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/p4util/solvers.html,8,['optimiz'],['optimize']
Performance,"ngles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.4;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2021, The Psi4 Project.; Last updated on Thursday, 05 August 2021 02:16PM.; Created using Sphinx 4.1.2.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html:22244,perform,perform,22244,psi4manual/1.4.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.energy-1.html,8,['perform'],['perform']
Performance,"ngles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples. >>> # [1] Coupled-cluster singles and doubles calculation with psi code; >>> energy('ccsd'). >>> # [2] Charge-transfer SAPT calculation with scf projection from small into; >>> # requested basis, with specified projection fitting basis; >>> set basis_guess true; >>> set df_basis_guess jun-cc-pVDZ-JKFIT; >>> energy('sapt0-ct'). >>> # [3] Arbitrary-order MPn calculation; >>> energy('mp7'). >>> # [4] Converge scf as singlet, then run detci as triplet upon singlet reference; >>> # Note that the integral transformation is not done automatically when detci is run in a separate step.; >>> molecule H2 {\n0 1\nH\nH 1 0.74\n}; >>> set basis cc-pVDZ; >>> set reference rohf; >>> scf_e, scf_wfn = energy('scf', return_wfn=True); >>> H2.set_multiplicity(3); >>> core.MintsHelper(scf_wfn.basisset()).integrals(); >>> energy('detci', ref_wfn=scf_wfn). >>> # [5] Run two CI calculations, keeping the integrals generated in the first one.; >>> molecule ne {\nNe\n}; >>> set basis cc-pVDZ; >>> cisd_e, cisd_wfn = energy('cisd', return_wfn=True); >>> energy('fci', ref_wfn=cisd_wfn). >>> # [6] Can automatically perform complete basis set extrapolations; >>> energy(""CCSD/cc-pV[DT]Z""). >>> # [7] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> energy(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.5;  · . PSI4. PSI4 API: Linking C++ and Python; energy. © Copyright 2021, The Psi4 Project.; Last updated on Sunday, 28 November 2021 02:41AM.; Created using Sphinx 4.3.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.energy-1.html:22309,perform,perform,22309,psi4manual/1.5.0/api/psi4.driver.energy-1.html,https://psicode.org,https://psicode.org/psi4manual/1.5.0/api/psi4.driver.energy-1.html,8,['perform'],['perform']
Performance,"ning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. [7]; (1,2,3); For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theory; Minimal Input; Spin/Symmetry Treatment; Broken Sym",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:49042,perform,performing,49042,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,4,['perform'],['performing']
Performance,"ning virtuals. First, an initial CISD computation is run to get the natural orbitals; this allows a meaningful partitioning of the virtual orbitals into groups of different importance. Next, the RASCI is run. The split-virtual CISD[TQ] takes all singles and doubles, and all triples and quadruples with no more than 2 electrons in the secondary virtual subspace (RAS 3). If any electrons are present in the tertiary virtual subspace (RAS 4), then that excitation is only allowed if it is a single or double. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-virtual integrals are transformed into MO basis. scf-occ; force occupations in scf. scf7; Tests SCF gradient in the presence of a dipole field. omp2-4; SCS-OMP2 cc-pVDZ geometry optimization for the H2O molecule. pywrap-all; Intercalls among python wrappers- database, cbs, optimize, energy, etc. Though each call below functions individually, running them all in sequence or mixing up the sequence is aspirational at present. Also aspirational is using the intended types of gradients. rasci-c2-active; 6-31G* C2 Test RASCI Energy Point, testing two different ways of specifying the active space, either with the ACTIVE keyword, or with RAS1, RAS2, RESTRICTED_DOCC, and RESTRICTED_UOCC. cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest \(^{2}A_1\) excited state of H2O+ (B1 excitation). omp3-4; SCS-OMP3 cc-pVDZ geometry optimization for the H2O molecule. dfomp2-4; OMP2 cc-pVDZ energy for the NO molecule. mcscf2; TCSCF cc-pVDZ energy of asymmetrically displaced ozone, with Z-matrix input. omp2-2; OMP2 cc-pVDZ energy with ROHF initial guess orbitals for the NO radical. cc33; CC3(UHF)/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). pywrap-freq-e-sowreap; F",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/testsuite-1.html:33233,optimiz,optimization,33233,psi4manual/1.1.0/testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/testsuite-1.html,4,['optimiz'],['optimization']
Performance,"nite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). return_history = kwargs.pop('return_history', False); if return_history:; # Add wfn once the deep copy issues are worked out; step_energies = []; step_gradients = []; step_coordinates = []. # For CBS wrapper, need to set retention on INTCO file; if custom_gradient or ('/' in lowername):; core.IOManager.shared_object().set_specific_retention(1, True). if kwargs.get('bsse_type', None) is not None:; raise ValidationError(""Optimize: Does not currently support 'bsse_type' arguements""). full_hess_every = core.get_option('OPTKING', 'FULL_HESS_EVERY'); steps_since_last_hessian = 0. if custom_gradient and core.has_option_changed('OPTKIN",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:58596,optimiz,optimize,58596,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,1,['optimiz'],['optimize']
Performance,"nklin Street, Fifth Floor, Boston, MA 02110-1301 USA.; #; # @END LICENSE; #. """"""Module with functions for Psi4/Cfour interface. Portions that require; calls to Boost Python psi4 module are here, otherwise in qcdb module.; Also calls to qcdb module are here and not elsewhere in driver.; Organizationally, this module isolates qcdb code from psi4 code. """"""; import inspect; import os; import re; import shutil; import subprocess; import sys; import uuid. import qcelemental as qcel. from psi4 import core. from .. import p4util, qcdb; from ..p4util.exceptions import *. # never import driver, wrappers, or aliases into this file. P4C4_INFO = {}. [docs]; def run_cfour(name, **kwargs):; """"""Function that prepares environment and input files; for a calculation calling Stanton and Gauss's CFOUR code.; Also processes results back into Psi4 format. This function is not called directly but is instead called by; :py:func:`~psi4.driver.energy` or :py:func:`~psi4.driver.optimize` when a Cfour; method is requested (through *name* argument). In order to function; correctly, the Cfour executable ``xcfour`` must be present in; :envvar:`PATH` or :envvar:`PSIPATH`. .. hlist::; :columns: 1. * Many :ref:`PSI Variables <apdx:cfour_psivar>` extracted from the Cfour output; * Python dictionary of associated file constants accessible as ``P4C4_INFO['zmat']``, ``P4C4_INFO['output']``, ``P4C4_INFO['grd']``, *etc.*. :type name: str; :param name: ``'c4-scf'`` || ``'c4-ccsd(t)'`` || ``'cfour'`` || etc. First argument, usually unlabeled. Indicates the computational; method to be applied to the system. :type keep: :ref:`boolean <op_py_boolean>`; :param keep: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether to delete the Cfour scratch directory upon; completion of the Cfour job. :type path: str; :param path:. Indicates path to Cfour scratch directory (with respect to Psi4; scratch directory). Otherwise, the default is a subdirectory; within the Psi4 scratch directory. If specified, GENBAS and/or ZMAT wi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html:2042,optimiz,optimize,2042,psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/procrouting/interface_cfour.html,4,['optimiz'],['optimize']
Performance,"nly the totally symmetric modes.; -1 indicates a full frequency calculation. Note; Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availability of gradients or energies. name; calls method. scf; Hartree–Fock (HF) [manual]. Examples:. >>> # [1] Frequency calculation for all modes through highest available derivatives; >>> frequency('ccsd'). >>> # [2] Frequency calculation for b2 modes through finite difference of gradients; >>> # printing lowest mode frequency to screen and Hessian to output; >>> E, wfn = frequencies('scf', dertype=1, irrep=4, return_wfn=True); >>> print wfn.frequencies().get(0, 0); >>> wfn.hessian().print_out(). >>> # [3] Frequency calculation at default conditions and Hessian reuse at STP; >>> E, wfn = freq('mp2', return_wfn=True); >>> set t 273.15; >>> set p 100000; >>> thermo(wfn, wfn.frequencies()). >>> # [4] Opt+Freq, skipping the gradient recalc at the start of the Hessian; >>> e, wfn = optimize('hf', return_wfn=True); >>> frequencies('hf', ref_gradient=wfn.gradient()). psi4.hessian(name[, molecule, return_wfn, func, dertype, irrep])[source]¶; Function complementary to frequency(). Computes force; constants, deciding analytic, finite difference of gradients, or; finite difference of energies. Returns:Matrix – Total non-mass-weighted electronic Hessian in Hartrees/Bohr/Bohr. Returns:(Matrix, Wavefunction) – Hessian and wavefunction when return_wfn specified. Examples:. >>> # [1] Frequency calculation without thermochemical analysis; >>> hessian('mp3'). >>> # [2] Frequency calc w/o thermo analysis getting the Hessian; >>> # in file, core.Matrix, and np.array forms; >>> set hessian_write on; >>> H, wfn = hessian('ccsd', return_wfn=True); >>> wfn.hessian().print_out(); >>> np.array(H). It’s handy to collect the wavefunction after a frequency; calculation through e, wfn = psi4.frequency(...,; return_wfn=True) as the frequencies can be accessed through; psi4.core.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/freq-1.html:3393,optimiz,optimize,3393,psi4manual/1.3.2/freq-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/freq-1.html,2,['optimiz'],['optimize']
Performance,"nner(name.upper()); core.print_out('\n'). # EFP preparation; efp = core.get_active_efp(); if efp.nfragments() > 0:; core.set_legacy_molecule(scf_molecule); core.set_global_option('QMEFP', True) # apt to go haywire if set locally to efp; core.efp_set_options(); efp.set_qm_atoms(); efp.print_out(). # the SECOND scf call; base_wfn = core.Wavefunction.build(scf_molecule, core.get_global_option('BASIS')); if banner:; core.print_out(""\n ---------------------------------------------------------\n"");; core.print_out("" "" + banner.center(58));. scf_wfn = scf_wavefunction_factory(name, base_wfn, core.get_option('SCF', 'REFERENCE')); core.set_legacy_wavefunction(scf_wfn). fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(scf_molecule.name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); read_filename = os.path.join(psi_scratch, fname + "".180.npz""). if (core.get_option('SCF', 'GUESS') == 'READ') and os.path.isfile(read_filename):; data = np.load(read_filename); Ca_occ = core.Matrix.np_read(data, ""Ca_occ""); Cb_occ = core.Matrix.np_read(data, ""Cb_occ""); symmetry = str(data[""symmetry""]); basis_name = str(data[""BasisSet""]). if symmetry != scf_molecule.schoenflies_symbol():; raise ValidationError(""Cannot compute projection of different symmetries.""). if basis_name == scf_wfn.basisset().name():; core.print_out("" Reading orbitals from file 180, no projection.\n\n""); scf_wfn.guess_Ca(Ca_occ); scf_wfn.guess_Cb(Cb_occ); else:; core.print_out("" Reading orbitals from file 180, projecting to new basis.\n\n""). puream = int(data[""BasisSet PUREAM""]). if "".gbs"" in basis_name:; basis_name = basis_name.split('/')[-1].replace('.gbs', ''). old_basis = core.BasisSet.build(scf_molecule, ""ORBITAL"", basis_name, puream=puream); core.print_out("" Computing basis projection from %s to %s\n\n"" % (basis_name, base_wfn.basisset().name())). nalphapi = core.Dimension.from_list(data[""nalphapi""]); nbetapi = core.Dimension.from_list(data[""nbetapi""]); pCa = scf_wfn.basis_proje",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html:36092,load,load,36092,psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/procrouting/proc.html,1,['load'],['load']
Performance,"nning at R_CONVERGENCE). It is defined; according to the quantum chemical method and so its default value is set; by each module individually. [7](1, 2, 3) For frequency computations by finite difference of energies,; convergence criteria are tightened further still to 10 for; E_CONVERGENCE and D_CONVERGENCE for SCF of HF or DFT, 11; for E_CONVERGENCE and D_CONVERGENCE for SCF of post-HF,; and 10 for E_CONVERGENCE for post-HF of post-HF. Recommendations¶; The SCF code is quite flexible and powerful.; We have tried as much as possible to keep the number of options to; a minimum and to allow all options to be used in the presence of all other; options. Below are some rough words of advice about using the SCF code for; practical calculations:. For GUESS, the SAD guess is usually your; friend, even for open-shell systems (at the very least, it gets the right; number of electrons, unlike some other programs). For instance, we have found; that a simple SAD guess is often as good as doing a full SCF in a 3-21G basis; and then performing a cast-up, at a fraction of the cost. However, SAD and; DOCC/SOCC arrays do not play very well together at the moment.; For wall time, DF may be a factor of ten or more faster than the exact; integral technologies available in PSI4.; Use DF unless you need absolute accuracy or do not; have a -JKFIT auxiliary set for your orbital basis/atom type. Then use; DIRECT.; Don’t mess with the DIIS convergence options unless convergence is a problem.; We have optimized the parameters for efficiency over a wide array of system; types.; Buy a developer a beer!. The “best-practice” input file for HF is:; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; basis cc-pvdz; scf_type df; guess sad; ints_tolerance 1.0E-10 # Even this is epically tight, 1.0E-8 is OK; }. energy('scf'). table of contents. HF: Hartree–Fock Theory; Introduction; Theor",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/scf-1.html:35579,perform,performing,35579,psi4manual/1.1.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/scf-1.html,6,['perform'],['performing']
Performance,"none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability'",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html:1225,optimiz,optimized,1225,psi4manual/1.4.0/api/psi4.driver.prop-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.prop-1.html,25,['optimiz'],['optimized']
Performance,"none. Caution; Some features are not yet implemented. Buy a developer a coffee. This function at present has a limited functionality.; Consult the keywords sections of other modules for further property capabilities. Name; Calls Method; Reference; Supported Properties. scf; Self-consistent field method(s); RHF/ROHF/UHF; Listed here. hf; HF Self-consistent field method(s); RHF/ROHF/UHF; Listed here. mp2; MP2 with density fitting only (mp2_type df); RHF; Listed here. cc2; 2nd-order approximate CCSD; RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. ccsd; Coupled cluster singles and doubles (CCSD); RHF; dipole, quadrupole, polarizability, rotation, roa_tensor. dct; density cumulant (functional) theory; [manual]; RHF/UHF; Listed here. omp2; orbital-optimized second-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp3; orbital-optimized third-order; MP perturbation theory; [manual]; RHF/UHF; Listed here; Density fitted only. omp2.5; orbital-optimized MP2.5; [manual]; RHF/UHF; Listed here; Density fitted only. olccd; orbital optimized LCCD; [manual]; RHF/UHF; Listed here; Density fitted only. eom-cc2; 2nd-order approximate EOM-CCSD; RHF; oscillator_strength, rotational_strength. eom-ccsd; Equation-of-motion CCSD (EOM-CCSD); RHF; oscillator_strength, rotational_strength. cisd, cisdt,; cisdt, cisdtq,; ci5, …, fci; Configuration interaction; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. casscf, rasscf; Multi-configurational SCF; RHF/ROHF; Listed here, transition_dipole,; transition_quadrupole. adc(0), adc(1),; …, adc(3),; cvs-adc(0), …; cvs-adc(3); Algebraic-diagrammatic construction methods; [manual]; RHF/UHF; dipole, transition_dipole, oscillator_strength,; rotational_strength. Parameters:. name (str) – 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; to be applied to the system. properties (List[str]) – \(\Rightarrow\) [] \(\Leftarrow\) || ['rotation', 'polarizability",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.prop.html:1227,optimiz,optimized,1227,psi4manual/1.7.x/api/psi4.driver.prop.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.prop.html,20,['optimiz'],['optimized']
Performance,"nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.a",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:53795,optimiz,optimization,53795,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). """"""; kwargs = p4util.kwargs_lower(kwargs). if hasattr(name, '__call__'):; lowername = name; custom_gradient = True; else:; lowername = name.lower(); custom_gradient = False. return_wfn = kwargs.pop('return_wfn', False). # For CBS wrapper, need to s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:55964,optimiz,optimization,55964,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"nonoo>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd | coupled cluster singles and doubles (CCSD) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsd>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | ccsd(t) | CCSD with perturbative triples (CCSD(T)) :ref:`[manual] <sec:cc>` :ref:`[details] <tlccsdt>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | eom-ccsd | equation of motion (EOM) CCSD :ref:`[manual] <sec:eomcc>` |; +-------------------------+---------------------------------------------------------------------------------------------------------------+. .. _`table:grad_scf`:. .. include:: ../autodoc_dft_opt.rst. .. include:: ../cfour_table_grad.rst. :examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Forced finite difference hf optimization run in; >>> # embarrassingly parallel fashion; >>> optimize('hf', dertype='energy', mode='sow'). >>> # [4] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [5] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [6] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optim",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html:57562,optimiz,optimization,57562,psi4manual/1.2.1/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/driver.html,2,['optimiz'],"['optimization', 'optimize']"
Performance,"not procedures['energy'][lowername] == run_scf and not procedures['energy'][lowername] == run_dft:; PsiMod.set_global_option('E_CONVERGENCE', 10). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient in the wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; optstash.restore(). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # call thermo module; PsiMod.thermo(). optstash.restore(); return energies[-1]. ## Aliases ##; frequencies = frequency; freq = frequency. # hessian to be changed later to compute force constants; [docs]def hessian(name, **kwargs):; r""""""Function to compute f",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:66640,Perform,Perform,66640,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,1,['Perform'],['Perform']
Performance,"nother. This; is presented in the “Orbital Check” section in these files – a value larger than; 0.1 docc is an indication that the picture of localizable functional groups may; be breaking down. We also strongly discourage the cutting of double,; triple, or aromatic bonding motifs when partitioning the molecule into fragments; – cuts across only simple sigma bonds are encouraged. Order-1 Visualization with PyMol¶; The fsapt.py script above also generates a number of order-1 .pdb files; that can be used to get a quick qualitative picture of the F-SAPT partition. The; preferred way to do this is to use PyMol to make plots of the molecular geometry; with the atoms colored according to their order-1 F-SAPT contributions. We have; a set of template .pymol scripts to help with this process. These can be; obtained by running:; >>> copy_pymol.py. and then in PyMol:; >>> @run.pymol. This last command runs all of the individual .pymol files (e.g.,; Elst.pymol), which in turn load in the molecule and order-1 analysis; (contained in the .pdb file), set up the visualization, and render a; .png image of the scene. Generally the view orientation and some specific; details of the .pymol files require some small tweaks to permit; publication-quality renderings. Difference F-SAPT Analysis¶; For those interested in taking the differences between two F-SAPT partitions; (e.g., to see how a substituent modulates a noncovalent interaction), we have; the fsapt-diff.py script to help with this. This is invoked as:; >>> fsapt-diff.py source-fsapt-dir1 source-fsapt-dir2 target-diff-fsapt-dir. Where the use has already performed fsapt.py analysis using the same; functional group names in source-fsapt-dir-1 and source-fsapt-dir-2. The; difference F-SAPT partition entries are computed as \(E^{\Delta} = E^{1} -; E^{2}\), and the geometries for order-1 .pdb visualization files are taken; from system 1. I-SAPT: A Representative Example¶. Caution; As of April 2018, you can’t specify molecule fragmen",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/fisapt-1.html:7474,load,load,7474,psi4manual/1.4.0/fisapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/fisapt-1.html,5,['load'],['load']
Performance,"now in molecule {...} block; cfour_REFerence=UHF; cfour_OCCUPATION [[3, 1, 1, 0], [3,0,1,0] ] # arrays in python notation; cfour_SCF_CONV=12; cfour_MEMORY=20000000; }. energy('cfour'). Here, note that none of capitalization, equals sign, or whitespace matter; for the keyword commands. Specifcation of strings and integers requires no; translation; booleans have extended freedom of; format; arrays must be translated into Python-style (square-bracket; bounded and comma delimited) of appropriate dimension. There are many; sample inputs in psi4/tests/cfour/ starting with sp- that take; examples from the Cfour manual and first run them in sandwich mode and; then run them as translated into Psi4 format. Note; Psi4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in Psi4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; Psi4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Severa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:6366,perform,perform,6366,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"nput. dfremp-2; density fitted REMP/cc-pVDZ energies for the CH3 radical. mints-helper; A general test of the MintsHelper function. dct-grad3; Restricted DF-DCT ODC-12 gradient for ethylene with cc-pVDZ/cc-pVDZ-RI standard/auxiliary basis set. mints10; H2 with tiny basis set, to test basis set parser’s handling of integers. mp2-h; check that methods can act on single atom. dfep2-2; Compute three IP and 2 EA’s for the PH3 molecule. cdremp-1; Cholesky decomposed REMP/cc-pVDZ energies for the CO2 molecule. cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. lccd-grad2; LCCD cc-pVDZ gradient for the NO radical. cc32; CC3/cc-pVDZ H2O \(R_e\) geom from Olsen et al., JCP 104, 8007 (1996). tdscf-6; td-camb3lyp with DiskDF and method/basis specification. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. cc13; UHF-CCSD/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. casscf-sp; CASSCF/6-31G** energy point. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-func; optimization with method defined via cbs. omp3-2; OMP3 cc-pCVDZ energy with ROHF initial guess for the NO radical. dfmp2-fc; Kr–Kr nocp energies with all-electron basis set to check frozen core. scf-occ; force occupations in scf. cdoremp-energy2; density fitted OO-REMP/cc-pVDZ engrad single points for the H2O+ molecule. dft-b2plyp; Double-hybrid density functional B2PYLP. Reproduces portion of Table I in S. Grimme’s J. Chem. Phys 124 034108 (2006) paper defining the functional. cc5; RHF CCSD(T) cc-pVDZ frozen-core energy of C4NH4 Anion. aediis-2; EDIIS test case from 10.1063/1.1470195. sapt7; SAPT0 open-shell computation of H2O-HO2 interaction energy First with cc-pVDZ and density fitted integrals with UHF Then with 6-31g and direct integrals, except for dispersion that is computed with cc-pVDZ-ri density fitting with UHF. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. dfccsd",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html:34579,optimiz,optimization,34579,psi4manual/master/autodoc_testsuite_corepsi4.html,https://psicode.org,https://psicode.org/psi4manual/master/autodoc_testsuite_corepsi4.html,2,['optimiz'],['optimization']
Performance,"nput. mints3; Test individual integral objects for correctness. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-cc-pVDZ BH Energy Point, with n=2-19. Compare against M. L. Leininger et al., J. Chem. Phys. 112, 9213 (2000). pywrap-checkrun-uhf; This checks that all energy methods can run with a minimal input and set symmetry. omp2_5-grad2; OMP2.5 cc-pVDZ gradient for the NO radical. cc38; RHF-CC2-LR/cc-pVDZ stati",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html:15196,perform,performed,15196,psi4manual/4.0b4/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance,"nput. mints3; Test individual integral objects for correctness. omp3-2; OMP3 cc-pVDZ energy with ROHF initial guess for the NO radical. cc2; 6-31G** H2O CCSD optimization by energies, with Z-Matrix input. pywrap-checkrun-convcrit; Advanced python example sets different sets of scf/post-scf conv crit and check to be sure computation has actually converged to the expected accuracy. cepa0-grad2; CEPA cc-pVDZ gradient for the NO radical. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. fci-tdm-2; BH-H2+ FCI/cc-pVDZ Transition Dipole Moment. psimrcc-ccsd_t-2; Mk-MRCCSD(T) single point. CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. psimrcc-fd-freq1; Mk-MRCCSD single point. O2 state described using the Ms = 0 component of the triplet. Uses ROHF triplet orbitals. rasci-h2o; RASCI/6-31G** H2O Energy Point. cc17; Single point energies of multiple excited states with EOM-CCSD. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. mrcc2; CCSDT(Q) cc-pVDZ energy for the H2O molecule using MRCC. This example builds up from CCSD. First CCSD, then CCSDT, finally CCSDT(Q). cc21; ROHF-EOM-CCSD/DZ analytic gradient lowest excited state of H2O+ (B1 excitation). opt7; Various constrained energy minimizations of HOOH with cc-pvdz RHF. For the “frozen” bonds, angles and dihedrals, these coordinates are constrained to remain at their initial values. For “fixed” bonds, angles, or dihedrals, the equilibrium (final) value of the coordinate is provided by the user. opt4; SCF cc-pVTZ geometry optimzation, with Z-matrix input. cc13a; UHF-CCSD(T)/cc-pVDZ CH2 geometry optimization via analytic gradients. mpn-bh; MP(n)/aug-c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html:15280,perform,performed,15280,psi4manual/4.0b5/autodoc_testsuite-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_testsuite-1.html,4,['perform'],['performed']
Performance,"nput.; Any combination of EFP and QM fragments can be placed in a molecule; even; the oddity below is legitimate. Note that symmetry and reorientation are; automatically turned off when EFP fragments are present (symmetry c1; and no_com and no_reorient are implied).; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17molecule qmefp {; efp nh3 0.0 0.0 5.0 5 2 8; --; C 0.0 0.0 0.0; O 0.0 1.5 0.0; O 0.0 -1.5 0.0; --; efp h2o 5.0 0.0 0.0 5 2 8; --; He -3.0 4.0 4.0; He -4.0 5.0 4.0; --; efp ch3oh; 1.275 -2.447 -4.673; 0.709 -3.191 -3.592; 2.213 -1.978 -4.343; }. Running EFP¶; EFP can be invoked in similar fashion as other theories provided in PSI4.; For example, if you want to obtain the EFP interaction energy for benzene and two waters,; simply provide the following:; 1; 2; 3; 4; 5; 6; 7; 8; 9molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o 4.0 0.0 0.0 0.0 0.0 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. energy('efp'). This computation involves purely EFP/EFP fragment interactions and is; performed entirely by the LIBEFP library. PSI4 can also handle mixed; systems of quantum mechanical (QM) and EFP fragments through the native; SCF code augmented by calls to the LIBEFP library. For; example, turning one of the waters in the example above into a QM; fragment is shown below.; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12molecule {; efp c6h6 0.0 0.0 0.0 0.0 0.0 0.0; --; O 4.0 0.0 0.0; H 4.7 0.7 0.0; H 3.3 -0.7 0.0; --; efp h2o -4.0 0.0 0.0 0.0 0.0 0.0; }. set basis 6-31g; energy('scf'). Whenever an EFP fragment is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the prece",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:5226,perform,performed,5226,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,6,['perform'],['performed']
Performance,"ns (e.g., the local option set by ``set scf scf_type df`` will not be respected). .. note:: To access a database that is not embedded in a |PSIfour|; distribution, add the path to the directory containing the database; to the environment variable :envvar:`PYTHONPATH`. :type name: string; :param name: ``'scf'`` || ``'sapt0'`` || ``'ccsd(t)'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the database. May be any valid argument to; :py:func:`~driver.energy`. :type db_name: string; :param db_name: ``'BASIC'`` || ``'S22'`` || ``'HTBH'`` || etc. Second argument, usually unlabeled. Indicates the requested database; name, matching (case insensitive) the name of a python file in; ``psi4/share/databases`` or :envvar:`PYTHONPATH`. Consult that; directory for available databases and literature citations. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``energy`` |dr| || ``optimize`` || ``cbs``. Indicates the type of calculation to be performed on each database; member. The default performs a single-point ``energy('name')``, while; ``optimize`` perfoms a geometry optimization on each reagent, and; ``cbs`` performs a compound single-point energy. If a nested series; of python functions is intended (see :ref:`sec:intercalls`), use; keyword ``db_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. Indicates whether the calculations required to complete the; database are to be run in one file (``'continuous'``) or are to be; farmed out in an embarrassingly parallel fashion; (``'sow'``/``'reap'``). For the latter, run an initial job with; ``'sow'`` and follow instructions in its output file. :type cp: :ref:`boolean <op_py_boolean>`; :param cp: ``'on'`` || |dl| ``'off'`` |dr|. Indicates whether counterpoise correction is employed in computing; interaction energies. Use this option and NOT the :py:func:`~wrappers.cp`; function for BSSE correction in database",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html:3512,perform,performed,3512,psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/wrapper_database.html,4,['perform'],['performed']
Performance,"ns are not yet available through the Psi4-GeomeTRIC interface""); Cons, CVals = geometric.prepare.parse_constraints(M, constraints_string); ; # Set up the internal coordinate system; coordsys = optimizer_keywords.get('coordsys', 'tric'); CoordSysDict = {; 'cart': (geometric.internal.CartesianCoordinates, False, False),; 'prim': (geometric.internal.PrimitiveInternalCoordinates, True, False),; 'dlc': (geometric.internal.DelocalizedInternalCoordinates, True, False),; 'hdlc': (geometric.internal.DelocalizedInternalCoordinates, False, True),; 'tric': (geometric.internal.DelocalizedInternalCoordinates, False, False); }; ; # Build internal coordinates; CoordClass, connect, addcart = CoordSysDict[coordsys.lower()]; IC = CoordClass(; M,; build=True,; connect=connect,; addcart=addcart,; constraints=Cons,; cvals=CVals[0] if CVals is not None else None); ; # Get initial coordinates in bohr; coords = M.xyzs[0].flatten() / constants.bohr2angstroms. # Setup an optimizer object; params = geometric.optimize.OptParams(**optimizer_keywords); optimizer = geometric.optimize.Optimizer(coords, M, IC, engine, None, params); ; # TODO: print constraints; # IC.printConstraints(coords, thre=-1); optimizer.calcEnergyForce(); optimizer.prepareFirstStep(); grms, gmax = optimizer.calcGradNorm(); conv_gmax = '*' if gmax < params.Convergence_gmax else ' '; conv_grms = '*' if grms < params.Convergence_grms else ' '; core.print_out(""\n Measures of convergence in internal coordinates in au. ~""); core.print_out(""\n Criteria marked as inactive (o), active & met (*), and active & unmet ( ). ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out(""\n Step Total Energy Delta E MAX Force RMS Force MAX Disp RMS Disp ~""); core.print_out(""\n --------------------------------------------------------------------------------------------- ~""); core.print_out((f""\n Convergence Criteria {params.Convergence_energy:10.2e} ""; f""{params.Conver",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html:58181,optimiz,optimize,58181,psi4manual/1.9.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/_modules/psi4/driver/driver.html,4,['optimiz'],['optimize']
Performance,"ns are slightly more efficient. Type: string; Possible Values: LAPLACE, CHOLESKY; Default: LAPLACE. DEBUG¶. The amount of information to print to the output file. Type: integer; Default: 0. Specific open-shell SAPT0 keywords¶. SAPT_MEM_SAFETY¶. Memory safety. Type: double; Default: 0.9. COUPLED_INDUCTION¶. Solve the CPHF equations to compute coupled induction and exchange-induction. These are not available for ROHF, and the option is automatically false in this case. In all other cases, coupled induction is strongly recommended. Only turn it off if the induction energy is not going to be used. Type: boolean; Default: true. SAPT(DFT)¶; In general, SAPT(DFT) should provide more accurate interaction energy; components, and overall interaction energies, than SAPT0. The drawback; is SAPT(DFT) method is more computationally demanding than SAPT0,; SAPT(DFT) can still be applied to medium-sized or large systems. The; SAPT(DFT) module was employed successfully in computations of systems; with up to 2000 basis functions, and the code should be scalable to; 3000 basis functions. Like higher-order SAPT, SAPT(DFT) requires; sufficient memory to hold \(2ovN_aux\) doubles.; SAPT(DFT) requires a few special treatments to obtain accurate; result. The DFT functionals used in SAPT(DFT) need to be asymptotically; corrected with Gradient Regulated Asymptotic Correction scheme (GRAC),; in order to recover the correct long-range asymptotic behavior; (approaching \(-1/r\) as \(r\) approaches infinity). The program; requires manual input of GRAC shift parameter for each monomer through; keywords SAPT_DFT_GRAC_SHIFT_A and SAPT_DFT_GRAC_SHIFT_B,; which should be equal to the difference of the actual ionization; potential and the corresponding Kohn-Sham HOMO energy. The dispersion; term needs to be computed with orbital response for good accuracy,; and it is recommended to enable SAPT_DFT_DO_HYBRID (set to; True by default). The coupled exchange-dispersion energy is usually; estimated by scalin",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/sapt-1.html:21478,scalab,scalable,21478,psi4manual/1.4.0/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/sapt-1.html,9,['scalab'],['scalable']
Performance,"ns for the block of two-electron integrals in the evaluation of second-order T2 amplitudes? Recommended true for all SAPT computations. Type: boolean; Default: false. OCC_TOLERANCE¶. Minimum occupation (eigenvalues of the MP2 OPDM) below which virtual natural orbitals are discarded for in each of the above three truncations. Type: conv double; Default: 1.0e-6. Advanced Keywords Controlling MP2 NO Approximations¶. Charge-Transfer in SAPT¶; It is possible to obtain the stabilization energy of a complex due to; charge-transfer effects from a SAPT computation. The charge-transfer energy; can be computed with the SAPT module as described by Stone; and Misquitta [Misquitta:2009:201].; Charge-transfer energies can be obtained from the following calls to the; energy function.; energy('sapt0-ct'); energy('sapt2-ct'); energy('sapt2+-ct'); energy('sapt2+(3)-ct'); energy('sapt2+3-ct'). A SAPT charge-transfer analysis will perform 5 HF computations: the dimer; in the dimer basis, monomer A in the dimer basis, monomer B in the dimer; basis, monomer A in the monomer A basis, and monomer B in the monomer B; basis. Next, it performs two SAPT computations, one in the dimer basis and; one in the monomer basis. Finally, it will print a summary of the; charge-transfer results:; SAPT Charge Transfer Analysis; -----------------------------------------------------------------------------; SAPT Induction (Dimer Basis) -2.0970 mH -1.3159 kcal mol^-1; SAPT Induction (Monomer Basis) -1.1396 mH -0.7151 kcal mol^-1; SAPT Charge Transfer -0.9574 mH -0.6008 kcal mol^-1. These results are for the water dimer geometry shown above computed with; SAPT0/aug-cc-pVDZ. Monomer-Centered Basis Computations¶; The charge-transfer analysis above is carried out by taking the; difference between SAPT induction as calculated in the dimer-centered; basis (i.e., each monomer sees the basis functions on both monomers); vs. the monomer-centered basis (i.e., each monomer utilizes only its; own basis set). It is also po",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/sapt-1.html:12432,perform,perform,12432,psi4manual/4.0b5/sapt-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/sapt-1.html,2,['perform'],['perform']
Performance,"ns it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Convergence Problems; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/occ-1.html:11159,optimiz,optimized,11159,psi4manual/4.0b5/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/occ-1.html,2,['optimiz'],['optimized']
Performance,"ns it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. DO_DIIS¶. Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_LEVEL_SHIFT¶. Do apply level shifting?. Type: boolean; Default: true. OCC: Conventional Møller–Plesset Perturbation Theories¶; Module: Keywords, PSI Variables, OCC; PSI4 also has a non-density-fitted MP2 algorithm for RHF and UHF; energies and gradients. The; density-fitted module DFMP2 is always the default, so to access the; conventional MP2 code, set MP2_TYPE to conv and call as usual; energy('mp2')/optimize('mp2'). Basic Keywords¶. MP2_TYPE¶. Algorithm to use for non-OO MP2 computation. Type: string; Possible Values: DF, CONV; Default: DF. MP2_OS_SCALE¶. MP2 opposite-spin scaling value. Type: double; Default: 6.0/5.0. MP2_SS_SCALE¶. MP2 same-spin scaling value. Type: double; Default: 1.0/3.0. Non-orbital-optimized counterparts to higher order MPn methods are also; available. Summarizing from tables above, the following methods are; available and can be controlled through OCC keywards. Name; Calls Method; Energy; Gradient; Reference. conv-mp2; MP2; Y; Y; RHF/ROHF/UHF. mp3; MP3; Y; Y; RHF/UHF. mp2.5; MP2.5; Y; Y; RHF/UHF. cepa0; CEPA(0) (identical to Linearized CCD); Y; Y; RHF/UHF. Table Of Contents. OCC: Orbital-Optimized Coupled-Cluster and Møller–Plesset Perturbation Theories; Introduction; Theory; Methods; Basic Keywords; E_CONVERGENCE; R_CONVERGENCE; RMS_MOGRAD_CONVERGENCE; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; WFN_TYPE; ORB_OPT. Advanced Keywords; OPT_METHOD; MO_DIIS_NUM_VECS; LINEQ_SOLVER; ORTH_TYPE; MP2_OS_SCALE; MP2_SS_SCALE; MP2_SOS_SCALE; MP2_SOS_SCALE2; NAT_ORBS; OCC_ORBS_PRINT; TPDM_ABCD_TYPE; DO_DIIS; DO_LEVEL_SHIFT. OCC: Conventional Møller–Plesset Perturbation Theories; Basic Keywords; MP2_TYPE; MP2_OS_SCALE; MP2_SS_SCALE. Previous topic; DF-MP2: Density-Fitted Second-Order Møller-Plesset Perturbation ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/occ-1.html:10562,optimiz,optimized,10562,psi4manual/4.0b4/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/occ-1.html,2,['optimiz'],['optimized']
Performance,"ns no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CPHF); CPHF — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (OCC); OCC — Cacheing level for libdpd governing the storage of amplitudes, integrals, and intermediates in the CC procedure. A value of 0 retains no quantities in cache, while a level of 6 attempts to store all quantities in cache. For particularly large calculations, a value of 0 may help with certain types of memory problems. The default is 2, which means that all four-index quantites with up to two virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 (Expert) — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the li",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html:9564,cache,cacheing,9564,psi4manual/4.0b5/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/autodoc_glossary_options_c-1.html,4,"['cache', 'perform']","['cacheing', 'perform']"
Performance,"ns. Type: boolean; Default: false. OPDM (DETCI)¶DETCI — Do compute one-particle density matrix if not otherwise required?. Type: boolean; Default: false. OPDM_GRID_CUTOFF (CCDENSITY)¶CCDENSITY — Cutoff (e/A^3) for printing one-particle density matrix values on a grid. Type: double; Default: 1.0e-30. OPDM_GRID_DUMP (CCDENSITY)¶CCDENSITY — Write one-particle density matrix on a grid to file opdm.dx. Type: boolean; Default: false. OPDM_GRID_STEPSIZE (CCDENSITY)¶CCDENSITY — Step size (Angstrom) for one-particle density matrix values on a grid. Type: double; Default: 0.1. OPDM_ONLY (CCDENSITY)¶CCDENSITY (Expert) — For internal use only! Compute the one-particle density matrix, but not the two-particle density matrix. Type: boolean; Default: false. OPDM_RELAX (CCDENSITY)¶CCDENSITY — Do relax the one-particle density matrix?. Type: boolean; Default: false. OPDM_RELAX (DFMP2)¶DFMP2 — Do relax the one-particle density matrix?. Type: boolean; Default: true. OPT_COORDINATES (OPTKING)¶OPTKING — Geometry optimization coordinates to use. REDUNDANT and INTERNAL are synonyms and the default. DELOCALIZED are the coordinates of Baker. NATURAL are the coordinates of Pulay. CARTESIAN uses only cartesian coordinates. BOTH uses both redundant and cartesian coordinates. Type: string; Possible Values: REDUNDANT, INTERNAL, DELOCALIZED, NATURAL, CARTESIAN, BOTH; Default: INTERNAL. OPT_METHOD (DFOCC)¶DFOCC — The orbital optimization algorithm. Presently quasi-Newton-Raphson algorithm available with several Hessian * options. Type: string; Possible Values: QNR; Default: QNR. OPT_METHOD (OCC)¶OCC — The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possi",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html:185209,optimiz,optimization,185209,psi4manual/1.6.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodoc_glossary_options_c.html,1,['optimiz'],['optimization']
Performance,"ns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :type irrep: int or string; :param irrep: |dl| ``-1`` |dr| || ``1`` || ``'b2'`` || ``'App'`` || etc. Indicates which symmetry block (:ref:`Cotton <table:irrepOrdering>` ordering) of vibrational; frequencies to be computed. ``1``, ``'1'``, or ``'a1'`` represents; :math:`a_1`, requesting only the totally symmetric modes.; ``-1`` indicates a full frequency calculation. .. note:: Analytic hessians are only available for RHF. For all other methods, Frequencies will; proceed through finite differences according to availabilit",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:70192,perform,performs,70192,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['performs']
Performance,"ns: (*float*, :py:class:`~psi4.core.Wavefunction`) |w--w| energy and wavefunction when **return_wfn** specified. :type name: string; :param name: ``'scf'`` || ``'mp2'`` || ``'ci5'`` || etc. First argument, usually unlabeled. Indicates the computational method; to be applied to the system. :type molecule: :ref:`molecule <op_py_molecule>`; :param molecule: ``h2o`` || etc. The target molecule, if not the last molecule defined. :type return_wfn: :ref:`boolean <op_py_boolean>`; :param return_wfn: ``'on'`` || |dl| ``'off'`` |dr|. Indicate to additionally return the :py:class:`~psi4.core.Wavefunction`; calculation result as the second element (after *float* energy) of a tuple.; Arrays of frequencies and the Hessian can be accessed through the wavefunction. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``freq_func`` instead of ``func``. :type mode: string; :param mode: |dl| ``'continuous'`` |dr| || ``'sow'`` || ``'reap'``. For a finite difference of energies or gradients frequency, indicates; whether the calculations required to complete the frequency are to be run; in one file (``'continuous'``) or are to be farmed out in an; embarrassingly parallel fashion (``'sow'``/``'reap'``)/ For the latter,; run an initial job with ``'sow'`` and follow instructions in its output file.; For maximum flexibility, ``return_wfn`` is always on in ``'reap'`` mode. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: |dl| ``'hessian'`` |dr| || ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available- they're not), finite; difference of gradients (if available) or finite difference of; energies is to be performed. :typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html:81849,perform,performs,81849,psi4manual/1.1.0/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/_modules/psi4/driver/driver.html,2,['perform'],['performs']
Performance,"ns_projection_sound = _energy_is_invariant(G0); core.print_out(; '\n Based on options and gradient (rms={:.2E}), recommend {}projecting translations and {}projecting rotations.\n'; .format(G0.rms(), '' if translations_projection_sound else 'not ',; '' if rotations_projection_sound else 'not ')); if not core.has_option_changed('FINDIF', 'FD_PROJECT'):; core.set_local_option('FINDIF', 'FD_PROJECT', rotations_projection_sound). # Does an analytic procedure exist for the requested method?; if dertype == 2:; core.print_out(""""""hessian() will perform analytic frequency computation.\n""""""). # We have the desired method. Do it.; wfn = procedures['hessian'][lowername](lowername, molecule=molecule, **kwargs); wfn.set_gradient(G0); optstash.restore(); optstash_conv.restore(). # TODO: check that current energy's being set to the right figure when this code is actually used; core.set_variable('CURRENT ENERGY', wfn.energy()). elif dertype == 1:; core.print_out(; """"""hessian() will perform frequency computation by finite difference of analytic gradients.\n""""""). # Obtain list of displacements; findif_meta_dict = driver_findif.hessian_from_gradient_geometries(molecule, irrep). # Record undisplaced symmetry for projection of displaced point groups; core.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(findif_meta_dict[""displacements""]) + 1. print("""""" %d displacements needed."""""" % ndisp). wfn = _process_displacement(gradient, lowername, molecule, findif_meta_dict[""reference""], 1, ndisp,; **kwargs); var_dict = core.variables(). for n, displacement in enumerate(findif_meta_dict[""displacements""].values(), start=2):; _process_displacement(; gradient, lowername, molecule, displacement, n, ndisp, write_orbitals=False, **kwargs). # Reset variables; for key, val in var_dict.items():; core.set_variable(key, val). # Assemble Hessian from gradients; # Final disp is undisp, so wfn has mol, G, H general to freq calc; H = driver_findif.compute_hessian_from_gradients(findif_meta_dict, irr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html:65957,perform,perform,65957,psi4manual/1.3.2/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/_modules/psi4/driver/driver.html,1,['perform'],['perform']
Performance,"nsensitive) set?. psi4.core.initialize() → bool¶. psi4.core.legacy_wavefunction() → psi::Wavefunction¶; Returns the current legacy_wavefunction object from the most recent computation. psi4.core.mcscf(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the MCSCF code, (N.B. restricted to certain active spaces). psi4.core.mrcc_generate_input(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Generates an input for Kallay’s MRCC code. psi4.core.mrcc_load_densities(arg0: psi::Wavefunction, arg1: dict) → psi4.core.PsiReturnType¶; Reads in the density matrices from Kallay’s MRCC code. psi4.core.occ(arg0: psi::Wavefunction) → psi::Wavefunction¶; Runs the orbital optimized CC codes. psi4.core.opt_clean() → None¶; Cleans up the optimizer’s scratch files. psi4.core.option_exists_in_module(arg0: str, arg1: str) → bool¶; Given a string of a keyword name arg1 and a particular module arg0, returns whether arg1 is a valid option for arg0. psi4.core.optking() → int¶; Runs the geometry optimization / frequency analysis code. psi4.core.outfile_name() → str¶; Returns the name of the output file. psi4.core.plugin(arg0: str, arg1: psi::Wavefunction) → psi::Wavefunction¶; Call the plugin of name arg0. Returns the plugin code result. psi4.core.plugin_close(arg0: str) → None¶; Close the plugin of name arg0. psi4.core.plugin_close_all() → None¶; Close all open plugins. psi4.core.plugin_load(arg0: str) → int¶; Load the plugin of name arg0. Returns 0 if not loaded, 1 if loaded, 2 if already loaded. psi4.core.prepare_options_for_module(arg0: str) → None¶; Sets the options module up to return options pertaining to the named argument (e.g. SCF). psi4.core.print_global_options() → None¶; Prints the currently set global (all modules) options to the output file. psi4.core.print_options() → None¶; Prints the currently set options (to the output file) for the current module. psi4.core.print_out(arg0: str) → None¶; Prints a string (using sprintf-like notation) to the output file. psi4.co",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:284354,optimiz,optimization,284354,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['optimiz'],['optimization']
Performance,"nsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float = 0.0, throw_if_negative: bool = False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html:10941,load,load,10941,psi4manual/1.4.0/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.core.matrix.html,6,['load'],['load']
Performance,"nsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return the",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html:11284,load,load,11284,psi4manual/master/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"nsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using numpy.load().; :rtype: Union[Matrix, Vector]. Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Matrix | Vector. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using nump",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html:11349,load,load,11349,psi4manual/1.9.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"nsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self (Union[Matrix, Vector]) – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html:11298,load,load,11298,psi4manual/1.7.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"nsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType = <SaveType.LowerTriangle: 2>) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(prefix='')¶; Reads the data from a NumPy compressed or uncompressed file using; numpy.load(). Parameters:. self – Pointer to which class to be constructed.; filename (str) – File name to read.; prefix (str) – Name under which array was saved for NumPy. Return type:; Union[Matrix, Vector]. np_write(filename=None, prefix='')¶; Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez().; Can return th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html:11278,load,load,11278,psi4manual/1.8.x/api/psi4.core.Matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/api/psi4.core.Matrix.html,2,['load'],['load']
Performance,"nsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. name¶; The name of the Matrix. Used in printing. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. np¶; View without only one irrep. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. nph¶; View with irreps. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/psi4api-1.html:135531,load,load,135531,psi4manual/1.3.2/psi4api-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/psi4api-1.html,2,['load'],['load']
Performance,"nsingular matrix using LU factorization. get(*args, **kwargs)¶; Overloaded function. get(self: psi4.core.Matrix, h: int, m: int, n: int) -> float. Returns a single element of a matrix in subblock h, row m, col n. get(self: psi4.core.Matrix, m: int, n: int) -> float. Returns a single element of a matrix, row m, col n. get_block(self: psi4.core.Matrix, rows: psi4.core.Slice, cols: psi4.core.Slice) → psi4.core.Matrix¶; Get a matrix block. hermitivitize(self: psi4.core.Matrix) → None¶; Average off-diagonal element in-place. hermitize(self: psi4.core.Matrix) → None¶; Makes a real matrix symmetric by averaging the matrix and its transpose. identity(self: psi4.core.Matrix) → None¶; Sets the matrix to the identity. invert(self: psi4.core.Matrix) → None¶; Computes the inverse of a real symmetric positive definite matrix. load(*args, **kwargs)¶; Overloaded function. load(self: psi4.core.Matrix, filename: str) -> None. Loads a block matrix from an ASCII file (see tests/mints3 for format). load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, tocentry: str, nso: int) -> bool. Load a matrix from a PSIO object from fileno with tocentry of size nso. load(self: psi4.core.Matrix, psio: psi4.core.IO, fileno: int, savetype: psi4.core.SaveType=SaveType.LowerTriangle) -> None. Load a matrix from a PSIO object from fileno and with toc position of the name of the matrix. load_mpqc(self: psi4.core.Matrix, filename: str) → None¶; Loads a matrix from an ASCII file in MPQC format. nirrep(self: psi4.core.Matrix) → int¶; Returns the number of irreps. classmethod np_read(filename, prefix='')¶; Reads the data from a NumPy compress file. np_write(filename=None, prefix='')¶; Writes the irreped matrix to a NumPy zipped file.; Can return the packed data for saving many matrices into the same file. partial_cholesky_factorize(self: psi4.core.Matrix, delta: float=0.0, throw_if_negative: bool=False) → psi4.core.Matrix¶; Computes the fully pivoted partial Cholesky factorization of a real symmetric ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html:10744,load,load,10744,psi4manual/1.3.2/api/psi4.core.matrix.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/api/psi4.core.matrix.html,1,['load'],['load']
Performance,"nsity-fitted calculations to the zero basis...; # ...until the user explicitly provides a DF basis.; wfn.set_basisset(""DF_BASIS_SCF"", core.BasisSet.zero_ao_basis_set()); return wfn. core.Wavefunction.build = _core_wavefunction_build. def _core_wavefunction_get_scratch_filename(self, filenumber):; """""" Given a wavefunction and a scratch file number, canonicalizes the name; so that files can be consistently written and read """"""; fname = os.path.split(os.path.abspath(core.get_writer_file_prefix(self.molecule().name())))[1]; psi_scratch = core.IOManager.shared_object().get_default_path(); return os.path.join(psi_scratch, fname + '.' + str(filenumber)). core.Wavefunction.get_scratch_filename = _core_wavefunction_get_scratch_filename. @staticmethod; def _core_wavefunction_from_file(wfn_data: Union[str, Dict, Path]) -> core.Wavefunction:; r""""""Build Wavefunction from data. Parameters; ----------; wfn_data; If a dict, use data directly. Otherwise, path-like passed to :py:func:`numpy.load`; to read from disk. Returns; -------; Wavefunction; A deserialized Wavefunction object. """"""; # load the wavefunction from file; if isinstance(wfn_data, dict):; pass; elif isinstance(wfn_data, str):; if not wfn_data.endswith("".npy""):; wfn_data = wfn_data + "".npy""; wfn_data = np.load(wfn_data, allow_pickle=True).item(); else:; # Could be path-like or file-like, let `np.load` handle it; wfn_data = np.load(wfn_data, allow_pickle=True).item(). # variable type specific dictionaries to be passed into C++ constructor; wfn_matrix = wfn_data['matrix']; wfn_vector = wfn_data['vector']; wfn_dimension = wfn_data['dimension']; wfn_int = wfn_data['int']; wfn_string = wfn_data['string']; wfn_boolean = wfn_data['boolean']; wfn_float = wfn_data['float']; wfn_floatvar = wfn_data['floatvar']; wfn_matrixarr = wfn_data['matrixarr']. # reconstruct molecule from dictionary representation; wfn_molecule = wfn_data['molecule']; molecule = core.Molecule.from_dict(wfn_molecule). # get basis set name and spherical harmoni",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html:4627,load,load,4627,psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/_modules/psi4/driver/p4util/python_helpers.html,6,['load'],['load']
Performance,"nsity-fitting scheme described in the Supplementary Material to; [Smith:2020:184108] for the second-order terms and in [Waldrop:2021:024103]; for the third-order exchange induction. The coupled (response) version of the; exchange-induction corrections are also calculated, exactly for; \(E_{exch-ind,resp}^{(20)}\) and by scaling the uncoupled term for; \(E_{exch-ind,resp}^{(30)}\). S^inf Keywords¶. DO_IND_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-induction term. Type: boolean; Default: false. DO_DISP_EXCH_SINF¶. For SAPT0 or SAPT(DFT), compute the non-approximated second-order exchange-dispersion term. Type: boolean; Default: false. DO_IND30_EXCH_SINF¶. For SAPT2+3, compute the non-approximated third-order exchange-induction term. Type: boolean; Default: false. SAPT0-D¶; In SAPT0, the computation of \(E_{disp}^{(20)} + E_{exch-disp}^{(20)}\) represents; the computational bottleneck. One can avoid this bottleneck by replacing these; dispersion terms with the empirical D3 corrections developed by Grimme.; Grimme’s dispersion corrections are discussed here.; The corresponding method, termed SAPT0-D, thus relies on empirically fit parameters; specific to SAPT0/jun-cc-pVDZ. While SAPT0-D can be used with any of the -D; variants using default parameters optimized for Hartee–Fock interaction energies,; we recommend using the refit parameters with Becke-Johnson damping, as described in; [Schriber:2021:234107]. Again, use of SAPT0-D with a basis set other than; jun-cc-pVDZ is not tested and not guaranteed to give meaningful results without; refitting the dispersion parameters.; A simple water dimer computation using SAPT0-D may look like:; molecule water_dimer {; 0 1; O -1.551007 -0.114520 0.000000; H -1.934259 0.762503 0.000000; H -0.599677 0.040712 0.000000; --; 0 1; O 1.350625 0.111469 0.000000; H 1.680398 -0.373741 -0.758561; H 1.680398 -0.373741 0.758561. units angstrom; no_reorient; symmetry c1; }. set basis jun-cc-pvdz. ener",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/sapt.html:47419,bottleneck,bottleneck,47419,psi4manual/1.6.x/sapt.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/sapt.html,5,['bottleneck'],['bottleneck']
Performance,"nslating psi4 options to cfour, part ii. cfour/kw-3; Basis set spherical/Cartesian with cfour_basis and cfour_spherical. cfour/opt-rhf-ccsd_t_-ecc; optimization CCSD(T)/dzp on water with ecc, aobasis. cfour/sp-rohf-ccsd_t_; single-point CCSD(T)/qz2p on NH2. cfour/sp-rhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on water with ecc module. cfour/sp-rohf-ccsd-ao; single-point CCSD/qz2p on NH2 with aobasis. cfour/kw-2; testing best practices options, part ii. cfour/sp-uhf-ccsd_t_-ecc; single-point CCSD(T)/qz2p on NH2 with ecc. cfour/scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is apecified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. cfour/psi-ghost-grad; MP2 optimization of dimers with one momomer ghosted. Gradients after three opt cycles are compared with those from psi4. cfour/opt-rhf-scf; optimization HF/svp on water. cfour/sp-uhf-mp2; single-point MP2/qz2p on NH2. cfour/kw-5; Basis set spherical/Cartesian with basis and cfour_spherical. cfour/sp-uhf-ccsd_t_-ao-ecc; single-point CCSD(T)/qz2p on NH2 with ecc, aobasis. cfour/psi-rohf-scsmp2; ROHF MP2 energy components. Checks that computed identically between cfour and psi4. cfour/psi-uhf-mp3; UHF MP3 energy components. Checks that converted identically between cfour and psi4. cfour/dfmp2-1; MP2/cc-PVDZ computation of formic acid dimer binding energy using automatic counterpoise correction. Monomers are specified using Cartesian coordinates. cfour/sp-uhf-ccsd; single-point CCSD/qz2p on NH2. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.9.1;  · . PSI4. Appendices; Test Suite and Sample Inputs; CFOUR. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 08 February 2024 09:32PM.; Created using Sphinx 7.2.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html:4338,optimiz,optimization,4338,psi4manual/1.9.x/autodoc_testsuite_cfour.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_testsuite_cfour.html,1,['optimiz'],['optimization']
Performance,"nstructions. Type: array; Default: No Default. DMRG_UNITARY_WRITE (DMRG); DMRG — Whether or not to store the unitary on disk (convenient for restarting). Type: boolean; Default: true. DO_CCD_DISP (SAPT); SAPT (Expert) — Do CCD dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3?. Type: boolean; Default: false. DO_DIIS (DFOCC); DFOCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_DIIS (OCC); OCC — Do apply DIIS extrapolation?. Type: boolean; Default: true. DO_IND_EXCH_SINF (SAPT); SAPT (Expert) — For SAPT(DFT) computes the S^inf Exchange-Induction terms. Type: boolean; Default: false. DO_LEVEL_SHIFT (DFOCC); DFOCC — Do apply level shifting?. Type: boolean; Default: true. DO_LEVEL_SHIFT (OCC); OCC — Do apply level shifting?. Type: boolean; Default: true. DO_MBPT_DISP (SAPT); SAPT (Expert) — Do MBPT dispersion correction in SAPT2+, SAPT2+(3) or SAPT2+3, if also doing CCD?. Type: boolean; Default: true. DO_SCS (DFOCC); DFOCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SCS (OCC); OCC — Do perform spin-component-scaled OMP2 (SCS-OMP2)? In all computation, SCS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SCS-OMP2, one needs to set ‘DO_SCS’ to true. Type: boolean; Default: false. DO_SINGLETS (CPHF); CPHF — Do singlet states? Default true. Type: boolean; Default: true. DO_SOS (DFOCC); DFOCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS-OMP2 energy is computed automatically. However, in order to perform geometry optimizations and frequency computations with SOS-OMP2, one needs to set ‘DO_SOS’ to true. Type: boolean; Default: false. DO_SOS (OCC); OCC — Do perform spin-opposite-scaled OMP2 (SOS-OMP2)? In all computation, SOS",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html:111999,perform,perform,111999,psi4manual/1.3.2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodoc_glossary_options_c-1.html,2,['perform'],['perform']
Performance,"nt OMP3 orbital energies?. Type: boolean; Default: false. OPT_METHOD¶. The optimization algorithm. Type: string; Possible Values: MSD, DIIS; Default: MSD. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. Type: conv double; Default: 1e-5. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. SCS_TYPE¶. Type of the SCS method. Type: string; Possible Values: SCS, SCSN, SCSVDW, SCSMI; Default: SCS. SOS_SCALE¶. Spin-opposite scaling (SOS) value for SCF orbitals. Type: double; Default: 1.3. SOS_SCALE2¶. Spin-opposite scaling (SOS) value for optimized-MP2 orbitals. Type: double; Default: 1.2. SOS_TYPE¶. Type of the SOS method. Type: string; Possible Values: SOS, SOSPI; Default: SOS. TPDM_ABCD_TYPE¶. How to take care of the TPDM VVVV-block. The COMPUTE option means it will be computed via an IC/OOC algoritm. The DIRECT option (default) means it will not be computed and stored, instead its contribution will be directly added to Generalized-Fock Matrix. Type: string; Possible Values: DIRECT, COMPUTE; Default: DIRECT. Table Of Contents. OMP3; General; CACHELEVEL; CC_MAXITER; CUTOFF; DIIS_MAX_VECS; DO_LEVEL_SHIFT; DO_SCS; DO_SOS; E3_SCALE; E_CONVERGENCE; HESS_TYPE; LEVEL_SHIFT; LINEQ_SOLVER; MAX_MOGRAD_CONVERGENCE; MO_MAXITER; MO_READ; MO_STEP_MAX; MO_WRITE; MP2_OS_SCALE; MP2_SS_SCALE; MP3L_ENERGY; NAT_ORBS; OMP3_ORBS_PRINT; OPT_METHOD; ORTH_TYPE; RMS_MOGRAD_CONVERGENCE; R_CONVERGENCE; SCS_TYPE; SOS_SCALE; SOS_SCALE2; SOS_TYPE; TPDM_ABCD_TYPE. Previous topic; SOS_TYPE; Next topic; CACHELEVEL; This Page. Show Source. Quick search. Enter search terms or a module, class or function name.; . Navigation. index. modules    . toc    . next    . previous    ; PSI4 [beta3] » ; Appendices »; Keywords by Module ». © Copyright 2012, The Psi4 Project.; Last updated on Oct 16, 2012.; Created using Sphinx 1.1.3.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html:4396,CACHE,CACHELEVEL,4396,psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/autodir_options_c/module__omp3-1.html,4,['CACHE'],['CACHELEVEL']
Performance,"nt calculation types. Type: conv double; Default: 1e-6. R_CONVERGENCE¶. Convergence criterion for amplitudes (residuals). Type: conv double; Default: 1e-5. RMS_MOGRAD_CONVERGENCE¶. Convergence criterion for RMS orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MAX_MOGRAD_CONVERGENCE¶. Convergence criterion for maximum orbital gradient. If this keyword is not set by the user, OCC will estimate and use a value required to achieve the desired E_CONVERGENCE The listed default will be used for the default value of E_CONVERGENCE. Type: conv double; Default: 1e-4. MO_MAXITER¶. Maximum number of iterations to determine the orbitals. Type: integer; Default: 50. WFN_TYPE¶. Type of the wavefunction. Type: string; Possible Values: OMP2, OMP3, OCEPA, OMP2.5, REMP, OREMP; Default: OMP2. ORB_OPT¶. Do optimize the orbitals?. Type: boolean; Default: true. Advanced OCC Keywords¶. OPT_METHOD¶. The optimization algorithm. Modified Steepest-Descent (MSD) takes a Newton-Raphson (NR) step with a crude approximation to diagonal elements of the MO Hessian. The ORB_RESP option obtains the orbital rotation parameters with a crude approximation to all elements of the MO Hessian. Additionally, for both methods a DIIS extrapolation will be performed with the DO_DIIS = TRUE option. Type: string; Possible Values: MSD, ORB_RESP; Default: MSD. ORTH_TYPE¶. The algorithm for orthogonalization of MOs. Type: string; Possible Values: GS, MGS; Default: MGS. MP2_OS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 6.0. MP2_SS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.0. MP2_SOS_SCALE¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.3. MP2_SOS_SCALE2¶. Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 1.2. NAT_ORBS¶. Do ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/occ.html:14422,optimiz,optimize,14422,psi4manual/1.7.x/occ.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/occ.html,4,['optimiz'],['optimize']
Performance,"nt for the NO radical. cdomp2-2; OMP2 cc-pVDZ energy for the NO molecule. olccd2; OLCCD cc-pVDZ energy with B3LYP initial guess for the NO radical. scf-hess4; DF SCF 6-31G UHFl vs RHF test Tests DF UHF hessian code for Ca = Cb. x2c-perturb-h; Test SFX2C-1e with a static electric field on He aug-cc-pVTZ. cc5; RHF CCSD(T) aug-cc-pvtz frozen-core energy of C4NH4 Anion. mp2p5-grad2; MP2.5 cc-pVDZ gradient for the NO radical. cubeprop-frontier; ROHF frontier orbitals of CH2(s) and CH2(t). pywrap-freq-g-sowreap; Finite difference of gradients frequency, run in sow/reap mode. dfccsdt1; DF-CCSD(T) cc-pVDZ energy for the H2O molecule. opt-freeze-coords; SCF/cc-pVDZ optimization example with frozen cartesian. dfomp2-grad2; OMP2 cc-pVDZ energy for the NO molecule. isapt1; This test case shows an example of running and analyzing an FI-SAPT0/jun-cc-pvdz computation for 2,4-pentanediol (targeting the intramolecular hydrogen bond between the two hydroxyl groups). cbs-xtpl-opt; Various extrapolated optimization methods for the H2 molecule. isapt2; This is a shorter version if isapt1 - does not do cube plots. See isapt1 for full details. scf-hess5; DF SCF 6-31G analytical vs finite-difference tests Tests DF UHF hessian code for Ca != Cb. cc43; RHF-CC2-LR/STO-3G optical rotation of (S)-methyloxirane. gauge = both, omega = (589 355 nm). pywrap-molecule; Check that C++ Molecule class and qcdb molecule class are reading molecule input strings identically. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. castup2; SCF with various combinations of pk/density-fitting, castup/no-castup, and spherical/cartesian settings. Demonstrates that puream setting is getting set by orbital basis for all df/castup parts of calc. Demonstrates that answer doesn’t depend on presence/absence of castup. Demonstrates (by comparison to castup3) that output file doesn’t depend on options (scf_type) being set global or local. This input uses global. sapt-ecp; sapt0 ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html:33440,optimiz,optimization,33440,psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"nt is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) BLAS/LAPACK. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/libefp-1.html:6853,perform,perform,6853,psi4manual/1.2.1/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/libefp-1.html,26,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"nt is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, PSI4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal PSI4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. How to configure libefp for building Psi4¶; Role and Dependencies. Role — In PSI4, libefp is a library that provides additional; molecular modeling capabilities (EFP).; Downstream Dependencies — PSI4 (\(\Leftarrow\) optional) libefp; Upstream Dependencies — libefp \(\Leftarrow\) None. CMake Variables. ENABLE_libefp — CMake variable toggling whether Psi4 builds with libefp; CMAKE_PREFIX_PATH — CMake list v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/libefp-1.html:6717,perform,perform,6717,psi4manual/1.1.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/libefp-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"nt is present in the active molecule, the SCF energy; will include EFP contributions. Warning; Although the EFP geometry is specified alongside the QM; geometry in a molecule name {...} block, internally the handling; of EFP is not so clean. In straightforward input files that involve; any number of [molecule block, energy/opt/etc, clean()] portions,; there should be no problem; the energy/opt computation will always; be run on the molecule defined in the preceding block. For advanced; users, unexpected difficulties may arise due to: (1) the EFP fragment; from the last molecule block executed will always be active (and; potentially interfering with SCF) and (2) recalling a molecule; through activate(name) (where name was the python handle; in the molecule block) will not load up any EFP portion of that; molecule. This divergent treatment is a stopgap while we determine; how best to handle molecules with different domains. At this time, Psi4 is only able to perform pure-efp single-points and; geometry optimizations and mixed qm/efp SCF single-points. name; molecule composition; calls method. efp; efp; efp. pure EFP; EFP interaction energy (IE) on all frags. mixed QM/EFP; EFP IE on EFP frags only. pure QM; error. scf; scf; scf. pure EFP; error. mixed QM/EFP; SCF energy on QM frags w/coupling to EFP frags, plus EFP IE on EFP frags. pure QM; SCF energy on all frags (normal Psi4 operation). Fragment Library¶; Below are documented the EFP fragments available from the LIBEFP library.; These systems are accessible in molecule {...} blocks without; additional configuration. 2aminopyridine¶. rotate: click+drag; translate: alt+click+drag; zoom: scroll. Visualization by ChemDoodle Web; Comment; 2-aminopyridine, S22 Complex Elec.: 6-31G* Rest: 6-311++G(3df,2p). Full Geometry in Angstroms; N -0.297712 -1.170382 0.001714; C -0.912531 0.026013 0.004723; C -0.175714 1.226496 0.003700; C 1.204216 1.176210 0.000547; C 1.842683 -0.065832 -0.001280; C 1.045154 -1.196712 0.000533; H -0.6",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/libefp-1.html:6011,perform,perform,6011,psi4manual/1.0.0/libefp-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/libefp-1.html,4,"['optimiz', 'perform']","['optimizations', 'perform']"
Performance,"nt optimization cycles. (not in current public version). Type: boolean; Default: true. CFOUR_VIBRATION (CFOUR); CFOUR — Specifies whether (harmonic) vibrational frequencies are calculated or not. If the default NO (=0) is specified then no frequencies are calculated. For ANALYTIC, vibrational frequencies are determined from analytically computed second derivatives, and for FINDIF (=2) vibrational frequencies are calculated from a force field obtained by numerical differentiation of analytically evaluated gradients (or even single-point energies) using symmetry-adapted mass-weighted Cartesian coordinates. If vibrational frequencies are calculated, a normal mode analysis using the computed force-constant matrix is performed, rotationally projected frequencies are computed, infrared intensities are determined, and zero-point energies (ZPE) are evaluated. Type: string; Possible Values: NO, ANALYTIC, FINDIF, EXACT; Default: NO. CFOUR_VTRAN (CFOUR); CFOUR — This keyword defines what type of integral transformation is to be performed in the program xvtran. FULL/PARTIAL (=0) allows the transformation program to choose the appropriate type of transformation, while FULL (=1) requires a full integral transformation and PARTIAL (=2) means a MBPT(2)-specific transformation where the \((ab \vert cd)\) integrals are not formed. Type: string; Possible Values: FULL/PARTIAL, FULL, PARTIAL; Default: FULL/PARTIAL. CFOUR_XFIELD (CFOUR); CFOUR — Specifies the X-component of an external electric field. The value must be specified as an integer and the field used by the program will be the value of the keyword \(\times 10^{-6}\). This allows field strengths \(|\varepsilon| > 10^{-6}\) to be used. Type: integer; Default: 0. CFOUR_XFORM_TOL (CFOUR); CFOUR — The tolerance for storing transformed integrals. Integrals less than \(10^{-N}\) are neglected and not stored on disk. Type: integer; Default: 11. CFOUR_YFIELD (CFOUR); CFOUR — Specifies the Y-component of an external electric field. The v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:83832,perform,performed,83832,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,4,['perform'],['performed']
Performance,"nt to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK; Default: PK. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TO",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__globals-1.html:5745,optimiz,optimized,5745,psi4manual/1.2.1/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance,"nt to the output file. 1 prints basic information, and higher levels print more information. A value of 5 will print very large amounts of debugging information. Type: integer; Default: 1. PROPERTIES¶. List of properties to compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. UNITS¶. Units used in geometry specification. Type: string; Possible Values: BOHR, AU, A.U., ANGSTROMS, ANG, ANGSTROM; Default: ANGSTROMS. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: conv double; Default: 1.0e-12. CUBIC_BLOCK_MAX_POINTS¶. CubicScalarG",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__globals-1.html:5743,optimiz,optimized,5743,psi4manual/1.1.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance,"nt"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). else: # Assume energy points; # If not, perform finite difference of energies; info = 'Performing finite difference calculations by energies'; print(info). # Obtain list of displacements; displacements = PsiMod.fd_geoms_freq_0(irrep); molecule.fix_orientation(True); molecule.reinterpret_coordentry(False); # Make a note of the undisplaced molecule's symmetry; PsiMod.set_parent_symmetry(molecule.schoenflies_symbol()). ndisp = len(displacements). # This version is pretty dependent on the reference geometry being last (as it is now); print(' %d displacements needed.' % ndisp); energies = []; for n, displacement in enumerate(displacements):; # Print information to output.dat; PsiMod.print_out('\n'); banner('Loading displacement %d of %d' % (n + 1, ndisp)). # Print information to the screen; print(' %d' % (n + 1), end=""""); if (n + 1) == ndisp:; print('\n', end=''); sys.stdout.flush(). # Load in displacement into the active molecule; molecule.set_geometry(displacement). # Perform the energy calculation; E = func(lowername, **kwargs). # Save the energy; energies.append(E). # clean may be necessary when changing irreps of displacements; PsiMod.clean(). # Obtain the gradient. This function stores the gradient into the reference wavefunction.; PsiMod.fd_freq_0(energies, irrep). print(' Computation complete.'). # Clear the ""parent"" symmetry now; PsiMod.set_parent_symmetry(""""). # TODO: These need to be restored to the user specified setting; PsiMod.get_active_molecule().fix_orientation(False); # But not this one, it always goes back to True; PsiMod.get_active_molecule().reinterpret_coordentry(True). # The last item in the list is the reference energy, return it; return energies[-1]. ## Aliases ##; frequencie",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/driver.html:50504,Load,Loading,50504,psi4manual/4.0b3/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/driver.html,1,['Load'],['Loading']
Performance,"nt((""\t%s: computed value (%."" + str(digits+1) + ""f) does not match (%."" + str(digits+1) + ""f) to %d decimal places."") % (label, computed, expected, digits)); sys.exit(1); if ( math.isnan(computed) ):; print(""\t%s: computed value (%f) does not match (%f) to %d decimal places.\n"" % (label, computed, expected, digits)); print(""\tprobably because the computed value is nan.""); sys.exit(1); success(label). [docs]def compare_integers(expected, computed, label):; """"""Function to compare two integers. Prints :py:func:`util.success`; when value *computed* matches value *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if (expected != computed):; print(""\t%s: computed value (%d) does not match (%d)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_strings(expected, computed, label):; """"""Function to compare two strings. Prints :py:func:`util.success`; when string *computed* exactly matches string *expected*.; Performs a system exit on failure. Used in input files in the test suite. """"""; if(expected != computed):; print(""\t%s: computed value (%s) does not match (%s)."" % (label, computed, expected)); sys.exit(1); success(label). [docs]def compare_matrices(expected, computed, digits, label):; """"""Function to compare two matrices. Prints :py:func:`util.success`; when elements of matrix *computed* match elements of matrix *expected* to; number of *digits*. Performs a system exit on failure to match symmetry; structure, dimensions, or element values. Used in input files in the test suite. """"""; if (expected.nirrep() != computed.nirrep()):; print(""\t%s has %d irreps, but %s has %d\n."" % (expected.name(), expected.nirrep(), computed.name(), computed.nirrep())); sys.exit(1); if (expected.symmetry() != computed.symmetry()):; print(""\t%s has %d symmetry, but %s has %d\n."" % (expected.name(), expected.symmetry(), computed.name(), computed.symmetry())); sys.exit(1); nirreps = expected.nirrep(); symmetry = expected.symmet",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/util.html:2466,Perform,Performs,2466,psi4manual/4.0b4/_modules/util.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/util.html,2,['Perform'],['Performs']
Performance,"nt. \(^1A_1\) CH2 state described using the Ms = 0 component of the singlet. Uses RHF singlet orbitals. dft-grac; Gradient regularized asymptotic correction (GRAC) test. cbs-xtpl-freq; Various gradients for a strained helium dimer and water molecule. cisd-h2o-clpse; 6-31G** H2O Test CISD Energy Point with subspace collapse. rasci-h2o; RASCI/6-31G** H2O Energy Point. opt8; Various constrained energy minimizations of HOOH with cc-pvdz RHF. Cartesian-coordinate constrained optimizations of HOOH in Cartesians. opt6; Various constrained energy minimizations of HOOH with cc-pvdz RHF Internal-coordinate constraints in internal-coordinate optimizations. dfmp2-3; DF-MP2 cc-pVDZ frozen core gradient of benzene, computed at the DF-SCF cc-pVDZ geometry. cdomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. fsapt-diff1; This test case shows an example of running and analyzing a difference F-SAPT0/jun-cc-pvdz procedure for phenol dimer from the S22 database. cc13a; UHF-CCSD(T)/cc-pVDZ \(^{3}B_1\) CH2 geometry optimization via analytic gradients. cbs-xtpl-alpha; Extrapolated water energies. cc8c; ROHF-CCSD cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Cartesian input. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc45; RHF-EOM-CC2/cc-pVDZ lowest two states of each symmetry of H2O. soscf-large; Second-order SCF convergnece: Benzene. fnocc4; Test FNO-DF-CCSD(T) energy. tu3-h2o-opt; Optimize H2O HF/cc-pVDZ. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the \(^2\Sigma^+\) state of the CN radical, with Z-matrix input. mcscf3; RHF 6-31G** energy of water, using the MCSCF module and Z-matrix input. mints2; A test of the basis specification. A benzene atom is defined using a ZMatrix containing dummy atoms and various basis sets are assigned to different atoms. The symmetry of the molecule is automatically lowered to account for the different basis sets. dcft8; DCFT calculation for",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html:30058,optimiz,optimization,30058,psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimization']
Performance,"nt_group('c2v'). During the SCF procedure, the occupation of orbitals is typically determined by; the Aufbau principal across all spatial symmetries. This may result in the; occupation shifting between iterations. If the occupations are known a priori,; they may be clamped throughout the procedure by using the DOCC and; SOCC options. For instance, all good quantum chemists know that; water is; actually,:; molecule h2o {; 0 1; O; H 1 1.0; H 1 1.0 2 104.5; }. set {; docc [3,0,1,1] # 1A1 2A1 1B1 3A1 1B2; basis cc-pvdz; }. energy('scf'). Broken Symmetry¶; For certain problems, such diradicals, allowing the spin-up and spin-down; orbitals to differ in closed-shell computations can be advantageous;; this is known as symmetry breaking. The resulting unrestricted wavefunction; will often provide superior energetics, due to the increased flexibility,; but will suffer non-physicical spin contamination from higher multiplicity states.; A convenient approach to break symmetry is to perform a UHF or UKS calculation; with the guess HOMO and LUMO orbitals mixed.; Mixing of the guess orbitals can be requested by setting the GUESS_MIX; keyword to true:; set reference uhf; set guess_mix true; energy('scf'). Orthogonalization¶; One of the first steps in the SCF procedure is the determination of an; orthogonal basis (known as the OSO basis) from the atomic orbital basis (known; as the AO basis). The Molecular Orbital basis (MO basis) is then built as a; particular unitary transformation of the OSO basis. In Psi4, the; determination of the OSO basis is accomplished via either symmetric or canonical; orthogonalization. Symmetric orthogonalization uses the symmetric inverse square; root of the overlap matrix for the orthogonalization matrix. Use of symmetric; orthogonalization always yields the same number of OSO functions (and thereby; MOs) as AO functions. However, this may lead to numerical problems if the; overlap matrix has small eigenvalues, which may occur for large systems or for;",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/scf-1.html:9392,perform,perform,9392,psi4manual/1.0.0/scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/scf-1.html,2,['perform'],['perform']
Performance,"nt_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within PSI4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html:9623,optimiz,optimize,9623,psi4manual/1.4.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/psithoninput-1.html,8,['optimiz'],['optimize']
Performance,"nt_variables(). Note that PSI variables; are cleared at the start of each energy(), etc. in an input; file by clean_variables().; So if you run in a single input file a STO-3G FCI followed by a; aug-cc-pVQZ SCF followed by a print_variables() command, the; last will include SCF TOTAL ENERGY but not; FCI TOTAL ENERGY.; The entire dictionary of PSI variables can be obtained through; get_variables(). Return Values¶; Most of the usual user computation functions (i.e.,; energy(), optimize(), and; frequency()) return simply the current total energy.; Consult the descriptions of other functions in Psithon Functions: Invoking a Calculation for; what quantities they return and for what data structures they make; available for post-processing. Many users need only deal with the simple return; form for the computation functions.; # E is total energy float; # G is gradient array; # H is hessian array; # wfn is class instance with many computational details. # simple returns; E = energy(...); E = optimize(...); E = frequency(...); G = gradient(...) # used by optimize(); H = hessian(...) # used by frequency(). For more elaborate post-processing of computations, adding; return_wfn=True keyword argument additionally returns; Wavefunction.; # power user returns; E, wfn = energy(..., return_wfn=True); E, wfn = optimize(..., return_wfn=True); E, wfn = frequency(..., return_wfn=True); G, wfn = gradient(..., return_wfn=True) # used by optimize(); H, wfn = hessian(..., return_wfn=True) # used by frequency(). # print gradient array and its rms; wfn.gradient.print_out(); print wfn.gradient().rms(). # format output for other programs; molden(wfn, 'mycalc.molden'). # access array in another format; np.array(wfn.hessian()). Loops¶; Python provides many control structures, any of which can be used within Psi4; input files. For example, to loop over three basis sets, the following code can; be used:; basis_sets = [""cc-pVDZ"", ""cc-pVTZ"", ""cc-pVQZ""]; for basis_set in basis_sets:; set basis = $basis",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html:10191,optimiz,optimize,10191,psi4manual/1.0.0/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/psithoninput-1.html,2,['optimiz'],['optimize']
Performance,"ntation in Cfour. dft2; DFT Functional Test. scf4; RHF cc-pVDZ energy for water, automatically scanning the symmetric stretch and bending coordinates using Python’s built-in loop mechanisms. The geometry is specified using a Z-matrix with variables that are updated during the potential energy surface scan, and then the same procedure is performed using polar coordinates, converted to Cartesian coordinates. dfomp2-1; OMP2 cc-pVDZ energy for the H2O molecule. cisd-sp; 6-31G** H2O Test CISD Energy Point. dft-psivar; HF and DFT variants single-points on zmat methane, mostly to test that PSI variables are set and computed correctly. Now also testing that CSX harvesting PSI variables correctly. sad1; Test of the superposition of atomic densities (SAD) guess, using a highly distorted water geometry with a cc-pVDZ basis set. This is just a test of the code and the user need only specify guess=sad to the SCF module’s (or global) options in order to use a SAD guess. The test is first performed in C2v symmetry, and then in C1. mp3-grad1; MP3 cc-pVDZ gradient for the H2O molecule. mp2-def2; Test case for Binding Energy of C4H5N (Pyrrole) with CO2 using MP2/def2-TZVPP. scf3; File retention, docc, socc, and bond distances specified explicitly. dfscf-bz2; Benzene Dimer DF-HF/cc-pVDZ. dfomp3-grad2; DF-OMP3 cc-pVDZ gradients for the H2O+ cation. sapt6; checks that all SAPT physical components (elst, exch, indc, disp) and total IE are being computed correctly for SAPT2+3(CCD)dMP2/aug-cc-pvdz and all lesser methods thereof. dft1; DFT Functional Test. mp2-grad1; MP2 cc-pVDZ gradient for the H2O molecule. omp3-3; OMP3 cc-pVDZ energy with B3LYP initial guess for the NO radical. dcft9; UHF-ODC-12 and RHF-ODC-12 single-point energy for H2O. This performs a simultaneous update of orbitals and cumulants, using DIIS extrapolation. Four-virtual integrals are handled in the AO basis, where integral transformation is avoided. In the next RHF-ODC-12 computation, AO_BASIS=NONE is used, where four-v",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:31267,perform,performed,31267,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['perform'],['performed']
Performance,"ntation of the linear-scaling “Linear Exchange” (LinK); algorithm described in [Ochsenfeld:1998:1663]. As with the COSX option,; the Coulomb term is computed with an integral-direct density-fitting; algorithm. The LINK algorithm provides many of the benefits of integral-direct; SCF algorithms, including no disk I/O, low memory usage, and effective; parallelization. Additionally, the; LINK implementation scales well with system size; while simultaneously providing a formally-exact computation of the; Exchange term. See Linear Exchange for more information. In some cases the above algorithms have multiple implementations that return; the same result, but are optimal under different molecules sizes and hardware; configurations. Psi4 will automatically detect the correct algorithm to run and; only expert users should manually select the below implementations. The DF; algorithm has the following two implementations. MEM_DFA DF algorithm optimized around memory layout and is optimal as long as; there is sufficient memory to hold the three-index DF tensors in memory. This; algorithm may be faster for builds that require disk if SSDs are used. DISK_DFA DF algorithm (the default DF algorithm before Psi4 1.2) optimized to; minimize Disk IO by sacrificing some performance due to memory layout. Note that these algorithms have both in-memory and on-disk options, but; performance penalties up to a factor of 2.5 can be found if the incorrect; algorithm is chosen. It is therefore highly recommended that the keyword “DF”; be selected in all cases so that the correct implementation can be selected by; PSI4‘s internal routines. Expert users can manually switch between MEM_DF and; DISK_DF; however, they may find documented exceptions during use as several; post SCF algorithms require a specific implementation.; For some of these algorithms, Schwarz and/or density sieving can be used to; identify negligible integral contributions in extended systems. To activate; sieving, set the INTS_T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/scf.html:28101,optimiz,optimized,28101,psi4manual/1.7.x/scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/scf.html,1,['optimiz'],['optimized']
Performance,"ntation, the ADC(2) secular matrix is treated effectively; by renormalization of the double excitation manifold into the single; excitation manifold. So, the effective secular equation is solved for; several times for the specific state due to the eigenvalue dependence of; the effective response matrix. Only the S component of the transition; amplitude is obtained explicitly and the squared norm of the S block; and the rotation angle from the corresponding CIS vector are given; below the element of the amplitude. The difference between the ADC(2); value and its non-iterative counterpart is mostly negligible if the; mixture among the CIS excited states is small and the quasi-degeneracy; in the excited state is tolerably weak. But if there is a significant; discrepancy in these energies, or the rotation angle is visibly large,; special care may have to be taken for the strong effects caused by the; higher excited states. Partial Renormalization Scheme¶; The ADC code is capable of performing the partially-renormalized; ADC(2) computation, termed PR-ADC(2). In the perturbative treatment of; the singly-excited state, the doubly and triply excited configurations; are accounted for as in the case of CIS(D). In the language of; CIS(D), the former is regarded to introduce the orbital relaxation (OR); effect while the latter is argued to give rise to the differential; correlation (DC) correction to the excited state. In the PR-ADC(2); scheme, the DC term is corrected according to the ground state; PR-MP2 correlation, in which the correlation between the electron pairs; is accounted for in size-consistent and unitary-invariant fashion by; modulating the MP1 amplitude. By utilizing the PR scheme, substantial; resistance against quasi-degeneracy is readily granted as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories star",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/adc-1.html:4006,perform,performing,4006,psi4manual/1.2.1/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/adc-1.html,6,['perform'],['performing']
Performance,"ntation, the ADC(2) secular matrix is treated effectively; by renormalization of the double excitation manifold into the single; excitation manifold. So, the effective secular equation is solved for; several times for the specific state due to the eigenvalue dependence of; the effective response matrix. Only the S component of the transition; amplitude is obtained explicitly and the squared norm of the S block; and the rotation angle from the corresponding CIS vector are given; below the element of the amplitude. The difference between the ADC(2); value and its non-iterative counterpart is mostly negligible if the; mixture among the CIS excited states is small and the quasi-degeneracy; in the excited state is tolerably weak. But if there is a significant; discrepancy in these energies, or the rotation angle is visibly large,; special care may have to be taken for the strong effects caused by the; higher excited states. Partial Renormalization Scheme¶; The ADC code is capable of performing the partially-renormalized; ADC(2) computation, termed PR-ADC(2). In the perturbative treatment of; the singly-excited state, the doubly and triply excited configurations; are accounted for as in the case of CIS(D). In the language of; CIS(D), the former is regarded to introduce the orbital relaxation (OR); effect while the latter is argued to give rise to the differential; correlation (DC) correction to the excited state. In the PR-ADC(2); scheme, the the DC term is corrected according to the ground state; PR-MP2 correlation, in which the correlation between the electron pairs; is accounted for in size-consistent and unitary-invariant fashion by; modulating the MP1 amplitude. By utilizing the PR scheme, substantial; resistance against quasi-degeneracy is readily granted as discussed; in Ref. [Saitow:2012]. Using the ADC(2) code¶; A complete list of keywords related to ADC(2) computations is provided in; Appendix ADC. Some sample inputs are provided in; psi4/samples, in directories ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/adc-1.html:4104,perform,performing,4104,psi4manual/1.0.0/adc-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/adc-1.html,10,['perform'],['performing']
Performance,"nteger; Default: 3. ENERGY_LEVEL_SHIFT¶. Level shift applied to the diagonal of the density-weighted Fock operator. While this shift can improve convergence, it does change the DCFT energy. Type: double; Default: 0.0. IGNORE_TAU¶. Controls whether to ignore terms containing non-idempotent contribution to OPDM or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: false. INTS_TOLERANCE¶. Schwarz screening threshold. Mininum absolute value below which TEI are neglected. Type: conv double; Default: 1e-14. MO_RELAX¶. Controls whether to relax the orbitals during the energy computation or not (for debug puproses only). For practical applications only the default must be used. Type: boolean; Default: true. ORBITAL_LEVEL_SHIFT¶. The shift applied to the denominator in the orbital update iterations. Type: double; Default: 0.0. RELAX_GUESS_ORBITALS¶. Controls whether to relax the guess orbitals by taking the guess density cumulant and performing orbital update on the first macroiteration (for ALOGRITHM = TWOSTEP only). Type: boolean; Default: false. RELAX_TAU¶. Controls whether to relax tau during the cumulant updates or not. Type: boolean; Default: true. STABILITY_ADD_VECTORS¶. The number of vectors that can be added simultaneously into the subspace for Davidson’s diagonalization in stability check. Type: integer; Default: 20. STABILITY_AUGMENT_SPACE_TOL¶. The value of the rms of the residual in Schmidt orthogonalization which is used as a threshold for augmenting the vector subspace in stability check. Type: conv double; Default: 0.1. STABILITY_CHECK¶. Performs stability analysis of the DCFT energy. Type: boolean; Default: false. STABILITY_CONVERGENCE¶. Controls the convergence of the Davidson’s diagonalization in stability check. Type: conv double; Default: 1e-4. STABILITY_MAX_SPACE_SIZE¶. The maximum size of the subspace for the stability check. The program will terminate if this parameter is exceeded and the c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dcft-1.html:5974,perform,performing,5974,psi4manual/1.3.2/autodir_options_c/module__dcft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__dcft-1.html,2,['perform'],['performing']
Performance,"nterface(self). axpby(self, a, b, other); Adds to this vector scaled by b another vector scaled by a; self <- a * other + b * self. axpy(self, a, other); Adds to this vector (unscaled) another vector scaled by a; self <- a * other + self. clone(self); Clone the vector. copy(self, arg0); Copy another vector into this. dim(self[, h]); Returns the dimensions of the vector per irrep h. dimpi(self); Returns the Dimension object. from_array([name, dim1, dim2]); Converts a NumPy array or list of NumPy arrays into a PSI4 Matrix or Vector (irrepped if list). from_list(x). from_serial(); Converts serialized data to the correct Psi4 data type :rtype: Union[Matrix, Vector]. get(*args, **kwargs); Overloaded function. get_block(self, slice); Get a vector block. init(self, arg0); Reallocate the data of the Vector. load(self, psio, file); Load the vector from disk. nirrep(self); Returns the number of irreps. np_read([prefix]); Reads the data from a NumPy compressed or uncompressed file using numpy.load(). np_write([filename, prefix]); Writes the irrepped matrix to a NumPy uncompressed file using numpy.savez(). print_out(self); Prints the vector to the output file. save(self, psio, file); Save the vector to disk. scale(self, sc); Scales the elements of a vector by sc. set(*args, **kwargs); Overloaded function. set_block(self, slice, block); Set a vector block. to_array([copy, dense]); Converts a PSI4 Matrix or Vector to a NumPy array. to_serial(); Converts an object with a .nph accessor to a serialized dictionary. vector_dot(self, other); Take the dot product of two vectors. zero(self); Zeros the vector. Attributes Documentation. name¶; The name of the Vector. Used in printing. np¶; View with single irrep. nph¶; View with irreps. shape¶; Shape of the Psi4 data object. Methods Documentation. add(*args, **kwargs)¶; Overloaded function. add(self: psi4.core.Vector, m: int, val: float) -> None. Add to a single element value located at m. add(self: psi4.core.Vector, h: int, m: int, val: fl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html:1425,load,load,1425,psi4manual/1.9.x/api/psi4.core.Vector.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/api/psi4.core.Vector.html,2,['load'],['load']
Performance,"nterpoise_correct is unhappy to be calling function \'%s\'.' % (func.__name__)). if 'check_bsse' in kwargs and yes.match(str(kwargs['check_bsse'])):; check_bsse = True; else:; check_bsse = False. # Make sure the molecule the user provided is the active one; if 'molecule' in kwargs:; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option(""BASIS"", PsiMod.get_global_option(""BASIS"")). df_ints_io = PsiMod.get_global_option('DF_INTS_IO'); # inquire if above at all applies to dfmp2 or just scf; PsiMod.set_global_option('DF_INTS_IO', 'SAVE'); psioh = PsiMod.IOManager.shared_object(); psioh.set_specific_retention(97, True). activate(molecule); molecule.update_geometry(). PsiMod.print_out(""\n""); banner(""CP Computation: Complex.\nFull Basis Set.""); PsiMod.print_out(""\n""); e_dimer = call_function_in_1st_argument(func, **kwargs); #e_dimer = energy(name, **kwargs). PsiMod.clean(); PsiMod.set_global_option('DF_INTS_IO', 'LOAD'). # All monomers with ghosts; monomers = extract_clusters(molecule, True, 1); e_monomer_full = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); banner((""CP Computation: Monomer %d.\n Full Basis Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_full.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_full.append(energy(name,**kwargs)); cluster_n = cluster_n + 1; PsiMod.clean(). PsiMod.set_global_option('DF_INTS_IO', 'NONE'); if (check_bsse):; # All monomers without ghosts; monomers = extract_clusters(molecule, False, 1); e_monomer_bsse = []. cluster_n = 0; for cluster in monomers:; activate(cluster); PsiMod.print_out(""\n""); #cluster.print_to_output(); banner((""CP Computation: Monomer %d.\n Monomer Set."" % (cluster_n + 1))); PsiMod.print_out(""\n""); e_monomer_bsse.append(call_function_in_1st_argument(func, **kwargs)); #e_monomer_bsse.append(energy(name,**kwargs)); cluster_n = cluster_n + 1. PsiMod.set_globa",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:19844,LOAD,LOAD,19844,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['LOAD'],['LOAD']
Performance,"ntical to the above, except that the frac_traverse() call is substituted; for something like:; # Argument is the functional.; # A useful optional argument is nmax, the total number of electrons to; # strip out of the molecule, in this case, 2.; # Many optional arguments are available, see the python file; frac.frac_nuke('wb97', molecule=h2o, nmax = 2). Dispersion Corrections¶; DFT-D dispersion corrections are discussed here.; HF-3c and PBEh-3c dispersion and BSSE corrections are discussed here.; DFT-NL dispersion corrections are discussed here. Recommendations¶; The KS-DFT code is quite new, but relatively complete. During code development,; emphasis was placed on flexibility of functional technology, efficiency for; medium to large systems in difficult electronic environments (e.g., compact; spatial extents, diffuse basis sets, low band-gaps, LRC and/or hybrid GKS; functionals), and time to code completion. We are very interested in optimizing; and extending the code, so expect performance gains and extensions to; gradients/hessians and TDDFT in future releases.; Some rough guidelines for using the KS-DFT code are as follows,. Use DF for the ERI algorithm wherever possible.; PSI4 is a “tight” code, meaning we’ve set the default numerical cutoffs; for integrals, grids, and convergence criteria in such a way that you will often; get many more digits of precision than needed. You may be able to realize; additional speed gains by loosening some of these thresholds. See; SCF Convergence for default convergence criteria.; Read the literature to determine which functional technology to use. The world; contains far too many papers using B3LYP on noncovalent interactions without a -D. The “best-practice” input file for KS-DFT is:; memory 1 GB # As much as you've got, the DF algorithm can use. molecule {; H; H 1 0.7; }. set {; basis cc-pvdz; scf_type df; guess sad; }. energy('b3lyp'). Advanced Functional Use and Manipulation¶; New DFT functionals can be created from scratch ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/dft-1.html:27758,optimiz,optimizing,27758,psi4manual/1.4.0/dft-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/dft-1.html,18,"['optimiz', 'perform']","['optimizing', 'performance']"
Performance,"ntimeError: value for ERI”; How to choose the compilation directory, {objdir}; How to save configuration settings for a future compilation; What is the directory layout of the installed or staged Psi4; How to run Psi4 as executable after compilation; How to configure paths for PsiAPI; How to run Psi4 as Python module after compilation; How to run Psi4 as executable or Python module from conda installation; How to run Psi4 as executable after compilation using driver from source; Why not to set PSIDATADIR; How to configure C++ and C compilers for building Psi4; What C and C++ compilers and versions are approved; How to obtain C and C++ compilers for Mac without Fink, MacPorts, or Homebrew; How to satisfy the GCC >= 4.9 requirement on Linux without updating the OS; How to configure a Psi4 build on Cray; How to configure Fortran compilers for building Psi4; What Fortran compilers are approved; How to obtain a Fortran compiler for Mac without Fink, MacPorts, or Homebrew; How to configure BLAS/LAPACK for building Psi4; How to configure Python for building Psi4; What Python is Psi4 running; How to fix “undefined symbol: _Py_FalseStruct”; How to use gdb and lldb with Psi4; How to see the actual compiling commands (or errors) with cmake; How to highlight git merge conflicts in vi; How to handle “runtime library may be hidden” when building with Anaconda Python; How to set up the scratch directory; How do I retain specific Psi4 scratch files; How to use Psi4 within a PBS queue; How to update and rebuild Psi4; How to run a minute’s worth of tests; How to run a subset of tests; How to see CTest testing errors; How to test a Psi4 installation; How to refer to Psi4; How to use a local Add-On repository in the Psi4 build. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.2.1;  · . PSI4. Installation and Runtime Configuration. © Copyright 2018, The Psi4 Project.; Last updated on Wednesday, 25 July 2018 04:21AM.; Created using Sphinx 1.7.6.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/build_planning-1.html:53764,queue,queue,53764,psi4manual/1.2.1/build_planning-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/build_planning-1.html,2,['queue'],['queue']
Performance,"nto CFOUR_SCF_MAXCYC. Type: integer; Default: 100. MOM_OCC¶. The absolute indices of orbitals to excite from in MOM (+/- for alpha/beta). Type: array; Default: No Default. MOM_START¶. The iteration to start MOM on (or 0 for no MOM). Type: integer; Default: 0. MOM_VIR¶. The absolute indices of orbitals to excite to in MOM (+/- for alpha/beta). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Secord order convergence threshold. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_R_START¶. When to start second-order SCF iterations based on gradient RMS. Type: double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attemp to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html:6520,perform,perform,6520,psi4manual/1.0.0/autodir_options_c/module__scf-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodir_options_c/module__scf-1.html,2,['perform'],['perform']
Performance,"nto PSI4 format. Note; PSI4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in PSI4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; PSI4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/cfour-1.html:7082,optimiz,optimize,7082,psi4manual/1.4.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/cfour-1.html,18,['optimiz'],"['optimization', 'optimize']"
Performance,"nto Psi4 format. Note; Psi4 only recognizes keywords by their full name, so the common; Cfour keyword abbreviations CALC, REF, etc. must be replaced by their; proper names of CFOUR_CALC_LEVEL, CFOUR_REFERENCE, etc. Whenever the molecule is supplied in Psi4 format, it is possible to; perform geometry optimizations where Cfour supplies the gradient and the; Psi4 module optking drives the structural; changes. Because of the limitations on geometry specification for; optimizations in Cfour, optking-driven optimizations are the only; optimizations allowed in the P4C4 interface. (The exception is sandwich; mode, which, of course, permits optimizations with the Cfour optimizer.); Below is an example of a geometry optimization:; memory 200 mb. molecule {; O; H 1 R; H 1 R 2 A. R=0.958; A=104.5; }. set {. cfour_CALC_level CCSD(T); cfour_BASIS DZP; cfour_CC_CONV 12; cfour_LINEQ_CONV 12; cfour_SCF_CONV 12; g_convergence cfour; }. optimize('cfour'). Note that the primary change is the exchange of energy(); for optimize() to trigger an optimization. Setting; G_CONVERGENCE=CFOUR provides a good imitation of Cfour; default convergence criteria. Although Cfour produces gradients only in; its standard orientation and atom ordering, these are transformed back to; input orientation by the P4C4 interface. Several sample inputs in; psi4/tests/cfour/ starting with opt- show basic geometry; optimizations. cfour/mints5-grad shows optimizations from a; variety of molecule input formats, and cfour/psi-ghost-grad; shows an optimization with ghosted atoms. To obtain a single gradient; sans optimization, call instead gradient().; Note that it can be convenient to monitor the progress of a geometry; optimization by grepping the tilde ~ character.; Measures of convergence in internal coordinates in au.; Criteria marked as inactive (o), active & met (*), and active & unmet ( ).; --------------------------------------------------------------------------------------------- ~; Step Total Energy Delta E",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/cfour-1.html:7095,optimiz,optimize,7095,psi4manual/1.0.0/cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/cfour-1.html,4,['optimiz'],"['optimization', 'optimize']"
Performance,"ntroduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital optimized MP2 (hence Orbital optimized MP3); will sol",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/occ-1.html:1387,optimiz,optimized,1387,psi4manual/1.0.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/occ-1.html,2,['optimiz'],['optimized']
Performance,"ntroduction¶; Orbital-optimized methods have several advantages over their non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann–Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invariant [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods do not suffer from artifactual symmetry-breaking; instabilities [Crawford:1997:instability], [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Furthermore, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). These abnormal eigenvalues may lead to unphysical; molecular properties such as vibrational frequencies. However, orbital-optimized MP2 (also MP3); will solve this N-represent",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.1.0/occ-1.html:1335,optimiz,optimized,1335,psi4manual/1.1.0/occ-1.html,https://psicode.org,https://psicode.org/psi4manual/1.1.0/occ-1.html,15,['optimiz'],['optimized']
Performance,"ntrols whether to include the coupling terms in the DCT electronic Hessian (for ALOGRITHM = QC with QC_TYPE = SIMULTANEOUS only). Type: boolean; Default: false. QC_MODULE (GLOBALS)¶GLOBALS — When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, ADCC, CCT3; Default: No Default. QC_TYPE (DCT)¶DCT — Controls the type of the quadratically-convergent algorithm (effective for ALGORITHM = QC). If set to TWOSTEP the Newton-Raphson equations are only solved for the orbital updates, the cumulant is updated using the standard Jacobi algorithm. If set to SIMULTANEOUS both cumulant and orbitals are updated in a single Newton-Raphson step. Type: string; Possible Values: TWOSTEP, SIMULTANEOUS; Default: SIMULTANEOUS. QCHF (DFOCC)¶DFOCC — Do perform a QCHF computation?. Type: boolean; Default: false. QCHF (SCF)¶SCF — Do perform a QCHF computation?. Type: boolean; Default: false. QMEFP (EFP)¶EFP (Expert) — Do turn on QM/EFP terms?. Type: boolean; Default: false. R4S (DETCI)¶DETCI (Expert) — Do restrict strings with \(e-\) in RAS IV? Useful to reduce the number of strings required if MIXED4=true, as in a split-virutal CISD[TQ] computation. If more than one electron is in RAS IV, then the holes in RAS I cannot exceed the number of particles in RAS III + RAS IV (i.e., EX_LEVEL), or else the string is discarded. Type: boolean; Default: false. R_CONVERGENCE (ADC)¶ADC — Convergence threshold for ADC matrix diagonalisation. Negative values keep the * adcc default (1e-6). Type: conv double; Default: -1. R_CONVERGENCE (CCENERGY)¶CCENERGY — Convergence criterion for wavefunction (change) in CC amplitude equations. Type: conv double; Default: 1e-7. R_CONVERGENCE (CCEOM)¶CCEOM — Convergence criterion for norm of the residual vector in the Davidson algorithm for CC-EOM. Type: conv double; Default: 1e-6. R_CONVERGENCE (",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html:195215,perform,perform,195215,psi4manual/1.4.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodoc_glossary_options_c-1.html,4,['perform'],['perform']
Performance,"ntry method. CoordValue method. ZMatrixEntry method. ip_fitting() in module frac. IP_POLES (OCC). IRC; . geometry optimization. IRC_DIRECTION (OPTKING). IRC_STEP_SIZE (OPTKING). IRC_STOP (OPTKING). irrep_labels() LibmintsMolecule method. is_axis() LibmintsMolecule method. is_computed() CoordEntry method. is_equivalent_to() CoordEntry method. is_ghosted() CoordEntry method. is_linear_planar() LibmintsMolecule method. is_plane() LibmintsMolecule method. is_required() Keyword method. Section method. is_set() Keyword method. Section method. is_type() Keyword method. is_variable() LibmintsMolecule method. ISTOP (DETCI). IVO (TRANSQT). J. J_FILE (TRANSQT). JOBTYPE (CCLAMBDA). (CPHF). JSCH module, [1]. K. KEEP_INTCOS (OPTKING). KEEP_J (TRANSQT). KEEP_OEIFILE (CCSORT). KEEP_PRESORT (TRANSQT). KEEP_TEIFILE (CCSORT). Keyword class in pcmgetkw. keywords; . C-side, setting. anharmonicity(), setting. cbs(), setting. cp(), setting. database(), setting. energy(), setting. molecule, setting. optimize(), setting. property(), setting. kwargs_lower() in module p4util.procutil. L. label() CoordEntry method. LibmintsMolecule method. LAG_IN_FILE (TRANSQT). LAGRAN_DOUBLE (TRANSQT). LAGRAN_HALVE (TRANSQT). LAMBDA_MAXITER (DCFT). LCC2(+LMP2)TOTALENERGY. LCCSD(+LMP2)TOTALENERGY. LEVEL_SHIFT (MCSCF). (OCC). LibmintsMolecule class in qcdb.libmintsmolecule. like_world_axis() LibmintsMolecule static method. LINEAR (CCRESPONSE). LINEQ_SOLVER (OCC). LINESEARCH_STATIC_MAX (OPTKING). LINESEARCH_STATIC_MIN (OPTKING). LINESEARCH_STATIC_N (OPTKING). load_basfam_dunning() in module p4util.basislistdunning. load_basfam_other() in module p4util.basislistother. load_basis_families() in module p4util.basislist. LOCAL (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_AMPS_PRINT_CUTOFF (CCENERGY). LOCAL_CORE_CUTOFF (CCSORT). LOCAL_CPHF_CUTOFF (CCENERGY). (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_CUTOFF (CCENERGY). (CCEOM). (CCLAMBDA). (CCRESPONSE). (CCSORT). LOCAL_DO_SINGLES (CCEOM). LOCAL_DOMAIN_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/genindex.html:27196,optimiz,optimize,27196,psi4manual/4.0b5/genindex.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/genindex.html,1,['optimiz'],['optimize']
Performance,"nts; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), mo_idx); intdump.write(eigs_dump); else:; PSIF_MO_A_FZC = 'MO-basis Alpha Frozen-Core Oper'; moH_A = core.Matrix(PSIF_MO_A_FZC, wfn.nmopi(), wfn.nmopi()); moH_A.load(core.IO.shared_object(), constants.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_A = moH_A.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_A.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = alpha_mo_idx(il[0][index] + offset); col = alpha_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; PSIF_MO_B_FZC = 'MO-basis Beta Frozen-Core Oper'; moH_B = core.Matrix(PSIF_MO_B_FZC, wfn.nmopi(), wfn.nmopi()); moH_B.load(core.IO.shared_object(), constants.PSIF_OEI); mo_slice = core.Slice(frzcpi, active_mopi); MO_FZC_B = moH_B.get_block(mo_slice, mo_slice); offset = 0; for h, block in enumerate(MO_FZC_B.nph):; il = np.tril_indices(block.shape[0]); for index, x in np.ndenumerate(block[il]):; row = beta_mo_idx(il[0][index] + offset); col = beta_mo_idx(il[1][index] + offset); if (abs(x) > ints_tolerance):; intdump.write('{:29.20E} {:4d} {:4d} {:4d} {:4d}\n'.format(x, row, col, 0, 0)); offset += block.shape[0]; # Additional one-electron integrals as requested in oe_ints; # Orbital energies; core.print_out('Writing orbital energies in FCIDUMP format to ' + fname + '\n'); if 'EIGENVALUES' in oe_ints:; alpha_eigs_dump = write_eigenvalues(wfn.epsilon_a().get_block(mo_slice).to_array(), alpha_mo_idx); beta_eigs_dump = write_eigenvalues(wfn.epsilon_b().get_block(mo_slice).to_array(), beta_mo_idx); intdump.write(alpha_eigs_dump + beta_eigs_dump); # Dipole integrals; #core.print_out('Writing dipole moment OEI in FC",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html:6614,load,load,6614,psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/_modules/psi4/driver/p4util/fcidump.html,1,['load'],['load']
Performance,"nty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # How many electrons are there?; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). # Work in the ot namespace for this procedure; PsiMod.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = PsiMod.get_global_option(""GUESS""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""); PsiMod.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;; ; charge1 = charge0 + 1; ; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.reference_wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; els",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/frac.html:12209,LOAD,LOAD,12209,psi4manual/4.0b2/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/frac.html,2,['LOAD'],['LOAD']
Performance,"nty iterations; maxiter = 20;; if (kwargs.has_key('maxiter')): ; maxiter = kwargs['maxiter']. # By default, do not read previous 180 orbitals file; read = False;; read180 = ''; if (kwargs.has_key('read')):; read = True;; read180 = kwargs['read']. # The molecule is required, and should be the neutral species; mol.update_geometry(); activate(mol); charge0 = mol.molecular_charge(); mult0 = mol.multiplicity() . # How many electrons are there?; N = 0;; for A in range(mol.natom()):; N += mol.Z(A); N -= charge0; N = int(N); Nb = int((N - mult0 + 1)/2); Na = int(N - Nb). # Work in the ot namespace for this procedure; PsiMod.IO.set_default_namespace(""ot""). # Burn in to determine orbital eigenvalues; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180); old_guess = PsiMod.get_global_option(""GUESS""); PsiMod.set_global_option(""DF_INTS_IO"", ""SAVE""); PsiMod.print_out('\n\t==> IP Fitting SCF: Burn-in <==\n'); energy('scf'); PsiMod.set_global_option(""DF_INTS_IO"", ""LOAD""). # Determine HOMO, to determine mult1; ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); if (Na == Nb):; HOMO = -Nb; elif (Nb == 0):; HOMO = Na; else:; E_a = eps_a[int(Na - 1)] ; E_b = eps_b[int(Nb - 1)] ; if (E_a >= E_b):; HOMO = Na; else: ; HOMO = -Nb. Na1 = Na;; Nb1 = Nb;; if (HOMO > 0):; Na1 = Na1-1;; else:; Nb1 = Nb1-1;; ; charge1 = charge0 + 1; ; mult1 = Na1 - Nb1 + 1. omegas = [];; E0s = [];; E1s = [];; kIPs = [];; IPs = [];; types = [];; ; # Right endpoint; PsiMod.set_global_option('DFT_OMEGA',omega_r). # Neutral; if (read):; PsiMod.set_global_option(""GUESS"", ""READ""); copy_file_to_scratch(read180, 'psi', 'ot', 180). mol.set_molecular_charge(charge0); mol.set_multiplicity(mult0); PsiMod.print_out('\n\t==> IP Fitting SCF: Neutral, Right Endpoint <==\n'); E0r = energy('scf'); ref = PsiMod.wavefunction(); eps_a = ref.epsilon_a(); eps_b = ref.epsilon_b(); E_HOMO = 0.0;; if (Nb == 0):; E_HOMO = eps_a[int(Na-1)]; else:; E_a = eps_a[int(",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/frac.html:12126,LOAD,LOAD,12126,psi4manual/4.0b4/_modules/frac.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/frac.html,1,['LOAD'],['LOAD']
Performance,"nual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC 1. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. 1; FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to CASCI",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/detci-1.html:5385,perform,performed,5385,psi4manual/1.4.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/detci-1.html,5,['perform'],['performed']
Performance,"nual will provide only an elementary introduction to the most; important keywords. Additional information is available in the complete; list of keywords for DETCI provided in Appendix DETCI.; For single-reference CI computations, the easiest way to invoke a CI; computation with DETCI is simply to call energy(), optimize(), etc.,; with the common name for that CI wavefunction, like energy('cisd'); for a CISD single-point energy. The Python driver; recognizes cisd, cisdt, and cisdtq. As mentioned above, codes; written specifically for CISD will be more efficient than DETCI for a; CISD computation, and energy('cisd') by default will call other,; more efficient modules. To force a CISD computation with DETCI,; set QC_MODULE = DETCI.; Higher order single-reference CI wavefunctions, like those including singles through; 6-fold excitations, can be invoked using numbers, like ci6. A full; CI can be specified by fci. More complicated CI computations, like; RASCI, can be performed by setting the appropriate keywords and calling the; module generically like energy('detci'). The latter approach; will also work for any of the previously-mentioned CI wavefunctions for; which the driver has built-in shortcuts, so long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Orbital spaces for CI computations¶. CI (e.g., CISD, FCI); RASCI; CASCI. FROZEN_UOCC; FROZEN_UOCC; FROZEN_UOCC [1]. (all orbitals not in; FROZEN_UOCC; or FROZEN_DOCC; are included in CI); RAS4; ACTIVE. RAS3. RAS2. RAS1. FROZEN_DOCC; FROZEN_DOCC; FROZEN_DOCC. [1]; FROZEN_UOCC is not required and will be inferred if; ACTIVE is provided. However, if it is easier to specify; FROZEN_UOCC, then this may be provided and ACTIVE can; be inferred. The table above shows the relevant orbitals spaces for CI computations (an; analogous table for MCSCF is also available).; The third column of the; table refers to C",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/detci.html:5385,perform,performed,5385,psi4manual/1.7.x/detci.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/detci.html,4,['perform'],['performed']
Performance,"nual]. c4-scf; Hartree–Fock (HF). c4-mp2; 2nd-order Møller–Plesset perturbation theory (non-density-fitting) (MP2). c4-mp3; 3rd-order Møller–Plesset perturbation theory (MP3). c4-mp4(sdq); 4th-order MP perturbation theory (MP4) less triples. c4-mp4; full MP4. c4-cc2; approximate coupled cluster singles and doubles (CC2). c4-ccsd; coupled cluster singles and doubles (CCSD). c4-cc3; approximate CC singles, doubles, and triples (CC3). c4-ccsd(t); CCSD with perturbative triples (CCSD(T)). c4-ccsdt; coupled cluster singles, doubles, and triples (CCSDT). cfour; expert full control over cfour program. Examples:. >>> # [1] Analytic hf optimization; >>> optimize('hf'). >>> # [2] Finite difference mp5 optimization with gradient; >>> # printed to output file; >>> e, wfn = opt('mp5', return_wfn='yes'); >>> wfn.gradient().print_out(). >>> # [3] Can automatically perform complete basis set extrapolations; >>> optimize('MP2/cc-pV([D,T]+d)Z'). >>> # [4] Can automatically perform delta corrections that include extrapolations; >>> # even with a user-defined extrapolation formula. See sample inputs named; >>> # cbs-xtpl* for more examples of this input style; >>> optimize(""MP2/aug-cc-pv([d,t]+d)z + d:ccsd(t)/cc-pvdz"", corl_scheme=myxtplfn_2). >>> # [5] Get info like geometry, gradient, energy back after an; >>> # optimization fails. Note that the energy and gradient; >>> # correspond to the last optimization cycle, whereas the; >>> # geometry (by default) is the anticipated *next* optimization step.; >>> try:; >>> optimize('hf/cc-pvtz'); >>> except psi4.OptimizationConvergenceError as ex:; >>> next_geom_coords_as_numpy_array = np.asarray(ex.wfn.molecule().geometry()). table of contents. optimize; optimize(). «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.10a1.dev61;  · . PSI4. PSI4 API: Linking C++ and Python; optimize. © Copyright 2007-2024, The Psi4 Project.; Last updated on Thursday, 07 November 2024 08:57AM.; Created using Sphinx 7.4.7.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/api/psi4.driver.optimize.html:16762,perform,perform,16762,psi4manual/master/api/psi4.driver.optimize.html,https://psicode.org,https://psicode.org/psi4manual/master/api/psi4.driver.optimize.html,19,"['Optimiz', 'optimiz', 'perform']","['OptimizationConvergenceError', 'optimization', 'optimize', 'perform']"
Performance,"nual]. sos-omp3; spin-opposite scaled OMP3 [manual]. omp2.5; orbital-optimized MP2.5 [manual] [details]. lccsd, cepa(0); coupled electron pair approximation variant 0 [manual] [details]. fno-lccsd, fno-cepa(0); CEPA(0) with frozen natural orbitals [manual]. cepa(1); coupled electron pair approximation variant 1 [manual] [details]. fno-cepa(1); CEPA(1) with frozen natural orbitals [manual]. cepa(3); coupled electron pair approximation variant 3 [manual] [details]. fno-cepa(3); CEPA(3) with frozen natural orbitals [manual]. acpf; averaged coupled-pair functional [manual] [details]. fno-acpf; ACPF with frozen natural orbitals [manual]. aqcc; averaged quadratic coupled cluster [manual] [details]. fno-aqcc; AQCC with frozen natural orbitals [manual]. qcisd; quadratic CI singles doubles (QCISD) [manual] [details]. fno-qcisd; QCISD with frozen natural orbitals [manual]. remp2; 2nd-order retaining-the-excitation-degree MP hybrid perturbation theory [manual] [details]. oremp2; orbital-optimized REMP2 [manual] [details]. lccd; Linear CCD [manual] [details]. fno-lccd; LCCD with frozen natural orbitals [manual]. olccd; orbital optimized LCCD [manual] [details]. cc2; approximate coupled cluster singles and doubles (CC2) [manual] [details]. ccd; coupled cluster doubles (CCD) [manual] [details]. ccsd; coupled cluster singles and doubles (CCSD) [manual] [details]. bccd; Brueckner coupled cluster doubles (BCCD) [manual] [details]. fno-ccsd; CCSD with frozen natural orbitals [manual]. qcisd(t); QCISD with perturbative triples [manual] [details]. fno-qcisd(t); QCISD(T) with frozen natural orbitals [manual]. ccsd(t); CCSD with perturbative triples (CCSD(T)) [manual] [details]. a-ccsd(t); CCSD with asymmetric perturbative triples (A-CCSD(T)) [manual] [details]. bccd(t); BCCD with perturbative triples [manual] [details]. fno-ccsd(t); CCSD(T) with frozen natural orbitals [manual]. cc3; approximate CC singles, doubles, and triples (CC3) [manual] [details]. ccenergy; expert full control ove",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html:4323,optimiz,optimized,4323,psi4manual/1.7.x/api/psi4.driver.energy.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.energy.html,12,['optimiz'],['optimized']
Performance,"numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = PsiMod.Molecule.create_molecule_from_string(new_geom); new_mol.update_geometry(); new_mol.print_out(); activate(new_mol); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html:3300,Queue,Queue,3300,psi4manual/4.0b2/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/_modules/wrappers.html,2,['Queue'],['Queue']
Performance,"numatoms):; A = F[f+1].split(); symbol[f] = A[0]; X[f] = float(A[1]); Y[f] = float(A[2]); Z[f] = float(A[3]); White.append(f); Fragment = [[] for i in range(numatoms)] # stores fragments. start = 0 # starts with the first atom in the list; Queue.append(start); White.remove(start). frag = 0; ; while((len(White) > 0) or (len(Queue) > 0)): # Iterates to the next fragment; while(len(Queue) > 0): # BFS within a fragment; for u in Queue: # find all nearest Neighbors; # (still coloured white) to vertex u; for i in White:; Distance = math.sqrt((X[i] - X[u]) * (X[i] - X[u]) +; (Y[i] - Y[u]) * (Y[i] - Y[u]) +; (Z[i] - Z[u]) * (Z[i] - Z[u])); if Distance < convert(u,symbol) + convert(i,symbol):; Queue.append(i) # if you find you, put it in the que; White.remove(i) # and remove it from the untouched list; Queue.remove(u) # remove focus from Queue; Black.append(u); Fragment[frag].append(int(u + 1)) # add to group (adding 1 to start; # list at one instead of zero). if(len(White) != 0): # cant move White->Queue if no more exist; Queue.append(White[0]); White.remove(White[0]); frag += 1; ; new_geom = """"""\n0 1\n"""""" ; for i in Fragment[0]:; new_geom = new_geom + F[i].lstrip() + """"""\n""""""; new_geom = new_geom + """"""--\n0 1\n""""""; for j in Fragment[1]:; new_geom = new_geom + F[j].lstrip() + """"""\n""""""; new_geom = new_geom + """"""units angstrom\n"""""". new_mol = geometry(new_geom); new_mol.print_out(); PsiMod.print_out(""Exiting auto_fragments\n""). #######################; ## Start of n_body ##; #######################. [docs]def n_body(name, **kwargs):; lowername = name.lower(); kwargs = kwargs_lower(kwargs). # Wrap any positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(). # Establish function to call; if not('n_body_func' in kwargs):; if ('func' in kwargs):; kwargs['n_body_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['n_body_func'] = energy; func = kwargs['n_body_func']; if not func:; raise ValidationErr",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:3325,Queue,Queue,3325,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,4,['Queue'],['Queue']
Performance,"numbers in the respective recipes; When L/LT all built and passed, edit the individual package version numbers in cbcy and increment to a new ltrtver with updated version numbers and/or build numbers (only if code changes); Build L/PSI4. If any trouble, edit psi4 code. Iterate until builds and passes. This stage is the only full ctest & pytest on Psi4+upstream; Build L/RT-MP. If any trouble, edit code in L/RT and rebuild those package(s). Iterate until builds and passes. This stage is the only full ctest & pytest of Psi4+downstream; Build L/DEV. If any trouble, edit psi4 build system, plugin system, or OpenMP setup. Iterate until builds and passes; Build L/DOCS. If any trouble, edit the docs or the tests. Iterate until builds and passes; Results of last should upload to psicode.org (docs) and codecov.io (coverage); Changes to targets’ “source” and “version” in individual recipes should be edited in psi4 external/*/*/CMakeLists.txt files; Once everything’s working on Linux, repeat on Mac; At this point, ready to fine-tune builds of “Psi4 stack”. Assemble postrelease changes¶. Collect PRs with “backport” label, and request other backport suggestions on upcoming RN issue; Cherry-pick backport PRs and commits, apply other changes manually, not forgetting CI files; Do the draft parts of Publish GitHub postrelease; Test thoroughly locally, including psi4-rt (may have to step back for dependency versions or builds); Note that while can’t change maintenance branch’s history, can push to it directly on upstream; If want to do trial conda builds, requires source/git_tag: 1.3.x and fake package/version: v1.3.1rc1. Tweak Conda for postrelease¶. In psi4-* recipes, find the best combination of master meta.yaml/build.sh and the v1N(x-1)-labeled ones. comment out any dependencies in master but not yet in postrelease; add {{ dep_bld }} entries if needed to step back build. make sure normal operation is ''. In cbcy,. create a postrelease new line and record anything not in continuous ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/manage_release-1.html:4069,tune,tune,4069,psi4manual/1.4.0/manage_release-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/manage_release-1.html,7,['tune'],['tune']
Performance,"nversion factor ; psi_dipmom_au2si = 8.47835281E-30 # Atomic units to SI units (Cm) conversion factor for dipoles ; psi_dipmom_au2debye = 2.54174623 # Atomic units to Debye conversion factor for dipoles ; psi_dipmom_debye2si = 3.335640952E-30 # Debye to SI units (Cm) conversion factor for dipoles ; psi_c_au = 137.035999679 # Speed of light in atomic units ; psi_hartree2ev = 27.21138 # Hartree to eV conversion factor ; psi_hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; psi_hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; psi_hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; psi_kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; psi_e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; psi_na = 6.02214179E23 # Avagadro's number ; psi_me = 9.10938215E-31 # Electron rest mass (in kg) . wrappers¶; Module with functions that call the four main driver; functions: driver.energy, driver.optimize,; driver.response, and driver.frequency. auto_fragments(name, **kwargs)[source]¶; Detects fragments if the user does not supply them.; Currently only used for the WebMO implementation of SAPT; usage: auto_fragments(‘’). call_function_in_1st_argument(funcarg, **largs)[source]¶; Function to make primary function call to energy(), opt(), etc.; with options dictionary largs.; Useful when funcarg to call is stored in variable. convert(p, symbol)[source]¶. reconstitute_bracketed_basis(needarray)[source]¶; Function to reform a bracketed basis set string from a sequential series; of basis sets (e.g, form ‘cc-pv[q5]z’ from array [cc-pvqz, cc-pv5z]). The; basis set array is extracted from the f_basis field of a NEED dictionary in; complete_basis_set(). Result is used to print a nicely; formatted basis set string in the results table. split_menial(menial)[source]¶; Function used by complete_basis_set() to separate; menial ‘scftot’ into [scf, tot] and ‘mp2corl’ into [mp2, corl]. tblhead(tbl_maxrgt",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html:11524,optimiz,optimize,11524,psi4manual/4.0b2/autodoc_driver-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_driver-1.html,6,['optimiz'],['optimize']
Performance,"ny positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_global_option('REFERENCE'); user_memory = PsiMod.get_memory(). user_molecu",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html:30241,load,load,30241,psi4manual/4.0b3/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/_modules/wrappers.html,2,['load'],['load']
Performance,"ny positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (PsiMod.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % PsiMod.psi_top_srcdir()); database = import_ignorecase(db_name); if database is None:; PsiMod.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); PsiMod.print_out('\nSearch path that was tried:\n'); PsiMod.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = PsiMod.get_global_option('BASIS'); user_df_basis_scf = PsiMod.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = PsiMod.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = PsiMod.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = PsiMod.get_global_option('DF_BASIS_ELST'). user_writer_file_label = PsiMod.get_global_option('WRITER_FILE_LABEL'). b_user_reference = PsiMod.has_global_option_changed('REFERENCE'); user_reference = PsiMod.get_gl",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html:30242,load,load,30242,psi4manual/4.0b4/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/wrappers.html,2,['load'],['load']
Performance,"ny positional arguments into kwargs (for intercalls among wrappers); if not('name' in kwargs) and name:; kwargs['name'] = name.lower(); if not('db_name' in kwargs) and db_name:; kwargs['db_name'] = db_name. # Establish function to call; if not('db_func' in kwargs):; if ('func' in kwargs):; kwargs['db_func'] = kwargs['func']; del kwargs['func']; else:; kwargs['db_func'] = energy; func = kwargs['db_func']; if not func:; raise ValidationError('Function \'%s\' does not exist to be called by wrapper database.' % (func.__name__)); if (func is cp):; raise ValidationError('Wrapper database is unhappy to be calling function \'%s\'. Use the cp keyword within database instead.' % (func.__name__)). # Define path and load module for requested database; sys.path.append('%sdatabases' % (psi4.Process.environment[""PSIDATADIR""])); sys.path.append('%s/lib/databases' % psi4.psi_top_srcdir()); database = p4util.import_ignorecase(db_name); if database is None:; psi4.print_out('\nPython module for database %s failed to load\n\n' % (db_name)); psi4.print_out('\nSearch path that was tried:\n'); psi4.print_out("", "".join(map(str, sys.path))); raise ValidationError(""Python module loading problem for database "" + str(db_name)); else:; dbse = database.dbse; HRXN = database.HRXN; ACTV = database.ACTV; RXNM = database.RXNM; BIND = database.BIND; TAGL = database.TAGL; GEOS = database.GEOS; try:; DATA = database.DATA; except AttributeError:; DATA = {}. # Must collect (here) and set (below) basis sets after every new molecule activation; user_basis = psi4.get_global_option('BASIS'); user_df_basis_scf = psi4.get_global_option('DF_BASIS_SCF'); user_df_basis_mp2 = psi4.get_global_option('DF_BASIS_MP2'); user_df_basis_sapt = psi4.get_global_option('DF_BASIS_SAPT'); user_df_basis_elst = psi4.get_global_option('DF_BASIS_ELST'). user_writer_file_label = psi4.get_global_option('WRITER_FILE_LABEL'). b_user_reference = psi4.has_global_option_changed('REFERENCE'); user_reference = psi4.get_global_option('REFERE",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html:30877,load,load,30877,psi4manual/4.0b5/_modules/wrappers.html,https://psicode.org,https://psicode.org/psi4manual/4.0b5/_modules/wrappers.html,2,['load'],['load']
Performance,"n’t depend on options (scf_type) being set global or local. This input uses global. mints3; Test individual integral objects for correctness. fci-tdm; He2+ FCI/cc-pVDZ Transition Dipole Moment. cc38; RHF-CC2-LR/cc-pVDZ static polarizabilities of HOF molecule. pywrap-db2; Database calculation, run in sow/reap mode. cbs-xtpl-func; optimization with method defined via cbs. cisd-h2o+-0; 6-31G** H2O+ Test CISD Energy Point. opt13; B3LYP cc-pVDZ geometry optimzation of phenylacetylene, starting from not quite linear structure. tu5-sapt; Example SAPT computation for ethene*ethine (i.e., ethylene*acetylene), test case 16 from the S22 database. ocepa1; OCEPA cc-pVDZ energy for the H2O molecule. props1; RHF STO-3G dipole moment computation, performed by applying a finite electric field and numerical differentiation. cc55; EOM-CCSD/6-31g excited state transition data for water with two excited states per irrep. omp2-grad2; OMP2 cc-pVDZ gradient for the NO radical. dft-freq; Frequencies for H2O B3LYP/6-31G* at optimized geometry. cc22; ROHF-EOM-CCSD/DZ on the lowest two states of each irrep in CH2. stability1; UHF->UHF stability analysis test for BH with cc-pVDZ Test direct SCF with and without symmetry, test PK without symmetry. dfomp2-2; OMP2 cc-pVDZ energy for the NO molecule. dfcasscf-sa-sp; Example of state-averaged CASSCF for the C2 molecule. cc9; UHF-CCSD(T) cc-pVDZ frozen-core energy for the state of the CN radical, with Z-matrix input. adc1; ADC/6-31G** on H2O. cc37; CC2(UHF)/cc-pVDZ energy of H2O+. omp2p5-grad1; OMP2.5 cc-pVDZ gradient for the H2O molecule. rasscf-sp; 6-31G** H2O Test RASSCF Energy Point will default to only singles and doubles in the active space. psithon2; Accesses basis sets, databases, plugins, and executables in non-install locations. x2c1; Test of SFX2C-1e on water uncontracted cc-pVDZ-DK The reference numbers are from Lan Cheng’s implementation in Cfour. dft2; DFT Functional Test. scf4; RHF cc-pVDZ energy for water, automatically scanning the s",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html:29401,optimiz,optimized,29401,psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_testsuite_corepsi4-1.html,4,['optimiz'],['optimized']
Performance,"o Default. CFOUR_GEO_CONV¶. Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC¶. Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP¶. Specifies largest step (in millibohr) which is allowed in geometry optimizations. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly INTRAFRAG_STEP_LIMIT. Type: integer; Default: 300. CFOUR_GEO_METHOD¶. Specifies the used geometry optimization methods. The following values are permitted: NR (=0) — straightforward Newton-Raphson search for minimum; RFA (=1) — Rational Function Approximation search for minimum (this method can be used to find minima when the initial structure is in a region where the Hessian index is nonzero); TS (=2) Cerjan-Miller eigenvector following search for a transition state (can be started in a region where the Hessian index is not equal to unity); MANR (=3) — Morse-adjusted Newton-Raphson search for minimum (very efficient minimization scheme, particularly if the Hessian is available); SINGLE_POINT (=5) for a single-point energy calculation. ENERONLY (=6) requests a geometry optimization based on single-point energy calculations. Default: SINGLE-POINT (NR as soon as variables are m",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html:30131,optimiz,optimizations,30131,psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__cfour-1.html,48,['optimiz'],"['optimizations', 'optimizer']"
Performance,"o FCI ». OMPn: Orbital-Optimized Møller–Plesset Perturbation Theory¶; Code author: Ugur Bozkaya; Section author: Ugur Bozkaya; Module: Keywords, PSI Variables, OMP2; Module: Keywords, PSI Variables, OMP3. Introduction¶; Orbital-optimized methods have several advantages over non-optimized counterparts.; Once the orbitals are optimized, the wave function will obey the Hellmann-Feynman theorem; for orbital rotation parameters. Therefore, there is no need for orbital response terms; in the evaluation of analytic gradients. In other words, it is unnecessary to solve the; first order coupled-perturbed CC and many-body perturbation theory (MBPT) equations.; Further, computation of one-electron properties is easier because there are no response contributions to the particle; density matrices (PDMs). Moreover, active space approximations can be readily incorporated into the CC methods; [Krylov:2000:vod]. Additionally, orbital-optimized coupled-cluster avoids spurious second-order; poles in its response function, and its transition dipole moments are gauge invarianti [Pedersen:1999:od].; Another advantage is that the orbital-optimized methods does not suffer from the artifactual symmetry-breaking; instabilities [Sherrill:1998:od], [Bozkaya:2011:omp2], and [Bozkaya:2011:omp3].; Further, Kurlancheek and Head-Gordon [Kurlancek:2009] demonstrated that first order properties such as; forces or dipole moments are discontinuous along nuclear coordinates when such a symmetry breaking occurs.; They also observed that although the energy appears well behaved, the MP2 method can have natural occupation; numbers greater than 2 or less than 0, hence may violate the N-representability condition. They further; discussed that the orbital response equations generally have a singularity problem at the unrestriction point; where spin-restricted orbitals become unstable to unrestriction. This singularity yields to extremely large or; small eigenvalues of the one-particle density matrix (OPDM). Th",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b3/ompn-1.html:1131,optimiz,optimized,1131,psi4manual/4.0b3/ompn-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b3/ompn-1.html,2,['optimiz'],['optimized']
Performance,"o Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below Hartree/bohr, where is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR — Specifies larges",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html:47162,perform,performs,47162,psi4manual/1.0.0/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/autodoc_glossary_options_c-1.html,2,['perform'],['performs']
Performance,"o Hydrogen and Helium atoms and specifies the number of contracted Gaussian functions per shell. There is usually no need to use this keyword, but it can be useful for using a subset of the functions in a particular entry in the GENBAS file, particularly for generally contracted WMR basis sets. For example, if entry H:BASIS in the GENBAS file contains 7 contracted s functions, 4 p functions and a single d function, then setting GENBAS_1=730 would eliminate the last p function and the d function. Default: use the unaltered GENBAS entry. Type: string; Default: No Default. CFOUR_GENBAS_2 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 above, but applies to second-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_3 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 and CFOUR_GENBAS_2 , but applies to third-row atoms. Type: string; Default: No Default. CFOUR_GENBAS_4 (CFOUR); CFOUR — This keyword performs the same function as CFOUR_GENBAS_1 , CFOUR_GENBAS_2 , and CFOUR_GENBAS_3 , but applies to fourth-row atoms. Type: string; Default: No Default. CFOUR_GEO_CONV (CFOUR); CFOUR — Specifies the convergence criterion for geometry optimization. The optimization terminates when the RMS gradient is below \(10^{-N}\) Hartree/bohr, where \(N\) is the specified value. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly G_CONVERGENCE =CFOUR, which should be equivalent except for different internal coordinate definitions. Type: integer; Default: 5. CFOUR_GEO_MAXCYC (CFOUR); CFOUR — Specifies the maximum allowed number of geometry optimization cycles. Psi4 Interface: Geometry optimizations run through PSI (except in sandwich mode) use PSI’s optimizer and so this keyword has no effect. Use optking keywords instead, particularly GEOM_MAXITER. Type: integer; Default: 50. CFOUR_GEO_MAXSTEP (CFOUR); CFOUR ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html:47290,perform,performs,47290,psi4manual/1.2.1/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/autodoc_glossary_options_c-1.html,6,['perform'],['performs']
Performance,"o SI units (Cm) conversion factor for dipoles ; c_au = 137.035999679 # Speed of light in atomic units ; hartree2ev = 27.21138 # Hartree to eV conversion factor ; hartree2wavenumbers = 219474.6 # Hartree to cm$^{-1}$ conversion factor ; hartree2kcalmol = 627.5095 # Hartree to kcal mol$^{-1}$ conversion factor ; hartree2kJmol = 2625.500 # Hartree to kilojoule mol$^{-1}$ conversion factor ; hartree2MHz = 6.579684E9 # Hartree to MHz conversion factor ; kcalmol2wavenumbers = 349.7551 # kcal mol$^{-1}$ to cm$^{-1}$ conversion factor ; e0 = 8.854187817E-12 # Vacuum permittivity (Fm$^{-1}$) ; na = 6.02214179E23 # Avagadro's number ; me = 9.10938215E-31 # Electron rest mass (in kg) . In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constants.h. Memory Specification¶; By default, PSI4 assumes that 500 MiB of memory are available. While this is; enough for many computations, many of the algorithms will perform better if; more is available. To specify memory, the memory keyword should be used. The following; lines are all equivalent methods for specifying that 2 GB of RAM is available; to PSI4:; 1; 2; 3; 4; 5; 6; 7# all equivalent. memory 2 GB. memory 2000 MB. memory 2000000 kB. Please note that memory can be specified both in IEC binary units (1 KiB = 1024 bytes) and SI units (1 kB = 1000 bytes). PSI4 recognizes and obeys both of them correctly. The units are not case sensitive (Kb and KB are equivalent to kB).; By default, PSI4 performs a “sanity check” when parsing Psithon input files, enforcing a minimum memory requirement of 250 MiB. While it is generally not recomennded to do so, expert users can bypass this check by directly setting the number of bytes availble to PSI4:; 1; 2# setting available memory to 2 MB; set_memory_bytes(2000000). Please note that this memory setting only governs the maximal memory usage of the major data structures and actual total memo",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html:4014,perform,perform,4014,psi4manual/1.2.1/psithoninput-1.html,https://psicode.org,https://psicode.org/psi4manual/1.2.1/psithoninput-1.html,2,['perform'],['perform']
Performance,"o be gained from loosening it, especially for higher-order SAPT. Type: conv double; Default: 1.0e-12. INTS_TOLERANCE (SCF)¶SCF — Screening threshold for the chosen screening method (SCHWARZ, CSAM, DENSITY) Absolute value below which TEI are neglected. Type: conv double; Default: 1e-12. IP_POLES (OCC)¶OCC — Do compute OCC poles for ionization potentials? Only valid OMP2. Type: boolean; Default: false. IRC_DIRECTION (OPTKING)¶OPTKING — IRC mapping direction. Type: string; Possible Values: FORWARD, BACKWARD; Default: FORWARD. IRC_POINTS (OPTKING)¶OPTKING — Maximum number of IRC points to collect before stopping. Type: integer; Default: 20. IRC_STEP_SIZE (OPTKING)¶OPTKING — IRC step size in bohr(amu)\(^{1/2}\). Type: double; Default: 0.2. ISOTROPIC_POL (PE)¶PE — Make polarizabilities isotropic. Type: boolean; Default: false. ISTOP (DETCI)¶DETCI — Do stop DETCI after string information is formed and before integrals are read?. Type: boolean; Default: false. JOBTYPE (CCLAMBDA)¶CCLAMBDA (Expert) — Type of job being performed. Type: string; Default: No Default. KIND (ADC)¶ADC — The kind of states to compute. Type: string; Possible Values: SINGLET, TRIPLET, SPIN_FLIP, ANY; Default: SINGLET. LEVEL_SHIFT (DFOCC)¶DFOCC — Level shift to aid convergence. Type: double; Default: 0.02. LEVEL_SHIFT (MCSCF)¶MCSCF — Level shift to aid convergence. Type: double; Default: 0.0. LEVEL_SHIFT (OCC)¶OCC — Removed in 1.4. Will raise an error in 1.5. Type: double; Default: 0.02. LEVEL_SHIFT (SCF)¶SCF — Do use a level shift?. Type: double; Default: 0.0. LEVEL_SHIFT_CUTOFF (SCF)¶SCF — DIIS error at which to stop applying the level shift. Type: double; Default: 1e-2. LINEAR (CCRESPONSE)¶CCRESPONSE — Do Bartlett size-extensive linear model?. Type: boolean; Default: false. LINEQ_SOLVER (DFOCC)¶DFOCC — The solver will be used for simultaneous linear equations. Type: string; Possible Values: CDGESV, FLIN, POPLE; Default: CDGESV. LINK_INTS_TOLERANCE (SCF)¶SCF — The screening tolerance used for ERI/Dens",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html:155593,perform,performed,155593,psi4manual/1.7.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodoc_glossary_options_c.html,4,['perform'],['performed']
Performance,"o be performed, PSI4 was built; upon the Python interpreter. However, to make the input syntax simpler, some; pre-processing of the input file is performed before it is interpreted,; resulting in Python syntax that is customized for PSI, termed Psithon. In; this section we will describe the essential features of the Psithon language.; PSI4 is distributed with an extensive test suite, described in section; Test Suite and Sample Inputs; the input files for these test cases can be found in the; samples subdirectory of the top-level PSI4 source directory and should; serve as useful examples.; The equivalent Python PsiAPI syntax is shown alongside the Psithon code snippets.; When using the Python API, one must import the PSI4 module with:; import psi4. No such directive is neccesary when using Psithon, which is run using the psi4; executable. Physical Constants¶; For convenience, the Python interpreter will execute the contents of the; ~/.psi4rc file in the current user’s home area (if present) before performing any; tasks in the input file. This allows frequently used python variables to be; automatically defined in all input files. For example, if we repeatedly make; use of the universal gravitational constant, the following line could be placed; in the ~/.psi4rc file; UGC = 6.67384E-11 # m^3 / kg^-1 s^-2. which would make the variable UGC available in all PSI4 input files.; For convenience, the physical constants used within the PSI4 code (which; are obtained from NIST CODATA 2014; are also automatically loaded as Psithon; variables (before ~/.psi4rc is loaded, so that the user’s ~/.psi4rc values can; override the builtins (in the input file, not in the C++ code).; The physical constants used within PSI4, which are automatically; made available within all PSI4 input files are in Physical Constants.; In Psithon input files, prepend physical constants with psi_ to; prevent clashes with user-defined variables (e.g., psi_h). In; PsiAPI mode, access as, e.g., psi4.constant",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psithoninput.html:1244,perform,performing,1244,psi4manual/master/psithoninput.html,https://psicode.org,https://psicode.org/psi4manual/master/psithoninput.html,1,['perform'],['performing']
Performance,"o be treated with standard DMA. Type: double; Default: 4.0. GEOM_MAXITER (OPTKING)¶OPTKING — Maximum number of geometry optimization steps. Type: integer; Default: 50. GRADIENT_WRITE (FINDIF)¶FINDIF — Do write a gradient output file? If so, the filename will end in .grad, and the prefix is determined by WRITER_FILE_LABEL (if set), or else by the name of the output file plus the name of the current molecule. Type: boolean; Default: false. GUESS (SCF)¶SCF — The type of guess orbitals. See Initial Guess for what the options mean and what the defaults are. Type: string; Possible Values: AUTO, CORE, GWH, SAD, SADNO, SAP, SAPGAU, HUCKEL, MODHUCKEL, READ; Default: AUTO. GUESS_MIX (SCF)¶SCF — Mix the HOMO/LUMO in UHF or UKS to break alpha/beta spatial symmetry. Useful to produce broken-symmetry unrestricted solutions. Notice that this procedure is defined only for calculations in C1 symmetry. Type: boolean; Default: false. GUESS_PERSIST (SCF)¶SCF — If true, then repeat the specified guess procedure for the orbitals every time - even during a geometry optimization. Type: boolean; Default: false. GUESS_R_CONVERGENCE (DCT)¶DCT — Convergence criterion for the density cumulant and orbital guess for the variationally orbital-optimized DFT methods. Currently only available for ALGORITHM = SIMULTANEOUS. Type: conv double; Default: 1e-3. GUESS_VECTOR (DETCI)¶DETCI (Expert) — Guess vector type. Accepted values are UNIT for a unit vector guess (NUM_ROOTS and NUM_INIT_VECS must both be 1); H0_BLOCK to use eigenvectors from the H0 BLOCK submatrix (default); DFILE to use NUM_ROOTS previously converged vectors in the D file;. Type: string; Possible Values: UNIT, H0_BLOCK, DFILE; Default: H0_BLOCK. H0_BLOCK_COUPLING (DETCI)¶DETCI (Expert) — Do use coupling block in preconditioner?. Type: boolean; Default: false. H0_BLOCK_COUPLING_SIZE (DETCI)¶DETCI (Expert) — Parameters which specifies the size of the coupling block within the generalized davidson preconditioner. Type: integer; Default: 0.",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodoc_glossary_options_c.html:146768,optimiz,optimization,146768,psi4manual/1.9.x/autodoc_glossary_options_c.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodoc_glossary_options_c.html,2,['optimiz'],['optimization']
Performance,"o can be accessed through; energy('myplugin') in an input file. Any other Python functions can; also be placed in this file.; __init__.py — Init script for the plugin (in the sense that; the whole plugin directory is a Python module). This file generally won’t; need editing unless additional Python files are added to the plugin; directory (add additional lines to the # Load Python modules section); or the plugin depends on .so codes in other plugin directories (add; additional plugin_load lines relative to the current plugin directory to; the # Load C++ plugin section). doc.rst — Documentation file. Place in this file any notes,; equations, warnings to users, todo lists, etc.. Plain text is fine,; though reStructuredText is the ultimate goal. Remove the .. comment; text and build Sphinx documentation for samples of linking keywords,; sections, and math. This file is absorbed into the PSI4; documentation, along with any docstrings to Python functions, and the C++; keywords block in the myplugin.cc file. See Updating the Users’ and Programmers’ Manual; for building documentation. Please note that pure virtual functions in a plugin may cause undefined symbols errors when; the plugin is loaded.; To create a purely Python plugin, create a new plugin directory, then; remove the Makefile and myplugin.cc files and; erase the shared object loading portion of __init__.py. Create as many .py; files as necessary (registering each one in __init__.py), use; input.dat as a model for loading the plugin, no recompile ever; necessary. table of contents. Creating New Plugins; Modular Approach to Development; Creating a New Plugin; Creating a New Plugin Using a Conda Pre-compiled Binary; Files in a Plugin Directory. «; hide menu. menu; sidebar; »; . Navigation. Index. modules    .    .    .    .  · ; 1.7;  · . PSI4. Adding New Code to PSI4; Creating New Plugins. © Copyright 2007-2022, The Psi4 Project.; Last updated on Tuesday, 06 December 2022 10:44PM.; Created using Sphinx 5.1.1.; . ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/plugins.html:7965,load,loaded,7965,psi4manual/1.7.x/plugins.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/plugins.html,3,['load'],"['loaded', 'loading']"
Performance,"o compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, ADCC, CCT3, BUILTIN; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK, COSX; Default: PK. SCREENING¶. The type of screening used when computing two-electron integrals. Type: string; Possible Values: SCHWARZ, CSAM, DENSITY; Default: CSAM. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. Type: c",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__globals.html:7308,optimiz,optimized,7308,psi4manual/1.6.x/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/1.6.x/autodir_options_c/module__globals.html,2,['optimiz'],['optimized']
Performance,"o compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, CCT3, BUILTIN, MRCC; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK, COSX, LINK; Default: PK. SCREENING¶. The type of screening used when computing two-electron integrals. Type: string; Possible Values: SCHWARZ, CSAM, DENSITY; Default: CSAM. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid basis cutoff. T",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html:8203,optimiz,optimized,8203,psi4manual/1.7.x/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__globals.html,2,['optimiz'],['optimized']
Performance,"o compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, CCT3, BUILTIN, MRCC; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK, DFDIRJ+COSX, DFDIRJ+LINK; Default: PK. SCREENING¶. The type of screening used when computing two-electron integrals. Type: string; Possible Values: SCHWARZ, CSAM, DENSITY; Default: CSAM. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. CubicScalarGrid b",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__globals.html:8205,optimiz,optimized,8205,psi4manual/1.8.x/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/autodir_options_c/module__globals.html,2,['optimiz'],['optimized']
Performance,"o compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, CCT3, BUILTIN, MRCC; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK, DFDIRJ, DFDIRJ+COSX, DFDIRJ+LINK, DFDIRJ+SNLINK; Default: PK. SCREENING¶. The type of screening used when computing two-electron integrals. Type: string; Possible Values: SCHWARZ, CSAM, DENSITY, NONE; Default: CSAM. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/autodir_options_c/module__globals.html:8481,optimiz,optimized,8481,psi4manual/master/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/master/autodir_options_c/module__globals.html,2,['optimiz'],['optimized']
Performance,"o compute. Type: array; Default: No Default. PROPERTIES_ORIGIN¶. Either a set of 3 coordinates or a string describing the origin about which one-electron properties are computed. Type: array; Default: No Default. PUREAM¶. Do use pure angular momentum basis functions? If not explicitly set, the default comes from the basis set. Cfour Interface: Keyword translates into CFOUR_SPHERICAL. Type: boolean; Default: true. QC_MODULE¶. When several modules can compute the same methods and the default routing is not suitable, this targets a module. CCENERGY covers CCHBAR, etc. OCC covers OCC and DFOCC. Type: string; Possible Values: CCENERGY, DETCI, DFMP2, FNOCC, OCC, CCT3, BUILTIN, MRCC; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. SCF_TYPE¶. What algorithm to use for the SCF computation. See Table SCF Convergence & Algorithm for default algorithm for different calculation types. Type: string; Possible Values: DIRECT, DF, MEM_DF, DISK_DF, PK, OUT_OF_CORE, CD, GTFOCK, DFDIRJ, DFDIRJ+COSX, DFDIRJ+LINK; Default: PK. SCREENING¶. The type of screening used when computing two-electron integrals. Type: string; Possible Values: SCHWARZ, CSAM, DENSITY, NONE; Default: CSAM. SOCC¶. An array containing the number of singly-occupied orbitals per irrep (in Cotton order). The value of DOCC should also be set. Type: array; Default: No Default. WRITER_FILE_LABEL¶. Base filename for text files written by PSI, such as the MOLDEN output file, the Hessian file, the internal coordinate file, etc. Use the add_str_i function to make this string case sensitive. Type: string; Default: No Default. Expert¶. CUBIC_BASIS_TOLERANCE¶. Cub",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__globals.html:8205,optimiz,optimized,8205,psi4manual/1.9.x/autodir_options_c/module__globals.html,https://psicode.org,https://psicode.org/psi4manual/1.9.x/autodir_options_c/module__globals.html,2,['optimiz'],['optimized']
Performance,"o converge for all irreps during instability analysis. (Overridden by SOLVER_ROOTS_PER_IRREP.). Type: integer; Default: 1. SOLVER_ROOTS_PER_IRREP¶. Number of roots to converge, per irrep, during instability analysis. (Overrides SOLVER_N_ROOT.). Type: array; Default: No Default. SOSCF¶. Do use second-order SCF convergence methods?. Type: boolean; Default: false. SOSCF_CONV¶. Second order convergence threshold. Cease microiterating at this value. Type: conv double; Default: 5.0e-3. SOSCF_MAX_ITER¶. Maximum number of second-order microiterations to perform. Type: integer; Default: 5. SOSCF_MIN_ITER¶. Minimum number of second-order microiterations to perform. Type: integer; Default: 1. SOSCF_PRINT¶. Do we print the SOSCF microiterations?. Type: boolean; Default: false. SOSCF_START_CONVERGENCE¶. When to start second-order SCF iterations based on gradient RMS. Type: conv double; Default: 1.0e-2. STABILITY_ANALYSIS¶. Whether to perform stability analysis after convergence. NONE prevents analysis being performed. CHECK will print out the analysis of the wavefunction stability at the end of the computation. FOLLOW will perform the analysis and, if a totally symmetric instability is found, will attempt to follow the eigenvector and re-run the computations to find a stable solution. Type: string; Possible Values: NONE, CHECK, FOLLOW; Default: NONE. Fractional Occupation UHF/UKS¶. FRAC_DIIS¶. Do use DIIS extrapolation to accelerate convergence in frac?. Type: boolean; Default: true. FRAC_LOAD¶. Do recompute guess from stored orbitals?. Type: boolean; Default: false. FRAC_OCC¶. The absolute indices of occupied orbitals to fractionally occupy (+/- for alpha/beta). Type: array; Default: No Default. FRAC_RENORMALIZE¶. Do renormalize C matrices prior to writing to checkpoint?. Type: boolean; Default: true. FRAC_START¶. The iteration to start fractionally occupying orbitals (or 0 for no fractional occupation). Type: integer; Default: 0. FRAC_VAL¶. The occupations of the orbital indic",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html:9364,perform,performed,9364,psi4manual/1.7.x/autodir_options_c/module__scf.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/autodir_options_c/module__scf.html,8,['perform'],['performed']
Performance,"o electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT, SIMINT; Default: LIBINT. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. MOLDEN_WITH_VIRTUAL¶. Write all the MOs to the MOLDEN file (true) or discard the unoccupied MOs (false). Type: boolean; Default: true. MP2_TYPE¶. Algorithm to use for MP2 computation. See Cross-module Redundancies for details. Type: string; Possible Values: DF, CONV, CD; Default: DF. MP_TYPE¶. Algorithm to use for MPn ( \(n>2\) ) computation (e.g., MP3 or MP2.5 or MP4(SDQ)). See Cross-module Redundancies for details. Type: string; Possible Values: DF, ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__globals-1.html:3821,optimiz,optimized,3821,psi4manual/1.3.2/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.3.2/autodir_options_c/module__globals-1.html,2,['optimiz'],['optimized']
Performance,"o electrons are frozen (with the exception of electrons treated by an ECP). With -1, -2, and -3, the user might request strict freezing of the previous first/second/third noble gas shell on every atom. In this case, when there are no valence electrons, the code raises an exception. More precise control over the number of frozen orbitals can be attained by using the keywords NUM_FROZEN_DOCC (gives the total number of orbitals to freeze, program picks the lowest-energy orbitals) or FROZEN_DOCC (gives the number of orbitals to freeze per irreducible representation). Type: string; Possible Values: FALSE, TRUE, 1, 0, -1, -2, -3; Default: FALSE. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. INTEGRAL_PACKAGE¶. Integral package to use. If compiled with ERD or Simint support, change this option to use them; LibInt is used otherwise. Type: string; Possible Values: ERD, LIBINT1, SIMINT, LIBINT2; Default: LIBINT2. LITERAL_CFOUR¶. Text to be passed directly into CFOUR input files. May contain molecule, options, percent blocks, etc. Access through cfour {...} block. Type: string; Default: No Default. MAX_RADIAL_MOMENT¶. Maximum Radial Moment to Calculate. Type: integer; Default: 4. MBIS_D_CONVERGENCE¶. MBIS Convergence Criteria. Type: conv double; Default: 1.0e-8. MBIS_MAXITER¶. Maximum Number of MBIS Iterations. Type: integer; Default: 500. MBIS_PRUNING_SCHEME¶. Pruning scheme for MBIS Grid. Type: string; Default: ROBUST. MBIS_RADIAL_POINTS¶. MBIS Number of Radial Points. Type: integer; Default: 75. MBIS_SPHERICAL_POINTS¶. MBIS Number o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html:3924,optimiz,optimized,3924,psi4manual/1.4.0/autodir_options_c/module__globals-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/autodir_options_c/module__globals-1.html,10,['optimiz'],['optimized']
Performance,"o hold. A translation of this ungainly equation to example [5] below is as; follows. In words, this is a double- and triple-zeta 2-point; Helgaker-extrapolated CCSD(T) coupled-cluster correlation correction; appended to a triple- and quadruple-zeta 2-point; Helgaker-extrapolated MP2 correlation energy appended to a SCF/aug-cc-pVQZ; reference energy. Energy Methods; The presence of a stage_wfn keyword is the indicator to incorporate; (and check for stage_basis and stage_scheme keywords) and compute; that stage in defining the CBS energy.; The cbs() function requires, at a minimum, name='scf' and scf_basis; keywords to be specified for reference-step only jobs and name and; corl_basis keywords for correlated jobs.; The following energy methods have been set up for cbs(). scf; df-scf. mp2; df-mp2. cc2; ccsd. bccd; cc3. ccsd(t); fci. Parameters:; name (string) – 'scf' || 'ccsd' || etc.; First argument, usually unlabeled. Indicates the computational method; for the correlation energy, unless only reference step to be performed,; in which case should be 'scf'. Overruled if stage_wfn keywords supplied. corl_wfn (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the energy method for which the correlation energy is to be; obtained. Can also be specified with name or as the unlabeled; first argument to the function. delta_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a delta correction; to the correlation energy is to be obtained. delta_wfn_lesser (string) – 'mp2' || 'ccsd' || etc.; Indicates the inferior energy method for which a delta correction; to the correlation energy is to be obtained. delta2_wfn (string) – 'ccsd' || 'ccsd(t)' || etc.; Indicates the (superior) energy method for which a second delta correction; to the correlation energy is to be obtained. delta2_wfn_lesser (string) – 'mp2' || 'ccsd(t)' || etc.; Indicates the inferior energy method for which a second delta correction; to the correlation energy is to be obtain",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/cbs-1.html:2773,perform,performed,2773,psi4manual/4.0b2/cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/cbs-1.html,2,['perform'],['performed']
Performance,"o long as the relevant options; (especially EX_LEVEL) are set appropriately. Some; examples of single-refence CI, RASCI, and full CI computations are provided; in psi4/samples. Basic DETCI Keywords¶. REFERENCE¶. Reference wavefunction type. Type: string; Possible Values: RHF, ROHF; Default: RHF. R_CONVERGENCE¶. Convergence criterion for CI residual vector in the Davidson algorithm (RMS error). The default is 1e-4 for energies and 1e-7 for gradients. Type: conv double; Default: 1e-4. EX_LEVEL¶. The CI excitation level. Type: integer; Default: 2. FCI¶. Do a full CI (FCI)? If TRUE, overrides the value of EX_LEVEL. Type: boolean; Default: false. FROZEN_DOCC¶. An array containing the number of frozen doubly-occupied orbitals per irrep (these are not excited in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_DOCC and FREEZE_CORE. Type: array; Default: No Default. RESTRICTED_DOCC¶. An array giving the number of restricted doubly-occupied orbitals per irrep (not excited in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. RESTRICTED_UOCC¶. An array giving the number of restricted unoccupied orbitals per irrep (not occupied in CI wavefunctions, but orbitals can be optimized in MCSCF). Type: array; Default: No Default. FROZEN_UOCC¶. An array containing the number of frozen unoccupied orbitals per irrep (these are not populated in a correlated wavefunction, nor can they be optimized in MCSCF. This trumps NUM_FROZEN_UOCC. Type: array; Default: No Default. CI_MAXITER¶. Maximum number of iterations to diagonalize the Hamiltonian. Type: integer; Default: 24. NUM_ROOTS¶. number of CI roots to find. Type: integer; Default: 1. ICORE¶. Specifies how to handle buffering of CI vectors. A value of 0 makes the program perform I/O one RAS subblock at a time; 1 uses entire CI vectors at a time; and 2 uses one irrep block at a time. Values of 0 or 2 cause some inefficiency in the I/O (requiring multiple reads of ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/detci-1.html:6026,optimiz,optimized,6026,psi4manual/1.0.0/detci-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/detci-1.html,2,['optimiz'],['optimized']
Performance,"o optimize(). Carries out one gradient pass,; deciding analytic or finite difference. """"""; lowername = name.lower(); kwargs = kwargs_lower(kwargs); dertype = 1. optstash = OptionsState(; ['SCF', 'E_CONVERGENCE'],; ['SCF', 'D_CONVERGENCE'],; ['E_CONVERGENCE']). # Order of precedence:; # 1. Default for wavefunction; # 2. Value obtained from kwargs, if user changed it; # 3. If user provides a custom 'func' use that. # Allow specification of methods to arbitrary order; lowername, level = parse_arbitrary_order(lowername); if level:; kwargs['level'] = level. # 1. set the default to that of the provided name; if lowername in procedures['gradient']:; dertype = 1; elif lowername in procedures['energy']:; dertype = 0; func = energy. # 2. Check if the user passes dertype into this function; if 'dertype' in kwargs:; opt_dertype = kwargs['dertype']. if der0th.match(str(opt_dertype)):; dertype = 0; func = energy; elif der1st.match(str(opt_dertype)):; dertype = 1; else:; raise ValidationError('Requested derivative level \'dertype\' %s not valid for helper function optimize.' % (opt_dertype)). # 3. if the user provides a custom function THAT takes precendence; if ('opt_func' in kwargs) or ('func' in kwargs):; if ('func' in kwargs):; kwargs['opt_func'] = kwargs['func']; del kwargs['func']; dertype = 0; func = kwargs['opt_func']. # Summary validation; if (dertype == 1) and (lowername in procedures['gradient']):; pass; elif (dertype == 0) and (func is energy) and (lowername in procedures['energy']):; pass; elif (dertype == 0) and not(func is energy):; pass; else:; raise ValidationError('Requested method \'name\' %s and derivative level \'dertype\' %s are not available.'; % (lowername, dertype)). # Make sure the molecule the user provided is the active one; if ('molecule' in kwargs):; activate(kwargs['molecule']); del kwargs['molecule']; molecule = PsiMod.get_active_molecule(); molecule.update_geometry(); PsiMod.set_global_option('BASIS', PsiMod.get_global_option('BASIS')). # S/R: Mode",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b4/_modules/driver.html:31524,optimiz,optimize,31524,psi4manual/4.0b4/_modules/driver.html,https://psicode.org,https://psicode.org/psi4manual/4.0b4/_modules/driver.html,2,['optimiz'],['optimize']
Performance,"o optimize(). hessian(name, **kwargs); Function complementary to frequency(). ipi_broker(LOT[, molecule, serverdata, options]); Runs IPIBroker to connect to i-PI (https://ipi-code.org/). levenshtein(seq1, seq2); Compute the Levenshtein distance between two strings. libint2_configuration(); Returns information on integral classes, derivatives, and AM from currently linked Libint2. libint2_print_out(). mdi_run(scf_method, **kwargs); Begin functioning as an MDI (MolSSI driver interface) engine. message_box(message[, max_width, min_width]); Put a message string into a box for extra attention. molden(wfn[, filename, density_a, ...]); Function to write wavefunction information in wfn to filename in molden format. molecule_get_attr(self, name); Function to redefine __getattr__ method of molecule class. molecule_set_attr(self, name, value); Function to redefine __setattr__ method of molecule class. oeprop(wfn, *args, **kwargs); Evaluate one-electron properties. opt(name, **kwargs); Function to perform a geometry optimization. optimize(name, **kwargs); Function to perform a geometry optimization. optimize_geometric(name, **kwargs). pcm_helper(block); Helper to specify the multiline PCMSolver syntax for PCM. process_input(raw_input[, print_level]); Function to preprocess raw input, the text of the input file, then parse it, validate it for format, and convert it into legitimate Python. prop(*args, **kwargs); Function to compute various properties. properties(*args, **kwargs); Function to compute various properties. sanitize_method(name); Replace characters in method name so that suitable for function name or Sphinx table anchor (both as-is) or HTML table link (replace underscore in returned string by dash). sanitize_name(name); Function to return name in coded form, stripped of characters that confuse filenames, characters into lowercase, + into p, * into s, and (, ), -, & , into _. scf_helper(name[, post_scf]); Function serving as helper to SCF, choosing whether to cast up o",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/master/psi4api.html:19259,perform,perform,19259,psi4manual/master/psi4api.html,https://psicode.org,https://psicode.org/psi4manual/master/psi4api.html,2,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"o the GeomeTRIC or optking optimizers. Indicates additional options to be passed to the GeomeTRIC optimizer if; chosen as the optimization engine. Alternatively, can be used to set optking options; that are not currently recognized by Psi4. :type func: :ref:`function <op_py_function>`; :param func: |dl| ``gradient`` |dr| || ``energy`` || ``cbs``. Indicates the type of calculation to be performed on the molecule.; The default dertype accesses ``'gradient'`` or ``'energy'``, while; ``'cbs'`` performs a multistage finite difference calculation.; If a nested series of python functions is intended (see :ref:`sec:intercalls`),; use keyword ``opt_func`` instead of ``func``. :type dertype: :ref:`dertype <op_py_dertype>`; :param dertype: ``'gradient'`` || ``'energy'``. Indicates whether analytic (if available) or finite difference; optimization is to be performed. :type hessian_with: str; :param hessian_with: ``'scf'`` || ``'mp2'`` || etc. Indicates the computational method with which to perform a hessian; analysis to guide the geometry optimization. .. warning:: Optimizations where the molecule is specified in Z-matrix format; with dummy atoms will result in the geometry being converted to a Cartesian representation. .. note:: Analytic gradients area available for all methods in the table; below. Optimizations with other methods in the energy table proceed; by finite differences. .. _`table:grad_gen`:. +-------------------------+---------------------------------------------------------------------------------------------------------------+; | name | calls method |; +=========================+===============================================================================================================+; | efp | efp-only optimizations |; +-------------------------+---------------------------------------------------------------------------------------------------------------+; | scf | Hartree--Fock (HF) or density functional theory (DFT) :ref:`[manual] <sec:scf>` :ref:`[detail",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html:63543,perform,perform,63543,psi4manual/1.7.x/_modules/psi4/driver/driver.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/_modules/psi4/driver/driver.html,16,"['optimiz', 'perform']","['optimization', 'perform']"
Performance,"o the conda-forge channel. Neither install docs; for users nor compile docs for developers have been updated yet to; reflect new patterns. Please consult psicode downloads; page for the latest guides. Warning; As of v1.2rc1, new (conda build 3; updated compilers); conda packages are available for Linux but not Mac).; Psi4conda installers are not ready for either platform. PSI4 is available as a pre-compiled binary for Mac and Linux (and; Windows, through the Ubuntu shell) and native Windows architectures; through Anaconda (formerly Continuum Analytics, the company that produces; Anaconda Python (a; full-fledged scientific python environment with package manager conda) and, more particularly, Miniconda (a lightweight Python; distribution with same package manager conda). Some nice features for us:. cross-platform; no root, administrator, or sudo access required; built with high-performance math libraries; lightweight software stack (<100 MB w/o PSI4; ~1 GB including PSI4, numpy, and MKL); updated nightly so new features accessible; standardizes python distribution so no need to find/install libpython packages; add-ons (plugins, extra features requiring Fortran compiler, etc.) can be made available as conda packages; develop PSI4 through plugins without a pre-existing development environment, see Creating a New Plugin Using a Conda Pre-compiled Binary. The PSI4 binary repository is at Anaconda (formerly Binstar).; For commands to get a default installation, go to How to install a Psi4 binary with the Psi4conda installer, command-line; or the psicode downloads page .; Users proficient with conda may prefer to consult What do the conda packages psi4 & psi4-dev and the installer psi4conda contain.; For more flexibility and a detailed explanation, go to; Detailed Installation of Miniconda and Detailed Installation of . How to install a Psi4 binary with the Psi4conda installer, download site¶; Download one of the nine installers (Linux/Mac/Windows; Py38/39/310).; bash it. ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.8.x/conda.html:1168,perform,performance,1168,psi4manual/1.8.x/conda.html,https://psicode.org,https://psicode.org/psi4manual/1.8.x/conda.html,3,['perform'],['performance']
Performance,"o the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float) – \(\Rightarrow\) 1.63 \(\Leftarrow\); Overrides the default alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different alpha might; be more appropriate. corl_xtpl_helgaker_2(). Combined interface. Parameters:; cbs_metadata (List[Dict]) – \(\Rightarrow\) autogenerated from above keywords \(\Leftarrow\) || [{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}] || etc.; This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. `wfn`: typically `HF`, which is subsumed in correlated methods anyway.; `basis`: basis set, can be in a bracketed form (eg. `cc-pv[tq]z`). Other supported arguments for the first dictionary are:. `scheme`: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as `basis`.; `alpha`: alpha for the above scheme, if the default is to be overriden; `options`: if special options are required for a step, they should be entered as a dict here. If some options should be",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html:10205,perform,performed,10205,psi4manual/1.7.x/api/psi4.driver.cbs.html,https://psicode.org,https://psicode.org/psi4manual/1.7.x/api/psi4.driver.cbs.html,12,['perform'],['performed']
Performance,"o the correlation energy.; Defaults to corl_xtpl_helgaker_2() if two valid basis sets; present in delta2_basis and xtpl_highest_1() otherwise. xtpl_highest_1(); corl_xtpl_helgaker_2(). scf_alpha (float) – \(\Rightarrow\) 1.63 \(\Leftarrow\); Overrides the default alpha parameter used in the listed SCF extrapolation procedures.; Has no effect on others, including xtpl_highest_1() and scf_xtpl_helgaker_3(). scf_xtpl_helgaker_2(); scf_xtpl_truhlar_2(); scf_xtpl_karton_2(). corl_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed corl_xtpl_helgaker_2() correlation; extrapolation to the corl stage. The supplied alpha does not impact delta or any further stages. corl_xtpl_helgaker_2(). delta_alpha (float) – \(\Rightarrow\) 3.00 \(\Leftarrow\); Overrides the default alpha parameter used in the listed; corl_xtpl_helgaker_2() correlation extrapolation for the delta correction. Useful when; delta correction is performed using smaller basis sets for which a different alpha might; be more appropriate. corl_xtpl_helgaker_2(). Combined interface. Parameters; cbs_metadata (List[Dict]) – \(\Rightarrow\) autogenerated from above keywords \(\Leftarrow\) || [{""wfn"": ""hf"", ""basis"": ""cc-pv[TQ5]z""}] || etc.; This is the interface to which all of the above calls are internally translated. The first item in; the array is always defining the SCF contribution to the total energy. The required items in the; dictionary are:. `wfn`: typically `HF`, which is subsumed in correlated methods anyway.; `basis`: basis set, can be in a bracketed form (eg. `cc-pv[tq]z`). Other supported arguments for the first dictionary are:. `scheme`: scf extrapolation scheme function, by default it is worked out from the number of basis sets (1 - 3) supplied as `basis`.; `alpha`: alpha for the above scheme, if the default is to be overriden; `options`: if special options are required for a step, they should be entered as a dict here. If some options should be ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html:10203,perform,performed,10203,psi4manual/1.4.0/api/psi4.driver.cbs-1.html,https://psicode.org,https://psicode.org/psi4manual/1.4.0/api/psi4.driver.cbs-1.html,15,['perform'],['performed']
Performance,"o virtual-orbital indices (e.g., integrals) may be held in the cache. Type: integer; Default: 2. CACHELEVEL (CCEOM); CCEOM —. Type: integer; Default: 2. CACHELEVEL (CCHBAR); CCHBAR —. Type: integer; Default: 2. CACHELEVEL (CCLAMBDA); CCLAMBDA —. Type: integer; Default: 2. CACHELEVEL (CCRESPONSE); CCRESPONSE — Cacheing level for libdpd. Type: integer; Default: 2. CACHELEVEL (CCSORT); CCSORT —. Type: integer; Default: 2. CACHELEVEL (DCFT); DCFT — Controls how to cache quantities within the DPD library. Type: integer; Default: 2. CACHELEVEL (MP2); MP2 — The amount of cacheing of data to perform. Type: integer; Default: 2. CACHELEVEL (OMP2); OMP2 —. Type: integer; Default: 2. CACHELEVEL (STABILITY); STABILITY —. Type: integer; Default: 2. CACHELEVEL (TRANSQT2); TRANSQT2 —. Type: integer; Default: 2. CACHETYPE (CCENERGY); CCENERGY — Selects the priority type for maintaining the automatic memory cache used by the libdpd codes. A value of LOW selects a “low priority” scheme in which the deletion of items from the cache is based on pre-programmed priorities. A value of LRU selects a “least recently used” scheme in which the oldest item in the cache will be the first one deleted. Type: string; Possible Values: LOW, LRU; Default: LOW. CACHETYPE (CCEOM); CCEOM —. Type: string; Possible Values: LOW, LRU; Default: LRU. CACHETYPE (MP2); MP2 — The criterion used to retain/release cached data. Type: string; Possible Values: LRU, LOW; Default: LRU. CANONICALIZE_ACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the active orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CANONICALIZE_INACTIVE_FAVG (MCSCF); MCSCF — Do canonicalize the inactive (DOCC and Virtual) orbitals such that the average Fock matrix is diagonal?. Type: boolean; Default: false. CART_HESS_READ (OPTKING); OPTKING — Do read Cartesian Hessian? Only for experts - use FULL_HESS_EVERY instead. Type: boolean; Default: false. CAS_FILES_WRITE (CLAG); CLAG — Do write the OEI, TEI, OPDM, TPDM,",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html:7228,cache,cache,7228,psi4manual/4.0b2/autodoc_glossary_options_c-1.html,https://psicode.org,https://psicode.org/psi4manual/4.0b2/autodoc_glossary_options_c-1.html,2,['cache'],['cache']
Performance,"o; MP2_TYPE: MP_TYPE,; CI_TYPE, CC_TYPE, which can have values CONV,; DF, and CD. These are all global keywords, as their values are; shared among modules rather than (or in addition to) being used internally; by the module). We’re sticking with SCF_TYPE and; MP2_TYPE defaulting to DF, while everything higher defaults; to CONV. In psi4/share/python/driver.py, a managed method calls a; “select” function rather than a “run” function.; procedures = {; 'energy': {; 'scf' : run_scf,; 'mp3' : select_mp3,; 'dcft' : run_dcft,. Then in psi4/share/python/proc.py, the select function runs through; reference (always outer loop) and type (inner loop) to specify the proc; function to call for any able, non-default module (e.g., mtd_type ==; 'DETCI' ) or able, default module (e.g., mtd_typd == ['', 'FNOCC'] ).; Don’t worry about ‘else’ statements as anything that falls through will be; caught and a readable error generated.; def select_mp3(name, **kwargs):; """"""Function selecting the algorithm for a MP3 energy call; and directing to specified or best-performance default modules. """"""; reference = psi4.get_option('SCF', 'REFERENCE'); mtd_type = psi4.get_global_option('MP_TYPE'); module = psi4.get_global_option('QC_MODULE'); # Considering only [df]occ/fnocc/detci. func = None; if reference == 'RHF':; if mtd_type == 'CONV':; if module == 'DETCI':; func = run_detci; elif module == 'FNOCC':; func = run_fnocc; elif module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'UHF':; if mtd_type == 'CONV':; if module in ['', 'OCC']:; func = run_occ; elif mtd_type == 'DF':; if module in ['', 'OCC']:; func = run_dfocc; elif mtd_type == 'CD':; if module in ['', 'OCC']:; func = run_dfocc; elif reference == 'ROHF':; if mtd_type == 'CONV':; if module in ['DETCI']:; func = run_detci. if func is None:; raise ManagedMethodError(['select_mp3', name, 'MP_TYPE', mtd_typ",MatchSource.WIKI,psi4,psi4,v1.9.1,https://psicode.org/psi4manual/1.0.0/proc_py-1.html:5122,perform,performance,5122,psi4manual/1.0.0/proc_py-1.html,https://psicode.org,https://psicode.org/psi4manual/1.0.0/proc_py-1.html,2,['perform'],['performance']
