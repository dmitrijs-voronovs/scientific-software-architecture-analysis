quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Availability," 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Clo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:11532,error,errors,11532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['error'],['errors']
Availability," Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:2133,error,error,2133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability," Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1851,error,error,1851,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability," I think we should require that. 1. The memory footprint of our model is no larger than it needs to be for a given problem (no 'extra' allocation of memory for unused tracers, for hydrostatic pressure when running in non hydrostatic mode, etc). 2. We do not perform unnecessary floating-point computations or indexing into arrays (the latter is especially important in GPU code) for unused tracers or hydrostatic pressure fields. 3. Equations are constructed / specified clearly and concisely (both in source code and user scripts). 4. Users can specify arbitrary types of forcing, including numbers, arrays, or functions (solving #110). 5. We can support arbitrary tracers with various features, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:1329,down,down,1329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['down'],['down']
Availability," Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}; indices=(Colon(), Colon(), 1)); Closest candidates are:; Field(::Field) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Fields/field.jl:160 got unsupported keyword argument ""indices""; Field(::Any, ::String, ::String, ::Any; grid, architecture, indices, boundary_conditions) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/OutputReaders/field_time_series.jl:150; Field(::Tuple, ::Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ, var""#s139""} where {FT, TX, TY, TZ, var""#s139""<:Oceananigans.Distributed.MultiArch}, ::Any, ::Any, ::Tuple, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Distributed/distributed_fields.jl:4 got unsupported keyword argument ""indices""; ...; Stacktrace:; [1] top-level scope; @ REPL[18]:1; ```. If I pass an abstract operation I get a different error:. ```julia; julia> Field(model.velocities.u^2; indices=(:,:,1)); ERROR: MethodError: no method matching offset_indices(::Type{Center}, ::Type{Bounded}, ::Int64, ::Int64, ::Int64); Closest candidates are:; offset_indices(::Any, ::Any, ::Any, ::Any, ::Colon) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:29; offset_indices(::Any, ::Any, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:16; offset_indices(::Any, ::Any, ::Any, ::Any, ::UnitRange) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:30; ...; Stacktrace:; [1] _broadcast_getindex_evalf(::typeof(Oceananigans.Grids.offset_indices), ::Type, ::Type, ::Int64, ::Int64, ::Int64); @ Base.Broadcast ./broadcast.jl:648; [2] _broadcast_getindex; @ ./broadcast.jl:621 [inlined]; [3] (::Base.Broadcast.var""#19#20""{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(Oceananigans.Grids.offset_indices), Tuple{Tuple{Dat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2391:2791,error,error,2791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391,1,['error'],['error']
Availability," Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:2438,checkpoint,checkpoint,2438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpoint']
Availability," a file called `rigid_lid.jl` exists (https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@NamedTup",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3735:1006,Error,Error,1006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735,1,['Error'],['Error']
Availability," a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:1445,error,error,1445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['error'],['error']
Availability," adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:1075,ERROR,ERROR,1075,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['ERROR'],['ERROR']
Availability," and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138:1369,checkpoint,checkpointer,1369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138,1,['checkpoint'],['checkpointer']
Availability," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314:1036,ERROR,ERROR,1036,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314,1,['ERROR'],['ERROR']
Availability," the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:1502,error,error,1502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,1,['error'],['error']
Availability," to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to be a topology because otherwise, users have to manually specify boundary conditions on everything? Then we can automatically set `OpenBoundaryCondition(nothing)` unless a user sets something else.; - Should we have an automatic way to setup a sponge layer?; - Do we think it is correct not to add a term to the pressure for time-varying inflow? I think we do not (see below",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:1410,down,downstream,1410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['down'],['downstream']
Availability, v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions; [44cfe95a] Pkg; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA; [9e88b42a] Serialization; [1a1011a3] SharedArrays; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics; [fa267f1f] TOML; [a4e569a6] Tar; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll; [deac9b47] LibCURL_jll; [29816b5a] LibSSH2_jll; [c8ffd9c3] MbedTLS_jll; [14a3606d] MozillaCACerts_jll; [83775a58] Zlib_jll; [8e850ede] nghttp2_jll; [3f19e933] p7zip_jll; ```. </details>,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:14647,Down,Downloads,14647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,1,['Down'],['Downloads']
Availability," vertically irregular grid can be passed to a nonhydrostatic model and seems to run without a problem, but when the same formulation is applied to the horizontal, a method error is returned by the PressureSolver. The error persists if either the FFTBasedPoissonSolver or the FourierTridiagonalPoissonSolver are called. Is this a known issue?. A MWE follows. Notice the MWE is a reduction of the example given in the [grid documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/), which also gives back the same error when passed to a nonhydrostatic model.; ``` ; using Oceananigans. Lx, Ly, Lz = 1e4, 1e4, 1e3;; Nx, Ny, Nz = 64, 64, 32;; chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny). grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = (-Lz,0); ). model = NonhydrostaticModel(; grid); ```. Gives:; ``` ; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, ; Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:23; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:24; PressureSolver(::Any, ::ImmersedBoundaryGrid) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\Nonhydros",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2940:958,ERROR,ERROR,958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2940,1,['ERROR'],['ERROR']
Availability," with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:1048,error,error,1048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['error'],['error']
Availability," Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² - 0.005027 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10Seawate",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3035:1494,error,error,1494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035,1,['error'],['error']
Availability,"!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part numbe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:2380,ERROR,ERROR,2380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,1,['ERROR'],['ERROR']
Availability,"""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:1344,ERROR,ERROR,1344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['ERROR'],['ERROR']
Availability,"""NaN error in u"" when trying to simulate open-ocean convection problem",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289,1,['error'],['error']
Availability,"""show"" method throws an error for models with no tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/700:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700,1,['error'],['error']
Availability,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,8,"['ERROR', 'checkpoint', 'error']","['ERROR', 'checkpoint', 'checkpointed', 'error']"
Availability,"' functionality to Oceananigans. With this PR, the user is now able to specify which tracers they would like to include in their simulation via the `Model` constructor:. ```julia; model = Model(..., tracers=(:b, :c1, :c2), ...); ```. ## User-facing considerations. 1. The specified tracers must be consistent with the specified buoyancy model. This consistency is ensured by `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, diff",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:1066,error,error,1066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['error'],['error']
Availability,"'ve figured out how to do the 3D pressure solve on a stretched grid following Chris' notes so I think we have all the pieces we need to implement vertically stretched grids, we just have to put it all together. I'm thinking about how to go about fully incorporating a vertically stretched grid, true finite volume operators, and the new FFT+tridiagonal Poisson solvers needed to solve for the pressure on a stretched grid. Seems like a good idea to split it up into steps with one pull request per step:; 1. Reverse the `k` index. Currently PR #462.; 2. Revise the `RegularCartesianGrid` struct so we're happy with it. Currently PR #464.; 3. Add finite volume operators as a separate piece of code. Technically they won't be tested in this PR and could have mistakes. Currently PR #283; 4. Nuke the old operators and start using the same set of finite volume operators for both `Oceananigans.Operators` and `closure_operators.jl`. This will test that the finite volume operators reduce down to the operators that currently work, but doesn't test them on a stretched grid.; 5. Implement a `VerticallyStretchedCartesianGrid`. Might have to iterate bit to figure out what we need, e.g. I think we'll want `ΔzC` to include the distance between the first cell center and the halo cell center, etc.; 6. Implement CPU and GPU pressure solvers for vertically stretched grids with tests. There will be two: one for horizontally periodic domains and another for channel models. I've figured most of this stuff out in Jupyter notebooks.; 7. Ensure that models with vertically stretched grids pass basic tests: e.g. incompressibility, tracer conservation, etc. This will test the finite volume operators.; 8. Run a model with a `VerticallyStretchedCartesianGrid` but with uniform grid spacing and make sure it produces the same numbers as a model with `RegularCartesianGrid`. This is a sanity check.; 9. Run additional tests for vertically stretched grids: e.g. vertical diffusion, internal wave, etc. This will a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/471:987,down,down,987,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/471,1,['down'],['down']
Availability,"(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel(; grid, timestepper, advection, closure). # Initial conditions:; rng = MersenneTwister(seed); u, v = if initial_condition == ""random""; u = rand(rng, actual_size...); v = rand(rng, actual_size...); u .-= mean(u); v .-= mean(v); u, v; else; error(""Unknown initial condition: $initial_condition""); end. set!(model; u=u, v=v). sim = Simulation(model; Δt, stop_time); sim.callbacks[:progress] = Callback(; s -> @info ""Iteration $(iteration(s)) at time $(time(s))"", IterationInterval(100); ). ω, speed = begin; u, v, _ = model.velocities; ω = ∂x(v) - ∂y(u); speed = sqrt(u^2 + v^2); ω, speed; end. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end; ; sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; filename=datadir(""simulations"", savename(d, ""jld2"")),; overwrite_existing=true,; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); return sim; end. Δt = 0.2; size = (128, 128); extent = (1, 1); Δx = extent[1] / size[1]; stop_time = 10.0; topology = (Periodic, Periodic, Flat); architecture = CPU(); timestepper = :RungeKutta3; advection = nothing; closure = nothing; initial_condition = ""random""; seed = 0. params = @strdict size extent topology architecture tim",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2829:2241,error,error,2241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829,1,['error'],['error']
Availability,"(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:3037,ERROR,ERROR,3037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['ERROR'],['ERROR']
Availability,(0.90.8) Fix a sign error in CATKE's implicit dissipative buoyancy flux,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3474:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3474,1,['error'],['error']
Availability,(0.90.9) Fix a sign error in CATKE's implicit dissipative buoyancy flux,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3484:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3484,1,['error'],['error']
Availability,(0.91.5) Tweak initialization procedure so that callback schedules work with checkpointed simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3660:77,checkpoint,checkpointed,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3660,1,['checkpoint'],['checkpointed']
Availability,"(:slice1,), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{UnitRange{Int64}, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}; filename::String, schedule::TimeInterval, dir::String, array_type::Type{Array{Float32, N} where N}, indices::Tuple{Colon, Colon, Colon}, with_halos::Bool, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, overwrite_existing::Bool, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/MVUJA/src/OutputWriters/netcdf_output_writer.jl:324; [14] top-level scope; @ ~/Dropbox/tests/new_project/tilted.jl:24; [15] include(fname::String); @ Base.MainInclude ./client.jl:444; [16] top-level scope; @ REPL[2]:1; ```. Am I missing something or is this a bug?. PS: I had to exclude a big chunk of the error because the output was too long and github wouldn't let me post it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:42813,error,error,42813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,1,['error'],['error']
Availability,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:702,ERROR,ERROR,702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,(v0.83.0) Fix error interpolating field on irregularly spaced grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912,1,['error'],['error']
Availability,"),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0 [inlined]; │ [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CuDeviceArray{Float64, 4, 1}, ::Oceananigans.AbstractOperations.ConditionalOperation{Face,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:1646,error,error,1646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['error'],['error']
Availability,"); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:643; [2] sum(c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:4761,mask,mask,4761,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['mask'],['mask']
Availability,"); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2660:1650,ERROR,ERROR,1650,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660,1,['ERROR'],['ERROR']
Availability,"**TL;DR: We can compress 18GB of Oceananigans simulation checkpoints into 350MB with bitrounding and lossless compression.**. #### Problem; Output is currently uncompressed in Float64 which contains; - redundancies: zeros for immersed boundaries, halos; similar/identical exponent bits; - false information: tailing mantissa bits with no mutual information to neighbouring grid points. #### Proposed solution; Bitrounding to remove false information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:57,checkpoint,checkpoints,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,2,['checkpoint'],"['checkpoint', 'checkpoints']"
Availability,", BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:2039,error,error,2039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,", NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:b,), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Tuple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:3704,down,download,3704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['down'],['download']
Availability,", but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.get_pgcstack); Stacktrace:; [1] multiple call sites; @ unknown:0; Reason: unsupported call through a literal pointer (call to jl_gc_run_pending_finalizers); Stacktrace:; [1] enable_finalizers; @ ./gcutils.jl:126; [2] _trylock; @ ./lock.jl:133; [3] multiple call sites; @ unknown:0; Reason: unsupported dynamic function invocation (call to kwcall(::Any, ::typeof(sprint), f::Function, args...) @ Base strings/io.jl:107); ```. I imagine `lambertw` isn't implemented by CUDA, but that doesn't seem to be what the error says, so I wonder if there's something else going on here. I also saw that [ClimaAtmos seems to be one of the packages that use `LambertW.jl`](https://juliapackages.com/p/lambertw), so maybe the Clima people have encountered (and hopefully solved) this before?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438:2516,error,error,2516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438,1,['error'],['error']
Availability,", they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worke",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1195,Error,Error,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,2,['Error'],['Error']
Availability,", y, z) = U∞ + 1e-5 * Ξ(z). ## Vertical velocity initial condition: random noise scaled by the friction velocity.; wᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-3 * Ξ(z). Tᵢ(x, y, z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this he",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:9001,error,error,9001,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['error'],['error']
Availability,", Δt=25, stop_time=1e4,). using Statistics: std; using Printf; progress_message(sim) = @printf(""Iteration: %04d, time: %s, iteration×Δt: %s, std(pNHS) = %.2e\n"",; iteration(sim), sim.model.clock.time, iteration(sim) * sim.Δt, std(model.pressures.pNHS)); add_callback!(simulation, progress_message, IterationInterval(1)). simulation.output_writers[:snaps] = NetCDFOutputWriter(model, (; model.pressures.pNHS,),; filename = ""test_pressure.nc"",; schedule = TimeInterval(100),; overwrite_existing = true,); run!(simulation); ```. On main this produces stuff like:. ```; Iteration: 0001, time: 25.0, iteration×Δt: 25.0, std(pNHS) = 6.02e-03; Iteration: 0002, time: 50.0, iteration×Δt: 50.0, std(pNHS) = 6.02e-03; Iteration: 0003, time: 75.0, iteration×Δt: 75.0, std(pNHS) = 6.02e-03; Iteration: 0004, time: 99.99999999999999, iteration×Δt: 100.0, std(pNHS) = 6.02e-03; Iteration: 0005, time: 100.0, iteration×Δt: 125.0, std(pNHS) = 2.72e+10; ```. The last two lines are of note where we went from `time: 99.99999999999999` to `time: 100.0`, implying a very tiny time-step, which results in a weird pressure field, as quantified by the last output of the last line: `std(pNHS) = 2.72e+10`. Note that because of this, `time` and `iteration×Δt` don't match up anymore in the last line. Namely `time: 100.0, iteration×Δt: 125.0`. This ""misstep"" happens many times throughout the run on `main`. On this branch this doesn't happen anymore, and even after many time-steps things remain aligned (albeit with a very small round-off error):. ```; Iteration: 0396, time: 9900.0, iteration×Δt: 9900.0, std(pNHS) = 5.99e-03; Iteration: 0397, time: 9925.000000000002, iteration×Δt: 9925.0, std(pNHS) = 5.99e-03; Iteration: 0398, time: 9950.000000000004, iteration×Δt: 9950.0, std(pNHS) = 5.99e-03; Iteration: 0399, time: 9975.000000000005, iteration×Δt: 9975.0, std(pNHS) = 5.99e-03; ```. Ideally the way to really fix this would be to figure out a way to avoid round-off errors, but I haven't been able to do that yet.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3606:2302,error,error,2302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3606,2,['error'],"['error', 'errors']"
Availability,",; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:133 [inlined]; [4] advect_particle; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:75 [inlined]; [5] macro expansion; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:145 [inlined]; [6] cpu__advect_particles!; @ C:\Users\xinle\.julia\packages\KernelAbstractions\WoCk1\src\macros.jl:276 [inlined]; [7] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, particles::StructVector{…}, restitution::Float64, grid::RectilinearGrid{…}, Δt::Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:1686,ERROR,ERROR,1686,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,1,['ERROR'],['ERROR']
Availability,",Int64,Periodic,Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},Oceananigans.Solvers.Backward,GPU,VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},Int64,Bounded,Int64,NamedTuple{(:forward, :backward),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}},Tuple{Int64,Int64,Int64}}}}}},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},Int64,Array{Any,1},Int64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/wJDxT/src/Simulations/run.jl:127; [8] top-level scope at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:80; [9] include(::Function, ::Module, ::String) at ./Base.jl:380; [10] include(::Module, ::String) at ./Base.jl:368; [11] exec_options(::Base.JLOptions) at ./client.jl:296; [12] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:76; ```. I believe this is caused by the `AnisotropicBiharmonicDiffusivity` component of the turbulence closure, since using a simple `AnisotropicDiffusivity` works fine. Also note that the above setup works on a `RegularRectilinearGrid`. Any ideas? . I am working on the `ali/unclog-docs` branch to avoid the error reported here #1571, using Julia v1.5.4 and Oceananigans v0.54.0 + GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:93778,error,error,93778,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['error'],['error']
Availability,". In order to organize the community's work (and also to support some work at Clima on biogeochemistry in Oceananigans), I propose that we create a new package that interfaces with `Oceananigans` --- could it be... `Biogeoceananigans.jl`... ? --- to:. 1. Facilitate sharing code, and collaboration on implementation and testing of biogeochemistry models to be used in Oceananigans simulations; 2. Develop documentation and a suite of examples to illustrate usage, setup, and analysis of numerical experiments with biogeochemistry . To achieve either of these there's no question we need a _particular place_ to collaborate on re-useable code (rather than working independently). But also, I think the Oceananigans.jl repository is not the best repo to use to achieve the above goals, because it's big and complex, which might make it harder for potential developers to contribute and see their place. I also think it would slow development down, because, for example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I thi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:1248,down,down,1248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['down'],['down']
Availability,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:5764,ERROR,ERROR,5764,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,".DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.On",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:2727,error,error,2727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['error'],['error']
Availability,".Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64...; ```. I'm not really sure what to make of this error. Because the simulation I need to run is necessarily complex, it's been hard to get rid of this error in my main simulation. Any ideas?. PS.: I ran this MWE in particular on an NVIDIA Quadro GP100 GPU, but I have gotten the same error (albeit with a longer MWE) on Tesla V100s. ```julia; julia> versioninfo(); Julia Version 1.8.3; Commit 0434deb161e (2022-11-14 20:14 UTC); Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 72 × Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-13.0.1 (ORCJIT, skylake-avx512); Threads: 1 on 72 virtual cores; Environment:; JULIA_DEPOT_PATH = /glade/work/tomasc/.julia; LD_LIBRARY_PATH = /glade/u/apps/dav/opt/cuda/11.4.0/extras/CUPTI/lib64:/glade/u/apps/dav/opt/cuda/11.4.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/lib:/glade/u/apps/dav/opt/julia/1.8.3/lib/julia:/glade/u/apps/dav/opt/openmpi/4.1.1/gnu/10.1.0/lib:/glade/u/apps/dav/opt/ucx/1.11.0/lib:/glade/u/apps/dav/opt/gnu/10.1.0/lib64:/glade/u/ap",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:23025,error,error,23025,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['error'],['error']
Availability,".ScaledPlan{ComplexF64, FFTW.cFFTWPlan{ComplexF64, 1, true, 3, Vector{Int64}}, Float64}, Oceananigans.Solvers.Backward, CPU, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String})(file::JLD2.JLDFile{JLD2.MmapIO}); @ Oceananigans.OutputWriters /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:197; [3] jldopen(::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:14880,checkpoint,checkpointer,14880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['checkpoint'],['checkpointer']
Availability,"/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:1087,Error,Error,1087,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['Error'],['Error']
Availability,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:4364,error,error,4364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['error'],['error']
Availability,"0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, -2, :]; 6×8 OffsetArray(::Matrix{Float64}, -1:4, -1:6) with eltype Float64 with indices -1:4×-1:6:; 4.06893e233 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 7.49511e247 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 3.83945e151 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 5.33788e223 0.0 0.0 0.0 0.0 0.0 0.0 0.0; 2.09002e-95 0.0 0.0 0.0 0.0 0.0 0.0 0.0. julia> my_field[:, :, -2]; 6×7 OffsetArray(::Matrix{Float64}, -1:4, -1:5) with eltype Float64 with indices -1:4×-1:5:; 0.0 NaN 0.0 2.42941e-314 5.13924e151 3.5e-323 4.06893e233; 0.0 0.0 0.0 2.66157e-314 5.6593e-314 4.0e-323 7.49511e247; NaN 0.0 NaN 1.4545e-320 2.98408e-314 6.09933e6 2.09002e-95; 0.0 0.0 0.0 8.46763e165 1.66e-321 4.06893e233 3.83945e151; 0.0 NaN 0.0 6.09933e6 2.75228e-318 7.49089e247 5.33788e223; 0.0 0.0 0.0 9.85509e165 3.0e-323 6.09933e6 2.09002e-95; ```. Even by accessing array elements indices outside the interior and halo ranges, we don’t get out-of-bounds errors. Instead, we obtain junk values for these indices. This behavior applies to windowed fields as well. But why is that the case? What is the reasoning behind this design choice, since I am assuming it’s on purpose?. Secondly, when accessing the interior elements of a windowed field, the indices in the windowed dimension must start from 1 instead of their actual values, which also results in junk values for these elements. Is this also intentional, or should I create a pull request to address it?. ```julia; julia> my_windowed_field = CenterField(grid, indices=(:, :, 5:6)); 2×3×2 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 2×2×2 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: Nothing, top: Nothing, immersed: ZeroFlux; ├── indices: (:, :, 5:6); └── data: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3615:2008,error,errors,2008,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3615,1,['error'],['errors']
Availability,"0_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:4459,error,error,4459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['error'],['error']
Availability,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:1284,error,error,1284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['error'],['error']
Availability,10-100x slowdown on CPU after upgrade to KernelAbstractions 0.8 (due to type inference failure?),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996:87,failure,failure,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996,1,['failure'],['failure']
Availability,"19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:16985,error,error,16985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['error']
Availability,"19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:9792,error,error,9792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['error']
Availability,"2.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:1798,ERROR,ERROR,1798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,2,['ERROR'],['ERROR']
Availability,"4, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:1484,ERROR,ERROR,1484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['ERROR'],['ERROR']
Availability,"40 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:1028,Checkpoint,Checkpointing,1028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,2,"['Checkpoint', 'Error']","['Checkpointing', 'Error']"
Availability,"4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA. ```. (Apologies this error message is a bit mangled because I use `InteractiveErrors`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:19182,error,errors,19182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,4,['error'],"['error', 'errors']"
Availability,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:3636,down,down,3636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['down'],['down']
Availability,"5; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x00000",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1381,error,error,1381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Int64, Int64}}(Statistics.mean!, 4×4×5 Field{Face, Face, Face} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=Nothing, top=Nothing, immersed=ZeroFlux; └── data: 6×6×7 OffsetArray(::Array{Float64, 3}, 0:5, 0:5, 0:6) with eltype Float64 with indices 0:5×0:5×0:6; └── max=0.0, min=0.0, mean=0.0, (1, 2)). julia> Average(field, dims=(1,3)); ERROR: UndefVarError: Ayᶠᶠᶠ not defined; Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:360 [inlined]; [3] eval; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/AbstractOperations.jl:1 [inlined]; [4] metric_function; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/grid_metrics.jl:139 [inlined]; [5] Oceananigans.AbstractOperations.GridMetricOperation(L::Tuple{DataType, DataType, DataType}, metric::Oceananigans.AbstractOperations.YAreaMetric, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia_bkp/packag",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2189:2426,ERROR,ERROR,2426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2189,1,['ERROR'],['ERROR']
Availability,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:13212,ERROR,ERROR,13212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,2,"['ERROR', 'error']","['ERROR', 'errored']"
Availability,"94736842105263; 0.13157894736842105; 0.18421052631578946; 0.23684210526315788; 0.2894736842105263; 0.3421052631578947. julia> collect(grid.xᶜᵃᵃ); 10-element Vector{Float64}:; -0.625; -0.375; -0.125; 0.125; 0.375; 0.625; 0.875; 1.125; 1.375; 1.625; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 6 threads. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); ERROR: ArgumentError: `length(z)` must be equal to size passed to `size` argument.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::LinRange{Float64}, dir::Symbol, size_dir::Int64, FT::Type); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:108; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}, FT::Type, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:284; [4] RectilinearGrid(architecture::CPU, FT::Type; size::Tuple{Int64, Int64, Int64}, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}, halo::Tuple{Int64, Int64, Int64}, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:259; [5] top-level scope; @ REPL[2]:1; [6] top-level scope; @ ~/.julia/packages/CUDA/Uurn4/src/initialization.jl:52; ```. I decided to throw an error instead of a warning because I don't think we want the user be able to proceed in a situation like this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550:2606,error,error,2606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550,1,['error'],['error']
Availability,"9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1152,ERROR,ERROR,1152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['ERROR'],['ERROR']
Availability,"::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_lat_lon_grid_args(FT::Type, latitude::Tuple{Int64, Int64}, longitude::Tuple{Int64, Int64}, z::Vector{Float64}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/latitude_longitude_grid.jl:272; [3] LatitudeLongitudeGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, longitude::Tuple{Int64, Int64}, latitude::Tuple{Int64, Int64}, z::Vector{Float64}, radius::Float64, topology::Tuple{DataType, DataType, DataType}, precompute_metrics::Bool, halo::Nothing); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/latitude_longitude_grid.jl:189; [4] LatitudeLongitudeGrid; @ ~/Research/OC6.jl/sr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319:1758,ERROR,ERROR,1758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319,1,['ERROR'],['ERROR']
Availability,":Vararg{…}; threads::Int64, blocks::Int64, kwargs::@Kwargs{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:340; [19] macro expansion; @ ~/.julia/packages/CUDA/35NC6/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:3790,mask,mask,3790,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['mask'],['mask']
Availability,"; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4483,ERROR,ERROR,4483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,2,"['ERROR', 'error']","['ERROR', 'errored']"
Availability,"<a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependenc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:5946,mainten,maintenance,5946,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['mainten'],['maintenance']
Availability,"= 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; #; k = collect(1:Nz); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimension",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2660:1636,error,error,1636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660,1,['error'],['error']
Availability,> Do you think that we should allow people to plan multithreaded FFTs on the CPU? There's no reason not to use multithreading if its available.; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/116#issuecomment-470798886_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119:133,avail,available,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119,1,['avail'],['available']
Availability,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1075:87,down,downside,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075,2,['down'],['downside']
Availability,"> Not sure if I should open another issue for this, but I was trying to set-up a 2D topology like `(Bounded, Flat, Bounded)` but couldn't. Apparently, however, `(Flat, Bounded, Bounded)` works.; > ; > Is there a list of available topologies to choose from? The `topology` page on the docs leads me to believe that they're all implemented but (unless I'm missing something) they're not. Is that list somewhere in the docs? I couldn't find it.; > ; > Cheers!; > ; > _Originally posted by @tomchor in https://github.com/CliMA/Oceananigans.jl/issues/1178#issuecomment-732235261_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1192:220,avail,available,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192,1,['avail'],['available']
Availability,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:2138,Error,Error,2138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"@Sbozzolo suggested that this is a bit silly and I have to agree it is sort of pointless red tape in some ways, rather like ""accepting cookies"" every time we have to visit a website. We don't really think about that anymore, we just click as fast as we can so we can move on with out lives... I think @Sbozzolo might have some idea for how to do this better. More or less I think the gist is that, rather than having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniform",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543:1714,down,downside,1714,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543,1,['down'],['downside']
Availability,"@arnscheidt reported this error when running this script. https://github.com/ali-ramadhan/antarctic-ice-shelf-meltwater-outflow/blob/eae17968349d72613ccbd0d5b856cc76b30b7850/ice_shelf_meltwater_outflow_2d.jl. ```; InvalidIRError: compiling _set_gpu!(Cassette.Context{nametype(Ctx),Nothing,Nothing,GPUifyLoops.var""##PassType#422"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields._set_gpu!), OffsetArrays.OffsetArray{Float64,3,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, RegularCartesianGrid{Float64,Oceananigans.Grids.Periodic,Oceananigans.Grids.Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_apply_type); ```. Looking at the full stacktrace it looks like `threadIdx` is undefined so maybe we just forgot to import CUDAnative.jl in the Fields submodule following the big reorganization in #591. There should have been a test for this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/634:26,error,error,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/634,1,['error'],['error']
Availability,"@glwagner I am attempting to run the Kelvin-Helmholtz instability example on a GPU, but the model fails and throws errors. Can someone help me to sort out this error? Please find the attached error below: . ```julia; using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])""; ```. ```; Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522:115,error,errors,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522,4,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"@jm-c suggested the following changes that might improve `Float32` precision for simulations with 100,000+ iterations. > Regarding issue with float32 precision: I looked to the code and; > I can see few things that would be easy to change and could make some difference; > regarding this precision issue:; > 1) Temp in Celcius instead of Kelvin (but this is probably not a big problem); > 2) recompute W from continuity instead of stepping forward W using: G_w - d.PNH/dz; > 3) apply pressure solver on provisional solution:; > with RHS = Div(u*,v*,w*) with u* = U + DeltaT * Gu (same for v*,w*); > instead of on tendencies with RHS = Div.(Gu,Gv,Gw); > ; > The problem with the way (2) is currently done is that the error in continuity equation; > are larger ; And with the way we currently do (3), these error can accumulate with time.; > Finally, with T in Kelvin, error in continuity equation can produce larger error in; > temperature.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/161:716,error,error,716,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/161,4,['error'],['error']
Availability,"@jm-c was right about Smagorinsky requiring a larger halo size than the rest of the code. Running `test_smag_divflux_finiteness(T)` causes a `BoundsError` when trying to access index `-1` which suggests we need halos of at least size 2. We do support halos of arbitrary size in all three directions so it would be easy to increase the size of the halos if Smagorinsky is used as a closure. Just wanted to open this issue to see if this is what we wanted to do. For now I'm skipping the test so it's showing up as broken. ```julia; Constant Smagorinsky: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:466; Test threw exception; Expression: test_smag_divflux_finiteness(T); BoundsError: attempt to access OffsetArray(::Array{Float32,3}, 0:4, 0:4, 1:3) with eltype Float32 with indices 0:4×0:4×1:3 at index [3, -1, 2]; Stacktrace:; [1] throw_boundserror(::OffsetArray{Float32,3,Array{Float32,3}}, ::Tuple{Int64,Int64,Int64}) at ./abstractarray.jl:484; [2] checkbounds at ./abstractarray.jl:449 [inlined]; [3] getindex at /home/alir/.julia/packages/OffsetArrays/ruvC7/src/OffsetArrays.jl:130 [inlined]; [4] ∂y_afa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:8 [inlined]; [5] ∂y_u(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32,StepRangeLen{Float32,Float64,Float64}}, ::OffsetArray{Float32,3,Array{Float32,3}}) at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:14; [6] Σ₁₂ at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:33 [inlined]; [7] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:44 [inlined]; [8] Σ₁₂² at /home/alir/Oceananigans.jl/src/closures/velocity_gradients.jl:80 [inlined]; [9] ▶x_caa at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:191 [inlined]; [10] ▶y_aca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:217 [inlined]; [11] ▶xy_cca at /home/alir/Oceananigans.jl/src/closures/closure_operators.jl:275 [inlined]; [12] ΣᵢⱼΣᵢⱼ_ccc at /home/alir/Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/260:553,Error,Error,553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/260,1,['Error'],['Error']
Availability,"@m3azevedo and me are doing a simulation of an unstable baroclinic jet in the context of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:813,error,errors,813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,1,['error'],['errors']
Availability,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59:673,down,down,673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59,2,"['degraded', 'down']","['degraded', 'down']"
Availability,@peterahrens suggested that instead of having `@inbounds` and `@inline` everywhere in [ops_regular_cartesian_grid_elementwise.jl](https://github.com/ali-ramadhan/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid_elementwise.jl) we can use a `@inbounds begin` and it should propagate all the way down unless we explicitly use `@boundscheck`. See: [Julia Docs: Propagating inbounds](https://docs.julialang.org/en/v1/devdocs/boundscheck/index.html#Propagating-inbounds-1),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/58:314,down,down,314,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/58,1,['down'],['down']
Availability,"@raphaelouillon reported this error when running `examples/langmuir_turbulence.jl` using julia 1.4.1:. ```julia; [ Info: i: 0100, t: 8.333 min, Δt: 5.000 s, umax = (7.7e-02, 2.4e-02, 2.0e-02) ms⁻¹, wall time: 11.796 s; [ Info: i: 0200, t: 17.500 min, Δt: 5.500 s, umax = (8.3e-02, 2.9e-02, 1.7e-02) ms⁻¹, wall time: 14.838 s; [ Info: i: 0300, t: 27.583 min, Δt: 6.050 s, umax = (8.7e-02, 3.4e-02, 1.6e-02) ms⁻¹, wall time: 17.098 s; [ Info: i: 0400, t: 38.675 min, Δt: 6.655 s, umax = (8.5e-02, 4.2e-02, 2.0e-02) ms⁻¹, wall time: 19.350 s; [ Info: i: 0500, t: 50.876 min, Δt: 7.321 s, umax = (9.9e-02, 4.4e-02, 2.1e-02) ms⁻¹, wall time: 21.588 s; [ Info: i: 0600, t: 1.072 hr, Δt: 8.053 s, umax = (9.1e-02, 5.3e-02, 2.2e-02) ms⁻¹, wall time: 23.869 s; [ Info: i: 0700, t: 1.315 hr, Δt: 8.773 s, umax = (9.5e-02, 5.9e-02, 2.5e-02) ms⁻¹, wall time: 26.116 s; [ Info: i: 0800, t: 1.548 hr, Δt: 8.392 s, umax = (9.3e-02, 6.6e-02, 2.6e-02) ms⁻¹, wall time: 28.362 s; [ Info: i: 0900, t: 1.787 hr, Δt: 8.595 s, umax = (9.6e-02, 6.7e-02, 2.5e-02) ms⁻¹, wall time: 30.612 s; [ Info: i: 1000, t: 2.019 hr, Δt: 8.331 s, umax = (9.4e-02, 6.3e-02, 2.2e-02) ms⁻¹, wall time: 32.931 s; [ Info: i: 1100, t: 2.255 hr, Δt: 8.515 s, umax = (9.6e-02, 6.8e-02, 2.7e-02) ms⁻¹, wall time: 35.212 s; [ Info: i: 1200, t: 2.486 hr, Δt: 8.321 s, umax = (9.5e-02, 7.3e-02, 2.7e-02) ms⁻¹, wall time: 37.449 s; [ Info: i: 1300, t: 2.721 hr, Δt: 8.455 s, umax = (9.3e-02, 7.7e-02, 2.2e-02) ms⁻¹, wall time: 39.705 s; [ Info: i: 1400, t: 2.960 hr, Δt: 8.615 s, umax = (9.1e-02, 8.8e-02, 3.3e-02) ms⁻¹, wall time: 42.052 s; ^P[ Info: i: 1500, t: 3.206 hr, Δt: 8.826 s, umax = (8.9e-02, 9.0e-02, 2.8e-02) ms⁻¹, wall time: 44.425 s; [ Info: i: 1600, t: 3.452 hr, Δt: 8.888 s, umax = (9.2e-02, 8.9e-02, 2.3e-02) ms⁻¹, wall time: 46.877 s; [ Info: i: 1700, t: 3.695 hr, Δt: 8.730 s, umax = (8.6e-02, 9.0e-02, 2.5e-02) ms⁻¹, wall time: 49.291 s; [ Info: i: 1800, t: 3.943 hr, Δt: 8.922 s, umax = (9.2e-02, 9.4e-02, 2.5e-02) ms⁻¹, wall tim",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:30,error,error,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['error'],['error']
Availability,"@tomchor and @whitleyv this PR adds a script that we can use to _estimate_ the relative effect of bottom drag vs form drag in buoyancy-stratified simulations over hilly bathymetry. This script only produces an estimate, because the bottom drag is implemented in a flat bottom setup, while form drag requires bathymetry. I'd hypothesis that we get more drag when there are both hills and bottom drag, because 1) greater shear at the bottom and 2) stronger downwards mixing of momentum due to strong turbulence. We could use #2275 to extend the results obtained here to cases with both drag and hills. I think it'll also be interesting if more accurate bathymetry representations like the one in #2306 lead to a reduction in form drag (cc @francispoulin). Possibly the spurious form drag is a nice metric to use to judge developments in our representation of bathymetry... I'll run these simulations at high resolution and report some results, hopefully soon. Side note: it's annoying that we don't serialized the immersed boundary so I might try to fix that here too...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402:455,down,downwards,455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402,1,['down'],['downwards']
Availability,"A common mistake is to give a `Number` as a schedule instead of `TimeInterval(Number)`. It'd be much more user-friendly if we have have a function that validates the schedule (and throw an error) because as is now, the first time you encounter the error usually in `run!` and it's hard to pin-point it. Another solution is to test-call the schedule when you initialize the simulation (e.g., put it in a `try-catch`) and throw the error to user?. (discovered with @glwagner)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:189,error,error,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,3,['error'],['error']
Availability,"A few ideas:. 1. Allow `grid` as a positional argument so we can write `WENO5(grid)` rather than `WENO5(grid=grid)`; 2. Emit a warning about ""stretched WENO"" in the model constructor rather than `WENO5`. It's misleading to throw a warning when using WENO5 on a uniform grid; we should only throw a warning if users specify `WENO5` with a stretched grid.; 3. Alternatively to 2, we can re-build WENO in model constructors with a `validate_advection` method. We already have `validate_momentum_advection` for hydrostatic models:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl#L127. The downside to 3 is that it's bad for testing, since it might _prevent_ us from using the ""uniform"" flavor of WENO on stretched grids. (@simone-silvestri is that true?) Also something that's not clear to me --- @simone-silvestri do coefficients like. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Advection/weno_fifth_order.jl#L30. become `Nothing` in regular directions, even with `WENO5(grid=grid)`? Or are they only `Nothing` for `WENO5()`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2271:699,down,downside,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2271,1,['down'],['downside']
Availability,"A lot of times the docs build fail. I notice that there are errors in the installation of deps and precompilation part of the docs build. I'm not totally sure that Manifest.toml is the culprit but shipping docs with its Manifest does require us to use non-conventional ways to build the docs. Specifically, we can't use `Pkg.develop` to install the required deps eg. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. and instead we have to rely to. https://github.com/CliMA/Oceananigans.jl/blob/adb728c8f5bdcd24729b8b9282459fc0344bca5b/docs/make.jl#L5-L11. I would like to experiment whether removing docs/Manifest.toml and using proper compat entries in docs/Project.toml will alleviate some of the issues",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3520:60,error,errors,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3520,1,['error'],['errors']
Availability,Abstract operations `compute_kinetic_energy` test fails with CUDA error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/732:66,error,error,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732,1,['error'],['error']
Availability,AbstractAverages and Checkpointing fixes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/783:21,Checkpoint,Checkpointing,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/783,1,['Checkpoint'],['Checkpointing']
Availability,"Actually, the problem looks like its with the method `has_velocities`. I got this error:. ```julia; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /Users/gregorywagner/.julia/packages/Oceananigans/Lzkia/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Cell,Oceananigans.Face,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Flat,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/700:82,error,error,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/700,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Add Downloads badges on README.md,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3652:4,Down,Downloads,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3652,1,['Down'],['Downloads']
Availability,Add support for only keeping the latest checkpoint,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1341:40,checkpoint,checkpoint,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1341,1,['checkpoint'],['checkpoint']
Availability,Added a list of available topologies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1193:16,avail,available,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1193,1,['avail'],['available']
Availability,"After discussion in #3177 I noticed that the warning only warns for Julia v1.7 and earlier... But it should warn for Julia v1.8 as well. (Although, if we decide to add a compat entry for Julia v1.9 as a response to #3184 then the warning is rendered redundant.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3182:250,redundant,redundant,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182,1,['redundant'],['redundant']
Availability,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179:192,failure,failures,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179,6,"['Checkpoint', 'ERROR', 'error', 'failure']","['Checkpointer', 'ERROR', 'errored', 'failures']"
Availability,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798:205,error,error,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,AllSchedule for combining scheduling criteria and avoiding checkpointing with NaNs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2088:59,checkpoint,checkpointing,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088,1,['checkpoint'],['checkpointing']
Availability,Allow NaNChecker.erroring,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2087:17,error,erroring,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087,1,['error'],['erroring']
Availability,Allow `pickup=true` with zero checkpoints,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1161:30,checkpoint,checkpoints,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1161,1,['checkpoint'],['checkpoints']
Availability,Allow users to mask output,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3092:15,mask,mask,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3092,1,['mask'],['mask']
Availability,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:43,fault,fault,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,2,"['ERROR', 'fault']","['ERROR', 'fault']"
Availability,Also:. * Changes test_examples.jl to spew example file into the build log on error.; * Makes a minor correction to the replace strings for the `ocean_wind_mixing_ and_convection.jl` example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/748:77,error,error,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/748,1,['error'],['error']
Availability,Also:; * Print available `CuDevice`s at startup; * Throw `ArgumentError` when attempting to construct a `Model{GPU}` when no CUDA-enabled GPU is detected. Resolves #82,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/148:15,avail,available,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/148,1,['avail'],['available']
Availability,"Am I doing something wrong?; ```julia; navid:Oceananigans.jl/ (master) $ julia --project [19:00:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.1.0 (2019-01-21); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> include(""examples/internal_wave.jl""); ERROR: LoadError: could not open file /Users/navid/Research/Oceananigans.jl/examples/utils.jl; ...; ```. I guess the problem is the `include(""utils.jl"")` line found in all example .jl scripts. Is this supposed to be `src/utils.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/254:382,ERROR,ERROR,382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/254,1,['ERROR'],['ERROR']
Availability,Ambiguous halo size error in HydrostaticFreeSurfaceModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2983:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983,1,['error'],['error']
Availability,Ambiguous method error when calculating a conditional `Average()` with an `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['error'],['error']
Availability,"An important missing component of our user interface is a function-based API for extracting properties from models. For example, we often write. ```julia; u, v, w = model.velocities; ```. when we really should write something like. ```julia; u, v, w = velocity_field(model); ```. A major advantage of a function-based interface is that it is more robust to changes to the underlying model implementation. For example, we will eventually need a `VectorField` implementation for velocities (eg for the cubed sphere, or non-orthogonal grids). We'll be sorry that we've written `u, v, w = model.velocities` everywhere when we need to change `model.velocities` to `model.velocity_field`. But with a function-based interface we only have to change `velocity_field(model) = model.velocities` to `velocity_field(model) = model.velocity_field`. A few other functions besides `velocity_field` that we might want are. * `tracers(model)`; * `free_surface_displacement(model)`; * `kinematic_pressure(model)`; * `buoyancy(model)`. `viscosity(model)` and `diffusivities(model)` might be nice too. One challenge there is figuring out what to do when the viscosity or diffusivities are really tensors rather than scalars (eg we need `VectorField` but we also may need `TensorField`...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2156:347,robust,robust,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2156,1,['robust'],['robust']
Availability,"Apparently defining a forcing in this way actually slows the model down by a lot. It's ~2x slower with just this one forcing function which seems a little excessive. ```julia; @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); forcing = Forcing(FT=FT); ```. Seems that maybe the exact way the forcing function is defined could have a huge impact on performance.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365:67,down,down,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365,1,['down'],['down']
Availability,"As GPUifyLoops.jl relies on Julia 1.1+, so does Oceananigans. We should print an error (there must be some Julia pattern people do here) if someone tries to run Oceananigans with Julia <1.1. Currently it's really bad for usability as Ubuntu repositories are ancient as usual and still on Julia 1.0.3, and Debian is probably even worse. And you get pretty cryptic messages if running Oceananigans from Julia 1.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/193:81,error,error,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/193,1,['error'],['error']
Availability,"As discussed in #3177 , there is a version bug with `fkeep` and Julia 1.8.3 (1.9.2 works fine).; Trying to use `ImmersedBoundaryGrid` with `HydrostaticFreeSurfaceModel` returns the following error:. ```julia; MethodError: no method matching fkeep!(::Oceananigans.Solvers.var""#60#61"", ::SparseArrays.SparseMatrixCSC{Float64, Int64}); ```. Minimal reproducible example:. ```julia; using Oceananigans. underlying_grid = RectilinearGrid(; size=(100, 100, 10),; x=(-2pi, 2pi),; y=(-2pi, 2pi),; z=(-2, 0),; topology=(Bounded, Bounded, Bounded),; halo=(4, 4, 4); ). @inline bathymetry(x,y) = sin(x)*sin(y)-1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)). model = HydrostaticFreeSurfaceModel(; grid); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184:191,error,error,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184,1,['error'],['error']
Availability,Assert that the topology is Flat in the vertical and also have a test that `Periodic` or `Bounded` in the vertical creates an error.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662:126,error,error,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662,1,['error'],['error']
Availability,At some point we should implement the following tests suggested by @edoddridge in https://github.com/climate-machine/Oceananigans.jl/issues/81. - [ ] Spin down of a flow-field under the influence of friction; - [ ] Thermal wind balance: specify a density structure and compare model velocity fields with analytical solution; - [ ] Rayleigh–Bénard convection (I think analytic solutions exist at low Rayleigh number?); - [ ] Onset of baroclinic instability: compare growth rates with analytical predictions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/157:155,down,down,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/157,1,['down'],['down']
Availability,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2824:18,error,error,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824,3,['error'],['error']
Availability,"At the moment this is possible:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = 1:1:10, y=1:1:10,; z = 1:1:10, ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 5.0) variably spaced with min(Δx)=1.0, max(Δx)=1.0; ├── Periodic y ∈ [1.0, 5.0) variably spaced with min(Δy)=1.0, max(Δy)=1.0; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> grid.Nz; 4. julia> length(grid.zᵃᵃᶜ); 10; ```; Meaning, you can pass a certain size to the constructor, say `Nx`, and also pass an array for that direction (to ""stretch it"") that has a different size than `Nx`. I haven't investigated the consequences of this, but this feels like it could cause problems. Should we throw a warning/error in these cases?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2548:818,error,error,818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548,1,['error'],['error']
Availability,"At the moment, restarting from checkpoints does not allow to restart from data with different halo size.; In particular, I encountered this issue when I wanted to restart a simulation with a different advection order from already evolved data. We might want to support this feature since, when dealing with large complex simulations, a lot of trial and error has to be done in order to find the optimal parameters, which include order of advection (and sub-stepping size for the free surface, which involves halo size for distributed simulations). If there is interest in this feature, I can start implementing it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3206:31,checkpoint,checkpoints,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206,2,"['checkpoint', 'error']","['checkpoints', 'error']"
Availability,"At the moment, to solve equations on a two-dimensional grid one has to provide `Nz=1` and any `Lz` they wish. For example, giving `Lz=2e-16` works pretty well:. ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, eps(Float64))); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 6.283185307179586], z ∈ [-2.220446049250313e-16, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 2.220446049250313e-16); ```. However, `Lz=0` spits out an error...; ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, 0)); ERROR: ArgumentError: Elements of extent=(6.283185307179586, 6.283185307179586, 0) must be > 0!; Stacktrace:; [1] validate_tupled_argument at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:306 [inlined]; [2] validate_regular_grid_size_and_extent(::Type{T} where T, ::Tuple{Int64,Int64,Int64}, ::Tuple{Float64,Float64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Nothing, ::Nothing, ::Nothing) at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:330; [3] RegularCartesianGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Nothing, y::Nothing, z::Nothing, extent::Tuple{Float64,Float64,Int64}, topology::Tuple{DataType,DataType,DataType}, halo::Tuple{Int64,Int64,Int64}) at /Users/navid/Research/Oceananigans.jl/src/Grids/regular_cartesian_grid.jl:126; [4] top-level scope at REPL[33]:1; ```. Perhaps it makes sense that there should be a check and each dimension that has extent =0 and number of grid-points =1 should be treated ""specially"" and bypass the validation at https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Grids/grid_utils.jl#L306?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1001:665,error,error,665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1001,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Auxiliary fields not directly available to tracer forcing functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2730:30,avail,available,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2730,1,['avail'],['available']
Availability,Available Potential Energy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297:0,Avail,Available,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297,1,['Avail'],['Available']
Availability,"Backend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/l",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3641,ERROR,ERROR,3641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['ERROR'],['ERROR']
Availability,Barebones checkpointing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/324:10,checkpoint,checkpointing,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324,1,['checkpoint'],['checkpointing']
Availability,"Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:611; [25] maximum; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:606 [inlined]; [26] #maximum#36; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:620 [inlined]; [27] maximum; @ /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:620 [inlined]; [28] data_summary(field::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:18878,mask,mask,18878,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['mask'],['mask']
Availability,"Based on. https://github.com/CliMA/Oceananigans.jl/blob/2e4ba6b36bf012d5dcb89ddc7160a10f774aadbe/src/TurbulenceClosures/turbulence_closure_diagnostics.jl#L67-L69. CATKE should also have an infinite cell diffusion timescale with the default implicit time discretization. When CATKE is run with explicit time discretization I suppose the cell diffusion timescale should be computed from the maximum viscosity/diffusivity in `model.diffusivity_fields`. Happy to add these `cell_diffusion_timescale` methods. I know `CATKEVerticalDiffusivity` is not exported so I'm just opening the issue to document. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=(12, 12, 12), extent=(1, 1, 1)); closure = CATKEVerticalDiffusivity(); buoyancy = SeawaterBuoyancy(); tracers = (:T, :S, :e). model = HydrostaticFreeSurfaceModel(; grid, closure, buoyancy, tracers). DiffusiveCFL(1.23)(model); ```. Error:. ```; ERROR: MethodError: no method matching cell_diffusion_timescale(::CATKEVerticalDiffusivity{…}, ::@NamedTuple{…}, ::RectilinearGrid{…}). Closest candidates are:; cell_diffusion_timescale(::Nothing, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:22; cell_diffusion_timescale(::ScalarBiharmonicDiffusivity{Dir}, ::Any, ::Any) where Dir; @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:40; cell_diffusion_timescale(::SmagorinskyLilly, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:47; ... Stacktrace:; [1] cell_diffusion_timescale(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:21; [2] (::CFL{…})(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.Diagnostics ~/atdepth/Oceananigans.jl/src/Diagnostics/cfl.jl:25; [3] top-level scope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3772:963,Error,Error,963,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3772,1,['Error'],['Error']
Availability,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086:69,error,error,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086,9,"['checkpoint', 'error']","['checkpointer', 'checkpointing', 'error']"
Availability,"Before this PR, the following would *NOT* error:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. After this PR:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319:42,error,error,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Before this PR:. ```julia; julia> using Oceananigans. julia> NamedTuple(); Error showing value of type NamedTuple{(), Tuple{}}:; ERROR: ArgumentError: collection must be non-empty; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> NamedTuple(); NamedTuple(); ```. you'd think this stuff would be easy. Closes #2398",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2401:75,Error,Error,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2401,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,"Below is a minimal working example of the problem:. ```julia; using Oceananigans; using Printf. grid = RectilinearGrid(Float64,; size = (4, 4, 4),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). b_initial(x, y, z) = rand(). model = NonhydrostaticModel(; ; grid = grid,; buoyancy = BuoyancyTracer(),; tracers = (:b),; timestepper = :RungeKutta3). simulation = Simulation(model, Δt=0.1, stop_iteration=200); outputs = merge(model.velocities, model.tracers). simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:705,checkpoint,checkpointer,705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointer']"
Availability,Better error when the closure is not valid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753:7,error,error,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753,1,['error'],['error']
Availability,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209:158,down,down,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209,1,['down'],['down']
Availability,Binary comparison operators and more robust support for Fields-as-conditionals,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2169:37,robust,robust,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2169,1,['robust'],['robust']
Availability,"Builds off @vchuravy's work in #261. Preliminary design of user API for concrete models. Probably most of the time the user will have to specify boundary conditions prior to building the model. We'll have to come up with good syntax for that. What we have is ok, but can be improved. The checkpointing tests currently fail, I think because they attempt to change the types of the some of the model fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/263:288,checkpoint,checkpointing,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/263,1,['checkpoint'],['checkpointing']
Availability,Bump down to 0.64.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2038:5,down,down,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2038,1,['down'],['down']
Availability,Bump v0.49.0 (as a checkpoint),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1388:19,checkpoint,checkpoint,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388,1,['checkpoint'],['checkpoint']
Availability,Bumping down to 0.64.0 since #1971 accidentally bumped too far to 0.65.0.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2038:8,down,down,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2038,1,['down'],['down']
Availability,"By default `NetCDFOutputWriter` uses `mode = ""c""` which overwrites existing files. The problem arises when using the same script to checkpoint and pickup (i.e. running the same script over and over): `mode = ""c""` is fine the first run but after that you want `mode = ""a""`. Making the user explicitly select the `mode` will force the user to check if there's a checkpoint to select a mode, which will add boilerplate code like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. mode = checkpointed ? ""a"" : ""c""; ```. Would be nice if `NetCDFOutputWriter` switched to `mode = ""a""` if a file exists (and print a warning).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1160:132,checkpoint,checkpoint,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1160,6,['checkpoint'],"['checkpoint', 'checkpointed', 'checkpoints']"
Availability,CUDA ERROR,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:5,ERROR,ERROR,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['ERROR'],['ERROR']
Availability,CUDA error with immersed boundary when running on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['error'],['error']
Availability,"CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS) when using Lagrangian particles under large CFL number",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,1,['error'],['error']
Availability,CUDA scalar operations error on GPU in `show` functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:23,error,error,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['error'],['error']
Availability,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140:156,checkpoint,checkpointing,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140,3,"['Checkpoint', 'checkpoint']","['Checkpointing', 'checkpoint', 'checkpointing']"
Availability,"Came across a rather cryptic error message that had me puzzled, so I've added this new error message to make sure it doesn't happen to other people.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753:29,error,error,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753,2,['error'],['error']
Availability,"Can we output the super long message that appears on the REPL when running the model to a text file so that the actual *key* error message will not be overwhelmed by the other irrelevant stuff? Something like the default option in MITgcm with the STDOUT/STDERR files. For those who run on a terminal, this is probably fine because they can scroll up (assuming they don't miss it!) but in VScode there's a limit on how much you can output.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363:125,error,error,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363,1,['error'],['error']
Availability,Cannot construct GPU models on PowerPC architectures: `ERROR: cfunction: closures are not supported on this platform`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:55,ERROR,ERROR,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['ERROR'],['ERROR']
Availability,Captures the masking of immersed cells for visualization in #3725. We can use this in https://github.com/CliMA/ClimaOcean.jl/pull/156,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3729:13,mask,masking,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3729,1,['mask'],['masking']
Availability,"Cause stuff like. ```julia; model = HydrostaticFreeSurfaceModel(; grid, coriolis, boundary_conditions = (; u_bcs)); ```. doesn't fail, it just doesn't actually apply boundary conditions to `u` (which was intended here). In the past we've allowed some fairly complex input. So maybe we can just pass a warning when keys of `boundary_conditions` are not prognostic fields. Even more neutral would be error if _none_ of the keys are prognostic fields (which would still catch the issue above but could miss some other annoying typos).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3788:398,error,error,398,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3788,1,['error'],['error']
Availability,"CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:condition, :mask, :dims), Tuple{Array{Bool, 3}, Int64, Tuple{Int64, Int64, Int64}}}}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:654; [3] Reduction(avg::Average, field::Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Array{Bool, 3}, mask::Int64, dims::Function); ```. I imagine fixing it would only take one extra method definition (as suggested by the error message), but I haven't been able to figure it out so far :grimacing:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:6390,mask,mask,6390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,2,"['error', 'mask']","['error', 'mask']"
Availability,Change `TimeInterval` to avoid roundoff error issue plus some cleanup,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3616:40,error,error,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3616,1,['error'],['error']
Availability,Checkpoint at the end of `run!`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1545:0,Checkpoint,Checkpoint,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545,1,['Checkpoint'],['Checkpoint']
Availability,Checkpoint is never created after upgrade (both with Julia 1.5 and 1.6),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547:0,Checkpoint,Checkpoint,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547,1,['Checkpoint'],['Checkpoint']
Availability,Checkpointer bug fixes and improved interface,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer cannot restore when using fields with OffsetArrays.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer cannot serialize functions to disk with JLD.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer does not work for ShallowWaterModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866,1,['Checkpoint'],['Checkpointer']
Availability,"Checkpointer does not work with a ShallowWaterModel; ```julia; using Oceananigans; using Oceananigans.Models: ShallowWaterModel; Lx, Ly, Lz = 2π, 20, 10; Nx, Ny = 128, 128. grid = RectilinearGrid(size = (Nx, Ny),; x = (0, Lx), y = (-Ly/2, Ly/2),; topology = (Periodic, Bounded, Flat)); gravitational_acceleration = 1; coriolis = FPlane(f=1); model = ShallowWaterModel(; grid, coriolis, gravitational_acceleration,; timestepper = :RungeKutta3,; momentum_advection = WENO()); simulation.output_writers[:checkpointer] = Checkpointer(model,; schedule=TimeInterval(5), prefix=""model_checkpoint"",; properties = [:architecture, :grid, :clock, :coriolis, :closure, :velocities, ; :tracers, :timestepper]); ```; Errors with:. ```; ┌ Warning: particles is required for checkpointing. It will be added to checkpointed properties; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/42rFA/src/OutputWriters/checkpointer.jl:78; ERROR: Cannot checkpoint particles, it is not a model property!; ```. This line https://github.com/CliMA/Oceananigans.jl/blob/c568df3d3729cc243de5453d2c60c1b34b8dd2b2/src/OutputWriters/checkpointer.jl#L77 could be modified to:. ```julia; if rp ∉ properties && p ∈ propertynames(model); ```. However I don't know if the thing will look for it when trying to pickup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866,10,"['Checkpoint', 'ERROR', 'Error', 'checkpoint']","['Checkpointer', 'ERROR', 'Errors', 'checkpoint', 'checkpointed', 'checkpointer', 'checkpointing']"
Availability,Checkpointer fails if boundary condition is a CuArray,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/420:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/420,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer needs a previous field,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/375:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/375,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer required properties includes `:architecture` despite it can be inferred from `grid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3463:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3463,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer revival,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer should not use the unstable Serialization package.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/30:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/30,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer that checkpoints the model to a NetCDF files,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoints']"
Availability,Checkpointer warning if properties included make restoring impossible,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/417:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/417,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointer was failing due to an upstream bug in JLD2.jl that has now been fixed: https://github.com/JuliaIO/JLD2.jl/issues/247,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1039:0,Checkpoint,Checkpointer,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1039,1,['Checkpoint'],['Checkpointer']
Availability,Checkpointing docs are stale,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/660:0,Checkpoint,Checkpointing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/660,1,['Checkpoint'],['Checkpointing']
Availability,"Checkpointing, NetCDF, and golden master tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140:0,Checkpoint,Checkpointing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140,1,['Checkpoint'],['Checkpointing']
Availability,Clean up redundant errors in `FieldTimeSeries`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3869:9,redundant,redundant,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3869,2,"['error', 'redundant']","['errors', 'redundant']"
Availability,Clearer Model instantiation error when HAVE_CUDA=false,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:28,error,error,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,1,['error'],['error']
Availability,Clearer error in operation average constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858,1,['error'],['error']
Availability,"Closes #3295. Before this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(; panel_size = (3, 3, 3), z = (-1, 0));. julia> model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); ERROR: UndefVarError: `rotation_from_panel_index` not defined; Stacktrace:; [1] with_halo(new_halo::Tuple{Int64, Int64, Int64}, csg::ConformalCubedSphereGrid{Float64, FullyConnected, ....; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/multi_region_cubed_sphere_grid.jl:431; [2] Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver(grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl:47; [3] build_implicit_step_solver(#unused#::Val{:Default}, grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/unified_implicit_free_surface_solver.jl:67; [4] FreeSurface(free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:95; [5] HydrostaticFreeSurfaceModel(; grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:169; [6] top-level scope; @ REPL[63]:1; ```. With this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(; panel_size = (3, 3, 3), z = (-1, 0));. julia> model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); HydrostaticFreeSurfaceModel{CPU, MultiRegionGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×3 ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 6×6×6 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3296:240,ERROR,ERROR,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3296,1,['ERROR'],['ERROR']
Availability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3637. This PR implements the scale-invariant dynamic Smagorinsky. My main reference for this was [Bou-Zeid et al. (2005)](https://dx.doi.org/10.1063/1.1839152), just because it's nicely summarized there. As a refresher, the coefficient in this case is calculated as. ```math; c_s^2 = \frac{\langle L_{ij} M_{ij}\rangle}{\langle M_{ij} M_{ij} \rangle},; ```; where $M_{ij}$ and $L_{ij}$ are obtained by applying the Germano identity and minimizing the error. $\langle \cdot \rangle$ is an average which usually is implemented as planar averaging. I'm implementing it here with an arbitrary `DirectionalAveraging` procedure that can average in whatever direction the user wants. Following a suggestion by @glwagner in #3637, I'm also starting to put the pieces in place for a more general averaging procedure so that eventually we can add Lagrangian averaging as an option for this model. Note that this PR is related to https://github.com/CliMA/Oceananigans.jl/pull/3638. The rationale for having this PR in addition to #3638 is that for most LES are doubly periodic, in which case there's not much advantage in having the Lagrangian averaging that's implemented in #3638. In these cases I'd argue the model implemented here is more efficient, so having both types of models is probably desirable. Another note is that, once this PR is merged, it should be very straightforward to implement a scale-_dependent_ version, which works better close to boundaries. The model seems to be working. Here's an animation of an unforced 3D turbulence simulation on a 32³ grid. Left is vorticity and right is the strain rate modulus squared:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/7131a99d-df6c-4883-850d-d4a87988cdb7. Note that the value of the calculated Smag coefficient $c_s$ (which I'm showing at the top of the plots above) is about 0.17, which is very close to the theoretical value obtained by Lilly of 0.16. I'm opening this as a d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642:506,error,error,506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642,1,['error'],['error']
Availability,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881:821,down,down,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881,1,['down'],['down']
Availability,"Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CUDA.CuDeviceArray{Float64, 4, 1}, ::Oceananigans.AbstractOperations.Condition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:2821,error,error,2821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['error'],['error']
Availability,"Column Hydrostatic models don't have a free surface and, therefore, produce an error here:; https://github.com/CliMA/Oceananigans.jl/blob/ce461f90e991a85105962e165ca4ceab15b1159a/src/Models/HydrostaticFreeSurfaceModels/show_hydrostatic_free_surface_model.jl#L13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2210:79,error,error,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2210,1,['error'],['error']
Availability,Compute third stage time-step for RK3 in a way that reduces the accumulation of error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3617:80,error,error,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3617,1,['error'],['error']
Availability,Construct grid parameters with `BigFloat` to avoid round-off error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499:61,error,error,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499,1,['error'],['error']
Availability,"Contributors,. We are planning to re-license Oceananigans under the [Apache License 2.0](https://www.apache.org/licenses/LICENSE-2.0), as required by the primary sponsors of the Climate Modeling Alliance, [Schmidt Sciences](https://www.schmidtsciences.org/). Practically speaking, [the two licenses are similarly permissive and open](https://soos.io/apache-vs-mit-license). However, the Apache license adds some additional protection for contributors (like yourselves) by, for example, requiring downstream applications that depend on Oceananigans to disclose major changes. Let us know if there are any concerns. Otherwise, we plan to make the change on August 19. The top 20 outside contributors are tagged here:. @ali-ramadhan ; @tomchor ; @francispoulin ; @hennyg888 ; @elise-palethorpe ; @whitleyv ; @suyashbire1 ; @jagoosw ; @vchuravy ; @xiaozhour ; @maeckha ; @iuryt ; @kburns ; @jbisits ; @maleadt ; @wsmoses ; @Moelf ; @RaphaelRR ; @simonbyrne ; @josuemtzmo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3708:496,down,downstream,496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3708,1,['down'],['downstream']
Availability,Convenience function: `checkpoint(simulation)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1249:23,checkpoint,checkpoint,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249,1,['checkpoint'],['checkpoint']
Availability,Correct error message in `validate_lat_lon_grid_args`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3887:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3887,1,['error'],['error']
Availability,Cosmetic improvement to checkpointer docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2531:24,checkpoint,checkpointer,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2531,1,['checkpoint'],['checkpointer']
Availability,"Currently I can't operate on a reduction using `AbstractOperation`s:. ```julia; julia> using Oceananigans;. julia> grid = RectilinearGrid(size=(4,4,4,), extent=(1,1,1));. julia> model = NonhydrostaticModel(grid = grid);. julia> Average(model.velocities.u)/2; ERROR: MethodError: no method matching /(::Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Tuple{Int64, Int64, Int64}}, ::Int64); Closest candidates are:; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Number, ::Oceananigans.AbstractOperations.BinaryOperation) at /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/AbstractOperations/binary_operations.jl:88; /(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractGrid, ::Any, ::Any, ::Oceananigans.AbstractOperations.BinaryOperation, ::Number) at /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/A",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2856:259,ERROR,ERROR,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2856,1,['ERROR'],['ERROR']
Availability,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2845:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1063:864,redundant,redundantly,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063,1,['redundant'],['redundantly']
Availability,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:35,checkpoint,checkpoint,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,6,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint', 'checkpointer']"
Availability,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131:365,error,errors,365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"Currently the `JLD2OutputWriter` labels output in a timeseries by `model.clock.iteration`. It might be easier to handle output if data is labeled by ""save point"", so it goes 0, 1, 2... This is easier to work with at the REPL, since you always know, for example, that `file[""timeseries/u/1""]` exists (rather than having to manually inspect the file to figure out the iterations that data ended up being saved at). We can add a field `iteration` so that the model iteration can be recovered, if that's needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/963:479,recover,recovered,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963,1,['recover'],['recovered']
Availability,"Currently the user may pass `diffusivity_fields` into model constructors, but `Oceananigans.TurbulantClosures.DiffusivityFields` resets these to the value of `validate_field_tuple_grid` which nominally is `nothing`. I have changed this to return the field values if `validate_field_tuple_grid` does not error instead. E.g. ```julia. using Oceananigans; using Oceananigans.TurbulenceClosures: DiffusivityFields. grid = RectilinearGrid(size = (64, 64, 16), extent = (150, 150, 10)). tracers = (:T, :S). closure = AnisotropicMinimumDissipation(). diffusivity_fields = diffusivity_fields = DiffusivityFields(grid, tracers, NamedTuple(), closure). model = NonhydrostaticModel(; grid,; tracers,; closure,; diffusivity_fields); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3367:303,error,error,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3367,1,['error'],['error']
Availability,"Currently we use a convention for fields wherein the ""halo points"" of a field stored on faces actually includes locations that are on the boundary of our domain. Is this strange? What I am saying, in other words, is that for the field `u = Field{Face, Cell, Cell}(arch, grid)`, the point. ```julia; u[grid.Nx+1, 1, 1]; ```. is defined as a ""halo point"", even though it is located *on* the right `x` boundary (it is inside the physical domain, not outside it). I think this is potentially odd and we should *consider* adopting the convention that `Face` fields include their boundary points by default. This would not change the algorithm; it only changes the user API. The reason why I recommend considering / discussing this change rather than immediately adopting it is because there are some downsides. One is a slight increase in memory allocation that is not needed. This is minor for large 3D problems but could be annoying for small 1D or 2D problems with ""flat"" dimensions. This last problem can potentially be solved by invoking special behavior for the ""flat"" dimensions of a grid (see #330).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/455:795,down,downsides,795,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/455,1,['down'],['downsides']
Availability,"Currently, `IncompressibleModel` keeps a reference to `TimeStepper`:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/Models/incompressible_model.jl#L33. This means that every model has one time stepper, and we use `time_step!(model, dt)` to advance a model forward. Yet this is not a necessary entanglement. A perfectly valid time-stepping loop is. ```julia; for i = 1:100; time_step!(model, forward_euler_stepper, dt); time_step!(model, rk3_stepper, dt); end; ```. (obviously we don't have a forward Euler time-stepper, which is a separate issue, but hopefully the point is made.). We can disentangle the timestepper from model by moving the timestepper reference over to `Simulation`. This would also clean up the interface since we wouldn't need to use symbols to specify the time-stepping method (#1119, this might be a hint that we're on the right track...). ```julia; model = IncompressibleModel(...); simulation = Simulation(model, RungeKutta3TimeStepper(model), kwargs...); ```. I think there's a conceptual advantage to this too. `Simulation`s manage the creation of a time-series, while a `Model` is more the idealization of a discrete physical system at a particular moment in time. To make this change, we first have to checkpoint `Simulation`s rather than `Model`s to support time-steppers that require history like AB2. I think this is something we need anyways. This is a major API change, though it could be mitigated if we put a default into the `Simulation` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1175:1276,checkpoint,checkpoint,1276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175,1,['checkpoint'],['checkpoint']
Availability,Cut down the examples. Moved stuff into a sandbox.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/230:4,down,down,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/230,1,['down'],['down']
Availability,"Dear Oceananigans developers,; I want to run an example on a HPC server where GPU nodes have no network access. Is it possible to force downloads on the frontend even if GPU is not available ?; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1035:136,down,downloads,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035,2,"['avail', 'down']","['available', 'downloads']"
Availability,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981:323,error,error,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an example, if `reduced_dim=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2105:2186,toler,tolerance,2186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105,1,['toler'],['tolerance']
Availability,"Distinguish between ""masking"" and ""enforcing impenetrability"" in immersed boundary routines",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249:21,mask,masking,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249,1,['mask'],['masking']
Availability,Do we want to be able to compute Available Potential Energy (APE) to get an idea as to the energtics of a flow?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1297:33,Avail,Available,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297,1,['Avail'],['Available']
Availability,"Do we want to update the one and two dimensional examples to include `Flat`? . If not then we can ignore this PR. . If yes, then this is my attempt to do so. The good news is that most of the one and two dimensional examples work very easily. Unfortunately, a couple of them, geostrophic adjustment and convecting plankton, do not. I don't know why at the moment and these should certainly be fixed before a merge happens. If it happens. The error get I get is `NaN` after (I believe) the first interval. So I suspect one of the tendencies is not being computed correctly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513:442,error,error,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513,1,['error'],['error']
Availability,Downbump to 0.71.4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2279:0,Down,Downbump,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2279,1,['Down'],['Downbump']
Availability,EGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_solver.jl:134; + [inlined]; Oceananigans.Models.NonhydrostaticModels; + calculate_pressure_correction! ~/.julia/packages/Oceananigans/mwXt0/src/Models/NonhydrostaticModels/pressure_correction.jl:15; > Oceananigans.TimeSteppers; v + #time_step!#8 ~/.julia/packages/Oceananigans/mwXt0/src/TimeSteppers/runge_kutta_3.jl:138; Oceananigans.Simulations; + time_step! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:134; + #run!#7 ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:97; + run! ~/.julia/packages/Oceananigans/mwXt0/src/Simulations/run.jl:85; + [top-level]; (system); ```; I can't get the whole error message because its longer than the screen length but this seems to be the relevant bit when using InteractiveErrors. . If I make the grid smaller it gets more iterations done before it errors but is nowhere near using all of the GPUs memory (A100 with 80GB and model is about 2GB when 256x256x64). This is with the latest version of Oceananigans (87.4). I'll try to make an MWE.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:3769,error,error,3769,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,2,['error'],"['error', 'errors']"
Availability,ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/686:0,ERROR,ERROR,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686,1,['ERROR'],['ERROR']
Availability,ERROR: MethodError: no method matching initarray! on Julia v1.8.0-rc1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663:0,ERROR,ERROR,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663,1,['ERROR'],['ERROR']
Availability,ERROR: Unsatisfiable requirements detected for package CuArrays,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:0,ERROR,ERROR,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['ERROR'],['ERROR']
Availability,ERROR: importing Flux into Main conflicts with an existing identifier,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1285:0,ERROR,ERROR,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285,1,['ERROR'],['ERROR']
Availability,"ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_5Az___E9identity1S30_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLG",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:4333,error,errors,4333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['error'],['errors']
Availability,"Easy mistake to make if you're new to Julia or unfamiliar with the package. Would be easy to do some input validation and throw an informative error. Examples:. Should be `CPU()` instead of `CPU` here:; ```julia; julia> model = Model(architecture=CPU, grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)));. ERROR: MethodError: no method matching Field(::Tuple{DataType,DataType,DataType}, ::Type{CPU}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}); Closest candidates are:; Field(::Any, ::Any, ::Any, ::Any, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:50; Field(::Tuple, ::Oceananigans.AbstractArchitecture, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:32; Field(::Tuple, ::AbstractArray, ::Any) at /home/alir/Oceananigans.jl/src/fields.jl:42; Stacktrace:; [1] Field(::Type, ::Type, ::Type, ::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:50; [2] Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465:143,error,error,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Easy to get burned by accidentally applying e.g. no-slip boundary conditions along a periodic dimension (mixing up `east` and `north`). Oceananigans should probably print a warning or error if you apply inconsistent boundary conditions. Definitely occurred to me multiple times (and recently encountered by @whitleyv too).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1177:184,error,error,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1177,1,['error'],['error']
Availability,"Eg for. ```julia; julia> κ; BinaryOperation at (Center, Center, Center); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; └── tree:; + at (Center, Center, Center);    ├── 1.0e-5;    └── / at (Center, Center, Center);       ├── 0.01;       └── + at (Center, Center, Center);          ├── 1;          └── * at (Center, Center, Center);             ├── 5;             └── ^ at (Center, Center, Center);                ├── 1×1×128 Field{Center, Center, Center} on RectilinearGrid on CPU;                └── 3; ```. we get. ```julia; julia> closure = ScalarDiffusivity(; κ); ScalarDiffusivity{ExplicitTimeDiscretization}(ν=0.0, κ=BinaryOperation at (Center, Center, Center)). julia> model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer()); ERROR: MethodError: no method matching tracer_diffusivities(::Tuple{Symbol}, ::BinaryOperation{Center, Center, Center, typeof(+); ```. It looks like `tracer_diffusivities` is being used to catch invalid diffusivity fields cause. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/TurbulenceClosures/turbulence_closure_utils.jl#L3. But it's kinda silly cause. ```julia; julia> closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). julia> model = HydrostaticFreeSurfaceModel(; grid, closure, tracers=:b, buoyancy=BuoyancyTracer()); ```. works just fine. So we should either. 1. Include `AbstractArray` in objects supported by `tracer_diffusivities`, and throw a useful error as a fallback rather than going to `MethodError`; 2. Relax https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/TurbulenceClosures/turbulence_closure_utils.jl#L3 to a fallback so it works for any object",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2342:810,ERROR,ERROR,810,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2342,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Egregious errors in `NonhydrostaticModel` simulations on `ImmersedBoundaryGrid` when nonhydrostatic pressure is not separated,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677:10,error,errors,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677,1,['error'],['errors']
Availability,"Encountered this pretty weird error where `compute!(::AveragedField)` fails when the grid is larger than 22^3. Not sure what's causing it but last thing on the stacktrace in Oceananigans.jl is `sum!` in `mapreduce_abstract_fields.jl` so maybe something changed with `CUDA.mapreducedim!` in v3?. Putting the _high priority_ tag on this issue since it breaks LESbrary.jl pretty badly and I expect other people's scripts too... ```julia; using Oceananigans. # grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)) # OK; # grid = RegularRectilinearGrid(size=(22, 22, 22), extent=(1, 1, 1)) # OK; # grid = RegularRectilinearGrid(size=(23, 23, 23), extent=(1, 1, 1)) # NOT OK; grid = RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1)) # NOT OK. model = IncompressibleModel(grid=grid, architecture=GPU()). U = AveragedField(model.velocities.u, dims=(1, 2)); compute!(U); ```. ```; ERROR: MethodError: Cannot `convert` an object of type CUDA.CuDeviceArray{Float64, 4, 1} to an object of type Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}} ; Closest candidates are:; convert(::Type{T}, ::LinearAlgebra.Factorization) where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58; convert(::Type{T}, ::T) where T<:AbstractArray at abstractarray.jl:14; convert(::Type{T}, ::T) where T at essentials.jl:205; ...; Stacktrace:; [1] cconvert(T::Type, x::CUDA.CuDeviceArray{Float64, 4, 1}); @ Base ./essentials.jl:396; [2] macro expansion; @ ~/.julia/packages/CUDA/3VnCC/lib/cudadrv/execution.jl:83 [inlined]; [3] convert_arguments(::CUDA.var""#32#33""{Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:threads, :blocks, :shmem), Tuple{Int64, Int64, I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:30,error,error,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Enhance Checkpointer + TendencyCallsite callback example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3461:8,Checkpoint,Checkpointer,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3461,1,['Checkpoint'],['Checkpointer']
Availability,Enhances docstring for the `ImplicitFreeSurface` constructor to include the available solver methods. Closes #2620,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2621:76,avail,available,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2621,1,['avail'],['available']
Availability,"Error for `maximum(::Field{Face, Center, Center})` on GPU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['Error'],['Error']
Availability,Error from benchmark/test distributed nonhydrostatic model scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,1,['Error'],['Error']
Availability,Error if expected input is not a NamedTuple,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1206:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1206,1,['Error'],['Error']
Availability,Error if using too low julia version?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2142:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2142,1,['Error'],['Error']
Availability,Error in AveragedTimeInterval Output,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,1,['Error'],['Error']
Availability,Error in ConjugateGradientPoissonSolver for nonuniform grids,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3889:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3889,1,['Error'],['Error']
Availability,Error in `num_prod`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2747:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2747,1,['Error'],['Error']
Availability,Error in `visualize_barotropic_gyre.jl` in validation exps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,1,['Error'],['Error']
Availability,Error in free surface build for `HydrostaticFreeSurfaceModels` on a `ConformalCubedSphereGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3295:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3295,1,['Error'],['Error']
Availability,Error in update,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1468:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468,1,['Error'],['Error']
Availability,Error interpolating on an irregularly spaced grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2911:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2911,1,['Error'],['Error']
Availability,Error on invalid time interval + time window combinations for AveragedTimeInterval,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1288:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1288,1,['Error'],['Error']
Availability,Error only while debugging in VSCode,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171,1,['Error'],['Error']
Availability,Error related to conjugate gradient Poisson solver when setting initial condition,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896,1,['Error'],['Error']
Availability,Error running on GPUs using `CUDA>=3.10`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['Error'],['Error']
Availability,Error setting `boundary_conditions` for `Field`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2837:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2837,1,['Error'],['Error']
Availability,Error showing value of type IncompressibleModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/707:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707,1,['Error'],['Error']
Availability,Error tagging new release,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/87:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/87,2,['Error'],['Error']
Availability,Error using HorizontalScalarBiharmonicDiffusivity with VerticalScalarDiffusivity on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2591:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2591,1,['Error'],['Error']
Availability,Error using `ScalarDiffusivity` where the viscosity or diffusivity are functions with parameters,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840,1,['Error'],['Error']
Availability,Error using closure tuples with CATKEVerticalDiffusivity,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3804:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804,1,['Error'],['Error']
Availability,Error using immersed boundary on GPUs with buoyancy tracer,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558,1,['Error'],['Error']
Availability,Error when attempting to plot results in langmuir_example.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/787:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/787,1,['Error'],['Error']
Availability,Error when constructing a `NetCDFOutputWriter` with an immersed lat-lon grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775,1,['Error'],['Error']
Availability,Error when setting GPU field using CuArray,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/634:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/634,1,['Error'],['Error']
Availability,Error when trying the hot bubble with GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451,1,['Error'],['Error']
Availability,Error when trying to diagnose `Average` of an abstract operation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/857:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/857,1,['Error'],['Error']
Availability,Error when trying to use `MultipleForcings`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3736:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736,1,['Error'],['Error']
Availability,Error when using `ImmersedBoundaryGrid` with `HydrostaticModel` and drag boundary condition,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711,1,['Error'],['Error']
Availability,Error when using `OpenBoundaryCondition` with `HydrostaticFreeSurfaceModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628,1,['Error'],['Error']
Availability,Error when writing `Field`s reduced over 3 dimensions to NetCDF,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['Error'],['Error']
Availability,Error while implementing Vertical stretched grid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571,1,['Error'],['Error']
Availability,Error while using `ImmersedBoundaries` on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367,1,['Error'],['Error']
Availability,"Error with NetCDF output - Julia v1.5, Oceananigans v0.34.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/862:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862,1,['Error'],['Error']
Availability,Error with default `HydrostaticFreeSurfaceModel` on `TripolarGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806:0,Error,Error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806,1,['Error'],['Error']
Availability,Errors in the output writers docs page,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2427:0,Error,Errors,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2427,1,['Error'],['Errors']
Availability,Example/tutorial on checkpointing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1136:20,checkpoint,checkpointing,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1136,1,['checkpoint'],['checkpointing']
Availability,"FFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:76931,Error,Error,76931,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Error'],['Error']
Availability,"FTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:38063,Error,Error,38063,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['Error'],['Error']
Availability,"First attempt at this. Still wasn't able to make sure the code in the example works. In fact, so far it has failed:. ```julia; julia> using Oceananigans.Operators. julia> using Oceananigans.Grids. julia> function isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, ν); Σˣˣ² = ∂xᶜᵃᵃ(i, j, k, grid, u)^2; Σʸʸ² = ∂yᵃᶜᵃ(i, j, k, grid, v)^2; Σᶻᶻ² = ∂zᵃᵃᶜ(i, j, k, grid, w)^2. Σˣʸ² = ℑxyᶜᶜᵃ(i, j, k, grid, fψ_plus_gφ², ∂yᵃᶠᵃ, u, ∂xᶠᵃᵃ, v) / 4; Σˣᶻ² = ℑxzᶜᵃᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, u, ∂xᶠᵃᵃ, w) / 4; Σʸᶻ² = ℑyzᵃᶜᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, v, ∂yᵃᶠᵃ, w) / 4. ϵ[i, j, k] = ν[i, j, k] * 2 * (Σˣˣ² + Σʸʸ² + Σᶻᶻ² + 2 * (Σˣʸ² + Σˣᶻ² + Σʸᶻ²)); end; isotropic_viscous_dissipation_rate_ccc (generic function with 1 method). julia> ε = KernelFunctionOperation(Center, Center, Center, isotropic_viscous_dissipation_rate_ccc, grid;; computed_dependencies=(u, v, w, ν)); ERROR: MethodError: no method matching KernelFunctionOperation(::Type{Center}, ::Type{Center}, ::Type{Center}, ::typeof(isotropic_viscous_dissipation_rate_ccc), ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}; computed_dependencies=(Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), Field located at (Center, Center, Face); ├── data: OffsetArra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1758:883,ERROR,ERROR,883,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1758,1,['ERROR'],['ERROR']
Availability,"First of all, thank god this model runs on GPU. It is awesome how fast this is!!. I am trying to run the the model using the following function for `ScalarDiffusivity`:; ```; width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; ```; which returns the error below while running the model. ```; ┌ Warning: Cannot save Function property into closure/2/ν; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Warning: Cannot save Function property into closure/2/κ/b; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (27.506 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 4000, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 16, 50)}, KernelAbstractions.NDIteration.StaticSize{(1, 256, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:317,error,error,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['error'],['error']
Availability,Fix minor error in `internal_wave.jl`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2500:10,error,error,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2500,1,['error'],['error']
Availability,Fixes bug in error for `validate_index`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2824:13,error,error,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824,1,['error'],['error']
Availability,Fixes checkpointer GPU to CPU loading and writing fields with function boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797:6,checkpoint,checkpointer,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797,1,['checkpoint'],['checkpointer']
Availability,Fixes error when reducing `Fields` with a `condition` on `ImmersedBoundaryGrids`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3440:6,error,error,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3440,1,['error'],['error']
Availability,Fixes interpolation error in centered fourth order tracer advection,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/935:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/935,1,['error'],['error']
Availability,Fixes off-by-one indexing error in hydrostatic pressure integrat…,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612:26,error,error,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612,1,['error'],['error']
Availability,Fixes sign error in HydrostaticSphericalCoriolis!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1439:11,error,error,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1439,1,['error'],['error']
Availability,Fixes sign error in flux divergence of `AnisotropicBiharmonicDiffusivity`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1703:11,error,error,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1703,1,['error'],['error']
Availability,Fixes strange error in ocean wind mixing and convection examples,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/748:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/748,1,['error'],['error']
Availability,"Fixing an error in the quick start code: set!(model, u=\epsilon, v=\epsilon) fails if the function \epsilon only has two arguments. Code runs if a third argument is added to the \epsilon definition.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3551:10,error,error,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3551,1,['error'],['error']
Availability,"Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/AbstractOperations/conditional_operations.jl:96; condition_operand(func::Function, op::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, cond, mask); @ Oceananigans.ImmersedBoundaries /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/ImmersedBoundaries/immersed_reductions.jl:18. Possible fix, define; condition_operand(::Function, ::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, ::AbstractArray, ::Any). Stacktrace:; [1] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetM",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:2565,mask,mask,2565,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['mask'],['mask']
Availability,"Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:198. [21] (::Core.var""#Type##kw"")(::NamedTuple{(:grid, :advection), Tuple{RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}}}, ::Type{NonhydrostaticModel}); @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:107; [22] top-level scope; @ ~/ocean_ex_1.jl:10; ```. I'm trying to step through the code to understand the code better, but I'm not able to figure out why I only get this error when I insert breakpoints. I'd greatly appreciate any help understanding this better, thank you",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171:3596,error,error,3596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171,1,['error'],['error']
Availability,Flux.jl is a pretty popular package. It seems Oceananigans conflicts with it.; If I do `using Flux` I get:; ```; ERROR: importing Flux into Main conflicts with an existing identifier; ```; Is there any way to import both?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1285:113,ERROR,ERROR,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285,1,['ERROR'],['ERROR']
Availability,Following a discussion with @glwagner I have tried to use the Immersed Boundary Method for `ShallowWaterModel`. I have not succeeded yet but hope we can have a fruitful discussison here to fix my error. . Can someone help me figure out what I'm doing wrong?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663:196,error,error,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663,1,['error'],['error']
Availability,"Following up from https://github.com/climate-machine/Oceananigans.jl/issues/73 it would be nice if the forcing can be also be expressed as an array. This might be nice for a couple of applications:; 1. A forcing that is constant and very expensive to compute (e.g. lots of calculations, branching statements, or intermediate calculations).; 2. Forcing array can be passed around and filled elsewhere, e.g. by a biogeochemical agent-based model. Pinging: @zhenwu0728",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110:445,Ping,Pinging,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110,1,['Ping'],['Pinging']
Availability,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:260,down,down,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['down'],['down']
Availability,"For example, this line:. ```julia; model.output_writers[:checkpointer] = Checkpointer(model; interval=1e6, prefix=""model_checkpoint""); ```. fails because `model` does not have a field `output_writers`. We need to use a `Simulation` here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/660:57,checkpoint,checkpointer,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/660,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointer']"
Availability,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1045:251,error,error,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045,1,['error'],['error']
Availability,"For example,. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. errors with. ```julia; julia> include(""problem.jl""); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/OHYQj/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:223; ERROR: LoadError: ArgumentError: halo must be ≤ size for coordinate y; ```. Sad, because I didn't actually ask for a halo (3, 3, 3)! Manually setting things doesn't help:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. I guess the restriction on the halo size is supposed to be an optimization, but its not working in this case because I can't even set up my model. @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3622:239,error,errors,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"For example. ```julia; using Oceananigans; using OrthogonalSphericalShellGrids; using Oceananigans.Fields: interpolate!. trg = TripolarGrid(size = (10, 10, 10), z = (0, 1)); llg = LatitudeLongitudeGrid(size = (10, 10, 10), latitude = (-75, 75), longitude = (0, 360), z = (0, 1)). ctrg = CenterField(trg); cllg = CenterField(llg). interpolate!(cllg, ctrg); ```. fails with. ```julia; julia> interpolate!(cllg, ctrg); ERROR: MethodError: no method matching fractional_x_index(::Float64, ::Tuple{…}, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}). Closest candidates are:; fractional_x_index(::Any, ::Any, ::ImmersedBoundaryGrid); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/ImmersedBoundaries/ImmersedBoundaries.jl:283; fractional_x_index(::Any, ::Any, ::Oceananigans.Grids.XRegularLLG); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:74; fractional_x_index(::Any, ::Any, ::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:89; ... Stacktrace:; [1] _fractional_indices; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:165 [inlined]; [2] fractional_indices; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:154 [inlined]; [3] interpolate; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:240 [inlined]; [4] macro expansion; @ ~/.julia/packages/Oceananigans/A6YUV/src/Fields/interpolate.jl:337 [inlined]; [5] cpu__interpolate!; @ ~/.julia/packages/KernelAbstractions/3B1v2/src/macros.jl:291 [inlined]; [6] cpu__interpolate!(__ctx__::KernelAbstractions.CompilerMetadata{…}, to_field::Field{…}, to_grid::LatitudeLongitudeGrid{…}, to_location::Tuple{…}, from_field::Field{…}, from_grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}, from_location::Tuple{…}); @ Oceananigans.Fields ./none:0; [7] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3745:416,ERROR,ERROR,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3745,1,['ERROR'],['ERROR']
Availability,"For example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> b = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> f = 1; 1. julia> vz_op = @at (Face, Center, Center) - ∂x(b) / f; ERROR: LoadError: MethodError: no method matching var""@at""(::LineNumberNode, ::Module, ::Expr); Closest candidates are:; var""@at""(::LineNumberNode, ::Module, ::Any, ::Any) at /Users/gregorywagner/Projects/Oceananigans.jl/src/AbstractOperations/at.jl:42; in expression starting at REPL[16]:1; ```. Found with @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415:950,ERROR,ERROR,950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415,1,['ERROR'],['ERROR']
Availability,"For example:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(3, 3, 3), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:476,ERROR,ERROR,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,For example:; https://buildkite.com/clima/oceananigans/builds/17468#0191fc2c-b421-4cf7-80b5-0429336b1d7f; https://buildkite.com/clima/oceananigans/builds/17473#0191fd88-d8b9-48d5-9c7f-18efc6747ea7; I believe this is because we are launching the docs from many different branches on a relatively small GPU. I think it would be best to move this test on the caltech cluster. Since the caltech cluster works with a slurm scheduler this error would never happen (I can open a PR to fix this),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779:433,error,error,433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779,1,['error'],['error']
Availability,"For now the 10 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". Maybe we just have to define `convert` for Fields with OffsetArrays?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:181,checkpoint,checkpointing,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,5,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointing']"
Availability,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:238,error,error,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"For some cases, we _want_ these two parameters to be different (eg to ""slow down"" the free surface wave speed by using reduced gravity). But it might be friendly to some unsuspecting users to throw a warning in the constructor for `HydrostaticFreeSurfaceModel`, just in case this was not intended. cc @simonbyrne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2148:76,down,down,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2148,1,['down'],['down']
Availability,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030:423,error,error,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030,1,['error'],['error']
Availability,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:46,error,errors,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,5,"['ERROR', 'error']","['ERROR', 'error', 'errors']"
Availability,"Forgot to use dynamic launch configs for the `calculate_G*` kernels. But, hmmm, this actually slows things down a bit... ```; ─────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 247s / 29.9% 14.9GiB / 0.56% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 34.0s 46.1% 3.40s 292KiB 0.34% 29.2KiB; 256×256×256 (CPU, Float32) 10 30.5s 41.4% 3.05s 227KiB 0.26% 22.7KiB; 128×128×128 (CPU, Float64) 10 3.94s 5.35% 394ms 292KiB 0.34% 29.2KiB; 128×128×128 (CPU, Float32) 10 3.54s 4.80% 354ms 227KiB 0.26% 22.7KiB; 64× 64× 64 (CPU, Float64) 10 417ms 0.57% 41.7ms 292KiB 0.34% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 406ms 0.55% 40.6ms 227KiB 0.26% 22.7KiB; 256×256×256 (GPU, Float64) 10 337ms 0.46% 33.7ms 11.0MiB 13.0% 1.10MiB; 256×256×256 (GPU, Float32) 10 254ms 0.34% 25.4ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (CPU, Float64) 10 52.6ms 0.07% 5.26ms 292KiB 0.34% 29.2KiB; 128×128×128 (GPU, Float64) 10 47.3ms 0.06% 4.73ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (CPU, Float32) 10 46.9ms 0.06% 4.69ms 227KiB 0.26% 22.7KiB; 128×128×128 (GPU, Float32) 10 36.4ms 0.05% 3.64ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (GPU, Float64) 10 26.6ms 0.04% 2.66ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (GPU, Float32) 10 24.6ms 0.03% 2.46ms 9.61MiB 11.4% 0.96MiB; 64× 64× 64 (GPU, Float64) 10 24.6ms 0.03% 2.46ms 11.0MiB 13.0% 1.10MiB; 64× 64× 64 (GPU, Float32) 10 22.6ms 0.03% 2.26ms 9.62MiB 11.4% 0.96MiB; ─────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedup:; 32× 32× 32: 1.122; 64× 64× 64: 1.027; 128×128×128: 1.114; 256×256×256: 1.114. GPU Float64 -> Float32 speedup:; 32× 32× 32: 1.081; 64× 64× 64: 1.086; 128×128×128: 1.301; 256×256×256: 1.326. CPU -> GPU speedup:; 32× 32× 32 (Float32): 1.903; 32×",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/308:107,down,down,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/308,1,['down'],['down']
Availability,From the test log; ```; WARNING: using CUDAdrv.device in module TimeSteppers conflicts with an existing identifier.; ```. Was also responsible for test failures on PR #559. Another reason to prefer `import` over `using`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/563:152,failure,failures,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/563,1,['failure'],['failures']
Availability,Further increase tolerance in implicit free surface solver tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1689:17,toler,tolerance,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1689,1,['toler'],['tolerance']
Availability,"GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1757,error,error,1757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/851:348,error,error,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851,1,['error'],['error']
Availability,"Greetings everyone,; I was recently started writing my outputs into a NetCDF file. Now I realize that I have to use checkpointer that can checkpoint the model to a NetCDF files, But I haven't found any method. There is for JLD2 files. So can you please look into this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1929:116,checkpoint,checkpointer,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929,2,['checkpoint'],"['checkpoint', 'checkpointer']"
Availability,"Grid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 10×10×10 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> bcs = FieldBoundaryConditions(grid, (Center, Center, Face); top=GradientBoundaryCondition(1), bottom=GradientBoundaryCondition(1)); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: PeriodicBoundaryCondition; ├── east: PeriodicBoundaryCondition; ├── south: PeriodicBoundaryCondition; ├── north: PeriodicBoundaryCondition; ├── bottom: GradientBoundaryCondition: 1; ├── top: GradientBoundaryCondition: 1; └── immersed: FluxBoundaryCondition: Nothing. julia> b_z = Field(∂z(b), boundary_conditions=bcs); ERROR: ArgumentError: Cannot specify bottom boundary condition GradientBoundaryCondition: 1 on a field at Face()!; Stacktrace:; [1] validate_boundary_condition_location(bc::BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Int64}, loc::Face, side::Symbol); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/Ey1oO/src/Fields/field.jl:52; [2] validate_boundary_conditions(loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, bcs::FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryConditi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2837:1776,ERROR,ERROR,1776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2837,1,['ERROR'],['ERROR']
Availability,"Happens with Julia 1.6.7 and 1.8.1 with Oceananigans v0.77.5. Not sure if this is connected to #2530 or #2709 although this errors on the CPU. ~Minimal~ working example:. ```julia; using Oceananigans. topo = (Bounded, Bounded, Bounded); domain = (x=(-1, 1), y=(-1, 1), z=(-1, 0)); grid = RectilinearGrid(CPU(); topology=topo, size=(8, 8, 8), domain...). v_bcs = FieldBoundaryConditions(grid,; east = ValueBoundaryCondition(0),; west = ValueBoundaryCondition(0); ). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(constant_salinity=true),; tracers = :T,; boundary_conditions = (v=v_bcs,); ); ```. Stacktrace from Julia 1.8.1: https://gist.github.com/ali-ramadhan/e45cc2d447f2ece001b4f2d9295b36b1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2768:124,error,errors,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2768,1,['error'],['errors']
Availability,"Hello everyone,; I am facing some difficulty in running this code. This doesn't show any error and generates an output JLD2 file and then seemed to freeze. No sign appears. It even doesn't write any output in the file. From the system point of view, I can see that Julia correctly recognizes GPUs as being am_70 type and compiles some code for them. Then it starts to execute the following statement:. ```run!(simulation)```. That statement is running for some time and get freezes. Can you please run it in your system, I want to check whether it is the code or my system creating this strange behaviour. . ```; using Printf; # using Pkg; # pkg""add Oceananigans#ali/unclog-docs""; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units: minute, minutes, hour; using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval; using Statistics; using CUDA. #number of grid spacing in south,north and vertical direction and in oceananigans ; #they call this as the size of one grid in that direction; const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. #Vetrical temperature gradient; const dTz = 70. #scaled gravitational acceleration; const g=300. const R0=1; const T0=30; const Factor_T =1e-6; const Factor_V=1e-8. Name_of_simulation = ""ocean_convection_Fplane_GPU"". #Coefficient of Thermal expansion; const alpha= 2e-4; #Coefficient of Salinity; const saline=0; #diffusive viscocity; const v=1e-5 ; #diffusivity; const k=2e-6 . const l=Lx/2 #center of gaussian field; const m=Ly/2 #center of gausian field. const Bo=3.6e-4 #maximum surface flux; const f=-0.5 #coriolis parameter. computational_grid = RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz)); show(computational_grid). ##xC,yC,zC are not defined for vertically stretched grid; # computational_grid.zᵃᵃᶜ; # computational_grid.xᶜᵃᵃ; # computational_gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:89,error,error,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['error'],['error']
Availability,"Hello! I am new to Julia, Oceananigans, and computational fluid dynamics, so please forgive me if I missed something obvious or made a trivial mistake. As a first exercise with Oceananigans I am trying to simulate some high salinity, low temperature water above low salinity, high temperature water (with a bit of random noise), with a small initial westward velocity component and a 10 second time step. The documentation was quite helpful (thanks for that), and the simulation works as expected until about t=50s, when small water parcels at the density interface heat up or cool down to unnatural levels (see attached gifs at bottom), and occasionally the entire temperature matrix fills with NaN's. I've tried removing all my boundary conditions to see if they were the problem, but the issue persisted. For reference, I am using Julia v1.5 with Oceananigans 0.44.1, with this platform:; OS: macOS (x86_64-apple-darwin18.7.0); CPU: Intel(R) Core(TM) i5-6360U CPU @ 2.00GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake). And here is a minimal example, along with code to gif-ify the output. Lowering the timestep down to 1 second from the current 10 seconds also does not fix anything. Also using a time step wizard with initial del_t at 1 second and cfl=0.3 still generates unrealistic temperatures; however, it then seems to freeze before converting entirely to NaN's and would not progress given an extra (real-life) hour to run compared to the fixed timestep. ```; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=Anisotropi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190:582,down,down,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190,1,['down'],['down']
Availability,"Hello, . I've worked implementing this automatic concatenation for the output, when a simulation is picked up from a checkpoint, with the flag splitting_files on. This feature addresses the fact that otherwise the simulation output filename needs to be changed manually each time the simulation is restarted. . In other words, if a simulation is run to output in a `file.nc` with the flag splitting_files, different files will be created such as `file_part1.nc`, `file_part2.nc`. If the overwrite_output is true, these files will be rewritten and the data will be deleted. If the overwrite_output is false, the simulation will crash since it will not find the original `file.nc`. The new code ensures that if overwrite_output is false, then the model will append the output to the last file. i.e. `file_part2.nc`. . Before working more on this (i.e. including joining output in jld2), I'm wondering if this will be useful to implement in the other schedulers and merge to master. What do you think @glwagner @tomchor @navidcy ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818:117,checkpoint,checkpoint,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818,1,['checkpoint'],['checkpoint']
Availability,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1635:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635,3,"['Down', 'error']","['Downloaded', 'error', 'errored']"
Availability,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:523,error,errored,523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,2,"['ERROR', 'error']","['ERROR', 'errored']"
Availability,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2662:536,error,error,536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662,1,['error'],['error']
Availability,"Hello,; I noticed a vertically irregular grid can be passed to a nonhydrostatic model and seems to run without a problem, but when the same formulation is applied to the horizontal, a method error is returned by the PressureSolver. The error persists if either the FFTBasedPoissonSolver or the FourierTridiagonalPoissonSolver are called. Is this a known issue?. A MWE follows. Notice the MWE is a reduction of the example given in the [grid documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/grids/), which also gives back the same error when passed to a nonhydrostatic model.; ``` ; using Oceananigans. Lx, Ly, Lz = 1e4, 1e4, 1e3;; Nx, Ny, Nz = 64, 64, 32;; chebychev_spaced_y_faces(j) = - Ly/2 * cos(π * (j - 1) / Ny). grid = RectilinearGrid(size = (Nx, Ny, Nz),; topology = (Periodic, Bounded, Bounded),; x = (0, Lx),; y = chebychev_spaced_y_faces,; z = (-Lz,0); ). model = NonhydrostaticModel(; grid); ```. Gives:; ``` ; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, ; Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:23; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:24; PressureSolver(::Any, ::ImmersedBoundaryGrid) at C:\Users\.julia\packages\Oceananigans\MDeEL\src\Models\Nonhydrosta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2940:191,error,error,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2940,3,['error'],['error']
Availability,"Hello,; maybe this is an easy one since those mentioned scripts ([lid_driven_cavity](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/lid_driven_cavity/lid_driven_cavity.jl) & [thermal_bubble](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/thermal_bubble/thermal_bubble.jl)) don't seem that complicated. But after several days of reading code, poking around and trying stuff out I couldn't get rid of this Error when running them.; Did someone have or can point me to a solution?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507:438,Error,Error,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507,1,['Error'],['Error']
Availability,"Hello. Thank you for this contribution. I am really interested in using it. . I tried to run the example here: https://clima.github.io/OceananigansDocumentation/v0.22.0/generated/ocean_wind_mixing_and_convection/. I am getting the error: RegularCartesianGrid not defined; Is there something I need to import? Thank you! Sorry, I am a novice with Julia.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3083:231,error,error,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3083,1,['error'],['error']
Availability,Helpful error message for incorrect usage of `FieldBoundaryConditions`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1968:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968,1,['error'],['error']
Availability,"Helpful error when using an invalid `schedule` in OutputWriters, Diagnostics, and Callbacks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2180:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2180,1,['error'],['error']
Availability,"Here I've removed the over-specification that `DiscreteForcing` must have a `Function` in the second parameter so that an object can be put there instead, and a method on that object be the forcing function (don't think I'm describing this very well). This is useful if you want to pass information to a forcing by defining a struct like:; ```julia; struct StructForcing{D}; data :: D; end. (forcing::StructForcing)(i, j, k, grid, clock, model_fields) = forcing.data[i, j, k]; ```. Then this would fail with this error:; <details>; <summary>; MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; </summary>; Struct method forcing [CPU]: Error During Test at /Users/jago/Documents/Projects/Oceananigans.jl/test/test_forcings.jl:204; Test threw exception; Expression: struct_method_forcing(arch); MethodError: objects of type DiscreteForcing{Nothing, StructForcing{Array{Float64, 3}}} are not callable; Stacktrace:; [1] u_velocity_tendency; @ ~/Documents/Projects/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:71 [inlined]; [2] cpu_calculate_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [3] cpu_calculate_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, Gu::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3237:513,error,error,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3237,2,"['Error', 'error']","['Error', 'error']"
Availability,"Here's an MWE:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. grid = RectilinearGrid(size=(2, 2), x = (0, 4), z=(0, 4), topology = (Periodic, Flat, Bounded)); mask = CenterField(grid); mask[1, 1, 1] = 1; grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(mask)). c = CenterField(grid); w = ZFaceField(grid); set!(c, 1); set!(w, 1). @show maximum(c) maximum(w); ```. as might be expected this returns . ```julia; maximum(c) = 1.0; maximum(w) = 1.0; ```. but then writing. ```julia; mask_immersed_field!(c, NaN); mask_immersed_field!(w, NaN). @show maximum(c) maximum(w); ```. leads to. ```julia; maximum(c) = 1.0; maximum(w) = NaN; ```. The reason is because `mask_immersed_field` will touch nodes that `maximum` does not ignore. But we want consistency between the two for many reasons, including analysis. I believe @simone-silvestri's suggestion is to fix `condition_operand` to ignore all `peripheral_nodes` --- not just `inactive` and `immersed_peripheral_node`. The difference between the two are points that lie on non-immersed boundaries, and only affect fields with at least one Face location (like `w` above).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3791:204,mask,mask,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3791,3,['mask'],['mask']
Availability,"Hey all,. Awesome software, I am really enjoying using it. I was wondering if you have any recommendations for compatibility with [DrWatson.jl](https://github.com/JuliaDynamics/DrWatson.jl)? In particular, I am hoping to combine the [`tagsave`](https://juliadynamics.github.io/DrWatson.jl/dev/save/#DrWatson.tagsave) functionality (which stores meta information about a simulation, like git commit, filename, etc) with `JLD2OutputWriter` somehow. This is what I have tried so far. (I'll give the full script at the end). ```julia. function init_jld2!(file, model); tag!(file) # Tag with git information; merge!(file, d) # Save parameters to model file; end. sim.output_writers[:fields] = JLD2OutputWriter(; model,; (; ω, speed);; # Save to `/data/simulations` based on parameters:; filename=datadir(""simulations"", savename(d, ""jld2"")),; schedule=TimeInterval(Δt * 3),; init=init_jld2!; ); ```. However, I get an error from `tag!`:; ```julia; ┌ Warning: Initialization of /Users/mcranmer/Documents/oceananigans_interpret/data/simulations/initial_condition=random_seed=0_stop_time=10.0_timestepper=RungeKutta3_Δt=0.2_Δx=0.00781.jld2 failed because MethodError: MethodError: no method matching tag!(::JLD2.JLDFile{JLD2.MmapIO}); │ Closest candidates are:; │ tag!(!Matched::AbstractDict{K, T}; gitpath, force, source, storepatch) where {K, T} at ~/.julia/packages/DrWatson/I8SbQ/src/saving_tools.jl:200; ```. Do you have any recommendations for using DrWatson.jl with Oceananigans.JL? Maybe there's something basic I'm missing here about saving data files. Thanks!; Miles. <details><summary>Full script</summary>. ```julia; using DrWatson; @quickactivate ""Learning Oceananigans.jl"". using Oceananigans; using Statistics; using Random. function makesim(d::Dict); @unpack size,; extent,; topology,; architecture,; timestepper,; advection,; closure,; Δt,; stop_time,; Δx,; initial_condition,; seed = d. actual_size = (size..., 1). grid = RectilinearGrid(; size, extent, topology); model = NonhydrostaticModel",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2829:912,error,error,912,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2829,1,['error'],['error']
Availability,"Hi Oceananigans Community,. As discussed with @glwagner and @johnryantaylor, I post an issue about adding Lagrangian particles to a nonuniform grid in the z-direction. Hope the following minimum working example is mini enough and bug-free. Happy to learn and discuss. . Best,; Si Chen. <details open>; <summary>Minimum Working Example</summary>. ```; using Random; using Printf; using Plots. using Oceananigans; using Oceananigans.Units: minute, minutes, hour. Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. h(k) = (k - 1) / Nz. ζ₀(k) = 1 + (h(k) - 1) / refinement. Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, 32, Nz), ; x = (0, 64),; y = (0, 64),; #z = (-Lz, 0)) # Errors are gone for uniform grid ; z = z_faces). ############################ Lagrangian Particles; n_particles = 10;; x₀ = 60*rand(n_particles); ; y₀ = 60*rand(n_particles);; z₀ = -Lz*0.5*rand(n_particles); ; lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀, restitution=0); ############################. b_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)). model = NonhydrostaticModel(advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:b,),; coriolis = FPlane(f=1e-4),; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (b=b_bcs,),; particles=lagrangian_particles) ############################ Lagrangian Particles. bᵢ(x, y, z) = 1e-5 * z + 1e-9 * rand(). set!(model, b=bᵢ). simulation = Simulation(model, Δt=10.0, stop_time=20minutes). wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=1minute). simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). run!(simulation); ```; </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2395:928,Error,Errors,928,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2395,1,['Error'],['Errors']
Availability,"Hi all! I've been testing the Lagrangian particles method (ideally on GPUs, but I'm including the error messages for CPU compilation for simplicity) and am running into two issues: (1) tracking dynamical fields, and using (2) Lagrangian particles with immersed boundary active. Would love to hear what is working/isn't available w.r.t. this method or if I'm making a mistake somewhere ... or any other suggestions!. (1) (solved, see comment below) Tracking dynamical fields I'm testing here is the LagrangianParticles for temperature/salinity (version below testing for CPUs). I tested Lagrangian particle tracking for saving x,y,z locations first, which works. However, once I add in T as a tracked field:. ```Julia. #++++ Lagrangian particles. n_particles = 1000;. x₀ = 50*ones(n_particles); . y₀ = (rand(n_particles).-0.5)*params.Ly;. z₀ = params.Lz*rand(n_particles); . T=3*ones(n_particles); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:98,error,error,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,2,"['avail', 'error']","['available', 'error']"
Availability,"Hi all, I am simulating an ocean surface mixed layer. However, I always get lots of noise in the ocean interior below the mixed layer. I have applied a Gaussian-mask sponge layer near the bottom. But the noise is still there. Below are two figures of the vertical velocity and buoyancy perturbations. Any suggestions?; ![b](https://github.com/CliMA/Oceananigans.jl/assets/46232007/f160c0b6-df59-4d8a-89a2-b6de279a6e23); ![w](https://github.com/CliMA/Oceananigans.jl/assets/46232007/1d42358b-c512-41c4-bffb-035a6a169b2b). Here are the codes for the sponge. ps. the whole depth is Lz = 150 m and the mixed layer is about 80m. ######========================================; damping_rate = 1/1800 # relax fields on a 100 second time-scale; bottom_mask = GaussianMask{:z}(center=-grid.Lz, width=grid.Lz/3); uvw_sponge = Relaxation(rate=damping_rate, mask=bottom_mask). model = NonhydrostaticModel(; grid, coriolis,; advection = WENO(),; timestepper = :RungeKutta3,; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = AnisotropicMinimumDissipation(),; stokes_drift = UniformStokesDrift(∂z_vˢ=∂z_vˢ),; boundary_conditions = (v=v_boundary_conditions, b=b_boundary_conditions),; forcing=(u=uvw_sponge, v=uvw_sponge, w=uvw_sponge)); #####============================================",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3560:161,mask,mask,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3560,2,['mask'],['mask']
Availability,"Hi all, I am trying to setup a DNS in a triply bounded domain with inflow conditions on the west wall. All boundary conditions are as default except for the bottom boundary (no-slip), west wall (inflow) and right wall (outflow). I tried setting up the boundaries as; ```; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0)); ```; The tracer boundary condition is fixed to 0 on the west wall. I am getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789:675,error,error,675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:465,error,error,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Hi all,. I think it would be useful for auxiliary fields to be available to tracer forcing functions in the same way that other tracers and the velocity fields are. I'm currently working round this by putting auxiliary fields in the parameters but this is quite cumbersome. It would be straightforward to implement by changing the `fields` functions e.g.:. `fields(model::NonhydrostaticModel) = merge(model.velocities, model.tracers, model.auxiliary_fields)`. I'm happy to try and do this later if there's no reason not to?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2730:63,avail,available,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2730,1,['avail'],['available']
Availability,"Hi all,. I'm currently building a model with lots of forced tracers with @johnryantaylor and @syou83syou83 and have come across an issue that I'm struggling to find a way around related to GPU compilation. I've spent a while looking through your previous similar issues (e.g. [PR #746](https://github.com/CliMA/Oceananigans.jl/pull/746)) and going through the error messages (below) the error message it gives and I'm fairly sure that its coming from the parameters size passed to the boundary tendency functions being too large. . I have looked through the source and while I think it would be possible to reduce the parameter size for the velocity tendencies by only passing them the T and S tracers as required (see the first, nonworking, step towards this [here](https://github.com/jagoosw/Oceananigans.jl/tree/reduce-gpu-params)) I don't see how this problem can be solved in the `tracer_tendency` function since tracer forcing/boundaries may depend on any number of fields. I also realize that the choice to pass all the tracers may be required for something else I've missed. I can have a go at overhauling the `tracer_tendency` function etc. based on [this](https://github.com/JuliaGPU/CUDA.jl/issues/267#issuecomment-1218097841) suggestion and [this](https://github.com/CliMA/Oceananigans.jl/issues/722) but am not sure if its necessarily the best/nicest solution?. Edit: Possibly could just remove a lot of the information from the fields using the `adapt_structure` method from [PR #1057](https://github.com/CliMA/Oceananigans.jl/pull/1057)?. Thanks!. ```; LoadError: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_4JwMaF.ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:360,error,error,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,2,['error'],['error']
Availability,"Hi all,. I'm stuck trying to debug an error I keep getting when running a non-hydrostatic model on GPU. . It runs for a bit and then throws this error:; ```; ... (loads of similar CUDA stuff that goes on for a very very long time); @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream) ; @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; [19] top-level scope; @ ~/.julia/packages/InteractiveErrors/JOo2y/src/InteractiveErrors.jl:329; [20] eval; @ ./boot.jl:370 [inlined]; [21] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [22] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [23] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOpti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:38,error,error,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,2,['error'],['error']
Availability,"Hi all,. I've come across a problem a few times with the output writer where it can't set up running with `indices`specified. This presents as a bounds error coming from the `offset_data` function:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/src/Grids/new_data.jl#L33-L48. An example of this occurs when you try to run the ""near_global_lat_lon"" example when it tries to output surface values:; https://github.com/CliMA/Oceananigans.jl/blob/c73ef035702b33b8d11c505365a4dd48444444a7/validation/near_global_lat_lon/near_global_quarter_degree.jl#L296-L301. Essentially what I think is happening is that when we output data and specify some slice that isn't the dimensions of the grid, in this example just the surface level `grid.Nz`, the data is being correctly (? not sure we actually want the halo here) selected as e.g. `-Hx:Nx+Hx` in dimensions specified as `:` but just whatever indices specified by the user in the other dimensions. In the `offset_data` function I think `ii` gets the halo added in all dimensions so there's a miss match. . I'm not sure how to fix this cleanly?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770:152,error,error,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770,1,['error'],['error']
Availability,"Hi all,. I've come across a strange issue with Lagrangian particles where if they're near the top of the domain they always jump down by Δz after the first intermediate time step. I have tracked this down to the boundary condition enforcement where there is an off by one error choosing the maximum allowed position. The error would also have occurred in the x and y directions too. I will pull request this fix: https://github.com/jagoosw/Oceananigans.jl/tree/particle_tracking. I realized @simone-silvestri is working on an overhaul of Lagrangian particle tracking but it seems to not be fixed in that branch either. Hope this helps!. MWE:; ```; using Oceananigans. grid = RectilinearGrid(size=(2,2,2), extent=(2,2,2)); particles = LagrangianParticles(x=[0.5], y=[0.5], z=[-0.5]); model = NonhydrostaticModel(; grid, timestepper=:RungeKutta3, particles=particles); set!(model, u=0, v=0, w=0); sim = Simulation(model, Δt=1, stop_time=1); printz(sim)=println(sim.model.particles.properties.z); sim.callbacks[:z] = Callback(printz); run!(sim); ```; Result:; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (429.036 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (22.760 seconds).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-1.5]; ```; Results with fix; ```; [ Info: Initializing simulation...; [-0.5]; [ Info: ... simulation initialization complete (10.887 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.866 ms).; [ Info: Simulation is stopping. Model time 1 second has hit or exceeded simulation stop time 1 second.; [-0.5]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2681:129,down,down,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2681,4,"['down', 'error']","['down', 'error']"
Availability,"Hi all,. Thanks, @glwagner for creating the [PR](https://github.com/CliMA/Oceananigans.jl/pull/3660) for solving the issue of `TimeInterval`. After merging it, I noticed a potential problem related to `AveragedTimeInterval`. Specifically, when resuming from a checkpoint, discontinuity seems to occur. For instance, in the figure below, the tidally averaged velocity is saved for each tidal period. The first run covers days 0-20, and the second run covers days 20-40. A noticeable discontinuity appears at the checkpoint transition from the first run.; <img width=""301"" alt=""image"" src=""https://github.com/user-attachments/assets/ffe04dc8-d829-49a7-8052-0b5a58c2b9a3"">. Here is a MWE for this issue:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:260,checkpoint,checkpoint,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,4,"['checkpoint', 'error']","['checkpoint', 'errors']"
Availability,"Hi all,; I have an issue with post-checkpoint runs. I've set the output saving interval to 30 minutes, but for the first few hours after picking up the checkpoint, the saving interval is actually equal to Δt (approximately 30 seconds in my case). Additionally, the progress message is generated every iteration (30 seconds) instead of every 30 minutes as intended. This strange behavior continues until iteration 13398, after which the interval and progress messages behave correctly (see the progress message below).; It is unclear to me what went wrong. Any ideas would be much appreciated!; (I can provide the code about how I set the `outputwriter` and progress message if needed; I am using Oceananigans v0.91.3, and Julia/1.10.2). ![image](https://github.com/user-attachments/assets/5cbba3b7-c686-48c2-8364-a85926867441)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657:35,checkpoint,checkpoint,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657,2,['checkpoint'],['checkpoint']
Availability,"Hi all,; I have tried the Vertical stretching function in my code, and I tried Constructing the Vertically stretched grid with Chebyshev spacing in the z direction.-; ```; julia> computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, Lx),; y = (0, Ly),; halo = (3, 3, 3),; zF = k -> cos(π * (2k - 1) / 2Nz)); VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 4.0], y ∈ [0.0, 4.0], z ∈ [0.9996988186962042, -0.9996988186962042]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (256, 256, 64); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (0.015625, 0.015625, [min=-0.04908245704582441, max=0.0]); ```. But when I set up the model, I got an UndefVarError stating this- . ```; julia> model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); ERROR: UndefVarError: ld not defined; Stacktrace:; [1] Oceananigans.Solvers.FourierTridiagonalPoissonSolver(::CPU, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::UInt32) at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/fourier_tridiagonal_poisson_solver.jl:54; [2] FourierTridiagonalPoissonSolver at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/fourier_tridiagonal_poisson_solver.jl:24 [inlined]; [3] PressureSolver at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/Solvers.jl:45 [inlined]; [4] IncompressibleModel(; grid::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571:1067,ERROR,ERROR,1067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571,1,['ERROR'],['ERROR']
Availability,"Hi! I am trying to implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:935,error,error,935,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Hi,. I know that `ImmersedBoundaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367:522,error,error,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788,8,"['ERROR', 'error']","['ERROR', 'error', 'errored']"
Availability,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1693:67,down,downwards,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693,3,"['down', 'error']","['downwards', 'error']"
Availability,"I accidentally left a duplicate `include(""index_permutations.jl"")` when resolving some merge conflicts in PR #1348 which led to method redefinition errors. This PR should get rid of those errors.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1390:148,error,errors,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1390,2,['error'],['errors']
Availability,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543:192,error,error,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I am attempting to use`ConjugateGradientPoissonSolver` in my simulation, but the error specifically occurs when the grids are stretched. The error happens when running either `fft_poisson_solver(grid.underlying_grid)` or `ConjugateGradientPoissonSolver(grid; preconditioner, maxiter=20)`. . The error message: ; ```; ERROR: type RectilinearGrid has no field underlying_grid; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] fft_poisson_solver(grid::RectilinearGrid{…}); @ Oceananigans.Solvers ~/code/Oceananigans.jl/src/Solvers/Solvers.jl:55; [3] top-level scope; @ REPL[7]:1. ```; I don't understand why there is no `underlying_grid`, which clearly exists.; Here is the MWE that I slightly modified from https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2415367426, thanks to @ali-ramadhan, @glwagner ; ```julia; using Printf; using Statistics; using Oceananigans; using Oceananigans.Grids: with_number_type; using Oceananigans.BoundaryConditions: FlatExtrapolationOpenBoundaryCondition; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver; using Oceananigans.Utils: prettytime. N = 16; h, w = 50, 20; H, L = 100, 100; x = y = (-L/2, L/2). # Create stretched vertical grid; kwarp(k, N) = (N + 1 - k) / N; # Linear near-surface generator; ζ(k, N, refinement) = 1 + (kwarp(k, N) - 1) / refinement; # Bottom-intensified stretching function; Σ(k, N, stretching) = (1 - exp(-stretching * kwarp(k, N))) / (1 - exp(-stretching)); # Generating function; z_faces(k) = - H * (ζ(k, N, 1.2) * Σ(k, N, 15) - 1); z = z_faces. # uniform vertical grid; # z = (-H, 0). grid = RectilinearGrid(size=(N, N, N); x, y, z, halo=(2, 2, 2), topology=(Bounded, Periodic, Bounded)). mount(x, y=0) = h * exp(-(x^2 + y^2) / 2w^2); bottom(x, y=0) = -H + mount(x, y); grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). prescribed_flow = OpenBoundaryCondition(0.01); extrapolation_bc = FlatExtrapolationOpenBoundaryCondition(); u_bcs = FieldBoundaryConditions(west = p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3889:81,error,error,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3889,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I am facing some issue with `TimeStepWizard`. It is saying that there is no method like `TimeStepWizard` , I have also faced this issue in previous version of `Oceananigans` but that time after updating `Oceananigans` resolved it. ; This time these are the information of version-; `Oceananigans` = `v0.61.3`; `julia` = `1.6.1`. I am pasting me whole code so that you can reproduce the error-; ```; using Printf; using Plots; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units: minutes, hour, hours, day; using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval; using Oceananigans.Diagnostics: accurate_cell_advection_timescale. #Defining Grid; #number of grid spacing in south,north and vertical direction; const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. const S = 1.6 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-Nz-1) ) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; architecture = CPU(),; x = (0,Lx),; y = (0,Ly),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes). #Governing parameters ; #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4. #diffusive viscocity; const v=1e-5 ; #diffusivity; const k=2e-6 . const f=0 #coriolis parameter; ; g = 300. #Temperature(Tracer) boundary condition ; Amplitude = 950 # Amplitude (W/m²) of Heat flux. Q_cool = -143.1092 # (W/m²) {due to Longwave + Latent heat + Sensible Heat}. gausian(t) = exp(-((t)^2)/(0.025*(86400)^2)) . # These are the times during which peak of the heat flux can be observed; peak1 = 0.56day; peak2 = 1.56day; peak3 = 2.56day; peak4 = 3.56day; peak5 = 4.56day; peak6 = 5.56day. # Heat absorbed due to shortwave; Q_sh(t) = Amplitude*(gausian(t-peak1) + gausian(t-peak2) + gausian(t-peak3) + gausian(t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946:386,error,error,386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946,1,['error'],['error']
Availability,"I am getting the following error from benchmark/distributed_nonhydrostatic_model.jl where I have set threaded = false and decomposition = Slab(). I get a very similar error from the distributed nonhydrostatic script when I run the tests script, but the distributed shallow water model runs fine. In case it matters, I'm running mpich/3.0.4 (a bit old) on a linux system running Ubuntu. ```; Oceananigans v0.71.5; Julia Version 1.6.5; Commit 9058264a69 (2021-12-19 12:30 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5645 @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, westmere); [2022/03/13 19:01:45.515] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 16), ranks=(1, 1, 1)]...; [2022/03/13 19:02:09.310] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 16) grid points and ranks=(1, 1, 1) on rank 0...; [2022/03/13 19:02:52.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:27,error,error,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,2,['error'],['error']
Availability,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2876:246,error,error,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I am trying to reproduce a simulation similar to the one in [this paper](https://journals.ametsoc.org/jpo/article/45/6/1554/12449/The-Energetics-of-Centrifugal-Instability) and when I checked the simulation after a whole day running I found it had crashed in the first hour. (Even though I was using the TimeStepWizard.) Or at least that's what I think happened judging by the output:. ```; i: 13960, sim time: 11.103 hours, wall time: 42.767 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13970, sim time: 11.111 hours, wall time: 42.797 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13980, sim time: 11.119 hours, wall time: 42.827 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13990, sim time: 11.127 hours, wall time: 42.856 minutes, Δt: 2.875 seconds, CFL: NaN; i: 14000, sim time: NaN years, wall time: 42.885 minutes, Δt: NaN years, CFL: NaN; i: 14010, sim time: NaN years, wall time: 42.913 minutes, Δt: NaN years, CFL: NaN; ```. I wonder if it's possible to implement a check that kills the simulation/throws an error when it notices that it crashed. In my LES Fortran code I implemented something like that and it prevented me from wasting many core-hours simulating `NaN`s. Basically it was just something that checked if there were any `NaN`s in the domain and killed it otherwise. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1196:1020,error,error,1020,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1196,1,['error'],['error']
Availability,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317:101,error,error,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317,4,['error'],['error']
Availability,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655:448,error,error,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655,5,"['down', 'error', 'fault']","['downloads', 'error', 'errors', 'fault']"
Availability,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1555:281,error,error,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I attempted to run the [eady_turbulence.jl](https://github.com/CliMA/Oceananigans.jl/blob/master/examples/eady_turbulence.jl) example with `TwoDimensionalLeith()`closure as follows:. ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, νz=κᵥ, κz=κᵥ),; #AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)); TwoDimensionalLeith()); ```. and got the error posted below. I am using Oceananigans.jl v0.40.0. . ```; ERROR: LoadError: TaskFailedException:; MethodError: no method matching ∂ⱼ_2ν_Σ₁ⱼ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Clock{Float64}, ::TwoDimensionalLeith{Float64,NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}, ::NamedTuple{(:νₑ,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}); Closest candidates are:; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid, ::Any, ::Tuple{C1,C2}, ::Any, ::Any) where {C1, C2} at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/closure_tuples.jl:13; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid{FT,TX,TY,TZ} where TZ where TY where TX, ::Any, ::Tuple, ::Any, ::Any, ::Any...) where FT at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/TurbulenceClosures.jl:110; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::Any, ::Any, ::IsotropicDiffusivity, ::Any, ::Any...) at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:53; ...; Stacktrace:; [1] call at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:456 [inlined]; [2] fallback at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:454 [inlined]; [3] _overdub_fallback at /home/guptam/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1034:343,error,error,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549:246,avail,available,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549,1,['avail'],['available']
Availability,"I believe the below MWE should work according to the `ScalarDiffusivity` docstring, but from the error it seems to be expecting `funky_diffusion(x, y, z, t)` instead of `funky_diffusion(x, y, z, t, p)`. https://github.com/CliMA/Oceananigans.jl/blob/fe056fb44ce7173ce9e7eaa4f5c349d6ee2b61a4/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl#L12-L67. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(CPU(), size=(3, 4, 5), extent=(1, 1, 1)). @inline funky_diffusion(x, y, z, t, p) = p.A + p.M * (x+y+z+t). params = (; A=1.2, M=0.7). closure = ScalarDiffusivity(;; ν = funky_diffusion,; κ = funky_diffusion,; parameters = params; ). model = NonhydrostaticModel(; grid, closure). time_step!(model, 0.1); ```. Error:. ```julia; ERROR: MethodError: no method matching funky_diffusion(::Float64, ::Float64, ::Float64, ::Float64). Closest candidates are:; funky_diffusion(::Any, ::Any, ::Any, ::Any, ::Any); @ Main REPL[2]:1. Stacktrace:; [1] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:309 [inlined]; [2] νᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:84 [inlined]; [3] ν_σᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:154 [inlined]; [4] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl:159 [inlined]; [5] viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/implicit_explicit_time_discretization.jl:43 [inlined]; [6] _viscous_flux_ux; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:4 [inlined]; [7] Ax_qᶜᶜᶜ; @ ~/atdepth/Oceananigans.jl/src/Operators/products_between_fields_and_grid_metrics.jl:12 [inlined]; [8] δxᶠᵃᵃ; @ ~/atdepth/Oceananigans.jl/src/Operators/difference_operators.jl:21 [inlined]; [9] ∂ⱼ_τ₁ⱼ; @ ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/closure_kernel_operators.jl:24 [inlined]; [10] u_v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840:97,error,error,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840,3,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I can't seem to construct a `Float32` hydrostatic model with CATKE. I'm pretty sure this used to work but I can't figure out when this error started happening or why. But it's happening as of the current `main` branch or v0.93.0 on two different machines. I guess with CUDA illegal memory access errors, they tend to occur after the illegal memory access has actually occured so the stacktrace might not be useful. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = CATKEVerticalDiffusivity(Float32); ); ```. Error:. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:135,error,error,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,5,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error', 'errors']"
Availability,"I cannot get the checkpointing test running in PR #140 as JLD is not able to serialize the model to disk with forcing functions. We can go back to forcing arrays but we I think that's a bad idea as we should avoid increasing GPU memory usage. I believe that [JLD2.jl](https://github.com/JuliaIO/JLD2.jl) might be able to serialize functions to disk but it's not actively maintained anymore and their README says ""If your tolerance for data loss is low, JLD may be a better choice at this time."". If we can fix this and figure out how to serialize functions to disk, then we may also be able to serialize the FFTW and CuFFT plans to disk (although we might still want to reconstruct them as in case the model is restored on a different computer with a different architecture). Stacktrace:; ```julia; Deserializing model from disk: test_model_checkpoint_5.jld; error parsing type string Oceananigans.Forcing{Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func,Oceananigans.#zero_func}; Checkpointing: Error During Test at D:\Home\Git\Oceananigans.jl\test\runtests.jl:246; Got exception outside of a @test; syntax: incomplete: premature end of input; Stacktrace:; [1] eval at .\boot.jl:328 [inlined]; [2] eval at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:3 [inlined]; [3] _julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:983; [4] julia_type(::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:30; [5] jldatatype(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:17,checkpoint,checkpointing,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,3,"['checkpoint', 'error', 'toler']","['checkpointing', 'error', 'tolerance']"
Availability,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/56:751,error,errors,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56,1,['error'],['errors']
Availability,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1072:361,ERROR,ERROR,361,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072,5,"['ERROR', 'down', 'error']","['ERROR', 'down', 'error']"
Availability,"I don't know what happened but yesterday I could type ""using Oceananigans"" after starting julia --project and it worked fine. This morning, after a software update on ubuntu, now I'm getting a CUDA ERROR. See below. Any ideas what I can do to try and fix this?. ```; julia> using Oceananigans; ┌ Warning: Recursion during initialization of CUDA.jl; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:41; ┌ Error: Could not initialize CUDA; │ exception =; │ CUDA error (code 803, CUDA_ERROR_SYSTEM_DRIVER_MISMATCH); │ Stacktrace:; │ [1] throw_api_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:198,ERROR,ERROR,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I don't think architecture is required, despite being included here:. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L74. For example, `:architecture` property is not called within. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L201",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3463:175,checkpoint,checkpointer,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3463,2,['checkpoint'],['checkpointer']
Availability,"I feel like this impacts usability, especially interactive use, but it's not a bug in the sense that your simulation scripts are fine. Is it worth trying to fix this?. Maybe not. After all, executing `model.velocities.u.data` in the REPL with a GPU model produces a similar error to the one below. One nuclear option is to allow scalar operations in `show` methods, but in this particular example it's for a `SubArray{OffsetVector{CuArray}}` so not a type we have control over without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/Offs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:274,error,error,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:337,error,error,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I get the following error when I call `maximum` on a field with location `Face, Center, Center` on an immersed boundary grid with a vertically stretched underlying grid on the GPU. For example:. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lx, Ly, Lz = 500, 600, 3. Nx, Ny, Nz = 128, 128, 64. σ = 1.04 # linear stretching factor; linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz). underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)). const H_deep = H = underlying_grid.Lz; const H_shelf = h = 0.5; const width_shelf = 100. shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); bathymetry(x, y) = shelf(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```. then just creating a `u` field gives:. ```julia; julia> u = Field((Face, Center, Center), grid); Error showing value of type Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['error'],['error']
Availability,I got a little confused reading . https://github.com/CliMA/Oceananigans.jl/blob/4f1fe0fa7edd9489ba20875be64b69daa0a77b95/src/ImmersedBoundaries/immersed_fields_reductions.jl#L28. because I thought that `solid_interface` was defined for fluxes while `solid_node` was for masking. Can we clarify what the purpose of these two functions are? Do their names need to be changed?. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2293:270,mask,masking,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2293,1,['mask'],['masking']
Availability,I got an incremental compilation error/warning here. https://github.com/CliMA/Oceananigans.jl/blob/b6dd1fa9b1d740f7d8cb4be116a24cbba0042f86/src/Architectures.jl#L23,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2676:33,error,error,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2676,1,['error'],['error']
Availability,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227:1195,error,error,1195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227,1,['error'],['error']
Availability,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1205:337,error,error,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637:251,down,downsides,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637,1,['down'],['downsides']
Availability,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188:1217,error,error,1217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I have found it inconvenient that output is masked to `0`. For most purposes, I'd prefer `NaN`. I'm opening this issue to discuss a user interface that would implement such a feature. My first idea is to add a property / kwarg to output writers called `immersed_values`. Then we might write something like. ```julia; output_writer = JLD2OutputWriter(model, output, immersed_values=NaN, other_kwargs...); ```. The default will be `immersed_values=nothing`. Then `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/OutputWriters/fetch_output.jl#L12-L15. would become something like. ```julia. function fetch_output(field::AbstractField, model, immersed_value) ; compute_at!(field, time(model)); !isnothing(immersed_value) && mask_immersed_field!(field, immersed_value); return parent(field) ; end ; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061:44,mask,masked,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061,1,['mask'],['masked']
Availability,"I have made a first attempt to add tracers into `ShallowWaterModel`, but unfortunately, have a problem with the new function I have created, `div_ucvc` to compute the divergence of the tracer, `c`, times the velocity `(u,v)`. . When I try running a simulation I get the following output, which is a TaskFailedexcetion, and seems to be having problems with convert. ```; julia> run!(simulation); ERROR: TaskFailedException:; MethodError: Cannot `convert` an object of type Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(+),Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(+),Float64,Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(*),Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}},Float64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(*),Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1510:395,ERROR,ERROR,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1510,1,['ERROR'],['ERROR']
Availability,"I have put together an example for my own benefit (not to be merged into master unless people want it to be) that looks at the simulation of inertial instability in 2D. See [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/inertially_unstable_jet.jl) for the code. . I believe everything is working on a CPU but I am having two difficulties with GPUs. . 1. In line 39, where I define the background buoyancy of the jet, I can't use `coriolis.f` because CUDA seems to need a global variable and this doesn't cut it. I am presently using `f` instead and this works, but should this work? `ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!`; 2. When I make a simulation from a gpu calculation, I get that the buoyancy perturbation has perturbations at the top and bottom, which are not physical. Which is to say that it has different boundary conditions. I didn't actually specify the boundary conditions differently but just wanted a solid top and bottom. If I specify the boundary conditions explicitly, should this fix the problem? Maybe that's a fix but is this expected behaviour?. https://user-images.githubusercontent.com/8239041/113899192-8d851900-979a-11eb-97a7-b7f8085864b7.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554:631,ERROR,ERROR,631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554,1,['ERROR'],['ERROR']
Availability,"I have the following output writer set-up in my simulation:. ```julia; import Oceananigans.Fields: ComputedField; u, v, w = model.velocities.u, model.velocities.v, model.velocities.w; b, pHY′, pNHS = model.tracers.b, model.pressures.pHY′, model.pressures.pNHS; ν, νₑ = model.closure.ν, model.diffusivities.νₑ; #-----. #-----; import Oceananigans.AbstractOperations: ∂x, ∂y, ∂z. ddx = ∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2; ddy = ∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2; ddz = ∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2; #avg_ε = AveragedField(ComputedField(ddx + ddy + ddz), dims=(1,)); avg_ε = AveragedField(ν*(ddx + ddy + ddz), dims=(1,)). outputs = (ε = avg_ε,); simulation.output_writers[:avg_field_writer] =; NetCDFOutputWriter(model, outputs,; filepath = ""avg.jd15_3dbounded.nc"",; schedule = TimeInterval(2minutes),; mode = ""c""); ```. This works successfully on CPUs, but running on GPUs I get a huge amount of error lines with some . ```; [16] compute! at /glade/u/home/tomasc/.julia/packages/Oceananigans/6JcUu/src/Fields/averaged_field.jl:86 [inlined]; ```. Running the simulation without that output works for both GPUs and CPUs. Am I doing something wrong here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241:880,error,error,880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241,1,['error'],['error']
Availability,"I haven't had the the time to investigate this for now, but `min_Δz()` (and supposedly the x and y version as well) complains about scalar indexing on the GPU when using irregular z spacing:. ```; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /glade/work/tomasc/.julia/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /glade/work/tomasc/.julia/packages/GPUArrays/7TiO1/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /glade/work/tomasc/.julia/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δz(grid::Recti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040:197,ERROR,ERROR,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I hit these issues when setting a field on an immersed boundary grid.; ```; ERROR: LoadError: MethodError: no method matching ξname(::ImmersedBoundaryGrid{Float64, Periodic, RightConnected, Bounded, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{OrthogonalSphericalShellGrids.Zipper, Int64}, Nothing, Nothing, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Flux, Nothing}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CUDA.CuArray{Tuple{UInt16, UInt16, UInt16}, 1, CUDA.DeviceMemory}, CUDA.CuArray{Tuple{UInt16, UInt16}, 1, CUDA.DeviceMemory}, GPU}). Closest candidates are:; ξname(!Matched::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/O8Ult/src/Grids/latitude_longitude_grid.jl:574; ξname(!Match",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742:76,ERROR,ERROR,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742,1,['ERROR'],['ERROR']
Availability,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1468:115,error,error,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I just realized that the output writers docs page has errors relating to the purging of `FieldSlicer()`: https://clima.github.io/OceananigansDocumentation/stable/model_setup/output_writers/#Examples. ![image](https://user-images.githubusercontent.com/13205162/162648339-b7b30179-a9cc-4c05-ab34-9833e7603044.png). Now that `FieldSlicer()` doesn't exist anymore, part of that section may be out of date and needs to be re-written.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2427:54,error,errors,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2427,1,['error'],['errors']
Availability,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1271:350,ERROR,ERROR,350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271,1,['ERROR'],['ERROR']
Availability,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2077:44,error,error,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077,1,['error'],['error']
Availability,"I know `MultipleForcings` is not exported and not tested so it's experimental. It seems like a useful feature so I tried using it but I ran into an error. Seems to be related to forcing function call arguments (or maybe incorrect regularization?) but I haven't been able to figure out the exact cause. Minimal working example:. ```julia; using Oceananigans. using Oceananigans.Forcings: MultipleForcings. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)). weird_forcing(λ, φ, z, t) = λ * φ + z; wonky_forcing(λ, φ, z, t) = z / (λ - φ). forcing1 = Forcing(weird_forcing); forcing2 = Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tenden",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3736:148,error,error,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I know `PartialCellBottom` is unexported and therefore experimental but just opening an issue that it doesn't currently work on GPUs with `HydrostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:730,error,error,730,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I may be missing something, but in the first example of the documentation I get an error when creating the model. The prior example (the still ocean without anything) runs fine. Based on the docs I think at some point you changed the keyword from `arch` to `architecture` in the `Model` function and didn't change the documentation, but since I'm not familiar with Oceananigans I decided to post here instead of making a pull request. Cheers. Also, quick edit: the link to `rising_thermal_bubble_2d.jl` in the front page is broken.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449:83,error,error,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449,1,['error'],['error']
Availability,"I noticed a file called `rigid_lid.jl` exists (https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3735:328,error,error,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735,2,['error'],['error']
Availability,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2840:237,avail,available,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840,3,"['ERROR', 'avail']","['ERROR', 'available']"
Availability,"I realize that https://github.com/CliMA/Oceananigans.jl/issues/3609 exists, but I think this is a different issue. The following MWE, which tries to advect `LagrangianParticle`s over an `ImmersedGrid` fails with this error:. ```; ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{…}, ::StructArrays.StructVector{…}, ::Float64, ::ImmersedBoundaryGrid{…}, ::Int64, ::@NamedTuple{…}). Closest candidates are:; cpu__advect_particles!(::Any, ::Any, ::Any, ::Oceananigans.Grids.AbstractUnderlyingGrid, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:144; [2] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:111; [3] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/60cqT/src/cpu.jl:46; [4] (::KernelAbstractions.Kernel{…})(::StructArrays.StructVector{…}, ::Vararg{…}); ```. This is the MWE:. ```julia; using Oceananigans. grid_base = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)); GFB = GridFittedBottom((x, y) -> -1/2); grid = ImmersedBoundaryGrid(grid_base, GFB). n_particles = 3; x₀ = rand(n_particles); y₀ = rand(n_particles); z₀ = .-rand(n_particles). lagrangian_particles = LagrangianParticles(x=x₀, y=y₀, z=z₀). model = NonhydrostaticModel(; grid, particles=lagrangian_particles); time_step!(model, 1); ```. I'm a bit confused, because, while the function `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3761:217,error,error,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3761,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I recently received the error. ```; ERROR: LoadError: ArgumentError: The grid halo (3, 3, 3) must be at least equal to (4, 4, 4). Note that an ImmersedBoundaryGrid requires an extra halo point.; ```. It's not clear what ""extra halo point"" means. I think this error needs to be a little bit more specific like, ""Note that an ImmersedBoundaryGrid requires an extra halo point in all directions compared to a non-immersed grid.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2983:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2983,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I report here some issues connected to updating to Oceananigans 0.80.0 . ```; ERROR: LoadError: MethodError: no method matching min_Δx(::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:78,ERROR,ERROR,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['ERROR'],['ERROR']
Availability,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:299,error,error,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['error'],['error']
Availability,"I see a few things to improve with the grid right now. 1. We need to add some kind of type information that indicates whether a given dimension is 'flat'. One way to do this could simply be to add the grid sizes in each dimension as parameters in the abstract type `Grid`, aka:. ```julia; abstract type Grid{T, Nx, Ny, Nz} end. struct RegularCartesianGrid{T, R, Nx, Ny, Nz} <: Grid{T, Nx, Ny, Nz}; ...; end; ```. Functions can then dispatch when one of `Nx`, etc is `1` (including halo-filling functions, which I think may fail when the size of the halo is 0). Another option is to use flags for each dimension rather than the actual size of the grid. In my opinion using the size makes the most sense. Using the actual size could have future advantages; for example, if some optimizations are possible when `Nz=2`. It is also nice to see the size of the grid from the type signature. A disadvantage is that we then could not have `mutable` grid types, but I'm not sure we want that. 2. There is a lot of redundant information in the `RegularCartesianGrid` struct: cell areas, volumes, total number of grid points, etc. I think it would be better --- meaning that our code would be shorter, easier to read, easier to maintain, easier to reason about (since storing them implies they *cannot* be computed, which is incorrect) and more computationally efficient --- to add functions that compute these quantities on the fly, rather than storing them in memory. Related: #287.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/330:1005,redundant,redundant,1005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/330,1,['redundant'],['redundant']
Availability,I see it here being exported:. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/OutputWriters.jl#L5. but nowhere else. I believe that currently this happens via. https://github.com/CliMA/Oceananigans.jl/blob/3b02321a350003fa9596c4f40839b031a5cc7ad1/src/OutputWriters/checkpointer.jl#L201. Right?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3462:323,checkpoint,checkpointer,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3462,1,['checkpoint'],['checkpointer']
Availability,"I set up my netcdf writer as follows:. `fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w,""T"" => model.tracers.T)`; `my_writer = NetCDFOutputWriter(model, fields, filename=""data/turb_box_test.nc"", time_interval=60)`; `simulation.output_writers[:field_writer] = my_writer`. and got the following error:. NetCDF error: Variable 'time' not found in file <unknown> (NetCDF error code: -33)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/862:337,error,error,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862,3,['error'],['error']
Availability,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1455:270,error,errors,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455,7,"['ERROR', 'Error', 'error', 'failure']","['ERROR', 'Error', 'error', 'errors', 'failure']"
Availability,"I stumbled on this trying to save the free surface for a `HydrostaticFreeSurfaceModel`. Here's an example:. ```Julia; using Oceananigans. model = HydrostaticFreeSurfaceModel(grid = RectilinearGrid(size = (5, 5, 4), x = (-1e3, 1e3), y = (-1e3, 1e3), z = (-1e3, 0))). ηᵢ(x, y, z) = 1 * exp(-(x^2 + y^2) / 2 * (2e2)^2). set!(model, η = ηᵢ). simulation = Simulation(model, Δt=100, stop_time = 1000). simulation.output_writers[:surface] = JLD2OutputWriter(model, (η=model.free_surface.η,),; schedule = TimeInterval(200),; filename = ""surface"",; overwrite_existing = true); ```. ```Julia; ERROR: BoundsError: attempt to access 11×11×1 Array{Float64, 3} at index [4:8, 4:8, 4:8]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:744; [2] checkbounds; @ ./abstractarray.jl:709 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:245; [5] view(f::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, ...; @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/field.jl:312; [6] #Field#13; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [7] Field; @ ~/Oceananigans.jl/src/Fields/field.jl:179 [inlined]; [8] construct_output(user_output::Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260:583,ERROR,ERROR,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260,1,['ERROR'],['ERROR']
Availability,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1643:533,down,downshifted,533,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643,1,['down'],['downshifted']
Availability,"I think I am encountering a bug using `ValueBoundaryCondition`s with `ImmersedBoundaryGrid`s. `FluxBoundaryCondition`s do not trigger this, and based on the error message it looks like it has to do with how the halos are treated (in `src/BoundaryConditions/fill_halo_regions.jl`)? See a MWE below. I am running the latest version of `Oceananigans` (0.73.8). ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; using Oceananigans.Units; using Printf. Nx = 60; Nz = 18; Lx = 1200kilometers; Lz = 1800meters; Δt = 30minutes; taux = -0.5 # [Pa]; ρ₀ = 1026 # [kg m⁻³]. stop_time = 1years; save_interval = 1days; wind_time_ramp = 5days; lateral_diffusive_time = 1days; αT = 2e-4; taux = taux/ρ₀. buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion=αT, haline_contraction=0.0)); momentum_advection = WENO5(); tracer_advection = WENO5(); tracers = (:T, :S). grid = RectilinearGrid(size = (Nx, Nx, Nz),; x = (0, Lx),; y = (0, Lx),; z = (-Lz, 0),; halo = (3, 3, 3),; topology = (Bounded, Bounded, Bounded)). free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver). # Rough topography.; ht = 100meters; Lt = 500kilometers; kt = 2π/Lt; topography(x, y) = ht*cos.(kt*x).*cos.(kt*y) .- Lz; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(topography)). coriolis = BetaPlane(latitude=45); κh = grid.Δxᶜᵃᵃ^2 / lateral_diffusive_time; νh = κh. κz = 0; νz = κz; horizontal_closure = HorizontalScalarDiffusivity(ν=νh, κ=κh); vertical_closure = VerticalScalarDiffusivity(ν=νz, κ=κz); closure = (vertical_closure, horizontal_closure). wind_stress(x, y, t) = - taux * cos(2π * y / (2Lx)) * tanh(t/wind_time_ramp); no_slip = ValueBoundaryCondition(0); no_flux = FluxBoundaryCondition(0). # No bottom drag (free-slip at the bottom).; boundary_conditions = (;; u = FieldBoundaryConditions(top=FluxBoundaryCondition(wind_stress), south=no_slip, north=no_slip),; v = FieldBoundaryConditions(east=no_slip, west=n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2430:157,error,error,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2430,1,['error'],['error']
Availability,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470:506,down,downward,506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470,1,['down'],['downward']
Availability,"I think it might make sense to serialize grids in JLD2 files with `CPU` architecture by default; this way they can be loaded on systems without a GPU. . The downside is that users with GPUs would have to write. ```julia; cpu_grid = file[""serialized/grid""]; grid = on_architecture(GPU(), cpu_grid); ```. to load their grid on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2179:157,down,downside,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179,1,['down'],['downside']
Availability,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1132:106,avail,available,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132,1,['avail'],['available']
Availability,I think it's time to have something there. At lease a docs page that writes down the equations solved and the state variables... cc @francispoulin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460:76,down,down,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460,1,['down'],['down']
Availability,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:1646,down,down,1646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,1,['down'],['down']
Availability,"I think we could use some utilities for instantiating grids and fields from files saved by Oceananigans' output writers. For this it could make sense to change `Oceananigans.OutputWriters` to `Oceananigans.Output` and include both output writers and utilities for reading output. (The checkpointer already has utilities for reading output, I suppose.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/706:285,checkpoint,checkpointer,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/706,1,['checkpoint'],['checkpointer']
Availability,I think we should tag a v0.37.0 release to ensure we have a code checkpoint before which we were recomputing w and after which we were not (since it's a change to the numerical methods). Might be good if we do this before merging in RK3.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/948:65,checkpoint,checkpoint,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/948,1,['checkpoint'],['checkpoint']
Availability,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1477:315,error,error,315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477,5,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried running the first example listed in README and I got the following error:; ```; julia> topology = (Periodic, Periodic, Bounded); ERROR: UndefVarError: Bounded not defined; Stacktrace:; [1] top-level scope at REPL[45]:1; ```; I'm running Julia 1.4 RC2 on macOS 10.15.3.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/679:75,error,error,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/679,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried submitting it as a package through an attobot request a few weeks ago but the PR build failed on METADATA.jl and I'm not sure why. Well, I think this was the error but not sure what to do about it as I put Julia 1.1 in the REQUIRE file.; ```; ERROR: LoadError: METADATA/Oceananigans/versions/0.4.0/requires: no julia entry (>= 0.6.0 needed); ```. See:; * https://github.com/JuliaLang/METADATA.jl/pull/21774",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/142:166,error,error,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/142,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I tried to construct a PGC free surface solver with an FFT preconditioned and I get an error. ```Julia; ArgumentError: The dimensions of the immersed boundary (408, 1) do not match the grid size (406, 1). Stacktrace:; [1] validate_ib_size(grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries /g/data/v45/nc3020/.julia/packages/Oceananigans/KZUtL/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries /g/data/v45/nc3020/.julia/packages/Oceananigans/KZUtL/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3093:87,error,error,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3093,1,['error'],['error']
Availability,"I tried to run the `eady_turbulence.jl` example in Oceananigans v0.25.0 in Julia 1.4 RC2 on macOS 10.15.3 and got the following error:. ```; julia> include(""eady_turbulence.jl""); [ Info: CUDAdrv.jl failed to initialize, GPU functionality unavailable (set JULIA_CUDA_SILENT or JULIA_CUDA_VERBOSE to silence or expand this message); N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined; Stacktrace:; [1] top-level scope at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; [2] include(::String) at ./client.jl:439; [3] top-level scope at REPL[1]:1; in expression starting at /Users/truedichotomy/GitHub/Oceananigans.jl/examples/eady_turbulence.jl:138; ```; I noticed that there are a lot of recent commits with regards to boundary conditions, may be the example is using an older interface?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/686:128,error,error,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I was actually expecting a different error. But this isn't a good one either. ```julia; julia> using Oceananigans. julia> using OrthogonalSphericalShellGrids. julia> grid = TripolarGrid(size=(4, 4, 4), z=(-1, 0)); 4×4×4 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I was doing some profiling on a model with no open boundaries and discovered that this function was causing a big slow down. I guess this is because the compiler isn't managing to work out its just a load of nothing operations but this change appears to make it completely go away.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792:119,down,down,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792,1,['down'],['down']
Availability,"I was just trying to precompile Oceananigans 0.34.1 on my macOS 10.15.6 machine and got the following error:. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:102,error,error,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,I was reading about the extension feature in Julia v1.9. https://pkgdocs.julialang.org/v1/creating-packages/#Conditional-loading-of-code-in-packages-(Extensions). and it reads to me that it's ideal to add for plotting methods that step onto Makie functionality. This way the code won't load unless one loads GLMakie/CairoMakie in the environment. What do others think?. I have put together a few methods for plotting Oceananigans fields at https://github.com/navidcy/Imaginocean.jl. I could move those into an extension in Oceananigans. Ideally I would like these things to live outside Oceananigans repo to minimise the burden of maintenance. But from what I understand for how extensions work they have to live in this repo? Or in the Makie repo which makes even less sense? Am I right?. x-ref: https://github.com/navidcy/Imaginocean.jl/issues/2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3178:631,mainten,maintenance,631,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3178,1,['mainten'],['maintenance']
Availability,"I was running an example of the 2D turbulence using Julia 1.4RC2 (Oceananigans 0.27.0) on an Azure Ubuntu 18.04.3 GPU instance (Tesla K80), I was defining the model:; ```; model = IncompressibleModel(; grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),; buoyancy = nothing,; tracers = nothing,; closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3); ); ```; when this error occurred:; ```; julia> model = IncompressibleModel(; grid = RegularCartesianGrid(size=(128, 128, 1), length=(2π, 2π, 2π)),; buoyancy = nothing,; tracers = nothing,; closure = ConstantIsotropicDiffusivity(ν=1e-3, κ=1e-3); ); Error showing value of type IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/707:388,error,error,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707,2,"['Error', 'error']","['Error', 'error']"
Availability,"I was thinking it might be cool/useful to inform users if their model is physically/numerically consistent. One example of this is to check that the boundary conditions being imposed match the grid topology (#890). But I think there are many more. Some examples:; * Using `BetaPlane` on a periodic grid.; * Using `WENO5` on a curvilinear grid.; * Using a free surface when z is `Periodic`.; * Using an `FFTBasedPressureSolver` on a curvilinear grid.; * ... Some errors are more likely to be made by users than others of course. But I don't think we can expect users to just know that e.g. `WENO5` doesn't work with `VerticallyStretchedRectilinearGrid` yet. To save ourselves and users some potential future headaches, it seems like we could create a function like `check_consistency(model)` that would perform these checks and print a warning for each inconsistency detected. Unfortunately this could become a pretty ugly monolithic function that's hard to modularize since we're checking the consistency of many different structs acting together.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453:462,error,errors,462,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453,1,['error'],['errors']
Availability,"I was trying to add some Lagrangian particles to a 2D simulation I was running but Lagrangian particle advection currently assumes that the grid is bounded or periodic in all dimensions. An MWE (on Julia 1.10.1+0.x64.w64.mingw32 and Oceananigans version 0.90.12) that reproduces the issue is:. ```; using Oceananigans; NX, NZ = 16, 16; grid = RectilinearGrid(size=(NX,NZ), x=(0,1), z=(0,1), topology=(Periodic, Flat, Bounded)); # initialise some particles at the cell centres; x₀ = reshape(xnodes(grid, Center()) * ones(NZ)', NX * NZ); y₀ = zeros(NX * NZ); z₀ = reshape(ones(NX) * znodes(grid, Center())', NX * NZ); model = NonhydrostaticModel(; grid, particles=LagrangianParticles(x=x₀, y=y₀, z=z₀)); simulation = Simulation(model; Δt=1, stop_iteration=5); run!(simulation); ```. with output. ```; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (115.810 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching unsafe_trunc(::Type{Int64}, ::Nothing). Closest candidates are:; unsafe_trunc(::Type{Int64}, ::Union{Float16, Float32, Float64}); @ Base float.jl:336; unsafe_trunc(::Type{<:Integer}, ::BFloat16s.BFloat16); @ BFloat16s C:\Users\hildi\.julia\packages\BFloat16s\u3WQc\src\bfloat16.jl:288; unsafe_trunc(::Type{T}, ::BigFloat) where T<:Integer; @ Base mpfr.jl:358; ... Stacktrace:; [1] advect_particle; @ C:\Users\hildi\.julia\packages\Oceananigans\kBe5X\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:81 [inlined]. ...; ```. The offending line is https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L81 . which fails because ; https://github.com/CliMA/Oceananigans.jl/blob/ce4fabaa0c6ddfd20ae43c671bbaec7bb5dae847/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl#L79; returns `j = nothing` when `y` is `Flat`. However, I think that in general `advect_particle` is not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3545:936,ERROR,ERROR,936,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3545,1,['ERROR'],['ERROR']
Availability,"I was trying use `NetCDFOutputWriter` to write some data using the syntax that is used in the example [here](https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/) and tried the following:. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filename = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. That did not work. The error was `keyword argument filepath not assigned`. . I checked `help` it said I should be using `filepath` instead of `'filename`. Hence I tried the following, which did work. ```; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, outputs;; filepath = ""buoyancy_displacement.nc"",; schedule = TimeInterval(0.1)); ```. I am using juliav1.6 and `NCDatasets v0.12.4`, which seems to be the latest version. . Does anyone have any suggestions as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2541:414,error,error,414,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2541,1,['error'],['error']
Availability,"I was wondering if it would be advantageous to have a place dedicated to document the features that are still experimental. I think that'd make it easier for other people to contribute to those features and having them mature faster. The main motivation for me to ask this is that often users (myself included) will ask about a particular feature that's still under development (generally immersed solids or parallelism), and someone ends up describing the state of affairs at that point and pointing to a validation script and the user has to figure everything out from there. I realize all these things are available in issues and PRs, but it's hard to find the right ones and distill what's ""relevant"" information from there. I'm going through that this moment with `ImmersedBoundaryGrid`, which I'm trying to advance. I can work backwards from a given script to figure out how the implementation exists now and get a sense of to expand it, but it'd be way easier if I could read about what's implemented already, why that's the chosen implementation, bumps on the road, etc. Another motivation is that the code has grown so much lately that I sometimes see PRs/issues here about some features and I realize I simply don't recognize (and I'm fairly involved with Oceananigans' development). Some of those features might be useful for my research, or they may be things that I'd be interest in developing that I'm missing out on. Possible places to host that info would be a dedicated section of the docs possibly named ""Experimental features"", but maybe the easiest way would be allowing a wiki for that. I think discussions wouldn't be as organized. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2355:609,avail,available,609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2355,1,['avail'],['available']
Availability,"I was working on post-processing the data from a simulation I ran in Oceananigans when I decided I wanted to access the background field data from the run and write it to a netCDF4. I had tried `output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v))` as seen in my minimal working example below(please let me know if you need more details); ```; u,v,w = model.velocities. output = (;u,v,w,U=(model.background_fields.velocities.u),V=(model.background_fields.velocities.v)). simulation.output_writers[:fields] = NetCDFOutputWriter(model, output;; schedule = TimeInterval(10),; filename = ""test2.nc"",; overwrite_existing = true); ```; but kept getting this error:; ```; ERROR: LoadError: MethodError: no method matching Field(::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, NamedTuple{(:Nₒ, :S, :γ, :ϕ, :f), Tuple{Float64, Float64, Float64, Int64, Float64}}, typeof(U_func), RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}; indices::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); ```; Luckily I made a work around by changing the output to `output = (; u, v, w, U=(model.background_fields.velocities.u+0*u), V=(model.background_fields.velocities.v+0*v))` on a suggestion from a postdoc in my group who has much more experience using Oceananigans. I think the issue here is that the background fields are classified as function fields, so it may be worthwhile to create a method that converts function fields to fields or something similar to make outputting them easier.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226:699,error,error,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I wonder if it may be a good idea to add a generic, user-definable 'parameters' field in `Model`. . The main purpose of this field would be to provide the user with more flexibility for boundary condition and forcing functions. Consider the implementation of a simple sponge layer in a script:. ```julia; const dTdz = 0.01; const μ₀ = 0.02. @inline μ(z, Lz) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z) = dTdz * z. @inline FT(grid, U, Φ, i, j, k) = @inbounds -μ(grid.zC[k], grid.Lz) * (Φ.T[i, j, k] - T₀(grid.zC[k])). model = Model(forcing=Forcing(FT=FT), ...); ```. This works, of course. However, it requires the global `const`s `dTdz` and `μ₀` in order to compile on the GPU. This prevents users from, for example, defining a function of the form `create_and_run_model(μ₀, dTdz, other_parameters...)`. The only way to set `μ₀` or `dTdz` is by defining them as global `const`s; therefore a new script (or argument parsing via `ArgParse` and bash scripting) is required for each new run. I feel this is a potentially major limitation to current and future automation and we should attempt to find a solution to address the problem. One partial solution is to add a field `parameters` to the model. This field is then passed down into `calculate_interior_source_terms!` and the boundary condition algorithm to be used, if desired, within a user-defined functions. In this case, the above pattern could become:. ```julia; @inline μ(z, Lz, μ₀) = μ₀ * exp(-(z + Lz) / 0.05Lz); @inline T₀(z, dTdz) = dTdz * z. @inline FT(grid, U, Φ, i, j, k, params) = @inbounds -μ(grid.zC[k], grid.Lz, params.μ₀) * (Φ.T[i, j, k] - T₀(grid.zC[k], params.dTdz)). model = Model(forcing = Forcing(FT=FT), parameters=(μ₀=0.02, dTdz=0.01), ...); ```. We need not restrict the type of the field `parameters`; we can simply add. ```julia; mutable struct Model{P, ...}; ...; parameters :: P; end; ```. And set it to `nothing` by default in the `Model` constructor. The user may provide any kind of `parameters` they wish.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/394:1226,down,down,1226,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/394,1,['down'],['down']
Availability,"I'd like to compute a `Field` (ideally in order to write it to a NetCDF file) but only at every `N` grid points. Something like the following example, which tries to compute `u` at every 2 grid points in the vertical direction:. ```julia; using Oceananigans; grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid,); u_slices = Field(model.velocities.u, indices=(:, :, 1:2:grid.Nz)); ```. However, the above code fails since `Field` currently doesn't accept `StepRange`s as `indices`, just (I think) `UnitRange`s and `Int`s:. ```; ERROR: LoadError: MethodError: no method matching isinteger(::StepRange{Int64, Int64}). Closest candidates are:; isinteger(::Integer); @ Base number.jl:20; isinteger(::Complex); @ Base complex.jl:148; isinteger(::Rational); @ Base rational.jl:281; ... Stacktrace:; [1] validate_index(idx::StepRange{Int64, Int64}, loc::Center, topo::Bounded, N::Int64, H::Int64); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:196; [2] map (repeats 3 times); @ ./tuple.jl:318 [inlined]; [3] validate_indices(indices::Tuple{Colon, Colon, StepRange{Int64, Int64}}, loc::Tuple{DataType, DataType, DataType}, topo::Tuple{DataType, DataType, DataType}, sz::Tuple{Int64, Int64, Int64}, halo_sz::Tuple{Int64, Int64, Int64}); ```. Is there a workaround?. CC @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460:572,ERROR,ERROR,572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460,1,['ERROR'],['ERROR']
Availability,"I'd like to use the [Lambert W function](https://github.com/JuliaMath/LambertW.jl) in a `KernelFunctionOperation` but it doesn't seem to work on the GPU. Here's a MWE that works on the CPU:. ```julia; using Oceananigans; using Oceananigans.Grids: xnode, ynode; using CUDA: has_cuda_gpu; using LambertW: lambertw. arch = has_cuda_gpu() ? GPU() : CPU(); grid = RectilinearGrid(arch, size = (4, 4, 4), extent = (1,1,1)). @inline W(x, y) = lambertw((y/x)^2); @inline W(i, j, k, grid) = W(xnode(i, grid, Center()), ynode(j, grid, Center())); op = KernelFunctionOperation{Center, Center, Center}(W, grid); compute!(Field(op)); ```. When running on a GPU this throws a huge error message, that you can check in full [here](https://github.com/CliMA/Oceananigans.jl/files/14013534/error.txt), but here are the first few lines:. ```; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.AbstractOperations.gpu__compute!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Float64, typeof(W), Tuple{}}, ::Tuple{Colon, Colon, Colon}) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438:667,error,error,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'll open a PR to add a test that covers this. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.Solvers: ConjugateGradientPoissonSolver. grid = RectilinearGrid(; CPU(),; Float64,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0); ). ConjugateGradientPoissonSolver(grid); ```. Error:. ```; ERROR: UndefVarError: `ImmersedBoundaryGrid` not defined; Stacktrace:; [1] ConjugateGradientPoissonSolver(grid::RectilinearGrid{…}; preconditioner::Oceananigans.Solvers.DefaultPreconditioner, reltol::Float64, abstol::Float64, kw::@Kwargs{}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:54; [2] ConjugateGradientPoissonSolver(grid::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{…}}, CPU}); @ Oceananigans.Solvers ~/atdepth/Oceananigans.jl/src/Solvers/conjugate_gradient_poisson_solver.jl:47; [3] top-level scope; @ REPL[6]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3829:339,Error,Error,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3829,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,"I'm encountering an odd behavior when creating a `NetCDFWriter`. In the example below `writer2` gets created successfully, but `writer1` does not. . ```julia; using Oceananigans. N = 4; grid = RectilinearGrid(topology = (Periodic, Periodic, Periodic),; size = (N, N, N),; extent = (1,1,1)). model = NonhydrostaticModel(; grid,). u, v, w = model.velocities; indices = (1,:,:); slice1 = Field(u, indices=indices); slice2 = Field(u). writer2 = NetCDFOutputWriter(model, (; slice2,);; filename = ""mwe2.nc"",; schedule = TimeInterval(1),; overwrite_existing = true,; indices=indices,; ). writer1 = NetCDFOutputWriter(model, (; slice1,),; filename = ""mwe1.nc"",; schedule = TimeInterval(1),; overwrite_existing = true); ```. When running this I get this error:. ```; ERROR: LoadError: BoundsError: attempt to access 1×10×10 view(::Array{Float64, 3}, 4:4, :, :) with eltype Float64 at index [4:7, 4:7, 4:7]; Stacktrace:; [1] throw_boundserror(A::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; @ ./subarray.jl:177 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}}, loc::Tuple{DataType, DataType, DataType}, grid::RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{UnitRange{Int64}, UnitRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2497:746,error,error,746,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2497,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm faced with an error when trying to `show()` a model with the `SmagorisnkyLilly()` closure:. ```julia; julia> grid = RectilinearGrid(CPU(), size=(1,1,1), extent=(1,1,1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> closure = SmagorinskyLilly(); SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model = NonhydrostaticModel(grid=grid; closure=SmagorinskyLilly()); Error showing value of type NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398:18,error,error,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398,2,"['Error', 'error']","['Error', 'error']"
Availability,"I'm facing an error that I'm not able to pinpoint. Running the following example on a CPU works, but I get an error on GPUs:. ```julia; using Oceananigans; using CUDA. arch = has_cuda_gpu() ? GPU() : CPU(). grid_base = RectilinearGrid(arch, size=(4, 4, 4), extent=(1, 1, 1)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). noflux = FluxBoundaryCondition(0); b_bcs = FieldBoundaryConditions(immersed=noflux). model = NonhydrostaticModel(grid = grid,; buoyancy = BuoyancyTracer(),; tracers = :b,; boundary_conditions = (b=b_bcs,),; ). simulation = Simulation(model, Δt=1, stop_iteration=100); run!(simulation); ```. The error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gc!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gc!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, Nothing}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, Val{1}, CenteredSecondOrder, Nothing, ImmersedBoundaryCondition{Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm finding that simulations with `VerticallyStretchedGrid`s don't get picked up and instead throw an error saying that the grid doesn't match. Here's a MWE:. ```julia; using Oceananigans. grid = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). model = NonhydrostaticModel(grid=grid). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:102,error,error,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,2,"['Checkpoint', 'error']","['Checkpointer', 'error']"
Availability,"I'm following the documentation so either we have a bug or the documentation needs to be clearer on how to use `JLD2OutputWriter` with named tuples. ```julia; using Oceananigans, Oceananigans.OutputWriters; grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1)); model = Model(grid=grid); outputs = (u=model->model.velocities.u, T=model->model.tracers.T); model.output_writers[:jld2] = JLD2OutputWriter(model, outputs; frequency=1, prefix=""test"", verbose=true); time_step!(model; Δt=1, Nt=1); ```; produces; ```; [ Info: Calculating JLD2 output (:u, :T)...; ERROR: MethodError: Cannot `convert` an object of type Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} to an object of type Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}} ; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:168; Stacktrace:; [1] setindex!(::Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}, ::Field{Oceananigans.Cell,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol) at ./dict.jl:380; [2] Dict{Symbol,Field{Oceananigans.Face,Oceananigans.Cell,Oceananigans.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}(::Base.Generator{Base.Iterators.Zip{Tuple{Tuple{Symbol,Symbol},Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/562:568,ERROR,ERROR,568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/562,1,['ERROR'],['ERROR']
Availability,"I'm getting an error when trying to compile constant Smagorinsky:. ```julia; ERROR: LoadError: InvalidIRError: compiling #12(RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Flo; at64},Base.TwicePrecision{Float64}}}, PlanetaryConstants{Float64}, LinearEquationOfState{Float64}, ConstantSmagorinsky{Fl; oat64}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global; }, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248:15,error,error,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I'm getting an error while running the following example on a GPU, it runs correctly on CPU though. It has a problem with the immersed boundary conditions, but the same BC on the normal boundary doesn't throw the error.; ```; using CUDA; using Oceananigans. arch = has_cuda_gpu() ? GPU() : CPU(); topo = [Flat, Periodic, Bounded] ; underlying_grid = RectilinearGrid(arch, size = (1,1), ; extent = (1, 1),; topology = topo). @inline slope(x, y) = -2.0*y; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). z₀ = 1e-2 # Charnock roughness; κ = 0.4 # Von Karman constant; @inline Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2; const dz = 0.1. @inline bottom_drag_v(x, y, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); @inline bottom_drag_v(x, y, z, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); v_drag_bc = FluxBoundaryCondition(bottom_drag_v, field_dependencies=(:v, :w), parameters=Cᴰ(dz)); v_bcs = FieldBoundaryConditions(bottom=v_drag_bc, immersed=v_drag_bc). boundary_conditions = (; v = v_bcs,). model = NonhydrostaticModel(grid = immersed_grid, ; boundary_conditions = boundary_conditions). simulation = Simulation(model, Δt = 0.1, stop_time = 1.0); run!(simulation); ```; Error, truncated stack trace for length:. ```; GPU compilation of kernel gpu_calculate_Gv!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gv!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:15,error,error,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,2,['error'],['error']
Availability,"I'm getting results that are different from what I expected. Here's how I'm setting my grid, model and sponge:. ```; #-----; Lx = Ly = 16_000; Lz = 1_000; topology = (Periodic, Periodic, Bounded); factor = 1; grid = RegularCartesianGrid(size=(2048÷factor, 1, 256÷factor),; x=(0, Lx),; y=(0, 1),; z=(-Lz/2, +Lz/2),; topology=topology); #-----. #-----; ubc = UVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); vbc = VVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); wbc = WVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Value, 0),; top = BoundaryCondition(Value, 0),; ); bbc = TracerBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, N2),; top = BoundaryCondition(Gradient, N2),; ); #-----. #-----; # Set-up sponge layer; bottom_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bottom_mask, target=0); #----. model = IncompressibleModel(; architecture = GPU(),; grid = grid,; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; coriolis = FPlane(f=f0),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; boundary_conditions = (b=bbc, u=ubc, v=vbc, w=wbc),; forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge),; ```. From the docs, I expected this to ; > relax velocity fields to zero [...] in the bottom 1/10th of the domain. which leads me to believe that there's some a sharp cut-off in the function mask so that velocities above the range `[-500, -400]`aren't affected. However, when I plot the vertical velocities (and other variables with zero mean) I get the results below, which indicate that the sponge layer is active in the approximate range `[-500, -200]`, which is around 3 times larger than what I (thought I) set up. ![Screenshot from 2020-11-24 08-45-47](https://user-images.githubuserconte",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203:1181,mask,mask,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203,1,['mask'],['mask']
Availability,"I'm not sure if we're officially supporting Julia 1.6 yet, but I noticed that when I create a `Checkpointer` in Julia 1.6 things don't really work. All other output files are created normally (meaning for me NetCDF files) but the checkpoint never does and the simulation just hangs there. ```julia; Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (TimeStepWizard{Float64}): 2.747 seconds ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: 300.0; ├── Stop time: 7.272 days, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── out_writer => typename(NetCDFOutputWriter); │ ├── vid_writer => typename(NetCDFOutputWriter); │ ├── avg_writer => typename(NetCDFOutputWriter); │ └── chk_writer => typename(Checkpointer). ---> Starting run!; ```. I waited for over 15 min but the next lines (which are supposed to be the progress messenger) never come up. Everything works normally when I revert back to Julia 1.5.3. . I don't have time to create a clean reproducible MWE at the moment, but I can do so later if needed. I just thought I should post this while it's fresh in my head.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547:95,Checkpoint,Checkpointer,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547,3,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint']"
Availability,"I'm trying to add some particles to a hydrostatic model on a lat-lon grid, but ran into some CUDA memory issues. After reducing down to a MWE I noticed that it also segfaults on the CPU. The MWE seems to be sensitive to the exact grid. Some lat-lon ranges lead to illegal memory accesses and others do not. I could not find a pattern though. On the CPU the segfault seems to occur after ~2 iterations. On the GPU after ~29 iterations. The particles are initialized within the domain and without any dynamics the particles should stay perfectly still. So I'm not sure where the illegal memory access is happening, but should be easy to debug on the CPU?. MWE:. ```julia; using Oceananigans; using Oceananigans.Architectures: on_architecture. arch = GPU(). H = 100. Nλ = 100; Nφ = 200; Nz = 60. grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (Nλ, Nφ, Nz),; longitude = (0.79, 1.23),; latitude = (-1.96, -1.12),; z = (-H, 0),; halo = (4, 4, 4); ). Np = 100 # Number of particles. particles = LagrangianParticles(; x = on_architecture(arch, 1 * ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:128,down,down,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['down'],['down']
Availability,"I'm trying to build the docs locally because I want to resolve https://github.com/CliMA/Oceananigans.jl/issues/1478. I followed the instructions in [the docs](https://clima.github.io/OceananigansDocumentation/stable/contributing/#Documentation) but I'm not able to generate `index.html`. Here's a pastebin with the first few errors that appear: https://pastebin.com/25A8SqeX. It looks like the doc generator is comparing the actual output with some expected output? Is that something the docs should do?. Anyway, I've never built julia docs before so I'm kinda unfamiliar with this. Help is appreciated!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1542:325,error,errors,325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542,1,['error'],['errors']
Availability,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281:223,error,errors,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281,4,"['Avail', 'error']","['Available', 'errors']"
Availability,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:712,ERROR,ERROR,712,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['ERROR'],['ERROR']
Availability,"I'm trying to run the hot bubble example but using a GPU. However I get an error when defining the model that I cannot understand (the caveat here being that I have zero experience working with GPUs). The minimum code to reproduce this is. ```; using Oceananigans; model = BasicModel(N=(256, 1, 256), L=(2000, 1, 2000), architecture=GPU(), ν=4e-2, κ=4e-2); ```. This is the error that I get:. ```; ERROR: LoadError: Device capability v2.1.0 not supported by available toolchain; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] supported_capability(::CUDAdrv.CuDevice) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/utils.jl:7; [3] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:388 [inlined]; [4] #cufunction#176(::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(CUDAnative.cufunction), ::getfield(GPUArrays, Symbol(""##23#24"")), ::Type{Tuple{CuArrays.CuKernelState,CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}}) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [5] cufunction(::Function, ::Type) at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:357; [6] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:174 [inlined]; [7] macro expansion at ./gcutils.jl:87 [inlined]; [8] macro expansion at /home/tomaschor/.julia/packages/CUDAnative/Lr0yj/src/execution.jl:171 [inlined]; [9] _gpu_call(::CuArrays.CuArrayBackend, ::Function, ::CuArrays.CuArray{Float64,3}, ::Tuple{CuArrays.CuArray{Float64,3},Base.Broadcast.Broadcasted{Nothing,Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Int64}}}, ::Tuple{Tuple{Int64},Tuple{Int64}}) at /home/tomaschor/.julia/packages/CuArrays/wXQp8/src/gpuarray_interface.jl:60; [10] gpu_call(::Function, ::CuArrays.CuArray{Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/451:75,error,error,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/451,6,"['ERROR', 'avail', 'error']","['ERROR', 'available', 'error']"
Availability,"I'm trying to validate a tilted bottom boundary layer example for https://github.com/CliMA/Oceananigans.jl/pull/1242 and I'm trying to use a `VerticallyStretchedGrid` to save computational resource (since I'm trying to do it on my laptop). I noticed that the simulation fails when using the `TimeStepWizard`:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::Array{Float64,3}, ::Array{Float64,3}, ::Array{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}) at /home/tomas/repos2/Oceananigans.jl/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:320,ERROR,ERROR,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['ERROR'],['ERROR']
Availability,"I've been facing an error using CUDA versions 3.10 and up that's been very hard for me to pinpoint. . It's pretty hard to come up with a _truly minimum_ working example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,5,"['down', 'error']","['down', 'error']"
Availability,"I've been trying to run [this code](https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/benchmark/distributed_nonhydrostatic_model_mpi.jl), and I get an error depending on the number of points and ranks I choose in each direction. For example I noticed that when `Nx*Rx == Ny*Ry == Nz*Rz` the code runs successfully. But if that condition isn't satisfied (for example if I set `Nx=Ny=Nz=8`, `Rx=Rz=1` and `Ry=2`) I get an error like this:. ```; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension wi""arrays could not be broadcast to a common size; got a dimension with lengths 8 andth lengths 8 and 4"") 4""); Stacktrace:; [1] ; Stacktrace:; [1] _bcs1_bcs1; @ ./; @ ./broadcast.jl:broadcast.jl:501 [inlined]; 501 [inlined]; [2] [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:Base.Broadcast ./broadcast.jl:495; [3]495; [3] broadcast_shape; @ broadcast_shape; @ ././broadcast.jl:broadcast.jl:489489 [inlined]; [inlined]; [4] [4] combine_axes combine_axes; @ ; @ ././broadcast.jl:broadcast.jl:484 [inlined]484 [inlined]. [5] [5] _axes_axes; @ ./; @ ./broadcast.jl:209broadcast.jl:209 [inlined]; [6] [inlined]; [6] axes; @ axes; @ ././broadcast.jl:207broadcast.jl:207 [inlined]; [inlined]; [7] [7] _unwrap_pa(bc::_unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445:188,error,error,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"I've been using `FieldTimeSeries` a lot over the last few weeks and have noticed a couple of issues calculating means and constructing operations on them. First, `mean` with `dims` only calculates it on the first time index (I think). For example, if I do `mean(f, dims = (1, 2, 3))` it returns a size `[1, 1, 1]` array vs calculating `mean(interior(f), dims = (1, 2, 3))` which returns a `[1, 1, 1, Nt]` array. I suspect it is also calculating means with no dimensions specified incorrectly. Second, constructing operators on field time series fails and returns operators with dimensions `[Nx, Ny, Nz]` which if you then try and index into fails as it tries to index into the underlying fields which have a time dimension. For example, `speed = √(u^2 + v^2 + w^2)` gives `speed` with size `[Nx, Ny, Nz]`, if I then try and index at `[1, 1, 1]` it throws a bounds error trying to access `Nx x Ny x Nz x Nt` array at `1, 1, 1`. Neither of these is particularly important but thought I would document in case anyone else has issues, and because I will try and fix them at some point. For reference, I am currently getting around this by calculating means on the interior (which I think would produce the wrong results with immersed boundaries because it wouldn't have the masking step), and by just calculating arrays like `speed = √(interior(u)^2 + interior(v)^2 + interior(w)^2)` which doesn't lose me too much performance since I end up indexing into the whole array anyway.; ```[tasklist]; ### Tasks; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3144:864,error,error,864,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3144,2,"['error', 'mask']","['error', 'masking']"
Availability,"I've been using `WindowedTimeAverage`s for my simulations (by setting `schedule = AveragedTimeInterval(...)` in a `NetCDFOutputWriter`). I noticed that whenever I run out of walltime and have to checkpoint my simulations, when I pick them up again I get the following warning for each of the time-averaged outputs:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters /glade/work/tomasc/.julia/packages/Oceananigans/3LHMs/src/OutputWriters/windowed_time_average.jl:201; ```; (which comes from [this call](https://github.com/CliMA/Oceananigans.jl/blob/f2511962ca15f3aaf87d2571e3551e59dc05c694/src/OutputWriters/windowed_time_average.jl#L196-L204).). Does this mean that the time averages aren't being correctly calculated after picking up? I tried following the trail to figure it out but couldn't determine the answer...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485:195,checkpoint,checkpoint,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485,1,['checkpoint'],['checkpoint']
Availability,"I've noticed that Oceananigans is _much_ slower when using forcing functions. As an example, I set-up a simulation without any forcing functions and I noticed that in the first minute (wall time) of the running simulation I complete 3.5% of the whole simulation period. However, if I include forcing functions as; ```julia; bot_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bot_mask, target=0); forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge); ```; then in the first (wall time) minute of running I complete only 0.15% of the simulation. Basically around 20 times slower!. I of course expected a slowdown after including forcing functions, but not by this much. Is this normal behavior?. So far I ran my tests only on CPUs, but I've observed similar behaviors on GPUs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827:442,mask,mask,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827,1,['mask'],['mask']
Availability,"I've received an error possibly related to the preconditioner, and it appears when I set the initial condition, e.g., `set!(model, u=uᵢ)`:; ```; ERROR: MethodError: no method matching cpu_fourier_tridiagonal_preconditioner_rhs!(::KernelAbstractions.CompilerMetadata{…}, ::Array{…}, ::Oceananigans.Grids.ZDirection, ::Field{…}). Closest candidates are:; cpu_fourier_tridiagonal_preconditioner_rhs!(::Any, ::Any, ::Oceananigans.Grids.ZDirection, ::Any, ::Any); @ Oceananigans none:0; cpu_fourier_tridiagonal_preconditioner_rhs!(::Any, ::Any, ::Oceananigans.Grids.YDirection, ::Any, ::Any); @ Oceananigans none:0; cpu_fourier_tridiagonal_preconditioner_rhs!(::Any, ::Any, ::Oceananigans.Grids.XDirection, ::Any, ::Any); @ Oceananigans none:0. Stacktrace:; [1] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [2] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; [3] (::KernelAbstractions.Kernel{…})(::Array{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; [4] (::KernelAbstractions.Kernel{…})(::Array{…}, ::Vararg{…}); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; [5] #_launch!#12; @ ~/.julia/packages/Oceananigans/HPOLD/src/Utils/kernel_launching.jl:286 [inlined]; [6] _launch!; @ ~/.julia/packages/Oceananigans/HPOLD/src/Utils/kernel_launching.jl:268 [inlined]; [7] launch!; @ ~/.julia/packages/Oceananigans/HPOLD/src/Utils/kernel_launching.jl:251 [inlined]; [8] compute_precondition",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"If you use the same script for checkpointing and pickup (i.e. you just keep running the same script) then `run!(simulation, pickup=true)` will fail the first time:. ```julia; julia> using Oceananigans;; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1));; julia> model = IncompressibleModel(grid=grid);; julia> simulation = Simulation(model, Δt=60, stop_time=60); julia> run!(simulation, pickup=true); ```. ```; ERROR: No checkpointers found: cannot pickup simulation!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] checkpoint_path(::Bool, ::Array{Oceananigans.AbstractOutputWriter,1}) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:158; [3] run!(::Simulation{IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1159:31,checkpoint,checkpointing,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159,5,"['ERROR', 'checkpoint', 'error']","['ERROR', 'checkpointers', 'checkpointing', 'error']"
Availability,"Implementing a vertically stretched grid (see PR #543) involves adding new Poisson solvers. This offers us a chance to:; 1. refactor the Poisson solvers into a more flexible API,; 2. support triply periodic and 3D box domains,; 3. unite some of the CPU and GPU Poisson solvers,; 4. reuse the Poisson solvers to implicitly time-step diffusion (vertically and possibly in 3D) in the future, and; 5. slide in (or dispatch on) a distributed pressure solve for distributed/MPI models without having to modify the time stepping code for regular models in the future. I am just throwing down some notes and ideas in this issue. This table summarizes the different boundary conditions and grids we may want to simulate, and the Poisson solver algorithm we would need. | Boundary conditions | Grid | Solver | Alternatives |; |----------------------|-----------------------|:-----------:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:580,down,down,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['down'],['down']
Availability,"In PR #715 (commit https://github.com/climate-machine/Oceananigans.jl/pull/715/commits/df22124af635970f9f46e9706c6b8694fcc921da) I skipped the kinetic energy multiary test as it was giving some weird CUDA error:. ```; Multiary computations [Float64, GPU]: Error During Test at /builds/JuliaGPU/Oceananigans-jl/test/test_abstract_operations.jl:399; Test threw exception; Expression: compute_kinetic_energy(model); CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE); ```. We should revisit this issue when we can. It's weird because the test used to work... Build log for more information: https://gitlab.com/JuliaGPU/Oceananigans-jl/-/jobs/510398403",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/732:205,error,error,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/732,3,"['Error', 'error']","['Error', 'error']"
Availability,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/942:326,toler,tolerance,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942,2,['toler'],['tolerance']
Availability,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3318:1286,error,error,1286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318,1,['error'],['error']
Availability,"In case we have reductions on a function (e.g `maximum(abs, f, condition = (i, j, k, f.grid, f) -> i < 3)`) we want to be able to apply the function to the field _first_ and mask the field where `condition = true` _after_. _to be more specific:_; When a reduction is called with a function as an argument such as; ```; sum(sin, a::AbstractField); ```; the function will be evaluated element-wise with `mapreduce`. i.e., the function is applied _first_ and the reduction is applied _after_; ```; mapreduce(x -> sin(x), +, a); ```; For this reason the `neutral_element` of a ""functional"" reduction is not the `neutral_element` of its basic operation (as we implemented) but the neutral element of `basic_operation(f())`. The neutral element is found by inverting this operation `f⁻¹(neutral_element(basic_operation))` In the example above it would be; ```; neutral_element = sin⁻¹(neutral_element(+)) = sin⁻¹(0); ```. In principle, we should mask the field with `f⁻¹(neutral_element(reduction))` so that applying `f` and then the reduction would effectively exclude the masked areas. Unfortunately, we do not know a-priori the inverse of the function. Therefore, this PR implements a workaround:. - `ConditionalOperation` has now a property `func`, which is a unary function applied to the elements of `operand` in `Base.getindex`; - functional reductions are implemented as `sum(f, c; condition) = sum(identity, conditional_operand(f, c, condition))` . this PR also introduces a docstring and a `show` method for `ConditionalOperation` ; closes #2188",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2200:174,mask,mask,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2200,3,['mask'],"['mask', 'masked']"
Availability,"In my attempt to study inertial instability I have two versions of the code. 1. Takes the solution to be a sum of the background and the perturbations, and **evolves the total** field. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/NoDecomposition/Bickley_Gaussian_jet_total.jl); 2. Stores the basic state in `BackgroundField` and **evolves the perturbation**, like the Eady problem. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/Bickley_Gaussian_jet.jl). Actually, the first one uses `BackgroundField` for the background stratification, but not for the jet. Since evolving a solution that uses `BackgroundField` has three times as many advection terms, and in this 2D scenario advection is probably the most costly, I was expecting the slow down to be a factor of `3`. What I actually find is a slow down of `16`!?. Is this to be expected?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564:847,down,down,847,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564,2,['down'],['down']
Availability,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2358:479,error,error,479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358,4,['error'],['error']
Availability,"In some scripts manually checkpointing, e.g. at the end, is useful so having a `checkpoint(simulation)` function would be nice.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1249:25,checkpoint,checkpointing,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249,2,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,"In the example below, the model crashes reporting a GPU illegal memory access error. The CFL number is intentionally set to a large value, under which the model will encounter numerical instability. I expect this model should abort itself when NANs appear instead of crashing due to a memory illegal access error. Besides, this only happens when I use Lagrangian particles. If not, the model will terminate by itself as I expect. I have also verified that the model does not crash when the CFL number is small. ``` Julia; using Oceananigans. const Lx = 1.0; const Nx = 50; const Δx = Lx / Nx; const max_velocity = 1.0; const cfl = 10.0; const Δt = cfl * Δx / max_velocity. function initial_u(x::R, y::R, z::R) where {R<:Real}; return (max_velocity / Lx) * y; end. grid = RectilinearGrid(; GPU(),; size = (Nx, Nx, Nx),; x = (0.0, Lx),; y = (0.0, Lx),; z = (0.0, Lx),; topology = (Periodic, Bounded, Bounded); ). arch_array = Oceananigans.Architectures.array_type(GPU()){Float64}; n_particles = 1000. xs = convert(arch_array, zeros((n_particles, ))); ys = convert(arch_array, LinRange(0.0, Lx, n_particles)); zs = convert(arch_array, zeros((n_particles, ))). particles = LagrangianParticles(x = xs, y = ys, z = zs). model = NonhydrostaticModel(;; grid,; particles = particles,; ). set!(model, u = initial_u). simulation = Simulation(model; Δt = Δt, stop_iteration = 200). run!(simulation); ```. The [output.log](https://github.com/CliMA/Oceananigans.jl/files/12835930/output.log) is uploaded as a file. Test environment:; - Julia version: v1.9.3; - Oceananigans: v0.89.0; - Tested on Ubuntu 20.04.6 LTS with CUDA 12.0 and MIT Satori with CUDA 11.4. This example tries to reproduce some of my simulations for convection. In these simulation, I used strong heating, and therefore I expect some of them to crash. However, I did not expect that they would trigger GPU illegal memory access errors. This issue is probably related to #3267.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320:78,error,error,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320,3,['error'],"['error', 'errors']"
Availability,"In the general case of a pre-computed grid or mesh, the `architecture` on which the grid is stored has be known. Thus in general, the `architecture` of a grid must be provided. The few special cases to this rule are grids with metrics that are either constant or can be computed on the fly, like `RegularRectilinearGrid`. Up to recently `RegularRectilinearGrid` was the only option, so we hadn't the motivation to ponder whether `architecture` belonged as a model property, field property, or grid property... Putting `architecture` in `grid` would mean that we don't have to specify it in model constructors. Since `grid` is so central we wouldn't really need `architecture` as a property anywhere else. For example, we wouldn't need to store `architecture` in every.single.field object, as we do now. Alleviating this boilerplate makes the change feel especially right... The main downside is a loss of flexibility for those grids that are truly architecture-independent, like `RegularRectilinearGrid` and `RegularLatitudeLongitudeGrid`. On the other hand, we have to specify `architecture` somewhere and rarely helpful to mix `CPU` and `GPU` computations using the same grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825:883,down,downside,883,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825,1,['down'],['downside']
Availability,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1077:1537,Checkpoint,Checkpointer,1537,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077,1,['Checkpoint'],['Checkpointer']
Availability,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/799:281,error,error,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799,2,"['error', 'failure']","['error', 'failure']"
Availability,"In this PR I'm exploring the possibility of adding methods for `diffusive_flux_x`, and `viscous_flux_ux` (along with other directions) for tuples. This is needed when reconstructing tracer variance and kinetic energy dissipation rates for tuples in a conservative formulation and, specifically, it's used in Oceanostics for that end (see https://github.com/tomchor/Oceanostics.jl/pull/112). At the moment these are [defined in Oceanostics](https://github.com/tomchor/Oceanostics.jl/blob/1264b4d61e00ab2fb2fd648d489e5fcd329a135c/src/FlowDiagnostics.jl#L347-L355), but as @glwagner mentioned [here](https://github.com/tomchor/Oceanostics.jl/pull/112#issuecomment-1479761310), this isn't ideal since in the future the behavior of the relevant functions may change in Oceananigans and subsequently this calculation will break in Oceanostics. The downside of defining these methods here is that it adds to the testing infrastructure, but I think the way I currently implemented the tests it doesn't contribute too negatively to this. I'm also proposing removing the fallback method here: https://github.com/CliMA/Oceananigans.jl/blob/200f0622278fcfa583da0119e9696048b334146f/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L154-L169. The reason is that I think these general fallback methods cause for hassle than they solve for less experienced Oceananigans developers (myself very much included) by silently returning something physically reasonable (zero in this case) for virtually any combination of arguments, which can be misleading in a debugging process. But I'm curious to get other people's opinion on this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3057:842,down,downside,842,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3057,1,['down'],['downside']
Availability,Increase tolerance for tracer conservation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/400:9,toler,tolerance,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/400,1,['toler'],['tolerance']
Availability,Increase tolerance in implicit free surface solver tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1686:9,toler,tolerance,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1686,1,['toler'],['tolerance']
Availability,Increase tolerance on `FieldTimeSeries` reduction tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1688:9,toler,tolerance,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1688,1,['toler'],['tolerance']
Availability,Increase ≈ tolerance to account for differences across GPU microarchitectures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179:11,toler,tolerance,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179,1,['toler'],['tolerance']
Availability,"Index computations inside`Field` constructors are wrong on `MultiArch`. As a result, this script. ```julia; using MPI; using Oceananigans; using Oceananigans.Distributed. MPI.Init(). comm = MPI.COMM_WORLD; rank = MPI.Comm_rank(comm); Nranks = MPI.Comm_size(comm). topology = (Periodic, Periodic, Flat); arch = MultiArch(CPU(); topology, ranks=(1, Nranks, 1)); grid = RectilinearGrid(arch; topology, size=(16, 16), halo=(3, 3), extent=(2π, 2π)). model = NonhydrostaticModel(; grid). uᵢ = rand(size(grid)...); vᵢ = rand(size(grid)...); set!(model, u=uᵢ, v=vᵢ). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u). simulation = Simulation(model, Δt=0.01, stop_iteration=3). simulation.output_writers[:fields] = JLD2OutputWriter(model, merge(model.velocities, (; ζ)),; schedule = IterationInterval(1),; with_halos = false,; prefix = ""test_output_writing_rank$rank"",; force = true). run!(simulation); ```. which is run with. ```; JULIA_NUM_THREADS=1 mpiexec -n 2 julia --project mpi_output_writing.jl; ```. errors with a huge stack trace... part of which is. ```; caused by: BoundsError: attempt to access 16×8×1 Array{Float64, 3} at index [1:16, 9:11, 1:1]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] view; ```. However, if `with_halos=true` we're fine... I think. The index computation is clearly wrong (when we have `with_halos=false`, we compute the indices we want to output in the output writer constructor), but the confusing thing is that this only an issue for `ζ` from the output works. Needs to be investigated. Here's the index computation:. https://github.com/CliMA/Oceananigans.jl/blob/6ceeb012f1432bf936edd977fa1390dc694a0adc/src/OutputWriters/output_construction.jl#L32-L41",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2352:996,error,errors,996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2352,1,['error'],['errors']
Availability,Informative error message for non-regularly spaced grids in `NonhydrostaticModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2946:12,error,error,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2946,1,['error'],['error']
Availability,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:346,error,error,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,2,['error'],['error']
Availability,Integer division error in `solve!` on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['error'],['error']
Availability,"Interacting with modeling software via scripts is novel for some users. We (and many others) are accumulating knowledge in this area, including:. * Scripting philosophy and its advantages.; * Literate scripting style for ""paper-like"" code, tutorials and pedagogical applications.; * Best practices for parameter exploration (eg how to replicate the functionality of a parameter file or namelist in your script, and why divorcing parameter lists from model setup should be considered carefully).; * Best practices for reproducibility (naming conventions, using output directories, checkpointing, script reuse).; * The use of external packages to achieve these goals (like `ArgParse`, or perhaps `DrWatson`). Oceananigans tries to give users great power and flexibility for designing numerical experiments. However, with this power comes great responsibility for users to write and use their scripts for Good. We can possibly help by adding some documentation. I also think the writers of said documentation might benefit if said documentation stimulates community input / outside contributions to these best practices. cc @ali-ramadhan @navidcy @kpamnany @kburns",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1127:580,checkpoint,checkpointing,580,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1127,1,['checkpoint'],['checkpointing']
Availability,Is `Architectures.next_stream()` redundant?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2748:33,redundant,redundant,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2748,1,['redundant'],['redundant']
Availability,Is `calc_∇²!` redundant in view of `compute_∇²!`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2638:14,redundant,redundant,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2638,1,['redundant'],['redundant']
Availability,Is something like this useful? See how they look at https://github.com/CliMA/Oceananigans.jl/tree/ncc/readme-downloads,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3652:109,down,downloads,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3652,1,['down'],['downloads']
Availability,"Is this correct?. https://github.com/CliMA/Oceananigans.jl/blob/adffd0cb67373da364a54d7f300d1f33817539bd/src/ImmersedBoundaries/mask_immersed_field.jl#L53. I'd expect it to use `solid_node` for masking scalars. Right?. For masking velocity fields for the purpose of enforcing impenetrable boundary conditions, it makes sense to me that we'd use `solid_interface`. But we should have a separate function for that. In reality, we only _need_ masking for the velocity field for our algorithm to work correctly. However, being able to mask scalars is sometimes useful for development purposes. @simone-silvestri can you shed some light?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2249:194,mask,masking,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2249,4,['mask'],"['mask', 'masking']"
Availability,Is this redundant? If there is no CUDA-enabled GPU then how could a `grid` on GPU be provided as constructor argument?. https://github.com/CliMA/Oceananigans.jl/blob/d675d8b9f7359219941fa81ce098eb51b7c5ac8f/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L125-L127,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2595:8,redundant,redundant,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2595,1,['redundant'],['redundant']
Availability,"It looks like that restarting from a checkpoint is not bit-for-bit? I think the issue is that when restarting from a checkpoint the time step is not restored -- it is still using the initial time step defined in `Simulation()`, not the `last_Δt` from the saved `Clock` object in the checkpoint file. See the example below, which is the output of the attached test case. . In the pickup run I changed the onscreen output from every 10 iterations to every 1 iterations to see the time step. Rather than using the previous time step (5.973 s) from the checkpoint, the pickup run is using a time step of 10 s which is the value when defining `simulation = Simulation(model, Δt=10, stop_iteration=220)`. I’m using v0.91.5. Initial run; ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, max(|u|) = 2.5e-01 ms⁻¹, wall time: 0 seconds; [ Info: ... simulation initialization complete (13.909 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (4.696 seconds).; Iteration: 0010, time: 1.833 minutes, Δt: 11.212 seconds, max(|u|) = 2.6e-01 ms⁻¹, wall time: 19.116 seconds; Iteration: 0020, time: 3.702 minutes, Δt: 10.681 seconds, max(|u|) = 2.8e-01 ms⁻¹, wall time: 19.345 seconds; Iteration: 0030, time: 5.482 minutes, Δt: 10.215 seconds, max(|u|) = 2.9e-01 ms⁻¹, wall time: 19.629 seconds; Iteration: 0040, time: 7.185 minutes, Δt: 9.802 seconds, max(|u|) = 3.0e-01 ms⁻¹, wall time: 19.854 seconds; Iteration: 0050, time: 8.819 minutes, Δt: 9.433 seconds, max(|u|) = 3.1e-01 ms⁻¹, wall time: 20.082 seconds; Iteration: 0060, time: 10.391 minutes, Δt: 9.100 seconds, max(|u|) = 3.2e-01 ms⁻¹, wall time: 20.306 seconds; Iteration: 0070, time: 11.907 minutes, Δt: 8.798 seconds, max(|u|) = 3.3e-01 ms⁻¹, wall time: 20.559 seconds; Iteration: 0080, time: 13.374 minutes, Δt: 8.523 seconds, max(|u|) = 3.4e-01 ms⁻¹, wall time: 20.773 seconds; Iteration: 0090, time: 14.794 minutes, Δt: 8.270 seconds, max(|u|) = 3.5e-01 ms⁻¹, wall time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3845:37,checkpoint,checkpoint,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845,4,['checkpoint'],['checkpoint']
Availability,"It looks like the Langmuir turbulence example is broken (the video generated in the documentation is blank and it does not run on my computer). I think it may be these two lines where the halo regions for each variable are manually removed, but Oceananigans seems to have already extracted those halo regions. This causes the variable and coordinate arrays to be different sizes, leading to a plotting error. https://github.com/CliMA/Oceananigans.jl/blob/24e9c2c3c85cc092913989d6c88d38046998aa07/examples/langmuir_turbulence.jl#L277-L278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1004:402,error,error,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1004,1,['error'],['error']
Availability,"It'd be nice to implement the 'Orlanski' boundary condition for open boundaries:. https://www.sciencedirect.com/science/article/pii/0021999183901274. For this to work properly, we need to modify the pressure solver to work for time-dependent inflows. We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf. This would allow us to simulate the spatial development of a boundary layer, a la . https://iopscience.iop.org/article/10.1088/1742-6596/318/2/022023/meta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/833:405,down,download,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833,1,['down'],['download']
Availability,"It's a bug:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat)); 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.333333; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.333333; └── Flat z. julia> ct = FieldTimeSeries{Center, Center, Center}(grid, (0, 1)); 3×3×1×2 FieldTimeSeries{InMemory} located at (Center, Center, Center) on CPU; ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── indices: (:, :, :); ├── time_indexing: Linear(); ├── backend: InMemory(); └── data: 9×9×1×2 OffsetArray(::Array{Float64, 4}, -2:6, -2:6, 1:1, 1:2) with eltype Float64 with indices -2:6×-2:6×1:1×1:2; └── max=0.0, min=0.0, mean=0.0. julia> view(ct[1], :, :, 1); ERROR: MethodError: no method matching topology(::Tuple{Colon, Colon, UnitRange{Int64}}). Closest candidates are:; topology(::Any, ::Any); @ Oceananigans ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:59; topology(::Oceananigans.Fields.AbstractField, Any...); @ Oceananigans ~/Projects/Oceananigans.jl/src/Fields/abstract_field.jl:47; topology(::Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ}) where {FT, TX, TY, TZ}; @ Oceananigans ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:52. Stacktrace:; [1] topology; @ ~/Projects/Oceananigans.jl/src/Grids/grid_utils.jl:59 [inlined]; [2] FieldBoundaryConditions(grid::Tuple{Colon, Colon, UnitRange{Int64}}, location::Nothing, indices::Tuple{Colon, Colon, Colon}); @ Oceananigans.BoundaryConditions ~/Projects/Oceananigans.jl/src/BoundaryConditions/field_boundary_conditions.jl:135; [3] view(f::Field{…}, i::Function, j::Function, k::Int64); @ Oceananigans.Fields ~/Projects/Oceananigans.jl/src/Fields/field.jl:326; [4] top-level scope; @ REPL[13]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3687:870,ERROR,ERROR,870,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3687,1,['ERROR'],['ERROR']
Availability,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:119,redundant,redundant,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,3,"['recover', 'redundant']","['recovers', 'redundant']"
Availability,"It's better to use `Field` for boundary conditions rather than `Array` --- this eliminates translation issues when switching architectures (eg CPU, to GPU, to multi-region, to distributed), and also allows diagnostics to be performed directly on the boundary conditions (which isn't always needed, but is very welcome to have available --- for example the spatial derivative of a flux). So, I think we should declare that it's ""best practice"" to use `Field`, not `Array`. To encourage this we should change the docs that show how to use an `Array`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-A-random,-spatially-varying,-constant-in-time-temperature-flux-specified-by-an-array. to using a `Field`. Also, we should add correctness tests for using `Field`, which has a bug up until #3287. Curious about @simone-silvestri's input because he has used arrays a lot in boundary conditions. Note that we also are working on support for `FieldTimeSeries` as a boundary condition in #3233 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3298:326,avail,available,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3298,1,['avail'],['available']
Availability,"It's currently defined _after_ these:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/Oceananigans.jl#L194-L215. in addition, `ImmersedBoundaries` extends a bunch of functions that were defined in `Advection` and `TurbulenceClosures`. But this is backwards: `ImmersedBoundaries` should be regarded as a fundamental extension of `Grids`. Then `Advection` and `TurbulenceClosures` should provide functionality that is valid on regular and immersed grids. This is a necessary change to split the repo in the future: we want to regard ""advection"" and ""turbulence closures"" as part of the model/physics, and as immersed boundaries as ""physics-agnostic"", ie, more fundamental. More practically it's the cause of some pain. For example, we can't mask immersed fields within `TurbulenceClosures` without changing how we currently define `mask_immersed_field!`. And so on. Things are tangled. I think maybe immersed boundaries belong right after grids, then `Fields` should define `mask_immersed_field!`. So making this change would distribute a lot of the immersed boundary functionality throughout the code. This is probably a natural evolution, since we used to think that immersed boundaries were an experimental add-on. Now its not. @simone-silvestri curious about your opinion since you've worked on a lot of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3062:783,mask,mask,783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3062,1,['mask'],['mask']
Availability,"It's not possible to build a `NetCDFOutputWriter` object with output that is not a field without specifying an ""attribute"", because this line. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L192. throws an error. The error is a `KeyError`, eg:. ```; KeyError: key :time_average not found; Stacktrace:; [1] getindex at ./dict.jl:477 [inlined]; [2] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S); ...; ```. which occurs because, in this case, `:time_average` is not one of the defaults provided:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L13-L20. There are really two issues:. 1. Should we really require users to specify ""output attributes"" with their output? While this does seem like good practice, I don't think we want to strictly police this behavior. Sometimes its nice to be able to play around with output, with no intention of sharing / using the data in the future. For example, we could throw a `try`-block around the above attempt to find ""default"" attributes, so that its possible to build an output writer with non-default output without specifying output attributes. 2. If we do intend to require ""output attributes"", we should probably throw an error that says something like ""output attributes must be specified for x"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/885:288,error,error,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/885,3,['error'],['error']
Availability,It's still failing intermittently after increasing the tolerance in PR #1686: https://buildkite.com/clima/oceananigans/builds/2672#74321ab5-528f-48c2-bd0c-5ab006881fd3/22-2077,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1689:55,toler,tolerance,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1689,1,['toler'],['tolerance']
Availability,"Just as in the title the function Label calls initialize_block and gives the ""no method matching initialize_block!(::label; fontsize::Int64) giving the error; got unsupported keyword argument ""fontsize""; Kevin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442:152,error,error,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442,1,['error'],['error']
Availability,"Just combining my commits from PRs #337 and #341. Idea is to make life more comfortable by getting `set!` to work out of the box for CPU and GPU fields, and for setting them with functions or arrays. The functions should be evaluated on the CPU as not every function is available through CUDAnative (notably `rand` and `randn` are missing). Will switch to using `copyto!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/343:270,avail,available,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343,1,['avail'],['available']
Availability,"Just hacked something together that allows for user-defined forcing functions for the CPU. Have not tested on the GPU yet. Basically there's a struct `Forcing` that stores the user-defined forcing functions. It will replace the old `ForcingFields` struct. See `examples/deep_convection_3d.jl` for how I switched to using a forcing function for T to enforce a cooling surface heat flux. A big issue is that the current implementation slows down the time stepping by a factor of 2-3x. So we'll have to figure out why before merging. The function must have a signature like `F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k)` right now so this won't produce a nice solution as we will have to figure out #59 before the function signature can look as nice as `surface_cooling_disk(grid, velocities, tracers, i, j, k)`. This is work for another branch. Will keep working on this before merging. Just wanted to start something. Resolves #73",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/85:439,down,down,439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/85,1,['down'],['down']
Availability,Kernel compilation error in model with `forcing` + `auxiliary_fields` on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:19,error,error,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['error'],['error']
Availability,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1031:232,down,downloads,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031,1,['down'],['downloads']
Availability,Kind of scary that we don't have tests for this. I wrote some as part of PR #167 but commented them out as I couldn't get them to work (I kept getting some CUDA error). I should make sure to finish that off.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/200:161,error,error,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/200,1,['error'],['error']
Availability,"L.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3749,error,error,3749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['error'],['error']
Availability,"L.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _includ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3888,error,error,3888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['error'],['error']
Availability,"L.jl:798; [22] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [23] invokelatest; @ ./essentials.jl:706 [inlined]; [24] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [25] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [26] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:406; ```. Digging a bit deeper, it seems that even showing the closure itself throws this error, but only if it's attached to a model:. ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model.closure; Error showing value of type SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] show; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:195 [inlined]; [8] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, x::SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}); @ Base.Multimedia ./multimedia.jl:47; [9] (::REPL.var""#38#39""{REPL.REPLDisplay{REPL.LineEditREPL},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398:47148,ERROR,ERROR,47148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398,1,['ERROR'],['ERROR']
Availability,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850:224,down,down,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850,1,['down'],['down']
Availability,Lock down master branch once the code is in use?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/80:5,down,down,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/80,1,['down'],['down']
Availability,"Looking at performance benchmarks, Float32 is slower than Float64 on the CPU. I suspect something is being done wrong somewhere maybe. I have a few ideas:; 1. Those benchmarks were run on Google Cloud where the virtual CPUs aren't very performant so I thought it was maybe just a low-end 64-bit CPU where Float32 operations were emulated via Float64 operations resulting in fewer FLOPS. However, even on my own laptop I found Float32 on a CPU to be a bit slower, but just by 5-10% whereas on Google Cloud it was like 30%+ slower.; 2. It's likely that Float32 is still being mixed with Float64, and maybe this slows the code down due to too many implicit conversions? (Somewhat related to #34).; 3. Unlikely but I wonder if this is a Julia issue... I could perhaps run some simple C code to see if it's a hardware thing or just a weird Julia thing.; 4. I thought it looked fine on the GPU as you do see a ""speedup"" of 10-15% which I took to mean that we were memory bandwidth/latency limited (which is probably true). The V100 GPUs have twice as many FP32 units as they do FP64 units and if FP32 operations are faster, then I expect more than just a 10-15% speedup. So maybe we have similar issues on the GPU, which are preventing us from doing better than 15% speedup. Or maybe the GPU doesn't do implicit conversions and we are actually just memory bandwidth/latency limited. @glwagner has also pointed out these posts:; * Check out these benchmarks for arithmetic cpu operations: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/ Conclusion: _usually_ single precision is faster, but is _occasionally_ comparable or slower depending on the processor (check results for x86-64 Intel Ivy Bridge).; * https://stackoverflow.com/questions/3426165/is-using-double-faster-than-float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/188:624,down,down,624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/188,1,['down'],['down']
Availability,Looks better now:. ![Square_RungeKutta3_UpwindBiasedThirdOrder_N64_CFL0 50_U+1](https://user-images.githubusercontent.com/15271942/94485679-4c3cfc80-01ac-11eb-90b1-4cf01cb5f1b5.gif). ![Square_RungeKutta3_UpwindBiasedThirdOrder_N64_CFL0 50_U-1](https://user-images.githubusercontent.com/15271942/94485715-5b23af00-01ac-11eb-8957-e47c06ace110.gif). Will post convergence plots when they are available. Resolves #986 (note there was also a bug in the right-biased interpolation function),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/993:389,avail,available,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/993,1,['avail'],['available']
Availability,"MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:161; [13] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\LagrangianParticleTracking.jl:131 [inlined]; [14] step_lagrangian_particles!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\NonhydrostaticModels\NonhydrostaticModels.jl:76 [inlined]; [15] time_step!(model::NonhydrostaticModel{…}, Δt::Float64; callbacks::Tuple{}, compute_tendencies::Bool); @ Oceananigans.TimeSteppers c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:110; [16] time_step!; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\TimeSteppers\runge_kutta_3.jl:81 [inlined]; [17] time_step!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:122; [18] run!(sim::Simulation{…}; pickup::Bool); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:97; [19] run!(sim::Simulation{…}); @ Oceananigans.Simulations c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Simulations\run.jl:85; [20] top-level scope; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\lagrangian_particle_MWE.jl:59; ```. The error indicates that `fractional_z_index` function hits https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L133 instead of https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/Fields/interpolate.jl#L129, which is the intended function dispatch. Note: doing something like ; ```julia; struct SimpleParticle{X}; x :: X; y :: X; end; ```; is not supported, but perhaps this is a separate discussion.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:5514,error,error,5514,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,1,['error'],['error']
Availability,"MWE ; ```julia; grid = RectilinearGrid(size = (5, 5, 5), extent = (1, 1, 1)); model = HydrostaticFreeSurfaceModel(; grid); c = CenterField(grid; indices = (:, :, grid.Nz)); d = CenterField(grid); JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ```; fails with ; ```julia; julia> JLD2OutputWriter(model, (; c, d), filename = ""test"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835:405,ERROR,ERROR,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835,1,['ERROR'],['ERROR']
Availability,"MWE in which I expected checkpointing to occur every 10 iterations:. ```julia. using Oceananigans, Oceananigans.Fields; arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));; model = IncompressibleModel(grid=RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1))); simulation = Simulation(model, Δt=0.1, stop_iteration=1000). simulation.output_writers[:checkpointer] = Checkpointer(model; interval=10, prefix=""model_checkpoint"") # expect to checkpoint every 10 iterations?. run!(simulation); ```. but the files produced are. ```; model_checkpoint_iteration0.jld2 model_checkpoint_iteration400.jld2 model_checkpoint_iteration801.jld2; model_checkpoint_iteration101.jld2 model_checkpoint_iteration500.jld2 model_checkpoint_iteration901.jld2; model_checkpoint_iteration200.jld2 model_checkpoint_iteration600.jld2; model_checkpoint_iteration300.jld2 model_checkpoint_iteration700.jld2; ```. eg, checkpoints are only saved every 100 iterations. Am I missing something?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/661:24,checkpoint,checkpointing,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/661,5,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint', 'checkpointer', 'checkpointing', 'checkpoints']"
Availability,"MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; x = (-5, 5),; y = (-5, 5),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). island(x, y) = (x^2 + y^2) < 1; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(island)). Δx = xspacings(grid, Center(), Center(), Center()); ```. produces. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: MethodError: no method matching xspacings(::ImmersedBoundaryGrid{…}, ::Center; with_halos::Bool). Closest candidates are:; xspacings(::Any, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; xspacings(::LatitudeLongitudeGrid{<:Any, <:Any, <:Any, <:Any, <:Any, <:Any, <:Number, <:Number}, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:674; xspacings(::LatitudeLongitudeGrid, ::Center, ::Center; with_halos); @ Oceananigans ~/.julia/packages/Oceananigans/OMBY0/src/Grids/latitude_longitude_grid.jl:658; ... Stacktrace:; [1] xspacings(grid::ImmersedBoundaryGrid{…}, ℓx::Center, ℓy::Center, ℓz::Center); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/OMBY0/src/Grids/nodes_and_spacings.jl:200; ```. This is probably also a problem for `yspacings` and `zspacings`, but I'm not sure. For `GridFittedBottom`, the spacings should just return spacings for the underlying grid (right now only `PartialCellBottom` immersed boundaries have different metrics than the underlying grid).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3701:380,ERROR,ERROR,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3701,1,['ERROR'],['ERROR']
Availability,"MWE:. ```Julia; julia> g(args...; kwargs...) = f(args...); g (generic function with 1 method). julia> f(x) = x + 1; f (generic function with 1 method). julia> x = MultiRegionObject(1, 2); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((1, 2), (CPU(), CPU())). julia> @apply_regionally a = f(x); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((2, 3), (CPU(), CPU())). julia> @apply_regionally a = g(x); MultiRegionObject{Tuple{Int64, Int64}, Tuple{CPU, CPU}}((2, 3), (CPU(), CPU())). julia> function h(x, args...; kwargs...); @apply_regionally a = g(args...; kwargs...); end; ERROR: syntax: ""..."" expression outside call around /Users/simonesilvestri/temp/Oceananigans.jl/src/Utils/multi_region_transformation.jl:212; Stacktrace:; [1] top-level scope; @ REPL[14]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/BbliS/src/initialization.jl:52; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2914:593,ERROR,ERROR,593,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2914,1,['ERROR'],['ERROR']
Availability,"MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10),; x = (0, 1),; z = (0, 1),; topology = (Periodic, Flat, Bounded)). mask = GaussianMask{:x}(center=1, width=0.1); sponge = Relaxation(rate=1; mask). model = HydrostaticFreeSurfaceModel(; grid, forcing = (; u=sponge)). simulation = Simulation(model; Δt=1, stop_iteration=1); run!(simulation); ```. The fix is a little involved because we can't distinguish between the arguments `(y, z)` and `(x, y)` by function arguments alone. Thus the mask itself needs to have grid information. This and other bug are the extended consequences of changing `node` to drop flat dimensions (#3355, with discussion on #3285). I still think the price was worth it for betting scripting, but it has come with a pretty significant trade-off in terms of under the hood code complexity...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3728:142,mask,mask,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3728,3,['mask'],['mask']
Availability,"MWE:; ```julia; using Oceananigans; using GLMakie. grid = RectilinearGrid(size = (10, 10, 10), extent = (10, 10, 10)); bottom(x, y) = - rand() * 5 # Between -5 and 0; grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)). f1 = Field{Center, Center, Nothing}(grid); f2 = Field{Center, Center, Nothing}(grid); set!(f1, (x, y) -> rand()); set!(f2, (x, y) -> rand()). fig = Figure(); ax1 = Axis(fig[1, 1]); ax2 = Axis(fig[1, 2]); heatmap!(ax1, f1); heatmap!(ax2, interior(f2, :, :, 1)); ```; Produces:. <img width=""1045"" alt=""Screenshot 2024-11-05 at 12 21 29 PM"" src=""https://github.com/user-attachments/assets/2840dd1b-edd2-4e74-a5f7-d0c378396e84"">. It seems the field has been masked by checking the immersed condition at `k = 1`, which is not true for `Reduced` fields that need to check the whole direction to see if they are immersed. To mask the field to `NaN,` we should check that all the `k` indices at `i, j` are immersed. . This is not a bug in the visualization but in the masking procedure that should do something different if a direction is nothing. I can create a PR for this; some computational efficiency considerations might be needed if this `mask_immersed_field!` is included in time-stepping loops.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3899:682,mask,masked,682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3899,3,['mask'],"['mask', 'masked', 'masking']"
Availability,Make checkpointer more memory efficient,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/416:5,checkpoint,checkpointer,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/416,1,['checkpoint'],['checkpointer']
Availability,Make error messages for grid generation more uniform,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333,1,['error'],['error']
Availability,Make it easier to restart a simulation from a checkpoint with additional passive tracers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:46,checkpoint,checkpoint,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpoint']
Availability,Make validation/barotropic/barotropic.jl run without errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1717:53,error,errors,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717,1,['error'],['errors']
Availability,Making it easier to set up and configure scripts with checkpointing on clusters with time limits,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/779:54,checkpoint,checkpointing,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779,1,['checkpoint'],['checkpointing']
Availability,"Many models of size (16, 16, 16) are reduced to size (1, 1, 1). Oftentimes the test just executes a time-step to ensure there's no error. For this, a size (1, 1, 1) is sufficient.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937:131,error,error,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937,1,['error'],['error']
Availability,Mask `ReducedFields` accounting the immersed column,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3900:0,Mask,Mask,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3900,1,['Mask'],['Mask']
Availability,Mask tracers for immersed boundaries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1888:0,Mask,Mask,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888,1,['Mask'],['Mask']
Availability,Method overwritten errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2102:19,error,errors,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2102,1,['error'],['errors']
Availability,"Might be because I updated the `Manifest.toml` which included an upgrade to OffsetArrays v1.3.0 but @qwert2266 ran into this issue on Oceananigans v0.37.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: MethodError: OffsetArrays.OffsetArray(::CUDA.CuArray{Float64,3}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) is ambiguous. Candidates:; (::Type{OffsetArrays.OffsetArray})(A::AbstractArray, inds...) in OffsetArrays at /home/alir/.julia/packages/OffsetArrays/CXQGe/src/OffsetArrays.jl:172; (::Type{OffsetArrays.OffsetArray})(underlying_data, grid::Oceananigans.Grids.AbstractGrid, loc) in Oceananigans.Fields at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:33; Possible fix, define; OffsetArrays.OffsetArray(::AbstractArray, ::Oceananigans.Grids.AbstractGrid, ::Any); Stacktrace:; [1] new_data(::Type{T} where T, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:70; [2] XFaceField(::DataType, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/991:538,ERROR,ERROR,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991,1,['ERROR'],['ERROR']
Availability,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/162:84,down,down,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162,1,['down'],['down']
Availability,"Might be nice if this worked (although right now we can use `FunctionField` directly which isn't too hard):. ```julia; julia> Ψ(λ, φ, z) = - R * u₀ * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)). julia> ∂x(Ψ); ```. ```; julia> ∂x(Ψ); ERROR: MethodError: no method matching ∂x(::typeof(Ψ)); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:45; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A) where {X, Y, Z} at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:62; ∂x(::Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A) where {X, Y, Z} at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:89; Stacktrace:; [1] top-level scope at REPL[18]:1; ```. I guess for it to work we would also have to sepcify the location of the function, maybe via; ```julia; julia> ∂x(@at (Face, Face, Center) Ψ); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1538:239,ERROR,ERROR,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1538,1,['ERROR'],['ERROR']
Availability,"Might be user script error (i.e. not Oceananigans related) but seems that sometimes when you run a Slurm/LSF script that keeps restoring from checkpoint and submitting itself again, you can sometimes end up with checkpoints at consective iterations which seems weird. Unsure what happened in this case but worth double checking that it's not an Oceananigans issue. ```; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration0.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration255659.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379710.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379711.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration379712.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration443975.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration498963.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration539690.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration573543.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration606802.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration640046.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration666801.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration666802.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration673488.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration706733.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration739977.jld2; europa_constant_bottom_heat_flux_100km_10W_1000days_lat10_checkpoint_iteration739981.jld2; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/778:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/778,3,"['checkpoint', 'error']","['checkpoint', 'checkpoints', 'error']"
Availability,Model constructor could emit a warning (error would be more suitable). Could re-create the grid but maybe that's not as good as getting the user to specify the right halo size. New users shouldn't have to interact with halos and getting `NaN`s because you didn't know to change the halo size can be frustrating.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/941:40,error,error,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/941,1,['error'],['error']
Availability,More friendly error messages when types are passed to `Model` instead of objects,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465,1,['error'],['error']
Availability,"More general criteria for writing data, checkpointing, calculating diagnostics, printing progress statements, etc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/845:40,checkpoint,checkpointing,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/845,1,['checkpoint'],['checkpointing']
Availability,More illustrative example for checkpointing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3469:30,checkpoint,checkpointing,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3469,1,['checkpoint'],['checkpointing']
Availability,"More of a general issue that #1118 made me think about is that we've been mixing data types and instantiated types. For example, we use data types when constructing grid topologies and specifying locations for abstract operations:. ```julia; topology = (Periodic, Bounded, Bounded); kinetic_energy @at (Cell, Cell, Cell) (u^2 + v^2) / 2; ```. but instantiated types when specifying which architecture and advection scheme to use. ```julia; model = IncompressibleModel(grid=grid, architecture=GPU(), advection=WENO5()); ```. It seems there's some element of memorization to know which one to use when. Maybe this will confuse future users (certainly it confused us in #1118). Changing this behavior would require a lot of refactoring but probably worth discussing whether changing makes sense or if we can make the user interface more robust and friendly to mismatches between data types and instantiated types?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1119:834,robust,robust,834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1119,1,['robust'],['robust']
Availability,More robust initialization of u and v in `examples/two_dimensional_turbulence.jl`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1917:5,robust,robust,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1917,1,['robust'],['robust']
Availability,More robust method for specifying fluxes across boundaries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1400:5,robust,robust,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1400,1,['robust'],['robust']
Availability,Moves masking fields from model update to output writers when using ImmersedBoundary,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616:6,mask,masking,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616,1,['mask'],['masking']
Availability,"My fault, must have messed up and forgot to skip `_apply_*_bcs!` for `NotFluxBC` in PR #631. . Fixes #675 and should fix failing tests on PR #671. Before:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 24.3s / 2.17% 1.83GiB / 18.1% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 256ms 48.6% 25.6ms 170MiB 50.0% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 270ms 51.4% 27.0ms 170MiB 50.0% 17.0MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. After:; ```; ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 126s / 62.8% 1.46GiB / 0.13% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 39.4s 49.9% 3.94s 1.00MiB 50.0% 102KiB; 32× 32× 32 [CPU, Float64] 10 39.5s 50.1% 3.95s 1.00MiB 50.0% 102KiB; ──────────────────────────────────────────────────────────────────────────────────────; ```. Unfortunately still a bit higher than v0.22.0 (~50 KiB allocations) but much better and more acceptable than 17 MiB!. Remaining memory allocations seem to be occuring in `fill_halo_regions.jl` but tried inlining some functions and didn't help so I'll revisit the problem in the future. ```; julia> analyze_malloc("".""); 323-element Array{CoverageTools.MallocInfo,1}: ; ⋮ ; CoverageTools.MallocInfo(5008, ""./benchmark/benchmark_static_ocean.jl.32885.mem"", 36) ; CoverageTools.MallocInfo(5952, ""./benchmark/benchmark_utils.jl.32885.mem"", 35) ; CoverageTools.MallocInfo(6080, ""./src/TimeSteppers/time_stepping_kernels.jl.32885.mem"", 139) ; Cove",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/685:3,fault,fault,3,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/685,1,['fault'],['fault']
Availability,NaN error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1432:4,error,error,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432,1,['error'],['error']
Availability,Need interpretable error if `LagrangianParticles` are initialized with invalid positions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2684:19,error,error,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2684,1,['error'],['error']
Availability,Need to document the available solver method options for ImplicitFreeSurface solvers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2620:21,avail,available,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2620,1,['avail'],['available']
Availability,"New checkpointer features: set! and simulation ""pickup""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1082:4,checkpoint,checkpointer,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082,1,['checkpoint'],['checkpointer']
Availability,Non-standard function throws an error when used in a `KernelFunctionOperation` on the GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3438:32,error,error,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3438,1,['error'],['error']
Availability,"Not sure how this is possible, but the following code throws a segfault:. ```julia; using Oceananigans; using Oceananigans.BoundaryConditions: fill_halo_regions!. partition = Partition(y=2); arch = Distributed(GPU(); partition); x = y = z = (0, 1); grid = RectilinearGrid(arch; size=(16, 16, 16), x, y, z, topology=(Periodic, Periodic, Bounded)); c = CenterField(grid); fill_halo_regions!(c); ```. I'm running with. ```bash; $ mpiexecjl -n 2 julia --project test_interpolate.jl; ```. (I found this error originally when trying to interpolate a field, but it seems it boils down to a halo filling issue). This is the error I get:. ```; [ Info: Oceananigans will use 32 threads; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: Oceananigans will use 32 threads; [ Info: MPI has not been initialized, so we are calling MPI.Init(). [116989] signal (11.2): Segmentation fault; in expression starting at /orcd/data/raffaele/001/glwagner/OceananigansPaper/listings/test_interpolate.jl:10; __memcpy_ssse3 at /lib64/libc.so.6 (unknown line); MPIDI_CH3_iSendv at /orcd/data/raffaele/001/glwagner/.julia/artifacts/e85c0a68e07fee0ee7b19c2abc210b1af2f4771a/lib/libmpi.so (unknown line); MPIDI_CH3_EagerContigIsend at /orcd/data/raffaele/001/glwagner/.julia/artifacts/e85c0a68e07fee0ee7b19c2abc210b1af2f4771a/lib/libmpi.so (unknown line); MPID_Isend at /orcd/data/raffaele/001/glwagner/.julia/artifacts/e85c0a68e07fee0ee7b19c2abc210b1af2f4771a/lib/libmpi.so (unknown line); MPI_Isend at /orcd/data/raffaele/001/glwagner/.julia/artifacts/e85c0a68e07fee0ee7b19c2abc210b1af2f4771a/lib/libmpi.so (unknown line); MPI_Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/api/generated_api.jl:2151 [inlined]; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/pointtopoint.jl:66; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/pointtopoint.jl:70 [inlined]; Isend at /orcd/data/raffaele/001/glwagner/.julia/packages/MPI/TKXAj/src/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:498,error,error,498,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,4,"['down', 'error', 'fault']","['down', 'error', 'fault']"
Availability,"Not sure if this is something we want to do by default, probably makes sense to make it a `Checkpointer` property, but it's useful as you might want to checkpoint a final time at the end of the simulation (preserving a 3D state) and when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1545:91,Checkpoint,Checkpointer,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545,3,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint']"
Availability,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147:806,error,errors,806,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147,3,"['down', 'error']","['downside', 'error-by-error', 'errors']"
Availability,"Not sure if this means we cannot use PowerPC/Satori for now?. ```julia; julia> using Oceananigans. julia> IncompressibleModel(architecture=GPU(), grid=RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1))); ```. ```julia; ERROR: cfunction: closures are not supported on this platform; Stacktrace:; [1] compile_method_instance(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/jlgen.jl:325; [2] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [3] irgen(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneT",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:228,ERROR,ERROR,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['ERROR'],['ERROR']
Availability,Not sure if this will fix the failing coverage job so I've also allows failures on coverage. Coverage will be reported from v1.2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/472:71,failure,failures,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/472,1,['failure'],['failures']
Availability,"Not sure someone already created this issue.; I know this is too new for having documentation yet, and I am only creating the issue to have it on the list.; I am trying to use CATKE vertical diffusivity for an experiment. Currently I am using Julia-1.6.5 and Oceananigans v0.72.0 it returned `UndefVarError: CATKEVerticalDiffusivity not defined`.; Am I calling it wrong? Or should I downgrade to v0.71.3 (@glwagner mentioned CATKE is available for this version).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2330:383,down,downgrade,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2330,2,"['avail', 'down']","['available', 'downgrade']"
Availability,"Not sure what the cause is. I get this error with or without a free surface model. The error goes away if I remove CATKE or if I switch to `Float64`. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Periodic, Bounded, Bounded),; size = (32, 32, 8),; longitude = (-180, 180),; latitude = (-80, 80),; z = (-5000, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = SeawaterBuoyancy(),; tracers = (:T, :S, :e),; closure = CATKEVerticalDiffusivity(); ); ```. Error:. ```; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/z3j2H/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/z3j2H/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTuple{image::Vector{UInt8}, entry::String}); @ CUDA ~/.julia/packages/CUDA/z3j2H/src/compiler/compilation.jl:413; [10] actual_compilation(cache::Dict{Any, CUDA.CuFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3785:39,error,error,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3785,5,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,Noticed this because `test_diffusion_cosine` was failing in PR #462. We should have that `length(zC) == Nz` but; ```julia; julia> Nz = 16; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 16. julia> Nz = 32; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 32. julia> Nz = 64; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 63. julia> Nz = 128; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 127. julia> Nz = 256; Lz = π/2; Δz = Lz / Nz; zC = -Lz+Δz/2:Δz:-Δz/2; length(zC); 255; ```. Looks like a scary effect of round-off error to me. I'll make the switch to using the `range` function with a fixed `length` and add a test to check for this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/480:571,error,error,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/480,1,['error'],['error']
Availability,Number of tests went down as a lot of them were regression tests between the three different sets of operators. But we will rebuild.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/96:21,down,down,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/96,1,['down'],['down']
Availability,Obscure GPU error when time stepping a model with Julia 1.5 and Oceananigans v0.33.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:12,error,error,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['error'],['error']
Availability,"Often when running CI, the tests fail on tartarus because of a loading error (there are apparently some missing files),. example; ```; ERROR: LoadError: LoadError: SystemError: opening file ""/storage5/buildkite-agent/.julia-5513/compiled/v1.6/Oceananigans/hU93i_FjLMs.ji"": No such file or directory; ```. Retrying the test clears the error, but maybe we should look a bit into it so that we don't have to manually retry...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2222:71,error,error,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2222,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,On GPU it throws an error regarding CUDA scalar operations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1637:20,error,error,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1637,1,['error'],['error']
Availability,"On main:. ```julia; julia> a = Oceananigans.BuoyancyModels.LinearEquationOfState(); Error showing value of type LinearEquationOfState{Float64}:; ERROR: MethodError: no method matching display(::LinearEquationOfState{Float64}); Closest candidates are:; display(::Any) at multimedia.jl:324; display(::AbstractDisplay, ::AbstractString, ::Any) at multimedia.jl:216; display(::AbstractString, ::Any) at multimedia.jl:217; ```. This PR:. ```julia; julia> a = Oceananigans.BuoyancyModels.LinearEquationOfState(); LinearEquationOfState(thermal_expansion=0.000167, haline_contraction=0.00078); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2861:84,Error,Error,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2861,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,Once we decide on a final draft on Google Docs I'll update `paper.md`. JOSS requires a Markdown paper to be available in the repository. X-Ref: https://github.com/openjournals/joss-reviews/issues/1965; X-Ref: https://github.com/openjournals/joss-reviews/issues/2018,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/564:108,avail,available,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/564,1,['avail'],['available']
Availability,Only mask AbstractDataField,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1959:5,mask,mask,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1959,1,['mask'],['mask']
Availability,Option for `NaNChecker` to exit with error,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2086:37,error,error,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086,1,['error'],['error']
Availability,"Our model constructor API asks users to pass several `NamedTuple`s for field-specific input like `forcing`, `boundary_conditions`, etc. For example:. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L108. We currently enforce that these are `NamedTuple` by typing the keyword argument. However, this leads to obscure `TypeError` that may not be all that helpful / interpretable. For example:. ```; ERROR: LoadError: TypeError: in keyword argument forcing, expected NamedTuple, got a value of type Oceananigans.Forcings.DiscreteForcing{NamedTuple{(:x₀, :z₀, :δᴸ, :R), NTuple{4, Float64}}, typeof(b_discrete_forcing_func)}; ```. A more user-friendly error might be an `ArgumentError` that says something like. ```; $argname must be `NamedTuple` but is $argtype instead! Check for missing commas or semicolons. A common typo is to write `(field=value)` rather than `(field=value,)` or `(; field=value)`.; ```. In particular, a super common typo is to write something like. ```julia; forcing = (u=u_forcing),; ```. rather than the two-character-different. ```julia; forcing = (; u=u_forcing),; ```. We can write a little utility for throwing an error message like this, and then just loop over the relevant `NamedTuple` inputs in every model constructor. We can also check that `keys(arg)` are contained in the fields of the model and emit a warning if there's a key that'll be unused. Noticed while working on a script with @raphaelouillon.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2269:492,ERROR,ERROR,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2269,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Out of bounds error in `auto_extension` if output writer filename is 4 characters or shorter,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3748:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748,1,['error'],['error']
Availability,Out of memory error with Docs tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779,1,['error'],['error']
Availability,Output error messages to a file?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2363:7,error,error,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2363,1,['error'],['error']
Availability,Output writer schedules should be checkpointed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280:34,checkpoint,checkpointed,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280,1,['checkpoint'],['checkpointed']
Availability,"OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:2062,checkpoint,checkpointer,2062,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpointer']
Availability,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1137:683,checkpoint,checkpointed,683,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137,2,['checkpoint'],['checkpointed']
Availability,"PR #3179 identified a few bugs with Flat dimensions in lat-lon grids. Errors appear when one tries to run a HydrostaticFreeSurface model with such grids. 1) for a lat-lon grid with Flat-Flat-Bounded the problem comes from . https://github.com/CliMA/Oceananigans.jl/blob/8c1f2fb7f51a459fcf8c472a92d10c3cad455793/src/Advection/momentum_advection_operators.jl#L54. which requires `Vᶠᶜᶜ` and in turn hits:. https://github.com/CliMA/Oceananigans.jl/blob/8c1f2fb7f51a459fcf8c472a92d10c3cad455793/src/Operators/spacings_and_areas_and_volumes.jl#L206. 2) for lat-lon grids with **either** lon **or** lat being Flat, the problem comes from the Matrix implicit free surface solver which assumes that there is no flat horizontal dimension. _Originally posted by @navidcy in https://github.com/CliMA/Oceananigans.jl/issues/3179#issuecomment-1630670511_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3181:70,Error,Errors,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3181,1,['Error'],['Errors']
Availability,"PR co-authored with @sandreza . This PR tests Oceananigans with the Pearson vortex test from p. 310 of ""Nodal Discontinuous Galerkin Methods: Algorithms, Analysis, and Application"" by Hesthaven & Warburton. Error after 100 time steps:; ```julia; i: 100, t: 0.008, Δu: (avg=0.000224, max=0.000224), Δw: (avg=0.000224, max=0.000224); ```; which compares well with the DG error (considering our low-order numerics). We discovered that recomputing w from continuity breaks this test because du/dx = 0 and dv/dy = 0 by construction so w = 0 even though this is wrong. This is probably because we need to impose Neumann boundary condition on w, but recomputing w from continuity requires us to assume the value of `w[i, j, :]`, which we take to be 0 since we usually run with a rigid lid. So we switched to explicitly time stepping w which means this PR is ""DO NOT MERGE"" is its current state. Note: Before the test is merged, more comments are needed in the pearson vortex test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/336:207,Error,Error,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/336,2,"['Error', 'error']","['Error', 'error']"
Availability,PTX compilation errors with GPU AbstractOperations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:16,error,errors,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['error'],['errors']
Availability,"PU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(; grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{…}, tracers::Nothing, forcing::@NamedTuple{}, closure::Nothing, boundary_co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806:1311,error,error,1311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806,1,['error'],['error']
Availability,"Passing `architecture = CPU` instead of `architecture = CPU()` when constructing an `IncompressibleModel` can produce a rather punishing error message as @glwagner and I found out with @vchuravy. Would be very easy to do a quick check for this and save future users the potential headache. ```; ERROR: LoadError: type NamedTuple has no field grid; Stacktrace:; [1] getbc at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:199 [inlined]; [2] getproperty at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:197 [inlined]; [3] topology at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Fields/abstract_field.jl:117 [inlined]; [4] topology(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Int64) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Grids/Grids.jl:81; [5] NamedTuple{(:x, :y, :z),T} where T<:Tuple(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:85; [6] UVelocityBoundaryConditions(::NamedTuple{(:x, :y",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1118:137,error,error,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1118,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Passing a `Clock` to `restore_from_checkpoint` gets overwritten by clock from checkpoint file,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1008:78,checkpoint,checkpoint,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1008,1,['checkpoint'],['checkpoint']
Availability,Passing parameters for nested boundary functions (nested task error: UndefKeywordError: keyword argument <name> not assigned),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336:62,error,error,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336,1,['error'],['error']
Availability,Poisson solver test: recovery of an analytic solution.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227:21,recover,recovery,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227,1,['recover'],['recovery']
Availability,PoissonBCs for pressure solver are redundant,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311:35,redundant,redundant,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311,1,['redundant'],['redundant']
Availability,Possible bug in checkpointing?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/778:16,checkpoint,checkpointing,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/778,1,['checkpoint'],['checkpointing']
Availability,Post-Checkpoint Output Saving Interval Issue,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3657:5,Checkpoint,Checkpoint,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3657,1,['Checkpoint'],['Checkpoint']
Availability,"Previously, I believe I was defining fields on immersed grids. When I try now I get an error. Am I doing something silly or has something changed?. ```; julia> using Oceananigans. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> h0, L = 0.5, 0.25; (0.5, 0.25). julia> grid = RectilinearGrid(size=(16, 8), y=(-1, 1), z=(-1, 0),; topology=(Flat, Periodic, Bounded), halo=(3,3)); 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> seamount2(x, y, z) = z < - 1 + h0*exp(-y^2/L^2); seamount2 (generic function with 1 method). julia> grid_with_seamount2 = ImmersedBoundaryGrid(grid, GridFittedBottom(seamount2)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Software/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; with immersed: GridFittedBottom{typeof(seamount2)}. julia> c2 = CenterField(grid_with_seamount2); Error showing value of type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Arra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2250:87,error,error,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250,1,['error'],['error']
Availability,"Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img width=""589"" alt=""image"" src=""https://github.com/user-attachments/assets/f9964aa3-f708-4c43-88a3-7b0a565148c1"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:1841,checkpoint,checkpointer,1841,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,6,['checkpoint'],"['checkpoint', 'checkpointer']"
Availability,"Probably defined twice by mistake; ```julia; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition convert_to_arch(Oceananigans.Architectures.CPU, Any) in module OutputWriters at /home/alir/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:9 overwritten at /home/alir/Oceananigans.jl/src/OutputWriters/checkpointer.jl:93.; ** incremental compilation may be fatally broken for this module **. WARNING: Method definition convert_to_arch(Oceananigans.Architectures.GPU, Any) in module OutputWriters at /home/alir/Oceananigans.jl/src/OutputWriters/output_writer_utils.jl:10 overwritten at /home/alir/Oceananigans.jl/src/OutputWriters/checkpointer.jl:94.; ** incremental compilation may be fatally broken for this module **; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/655:356,checkpoint,checkpointer,356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/655,2,['checkpoint'],['checkpointer']
Availability,Probably due to a sign error in flux divergence according to @glwagner,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1702:23,error,error,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1702,1,['error'],['error']
Availability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127:871,recover,recover,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127,1,['recover'],['recover']
Availability,Problem when starting from a checkpoint with `AveragedTimeInteval`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2226:29,checkpoint,checkpoint,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2226,1,['checkpoint'],['checkpoint']
Availability,"Recently, many of my simulations that run on clusters have crashed due to out-of-memory errors. I find that `NetCDFOutputWriter` seems to cause memory leak, which can by reproduced by the code below:. ```Julia; using Printf; using Oceananigans; using Oceananigans.OutputWriters: write_output!. const arch = CPU(). const Nx = 50; const Ny = 50; const Nz = 50. grid = RectilinearGrid(; arch,; size = (Nx, Ny, Nz),; x = (0., 1.),; y = (0., 1.),; z = (0., 1.),; topology = (Bounded, Bounded, Bounded),; ). # Model; model = NonhydrostaticModel(;; grid = grid,; ). output_writer = NetCDFOutputWriter(; model,; model.velocities,; filename = ""output.nc"",; schedule = TimeInterval(1.0),; ). for i in 1:1000; write_output!(output_writer, model); # GC.gc(); @info i; @info Printf.@sprintf ""Max. RSS: %9.3f MiB\n"" Sys.maxrss()/2^20; end; ```. The total memory usage reported by `Sys.maxrss` keeps increasing over time, the rate which is roughly the output data size. Forcing `Gc.gc()` slows down the trend but cannot stop the increase. I believe it is a bug in `NCDatasets`. See Alexander-Barth/NCDatasets.jl#266. The version of `NCDatasets` is 0.14.5 in my case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3777:88,error,errors,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3777,2,"['down', 'error']","['down', 'errors']"
Availability,"Related to https://github.com/CliMA/Oceananigans.jl/issues/1465. When fixing the MWE I gave in https://github.com/CliMA/Oceananigans.jl/issues/1465 but outputting things with a NetCDFWriter I also get an error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::FieldSlicer{Colon,Colon,Colon}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:38; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coordi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:204,error,error,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Release notes:. This release adds some new features, fixes some bugs, and improves the API (so there are some breaking changes, listed below). Major changes:; * Triply periodic models are now available by passing the `topology = (Periodic, Periodic, Periodic)` keyword argument to grids.; * All 1D, 2D, and 3D averages are now available through the `Average` diagnostic with the `dims` keyword argument.; * Fixed some checkpointing bugs.; * **BREAKING:** Use `Average(..., dims=(1, 2))` instead of `HorizontalAverage(...)`.; * **BREAKING:** Use `iteration_interval` and `time_interval` instead of `frequency` and `interval` for diagnostics and output writers.; * **BREAKING:** Use `iteration_interval` instead of `progress_frequency` for simulations.; * **BREAKING:** Use `IsotropicDiffusivity` and `AnisotropicDiffusivity` instead of `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity`. Also, use `νz` instead of `νv` and `κz` instead of `κv`.; * **BREAKING:** To `restore_from_checkpoint`, pass model constructor arguments as you would to a normal constructor, e.g. `restore_from_checkpoint(""my_checkpoint.jld2"", boundary_conditions=custom_bcs)`. Previous behavior was to pass a dictionary which was less user friendly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/847:192,avail,available,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/847,3,"['avail', 'checkpoint']","['available', 'checkpointing']"
Availability,Remove redundant definition of `diffusive_flux_z` for divergence damping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2482:7,redundant,redundant,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2482,1,['redundant'],['redundant']
Availability,Removes redundant definition for `halo_size`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2130:8,redundant,redundant,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2130,1,['redundant'],['redundant']
Availability,"Reported by @qwert2266. Would happen to any model property that is part of; ```; properties = [:architecture, :grid, :clock, :coriolis, :buoyancy, :closure, :velocities, :tracers, :timestepper]; ```; passed to `Checkpointer` upon construction. https://github.com/CliMA/Oceananigans.jl/blob/ac3130e84ac132daaacbd428ea6450beb9b330aa/src/OutputWriters/checkpointer.jl#L186-L189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1008:211,Checkpoint,Checkpointer,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1008,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointer']"
Availability,"Reported in PR #666. Might be serious enough that it is slowing down documentation building in PR #671. ```; Julia Version 1.3.1; Commit 2d5741174c (2019-12-30 21:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-6.0.1 (ORCJIT, skylake); GPU: TITAN V. ──────────────────────────────────────────────────────────────────────────────────────; Static ocean benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 173s / 51.2% 43.6GiB / 64.5% . Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [CPU, Float32] 10 127ms 0.14% 12.7ms 170MiB 0.59% 17.0MiB; 32× 32× 32 [CPU, Float64] 10 153ms 0.17% 15.3ms 170MiB 0.59% 17.0MiB; 32× 32× 32 [GPU, Float32] 10 24.4ms 0.03% 2.44ms 10.0MiB 0.03% 1.00MiB; 32× 32× 32 [GPU, Float64] 10 24.2ms 0.03% 2.42ms 10.0MiB 0.03% 1.00MiB; 64× 64× 64 [CPU, Float32] 10 713ms 0.81% 71.3ms 676MiB 2.35% 67.6MiB; 64× 64× 64 [CPU, Float64] 10 868ms 0.98% 86.8ms 676MiB 2.35% 67.6MiB; 64× 64× 64 [GPU, Float32] 10 24.8ms 0.03% 2.48ms 10.0MiB 0.03% 1.00MiB; 64× 64× 64 [GPU, Float64] 10 25.2ms 0.03% 2.52ms 10.0MiB 0.03% 1.00MiB; 128×128×128 [CPU, Float32] 10 5.22s 5.90% 522ms 2.64GiB 9.39% 270MiB; 128×128×128 [CPU, Float64] 10 5.44s 6.14% 544ms 2.64GiB 9.39% 270MiB; 128×128×128 [GPU, Float32] 10 46.3ms 0.05% 4.63ms 10.0MiB 0.03% 1.00MiB; 128×128×128 [GPU, Float64] 10 45.6ms 0.05% 4.56ms 10.0MiB 0.03% 1.00MiB; 256×256×256 [CPU, Float32] 10 37.4s 42.3% 3.74s 10.5GiB 37.5% 1.05GiB; 256×256×256 [CPU, Float64] 10 37.7s 42.6% 3.77s 10.5GiB 37.5% 1.05GiB; 256×256×256 [GPU, Float32] 10 338ms 0.38% 33.8ms 10.0MiB 0.03% 1.00MiB; 256×256×256 [GPU, Float64] 10 336ms 0.38% 33.6ms 10.0MiB 0.03% 1.00MiB; ──────────────────────────────────────────────────────────────────────────────────────; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/675:64,down,down,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/675,1,['down'],['down']
Availability,"Resolves #1702 noticed by @mukund-gupta . In a [previous PR](https://github.com/CliMA/Oceananigans.jl/commit/3afd5b59fce91f9ab4aa6d0d19cd64fef7aea4cf#) we changed the notation of the closure term to indicate that it's the divergence of a flux, rather than specifically the divergence of a _viscous_ or _diffusive_ flux. This notational change required us to change the term's sign. Specifically, we used the redefinition. ```; ∂ⱼ_2ν_Σ₁ⱼ = - ∂ⱼ_τ₁ⱼ; ```. for the diffusive flux of x-momentum. However, we did not change the sign of the flux divergence for `AnisotropicBiharmonicDiffusivity`; we only changed the _name_ of the term. This PR corrects the sign error. There are a few closures that don't have regression tests and this highlights the danger of that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1703:657,error,error,657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1703,1,['error'],['error']
Availability,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799:142,error,error,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799,1,['error'],['error']
Availability,Resolves #3061. Questions:. Does it make sense to mask when`with_halos = true`? With `with_halos = true` implies that the users can use the output to compute derivative fields etc; will masking obscure this?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3092:50,mask,mask,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3092,2,['mask'],"['mask', 'masking']"
Availability,"Resolves #857 . Minimal working example:; ```julia; using Oceananigans, Oceananigans.Diagnostics, Oceananigans.AbstractOperations; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=CPU(), grid=grid) # Same with GPU(); u, v, w = model.velocities; ∫uv = Average(u*v, dims=(1, 2), return_type=Array); ```. Old error (obscure and not useful to users):; ```; ERROR: MethodError: no method matching architecture(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}); Closest candidates are:; architecture(::Array) at /home/alir/Oceananigans.jl/src/Architectures.jl:46; architecture(::CUDA.CuArray) at /home/alir/Oceananigans.jl/src/Architectures.jl:47; architecture(::Field) at /home/alir/Oceananigans.jl/src/Fields/field.jl:167; ...; Stacktrace:; [1] Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims::Tuple{Int64,Int64}, iteration_interval::Nothing, time_interval::Nothing, return_type::Type{T} where T) at /home/alir/Oceananigans.jl/src/Diagnostics/average.jl:52; [2] top-level scope at REPL[17]:1; ```. New error (more useful):; ```; ERROR: MethodError: no method mat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858:364,error,error,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Respected sir,; I want to simulate a small prototype of Open Ocean convection and did all necessary scaling according to that. Please have a look at my code, I don't know why my code isn't working. It is giving NaN error.; ````; using Printf; using Plots; using JLD2. using Oceananigans; using Oceananigans.Utils. using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics: FieldMaximum; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval. #number of grid spacing in south,north and vertical direction; Nx=256; Ny=256; Nz=64. #Length of grid in south, north and vertical direction; Lx=4; Ly=4; Lz=0.1. grid = RegularCartesianGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz)). #Coefficient of Thermal expansion; alpha= 2e-4. #Coefficient of Salinity; saline=0. Ra=1.8e8 #rayleigh number. Ro=0.24 #Horizontal Rossby number. v=1e-6 #diffusive viscocity. k=1e-6 #diffusivity . l=Lx/2 #center of gaussian field. m=Ly/2 #center of gausian field. Bo=9e-5 #maximum surface flux. f=0.5386 #coriolis parameter. beta=4.039e-3. #Gaussian Surface forcing; heat_flux(x,y,t) = Bo*exp(-0.5*((x-l)^2+(y-m)^2)). dTdz = 0 # K m⁻¹. T_bcs = TracerBoundaryConditions(grid,; top = BoundaryCondition(Flux, heat_flux),; bottom = BoundaryCondition(Gradient, dTdz)). Qᵘ=0 #Zero flux boundary condition at the top surface. u_bcs = UVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = 300,equation_of_state=LinearEquationOfState(α=alpha, β=saline)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),. timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1432:215,error,error,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432,1,['error'],['error']
Availability,Restarting from a checkpoint should restore the time step?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3845:18,checkpoint,checkpoint,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3845,1,['checkpoint'],['checkpoint']
Availability,Resume from checkpoint should be integrated with model constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/602:12,checkpoint,checkpoint,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/602,1,['checkpoint'],['checkpoint']
Availability,"Revert ""Cut down the examples. Moved stuff into a sandbox.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/231:12,down,down,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/231,1,['down'],['down']
Availability,"Revert ""Fixes checkpointer GPU to CPU loading and writing fields with function boundary conditions""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/807:14,checkpoint,checkpointer,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/807,1,['checkpoint'],['checkpointer']
Availability,"Revert ""Revert ""Cut down the examples. Moved stuff into a sandbox.""""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/232:20,down,down,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/232,1,['down'],['down']
Availability,"Revert ""Update CUDA packages to get rid of CUDA errors on CPU and use CUDAapi.has_cuda()""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/387:48,error,errors,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/387,1,['error'],['errors']
Availability,"Reverts CliMA/Oceananigans.jl#1444. PR #1444 is quite nice but unfortunately I think the new `fill_halo_regions!`. ```julia; fill_halo_regions!(c::AbstractArray, fieldbcs, grid, args...; kwargs...); ```. broke MPI halo filling since it needs dispatch on. ```julia; fill_halo_regions!(c::AbstractArray, bcs, arch::AbstractMultiArchitecture, grid, c_location, args...); ```. It might be tricky to fix since you can't tell whether you're on `CPU` or `MultiCPU` from inside `fill_halo_regions!` with just knowledge of the `field`... I propose we revert #1444 just for now (since distributed models + tests are broken on master) and immediately open a new PR with the contents of #1444 where we can find a solution. My only idea is to add `architecture` to Field but perhaps it feels a little bloated... This failure was not caught by Buildkite since PR #590 was merged after #1444 was opened, and I think Buildkite only runs tests on branches, not pull requests (i.e. it doesn't merge master and run tests).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1484:804,failure,failure,804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484,1,['failure'],['failure']
Availability,"Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01 | 7.889e-03 | 8.798e-03 |; ```. (https://github.com/CliMA/OceananigansArtifacts.jl/pull/14). Everything is preliminary because we still need to upgrade to LESbrary 2.0 (with Stokes drift and more cases).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2423:1637,error,error,1637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423,2,['error'],['error']
Availability,Right now `show` errors since `ZeroField.grid` is not a struct property.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1682:17,error,errors,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1682,1,['error'],['errors']
Availability,"Right now if we do this, we get an obscure error from `calc_correct_velocity_u` (which is already a confusing name --- what's the ""incorrect"" velocity?). ```julia; nested task error: BoundsError: attempt to access 608-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -3:604) with eltype Float64 with indices -3:604 at index [-58]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:691; [2] checkbounds; @ ./abstractarray.jl:656 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] calc_correct_velocity_u; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:104 [inlined]; [5] update_particle_position!; @ ~/.julia/packages/Oceananigans/HYqGf/src/LagrangianParticleTracking/update_particle_properties.jl:72 [inlined]; ```. This probably has to be checked in model constructors, since `LagrangianParticles` doesn't know about `grid`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2684:43,error,error,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2684,2,['error'],['error']
Availability,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2107:934,error,error,934,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107,4,"['error', 'resilien']","['error', 'resilient']"
Availability,"Right now it seems like output writer file names cannot be 4 characters or shorter (if specified without an extension). MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size=(10, 10, 10), extent=(1, 2, 3)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""abcd"",; schedule = IterationInterval(1),; overwrite_existing = true; ); ```. Error:. ```; ERROR: BoundsError: attempt to access 4-codeunit String at index [0:4]; Stacktrace:; [1] checkbounds; @ ./strings/basic.jl:216 [inlined]; [2] getindex; @ ./strings/string.jl:468 [inlined]; [3] auto_extension(filename::String, ext::String); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/output_writer_utils.jl:219; [4] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Hkk5J/src/OutputWriters/jld2_output_writer.jl:179; [5] top-level scope; @ REPL[5]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. Also happens with `""a""`, `""ab""`, `""abc""`, but not `""abcde""`. Also an issue with `NetCDFOutputWriter` since it also uses `auto_extension`. I think an easy fix is to use built-in Julia functions instead of manual indexing:. ```diff; """"""; auto_extension(filename, ext); ; If `filename` ends in `ext`, return `filename`. Otherwise return `filename * ext`.; """"""; function auto_extension(filename, ext); - Next = length(ext); - filename[end-Next+1:end] == ext || (filename *= ext); - return filename; + if endswith(filen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3748:491,Error,Error,491,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3748,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,Right now it won't run on a computer without CUDA and is also why Travis CI builds are erroring. A quick hack would be to do something like what CliMA does:; ```julia; const HAVE_CUDA = try; using CUDAdrv; using CUDAnative; true; catch; false; end. macro hascuda(ex); return HAVE_CUDA ? :($(esc(ex))) : :(nothing); end. @hascuda device!(MPI.Comm_rank(mpicomm) % length(devices())); ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/62:87,error,erroring,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/62,1,['error'],['erroring']
Availability,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:682,failure,failure,682,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['failure'],['failure']
Availability,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1056:101,down,down,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056,1,['down'],['down']
Availability,"Right now the `Checkpointer docstring says. ```; Note that extra model `properties` can be safely specified, but removing; crucial properties such as `:velocities` will make restoring from the; checkpoint impossible.; ```. Would be good to print a warning if something crucial is missing from `properties`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/417:15,Checkpoint,Checkpointer,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/417,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint']"
Availability,"Right now the functions that calculate implicit vertical diffusion coefficients don't know about a field's horizontal location:. https://github.com/CliMA/Oceananigans.jl/blob/11727d66587e01067bf1ac24e2655e593e98fe9e/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L41-L44. except implicitly through `κ⁻⁻ᶠ`. However, when using an immersed boundary, we need the _horizontal_ location in order to correctly mask the coefficients of the implicit vertical diffusion tridiagonal matrix. So, rather than passing the function `κ⁻⁻ᶠ`, we should pass the field's location here. This will also mean that we only need one `ivd_upper_diagonal`, and we can dispatch on the special case that a field is located at cell interfaces in the vertical.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2116:420,mask,mask,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2116,1,['mask'],['mask']
Availability,Right now we just call `findfirst`:. https://github.com/CliMA/Oceananigans.jl/blob/b7871d3fc8b53e8bfecb5395e80287ac9c12d0da/src/OutputReaders/field_time_series.jl#L174. which will return `nothing` index if it doesn't find a time in the file that's approximately equal to the requested one. Then we can error because you can't index with `nothing`. It'd be nice to throw a helpful error instead of letting `getindex` error. This error might also help users debug because we could display the times that are nearby to the requested one.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2234:302,error,error,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2234,4,['error'],['error']
Availability,Robust setting of fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/343:0,Robust,Robust,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/343,1,['Robust'],['Robust']
Availability,Round-off error in `RegularCartesianGrid` produces ranges of wrong length,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/480:10,error,error,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/480,1,['error'],['error']
Availability,"Running a simulation with `FT=Float32` is fairly onerous because the number type has to be passed to a huge number of model components individually. Eg we need to write. ```julia; using Oceananigans; using SeawaterPolynomials: TEOS10EquationOfState. FT = Float32; grid = RectilinearGrid(FT, size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(FT, f=1); equation_of_state = TEOS10EquationOfState(FT); buoyancy = SeawaterBuoyancy(FT; equation_of_state); ```. Here are two ideas to make this easier:. ## Use an environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the num",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:869,error,error,869,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,1,['error'],['error']
Availability,Running the example from #2389 it returned this error; `ERROR: LoadError: UndefVarError: div_Uc not defined`. Hope this suggestion makes sense.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390:48,error,error,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"S7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_E5FieldIvvS14_vvvS22_IS7_Li3ES9_IS7_Li3ELi1EEES7_vvvES31_S32_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvES7_ES_S18_IS7_S19_S19_S20_S21_IS7_S19_S19_S20_S7_S7_S7_S22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvES25_IS22_IS7_Li2ES9_IS7_Li2ELi1EEES26_EvvE11NotImmersedI8truefuncES4_S7_E' uses too much parameter space (0x11f0 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compile(job::GPUCompiler.CompilerJob, ctx::LLVM.Context); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:208; [3] #1032; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:120 [inlined]; [4] JuliaContext(f::CUDA.var""#1032#1033""{GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}}); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/driver.jl:37; [5] compile; @ /glade/work/tomasc/.julia/packages/CUDA/pCcGc/src/compiler/compilation.jl:119 [inlined]; [6] actual_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams}, compiler::typeof(CUDA.compile), linker::typeof(CUDA.link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/NVLGB/src/execution.jl:125; [7] cached_compilation(cache::Dict{Any, Any}, src::Core.MethodInstance, cfg::GPUCompiler.CompilerConfi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:4486,error,error,4486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['error'],['error']
Availability,Seems like when we call. ```Julia; julia> maximum(f); ```; where `f::Field` then this is called:; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/src/Fields/field.jl#L600-L618. This errors on the GPU. Why not simply:. ```julia; import Base: maximum. maximum(f::Field) = maximum(parent(f.data)); ```; ?. cc @taimoorsohail,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2727:221,error,errors,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2727,1,['error'],['errors']
Availability,Seems that examples are NaNing out while building documentation since PR #1198 was merged even though everything was fine for the latest Buildkite build on that PR: https://buildkite.com/clima/oceananigans/builds/649. Two failures on the same commit so it's a consistent issue:; https://buildkite.com/clima/oceananigans/builds/824; https://buildkite.com/clima/oceananigans/builds/830. I was able to reproduce locally as well. Thankfully this is just master as PR #1198 was not part of v0.45.0. Not sure how that happened but if this issue can't be fixed soon we should revert #1198.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1247:222,failure,failures,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1247,1,['failure'],['failures']
Availability,Seems that there is a bug here?. https://github.com/CliMA/Oceananigans.jl/blob/5218acd72d146f063838286e7bf61c2d26165fbf/src/OutputReaders/field_time_series_indexing.jl#L205. `target_times` is never defined but used as an arg in the kernel?. This produces the error in the ClimaOcean CI; see https://buildkite.com/clima/climaocean-ci/builds/1264#01918d21-30e8-4d9c-9ee8-a220eb16eb28/202-514. cc @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3731:259,error,error,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3731,1,['error'],['error']
Availability,"Seems to be defined for x, y, z nodes but not λ and φ nodes. Probably just an easy case of defining a couple of extra functions. MWE:. ```julia; using Oceananigans. underlying_grid = RectilinearGrid(size=(12, 12, 12), extent=(1, 1, 1)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). xnodes(grid, Center(), Center(), Center()) # Works :); ynodes(grid, Center(), Center(), Center()) # Works :); znodes(grid, Center(), Center(), Center()) # Works :). underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). λnodes(grid, Center(), Center(), Center()) # Doesn't work :(; φnodes(grid, Center(), Center(), Center()) # Doesn't work :(; znodes(grid, Center(), Center(), Center()) # Works :); ```. Error:. ```; ERROR: MethodError: no method matching λnodes(::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, ::Center, ::Center, ::Center). Closest candidates are:; λnodes(::OrthogonalSphericalShellGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/orthogonal_spherical_shell_grid.jl:1154; λnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:652; λnodes(::Oceananigans.Grids.AbstractCurvilinearGrid, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:129; ... Stacktrace:; [1] top-level scope; @ REPL[18]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3771:892,Error,Error,892,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3771,2,"['ERROR', 'Error']","['ERROR', 'Error']"
Availability,Segmentation Fault when trying to run a script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655:13,Fault,Fault,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655,1,['Fault'],['Fault']
Availability,Segmentation fault filling halo regions with `Partition(y=2)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:13,fault,fault,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['fault'],['fault']
Availability,Should at least help with detecting doctest failures and we want to build+deploy docs on Buildkite anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1018:44,failure,failures,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018,1,['failure'],['failures']
Availability,Should be useful for LESbrary simulations whose states might actually have an associated date and time from the real world. But I'm not sure if we should merge this PR as `DateTime` from `Base.Dates` only has millisecond precision so you could get small errors in actual `model.clock.time` after many iterations (LESbrary simulations will probably run for millions of iterations). Two small packages that might help us here; https://github.com/JeffreySarnoff/TimesDates.jl; https://github.com/FugroRoames/Chrono.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/632:254,error,errors,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/632,1,['error'],['errors']
Availability,"Should help address some outstanding issues about error accumulation in `model.clock.time`, like #3606 and #3056.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3617:50,error,error,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3617,1,['error'],['error']
Availability,"Should probably add a note on citing Oceananigans.jl to the README and docs. A lot of other packages do this. Would also make the ""Development team"" section kinda redundant so we could remove it then.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1101:163,redundant,redundant,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1101,1,['redundant'],['redundant']
Availability,"Should we replace grid if halos are wrong, or throw an error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2107:55,error,error,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107,1,['error'],['error']
Availability,Should we throw an error if users try to run code with a julia version that's too low?. cc @mukund-gupta,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2142:19,error,error,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2142,1,['error'],['error']
Availability,"Shouldn't be too hard to implement an `InterpolatedField` object where. ```julia; ℑc = InterpolatedField(model.tracers.c, new_grid); ℑc(x, y, z); ```. evaluates the `model.tracers.c` field at the location `(x, y, z)` with tri-linear interpolation (for now, could support other interpolation schemes in the future but not sure if it's that beneficial). This has at least three potential uses:; 1. Lagrangian particle tracking where the velocities need to be evaluated in-between grid points.; 2. Writing output to a custom grid (different from the model grid). This should be as easy as passing an `InterpolatedField` to one of the output writers.; 3. If a custom grid is passed when restoring from checkpoint, i.e. `restore_from_checkpoint(filepath, grid=new_grid)`, the checkpointed fields are interpolated onto the new grid. This is useful for spinning up simulations on a coarse grid then restoring from checkpoint on a finer grid. cc @sandreza from our Slack discussion on mesoscale channels",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/975:698,checkpoint,checkpoint,698,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/975,3,['checkpoint'],"['checkpoint', 'checkpointed']"
Availability,Sign error in Docs/Numerical implementation/Pressure decomposition,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2653:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2653,1,['error'],['error']
Availability,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/316:199,down,downloaded,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316,1,['down'],['downloaded']
Availability,Simplify checkpointer and make it work for large models,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628:9,checkpoint,checkpointer,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628,1,['checkpoint'],['checkpointer']
Availability,"Since it has to do with the `*nodes` functions this might be closely related to issue #3771 although the error is different so I'm opening a separate issue about it. I'll look into both together. MWE:. ```julia; using Oceananigans. underlying_grid = LatitudeLongitudeGrid(size = (12, 12, 12), latitude = (0, 1), longitude = (0, 1), z = (-1, 0)); slope(x, y) = x + y - 1; grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid). NetCDFOutputWriter(model, model.velocities; filename=""test"", schedule=IterationInterval(1)); ```. Error:. ```; ERROR: MethodError: no method matching xnodes(::LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetArrays.OffsetVector{…}, Float64, Float64, Float64, Float64, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, OffsetArrays.OffsetVector{…}, CPU}, ::Center; with_halos::Bool). Closest candidates are:; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:655; xnodes(::LatitudeLongitudeGrid, ::Any, ::Any; with_halos); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/latitude_longitude_grid.jl:635; xnodes(::Any, ::Any, ::Any, ::Any; kwargs...); @ Oceananigans ~/atdepth/Oceananigans.jl/src/Grids/nodes_and_spacings.jl:79; ... Stacktrace:; [1] xnodes(ibg::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, loc::Center; kwargs::@Kwargs{with_halos::Bool}); @ Oceananigans.ImmersedBoundaries ~/atdepth/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:268; [2] native_dimensions_for_netcdf_output(grid::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, LatitudeLongitudeGrid{…}, GridFittedBottom{…}, Nothing, Nothing, CPU}, indices::Dict{String, Tuple{…}}, TX::Type{Bounded}, TY::Type{Bounded}, TZ::Type{Bounded}, Hx::Int64, Hy::Int64, Hz::Int64); @ Oceananigans.OutputWriters ~/atdepth/Oceananig",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3775:105,error,error,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3775,3,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,Slims down model size for many tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/937:6,down,down,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937,1,['down'],['down']
Availability,"So far we have a better error message but after trying a few different things I couldn't get `_permute_index(i, N)` to work =/. Gonna keep this open since it's becoming a high priority issue. Resolves #828",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/997:24,error,error,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/997,1,['error'],['error']
Availability,"So initially me and @djlikesdjs were trying to use the `SplitExplicitFreeSurface` with the adaptive barotropic step based on CFL. This:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)). free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); ```. errors. ```Julia; ERROR: ArgumentError: either specify a cfl or a number of substeps; Stacktrace:; [1] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings(FT::DataType; substeps::Int64, cfl::Float64, grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, fixed_Δt::Nothing, gravitational_acceleration::Float64, averaging_kernel::Function, timestepper::Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:343,error,errors,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,2,"['ERROR', 'error']","['ERROR', 'errors']"
Availability,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:141,error,errors,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,3,['error'],"['error', 'errors']"
Availability,"So, only now am I realizing that maybe the name `gravitational_unit_vector` is misleading since it points the opposite way as it should. . I think what we had in mind was the vertical unit vector, which should point up, but we ended up naming it `gravitational_unit_vector`, which actually points down! I suggest a change to `vertical_unit_vector` which is more in line with what we want, and also the same name can be used when we implement that tilting of the Coriolis parameter. So a user could set-up a simulation as. ```julia; model = IncompressibleModel(grid, buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=g̃),; coriolis = FPlane(f=1e-4, vertical_unit_vector=g̃,); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1496:297,down,down,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1496,1,['down'],['down']
Availability,"Some model constructor kwargs, e.g. `boundary_conditions` and `forcing` need to be named tuples otherwise things can silently fail (or fail in an obscure manner). Would be nice if the model constructors threw an error if it expected a named tuple. Could just type the kwargs, e.g. `boundary_conditions::Union{Nothing,NamedTuple}` like we did for #1118. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1204:212,error,error,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1204,1,['error'],['error']
Availability,Some regular maintenance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/860:13,mainten,maintenance,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/860,1,['mainten'],['maintenance']
Availability,Sometimes different Buildkite jobs try to download the same file as the same time leading to freezes like in https://buildkite.com/clima/oceananigans/builds/3066#157d0809-a11d-476b-b78d-fc5b1a241286. This PR tries to avoid race conditions by just downloading the file once during the initialization stage. Doesn't always happen though so not sure when/how to merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1804:42,down,download,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804,2,['down'],"['download', 'downloading']"
Availability,"Sometimes it's useful to run a simulation with tracers and have the tracers start evolving _only_ after a certain spin-up period. Since https://github.com/CliMA/Oceananigans.jl/pull/2938 this is possible by running a simulation without tracers, saving a checkpoint file from it, building a new model that is identical to the previous one but with extra tracers, manually `set!()` the prognostic fields from the checkpoint file, and then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:254,checkpoint,checkpoint,254,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,3,"['checkpoint', 'down']","['checkpoint', 'downsides']"
Availability,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/855:340,error,error,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855,1,['error'],['error']
Availability,"Somewhere between this commit ; https://buildkite.com/clima/oceananigans-distributed/builds/3113#01917ace-fe81-401d-ba21-467037e6aead; and main, we switched from using `libmpitrampoline.so` in the distributed tests to `libmpi.so` downloaded from the artifacts. . Previously, the mpi trampoline was loading a CUDA-aware implementation of Open MPI, while the libmpi.so we use now is a ; MPICH implementation non CUDA-aware:; https://buildkite.com/clima/oceananigans-distributed/builds/4227#0192f70a-b947-4d38-bd1c-c2497a964de9. This makes our GPU distributed tests fail. ; I am wondering where this switch happened because I couldn't trace any changes to the code. @Sbozzolo, do you know if something changed in the `LocalPreferences.toml` in the Caltech cluster?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3897:230,down,downloaded,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3897,1,['down'],['downloaded']
Availability,"Sorry in advance if I'm packing too much stuff into one issue. Let me know if that's the case and I can separate this into other issues. The function `calc_κᶜᶜᶜ()` is only defined for the AMD closure, so for every other closure it silently defaults to https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_utils.jl#L33. So one obvious thing is that we definitely should define `calc_κᶜᶜᶜ()` for other closures. A bigger question regards the use of multiple dispatch to create this ""default"" behavior for when the desired behavior isn't implemented yet. In this case, silently defaulting to `zero()` made be lose some hours of work because I thought there was something wrong with my script, when in reality `calc_κᶜᶜᶜ()` just wasn't defined for the closure I was using. Sure, this is a bit my fault for not checking the code thoroughly, but from a user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c7",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751:868,fault,fault,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751,2,"['error', 'fault']","['error', 'fault']"
Availability,"Started to write documentation and docstrings but some parts of the code were a little too messy to be documented easily, so I ended up doing some cleanup that seems to deserve its own PR. I mainly renamed all the abstract types to have the `Abstract` prefix (following the Julia style guide) and simplified `LinearEquationOfState`, `PlanetaryConstants`, and `RegularCartesianGrid` where I removed properties that weren't being used or that were redundant/useless. Resolves #190 (because the constants in question have been removed); Resolves #285",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/406:446,redundant,redundant,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/406,1,['redundant'],['redundant']
Availability,"Starting proposal for tasks that ensure the cubed sphere halo filling and dynamics are correct:. - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash. ```[tasklist]; ### Tasks; - [ ] Advect a Gaussian bump over the sphere, show correctness of the solution and tracer conservation.; - [ ] Test that the velocity halos are correct by direct inspection.; - [ ] Test that vorticity can be computed (also at corners), recover analytical solution; - [ ] Shallow water tests: Rossby-Haurwitz, Gaussian splash; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3020:333,recover,recover,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3020,2,['recover'],['recover']
Availability,Summary of Callback with parameters gave an error before,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2750:44,error,error,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2750,1,['error'],['error']
Availability,Supressing harmless warning and error messages,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/366:32,error,error,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/366,1,['error'],['error']
Availability,"Take the 1D diffusion example: https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/. This is the plotting code:. ```julia; using JLD2. file = jldopen(simulation.output_writers[:temperature].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i, iter) in enumerate(iterations). T = file[""timeseries/T/$iter""][1, 1, :]; t = file[""timeseries/t/$iter""]. plot(T, z, linewidth=2, title=@sprintf(""t = %.3f"", t),; label="""", xlabel=""Temperature"", ylabel=""z"", xlims=(0, 1)); end; ```. But where did `z` come from? From `z = znodes(model.tracers.T)` some lines above. But what if I want to plot in a separate script? Or what if I run my simulation on a cluster and want to plot some data on a different machine?. One solution would be to use `z = file[""grid/zC""]`. However, users may be surprised to learn that this output is not sliced and includes halos though (https://github.com/CliMA/Oceananigans.jl/issues/1194) so many plotting libraries will error because of some dimension mismatch. So if you don't have access to the `grid` then you can't plot the coordinates correctly without wrangling with `file[""grid""]` (which requires users to know about halos). And users may want to plot using other programming languages and libraries/programs where you can't get access to an Oceananigans grid. ---. I guess I'm advocating for plotting without using any Oceananigans functions to make the examples more useful for users. We can make the plotting code more local which would make it more copy-paste-able for users (more user friendly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1405:1014,error,error,1014,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405,1,['error'],['error']
Availability,Tests whether the Poisson solver can recover an analytic solution that is a product of sines and cosines. It can!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/227:37,recover,recover,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/227,1,['recover'],['recover']
Availability,"Thanks to @hennyg888 , we now have scalings results for the distributed shallow water and nonhydrostatic models for both weak and strong scaling going up to 128 cores. . https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md. The good news is that the `ShallowWaterModel`, in both weak and strong scaling, reaches efficienties of around 80% on 128 cores. This is something we can probably make better but not the first concern. The not so good news is that the `NonhydrostaticModel`, the efficiency goes down close to 10%. I don't know why but wanted to mention it as it's something that we should be able to do much better with. Thoughts? @christophernhill @glwagner @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1948:534,down,down,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948,1,['down'],['down']
Availability,"The CPU status in the README currently states that a build is erroring: . <img width=""995"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/77115376-96c30c80-6a04-11ea-95dc-c94f17dd09d7.png"">. However, [clicking on the banner](https://travis-ci.com/climate-machine/Oceananigans.jl) shows that this result does not correspond to `master`:. <img width=""815"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/77115429-ae01fa00-6a04-11ea-82fd-855fe9534062.png"">. but instead to the branch `glw/forced-flow-verification`. Is this what is intended?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/712:62,error,erroring,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/712,1,['error'],['erroring']
Availability,"The `@hascuda` macro used to be necessary but with the addition of `CUDA.has_cuda()` I don't think it is anymore. So this PR finally gets rid of the `@hascuda` macro. It's been a source of errors for users, especially when using Oceananigans on clusters where some nodes have GPUs and others do not. So hopefully this PR will help reduce errors for users on clusters.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1589:189,error,errors,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1589,2,['error'],['errors']
Availability,"The `NetCDFOutputWriter` requires the keyword argument `filename`:. https://github.com/CliMA/Oceananigans.jl/blob/ed73ad36c99b61f24c37c73e4a2d26a12c7601d9/src/OutputWriters/netcdf_output_writer.jl#L147-L163. while `JLD2OutputWriter` requires `prefix` (which is optional, even though the default `prefix=""""` would produce a file called `.jld2`:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/jld2_output_writer.jl#L56-L60. There are also some minor differences: `filename` is used for the NetCDF writer, while `filepath` is used for the JLD2 writer. We should probably even out these differences:. * I think `filename` is more descriptive than `prefix`; * I also think its redundant to require the user to specify the file suffix (`.jld2` or `.nc`) in addition to specifying `JLD2` or `NetCDF` in the output writer name. So we need to weigh the two above considerations in coming to a decision. ; * `filepath` may be a better name for the struct member if we are also going to allow the keyword argument `dir` (this is not part of `NetCDFOutputWriter` either). In general I think we should strive to make all the keywords as identical as possible so that users can switch between the writers by changing `NetCDF` to `JLD2` and vice versa.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/884:731,redundant,redundant,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884,1,['redundant'],['redundant']
Availability,"The `PoissonBCs`:. https://github.com/climate-machine/Oceananigans.jl/blob/c961d3904700e73b1a4aebb71ebcc3f518693014/src/poisson_solvers.jl#L4. are redundant with the boundary conditions on the velocity fields. In other words, the pressure boundary conditions *depend* on the boundary conditions applied to the velocity field. There should not, therefore, be separate boundary condition types for the pressure solver. In particular, periodic boundary conditions on the velocity fields imply periodic boundary conditions on the pressure solver, while non-periodic boundary conditions on the velocity fields imply Neumann boundary conditions for the pressure solver. The redundant implementation of boundary condition complicates model instantiation (the boundary conditions on the Poisson solver should be *inferred* from the boundary conditions on the velocity field, rather than specified independently), and is a source of fragility (because a physically invalid combination of boundary conditions on the velocity field and pressure solver can be specified).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/311:147,redundant,redundant,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/311,2,['redundant'],['redundant']
Availability,"The `precondition!` defined for `DiagonallyDominantPreconditioner` takes the arguments:. ```julia; P_r, ::DiagonallyDominantInversePreconditioner, r, ∫ᶻ_Axᶠᶜᶜ, ∫ᶻ_Ayᶜᶠᶜ, ...; ```. https://github.com/CliMA/Oceananigans.jl/blob/2edd2b1fa321725ad4e7891d3442ca9dd0657d98/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L243. however, the _fourth_ argument to `precondition` is supposed to be the free surface displacement (ie, the solution to the implicit step equation) as in. https://github.com/CliMA/Oceananigans.jl/blob/2edd2b1fa321725ad4e7891d3442ca9dd0657d98/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L191. as I recall this preconditioner has never worked properly (ie it slows down convergence rather than speeding it up). Is this the reason?. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2668:722,down,down,722,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2668,1,['down'],['down']
Availability,"The call to `Field()` doesn't appear to be working with just the `indices` keyword argument:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> model = NonhydrostaticModel(; grid); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> Field(model.velocities.u; indices=(:,:,1)); ERROR: MethodError: no method matching Field(::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}; indices=(Col",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2391:854,ERROR,ERROR,854,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391,1,['ERROR'],['ERROR']
Availability,"The codebase makes extensive use of `@inbounds`, for good reason and usually pretty safely. But does it make sense to run the tests with `--check-bounds=yes` to catch any cases of out-of-bounds memory accesses?. Out of bounds accesses don't always produce an error and can silently lead to undefined behavior. This may lead to slightly slower tests, although I doubt it would slow them down by much as most of the time is spend on compiling. Might help with discovering certain issues sooner. Probably #3615 but maybe not #3320. X-Ref: https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3747:259,error,error,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3747,2,"['down', 'error']","['down', 'error']"
Availability,"The current Manifest conflicts with FFMPEG v0.4 and thus enforces it to fallback to FFMPEG v0.2.; This, in principle, is not a problem since we don't depend on FFMPEG. But as soon as we try to use Makie/GLMakie which has FFMPEG as a dependency then it is forced to use FFMPEG v0.2. FFMPEG v0.2 cannot compile on Apple’s M1/M2 chips and this creates errors and inconvenience. . I tried to enforce installing `FFMPEG@v0.4` on the current environment and this resulted in downgrade of some `jll`s. ```; ⌅ [0234f1f7] ↓ HDF5_jll v1.14.0+0 ⇒ v1.12.2+2; ⌃ [7243133f] ↓ NetCDF_jll v400.902.208+0 ⇒ v400.902.5+1; ⌅ [458c3c95] ↓ OpenSSL_jll v3.0.9+0 ⇒ v1.1.21+0; ```. Informed by that, this PR ensures that those `jll`s satisfy `FFMPEG`s dep requirements so that people with Apple M1/2 chips (like myself) can still use Oceananigans + Makie for plotting. I've been troubling with this all morning along with @glwagner and @siddharthabishnu. Not sure if this is the best solution possible, but it does work. Hopefully this is something that it will be fixed from other packages moving forward.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3161:349,error,errors,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161,2,"['down', 'error']","['downgrade', 'errors']"
Availability,"The deep convection golden master fails intermittently even if the random number generator is seeded with the same value. Some randomness is added to the initial surface temperature. For now the 5 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". @christophernhill suggested using a portable random number generator: http://mitgcm.org/download/daily_snapshot/MITgcm/model/src/port_rand.F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176:368,down,download,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176,1,['down'],['download']
Availability,"The docs have an incorrect description of the `AnisotropicBiharmonicDiffusivity`: . https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/#Constant-anisotropic-biharmonic-diffusivity. since the docs claim we use a horizontal biharmonic operator (dx^2 + dy^2)^2 + dz^2, despite that in our implementation:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L64-L68. we actually use dx^4 + dy^4 + dz^4. Our implementation is not truly biharmonic, but is instead might be described as ""fourth-order hyperdiffusion"". A downside of the form we use is that the amount of dissipation it provides depends on the orientation of a feature (""diagonal"" gradients are dissipated less than purely horizontal or vertical gradients). An upside is that we can ensure zero fluxes on solid boundaries more easily. We could solve this by having separate implementation of the true horizontal biharmonic operator for `AnisotropicBiharmonicDiffusivity` (still useful for horizontally-periodic problems), as well as a `FourthOrderHyperDiffusivity` that uses our current implementation. It also might make sense to have `IsotropicBiharmonicDiffusivity` since we can do triply periodic.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1279:679,down,downside,679,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1279,1,['down'],['downside']
Availability,"The example [`validation/immersed_boundaries/flow_over_hills.jl`](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/flow_over_hills.jl) in the main branch is failing for me with the following cryptic error (which I've truncated because it was too long to fit). The error clearly has something to do with how bottom drag interacts with the immersed boundaries, but I haven't made much progress debugging. ```julia; Exception has occurred: CompositeException; TaskFailedException. nested task error: BoundsError: attempt to access 1-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64} at index [2]; Stacktrace:; [1] throw_boundserror(A::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/dy5oz/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./range.jl:932 [inlined]; [5] ynode(::Face, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}); @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [6] overdub; @ ~/LocalDocs/code/Oceananigans.jl/src/Grids/rectilinear_grid.jl:366 [inlined]; [7] ynode(::Face, ::Face, ::Center, ::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:232,error,error,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,3,['error'],['error']
Availability,"The example below throws an error. ```julia; julia> grid = RectilinearGrid(size=(4,4,4,), extent=(1,1,1)); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid, tracers=:b); NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: Nothing; ├── buoyancy: Nothing; └── coriolis: Nothing. julia> b = model.tracers.b; 4×4×4 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 10×10×10 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> bcs = FieldBoundaryConditions(grid, (Center, Center, Face); top=GradientBoundaryCondition(1), bottom=GradientBoundaryCondition(1)); Oceananigans.FieldBoundaryConditions, with boundary conditions; ├── west: PeriodicBoundaryCondition; ├── east: PeriodicBoundaryCondition; ├── south: PeriodicBoundaryCondition; ├── north: PeriodicBoundaryCondition; ├── bottom: GradientBoundaryCondition: 1; ├── top: GradientBoundaryCondition: 1; └── immersed: FluxBoundaryCondition: Nothing. julia> b_z = Field(∂z(b), boundary_conditions=bcs); ERROR: ArgumentError: Cannot specify bottom boundary condition GradientBoundaryCondition: 1 on a field at Face()!; Stacktrace:; [1] validate_boundary_condition_location(bc::BoundaryCondition{Oceananigans.BoundaryConditions.Gr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2837:28,error,error,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2837,1,['error'],['error']
Availability,"The floating point type can and should be determined from `eltype(grid)`, since `grid` is a required argument for constructing `IncompressibleModel`. An independent `float_type` argument is not only redundant but creates the possibility that models can have inconsistent float types. Eliminating this argument and using `eltype(grid)` as the source of knowledge re: floating point types solves this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1786:199,redundant,redundant,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1786,1,['redundant'],['redundant']
Availability,"The following snippet fails:. ```julia; using Oceananigans; grid_base = RectilinearGrid(size=(8, 8, 8), extent = (1,1,1), halo=(4,4,4)); bathymetry(x, y) = -0.5; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); WENO(grid=grid); ```. The error is. ```; julia> WENO(grid=grid); ERROR: ArgumentError: The dimensions of the immersed boundary (16, 16) do not match the grid size (18, 18); Stacktrace:; [1] validate_ib_size(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/9znTg/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/9znTg/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3137:258,error,error,258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3137,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"The function `interpolate` is currently mostly used for Lagrangian particle advection:. https://github.com/CliMA/Oceananigans.jl/blob/d0b7ec8f98c860ce49927e0a7214961d2f47fb75/src/Fields/interpolate.jl#L186-L198. However, it's also potentially useful for many other things. Right now though it doesn't work (or make sense) for fields with `Nothing` locations:. ```julia; source_grid = RectilinearGrid(size=(2, 2), x=(0, 1), y=(0, 1), topology=(Periodic, Periodic, Flat)); s = Field{Center, Center, Nothing}(source_grid); set!(s, (x, y) -> x + y); loc = Tuple(L() for L in location(s)); x = y = 0.67; z = 0; interpolate(s, loc..., source_grid, x, y, z); ```. gives. ```julia; julia> interpolate(s, loc..., source_grid, x, y, z); ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base ./tuple.jl:29; [2] fractional_z_index; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:110 [inlined]; [3] fractional_indices; @ ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:133 [inlined]; [4] interpolate(field::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356:727,ERROR,ERROR,727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356,1,['ERROR'],['ERROR']
Availability,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/603:124,checkpoint,checkpoint,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603,5,['checkpoint'],"['checkpoint', 'checkpointer']"
Availability,"The installation instructions are helpful for users who have downloaded julia. However, to run examples one needs to know how to use git, and also to have a text editor. Neither of these is necessarily trivial so it might be nice both to provide some simple explanations about how to get started with running the examples, and also to link to info about text editing, IDEs, and using github.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149:61,down,downloaded,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149,1,['down'],['downloaded']
Availability,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:268,down,down,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['down'],['down']
Availability,"The line `model.tracers.T.data .= 282.99 .+ 2 .* reshape(hot_bubble_perturbation, (Nx, Ny, Nz))` in the README should be replaced with `data(model.tracers.T) .= model.eos.T₀ .- 0.01 .+ 2 .* reshape(hot_bubble_perturbation, (Nx, Ny, Nz))`. The former gives a broadcast error. The latter is used in the `rising_thermal_bubble_2d.jl` example and seems to produce the expected bubble.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/267:268,error,error,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/267,1,['error'],['error']
Availability,The main point of upgrading is to get rid of CUDA errors on the CPU and use `CUDAapi.has_cuda()` which replaces the `HAVE_CUDA` variable we've been using. This was originally in PR https://github.com/climate-machine/Oceananigans.jl/pull/378 (this PR is mostly cherry picked commits) but when it was merged @glwagner reported issues with forcing functions on the GPU. So now I've added a test that makes sure that forcing functions don't crash when used in a CPU or GPU model (one with and one without `const`).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/388:50,error,errors,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388,1,['error'],['errors']
Availability,The preview will be available here:. https://clima.github.io/OceananigansDocumentation/previews/PR1148/generated/langmuir_turbulence/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1148:20,avail,available,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1148,1,['avail'],['available']
Availability,"The primary issue fixed here are actually the tests themselves, rather than the implementation. However this PR also makes a number of small improvements to the implementation, including a bug in which `recompute_safely` was implemented wrong (despite producing correct behavior, due to a ""cancellation of errors""). It looks like computations on `Faces` and along `Bounded` dimensions may not be possible with `BuoyancyField`. I will open an issue with an MWE. This is not a high-priority, because making such computations on boundaries correct in general really requires solving #971 ; otherwise we cannot guarantee that boundary conditions are correct (and they will often be wrong when averages are taken, as they commonly are during output). Relies on #1016 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1020:306,error,errors,306,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1020,1,['error'],['errors']
Availability,"The signature of the model constructor is . ```julia; function IncompressibleModel(;; grid,; architecture = CPU(),; float_type = Float64,; tracers = (:T, :S),; closure = ConstantIsotropicDiffusivity(float_type, ν=ν₀, κ=κ₀),; clock = Clock{float_type}(0, 0), ; buoyancy = SeawaterBuoyancy(float_type),; coriolis = nothing,; surface_waves = nothing,; forcing = ModelForcing(),; boundary_conditions = (u=UVelocityBoundaryConditions(grid),; v=VVelocityBoundaryConditions(grid),; w=WVelocityBoundaryConditions(grid)),; parameters = nothing,; velocities = VelocityFields(architecture, grid, boundary_conditions),; tracer_fields = TracerFields(architecture, grid, tracernames(tracers), boundary_conditions),; pressures = PressureFields(architecture, grid, boundary_conditions),; diffusivities = DiffusivityFields(architecture, grid, tracernames(tracers), boundary_conditions, closure),; timestepper_method = :AdamsBashforth,; timestepper = TimeStepper(timestepper_method, float_type, architecture, grid, tracernames(tracers)),; pressure_solver = PressureSolver(architecture, grid, PressureBoundaryConditions(grid)); ) ; ```. Issues:. 1. `tracers` is apparently expected only to be a tuple of symbols. Nevertheless, the function `tracernames` is called on this argument --- whose only purpose is to return tracer names when its argument may *either* be a tuple of symbols, or a tuple of fields. 2. The arguments (`tracers`, `tracer_fields`) and (`timestepper_method`, `timestepper`) are redundant. . 3. Worse, `tracer_fields` can be set to something inconsistent with `tracers`, and therefore `diffusivities` and `timestepper`. It's probably best if we assign only one keyword argument to each ""concept"", for the sake of simplicity and interpretability. A little bit of cleaning / interpretation to arguments (eg, if an argument may either be a tuple of symbols corresponding to tracer names, or a tuple of tracer fields) is ok, in my opinion, because it could make the code less confusing and easier to use.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/647:1479,redundant,redundant,1479,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/647,1,['redundant'],['redundant']
Availability,"The spacings functions aren't working for `ImmersedBoundaryGrid`s on `main`. This PR fixes that. On main:. ```julia; julia> using Oceananigans. julia> grid_base = RectilinearGrid(size=(4, 5, 6), extent=(1, 1, 1));. julia> ibg = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1)); 4×5×6 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=1.00e+00, max(h)=1.00e+00); ├── underlying_grid: 4×5×6 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.2; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.166667. julia> xspacings(ibg, Center()); ERROR: MethodError: no method matching xspacings(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::Center); Closest candidates are:; xspacings(::Any, ::Any, ::Any, ::Any; with_halos) at ~/repos/Oceananigans.jl/src/Grids/grid_utils.jl:363; xspacings(::Any, ::ImmersedBoundaryGrid) at ~/repos/Oceananigans.jl/src/ImmersedBoundaries/immersed_grid_metrics.jl:37; xspacings(::Oceananigans.Grids.XRegRectilinearGrid, ::Center; with_halos) at ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:473; ...; Stacktrace:; [1] top-level scope; @ REPL[18]:1; ```. On this branch:. ```julia; julia> xspacings(ibg, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143:775,ERROR,ERROR,775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143,1,['ERROR'],['ERROR']
Availability,"There are a couple of issues with reductions on a fts.; Given the following field time series; ```julia; grid = RectilinearGrid(size = (1, 1, 1), extent = (1, 1, 1)); fts = FieldTimeSeries{Center, Center, Center}(grid, 1:10; backend = OnDisk(), path = ""./test.jld2"", name = ""T""); f = CenterField(grid). for i in 1:10; set!(f, i); set!(fts, f, i); end; ```. ```julia; julia> sum(f; dims = 1); ERROR: UndefVarError: `filltype` not defined; Stacktrace:; [1] sum(f::Function, fts::FieldTimeSeries{…}; dims::Int64, kw::@Kwargs{}); @ Oceananigans.OutputReaders ~/development/Oceananigans.jl/src/OutputReaders/field_time_series_reductions.jl:30; [2] sum(fts::FieldTimeSeries{…}; kw::@Kwargs{…}); @ Oceananigans.OutputReaders ~/development/Oceananigans.jl/src/OutputReaders/field_time_series_reductions.jl:38; [3] top-level scope; @ REPL[19]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; Also, I think that the index for the reduction here is wrong, `i` instead of `n`; https://github.com/CliMA/Oceananigans.jl/blob/3c95e7ee6772a2597e206ae35202500be1ef5b32/src/OutputReaders/field_time_series_reductions.jl#L42-L45",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3752:392,ERROR,ERROR,392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3752,1,['ERROR'],['ERROR']
Availability,"There are a few gotchas when setting up GPU simulations so it's not always as simple as just changing `CPU` to `GPU`, mainly related to things the GPU compiler does not like. A common one that produces a very non-obvious error is using global variables in forcing functions or any function that will get used in a GPU kernel (e.g. https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704 and https://github.com/CliMA/Oceananigans.jl/issues/1477). Might be helpful for users if we add a section or page to the docs that describes these issues.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478:221,error,error,221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478,1,['error'],['error']
Availability,"There have been 78 commits since the last release so I thought it would be good to put out a checkpoint release. Happy to close this PR if people think this is not necessary. Release notes could say:. Checkpoint release including very experimental support for curvilinear grids, a vertically-stretched rectilinear grid, and a preconditioned conjugate-gradient solver. (or nothing at all). There should be no breaking changes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1388:93,checkpoint,checkpoint,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388,2,"['Checkpoint', 'checkpoint']","['Checkpoint', 'checkpoint']"
Availability,"There is a bug when trying to auto add bgc tracers when a user has specified a namedtuple of tracers. @glwagner I recall discussing dropping support for auto adding tracers, I find it quite useful but can't remember where we landed. . This PR:; - fixes an issue with auto adding bgc tracers; - fixes an issue with auxiliary field dependant forcing in hydrostatic free surface models and boundary conditions; - adds an error when a user tries to define a forcing or functional boundary condition which depends on a field not found in the model, previously this would just raise a mysterious error like the one in https://github.com/OceanBioME/OceanBioME.jl/pull/146#issuecomment-1755771558",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3323:418,error,error,418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3323,2,['error'],['error']
Availability,"There is a test for immersed boundary inside `test_implicit_free_surface.jl` but it seems to be *trivially passing* (see, e.g., the [log](https://buildkite.com/clima/oceananigans/builds/8449#0182eb0d-74d3-440e-92a7-eb0ffecfb042/25-734) from tests run on `main`). One problem was that `set_simple_divergent_velocity!` function defined at; https://github.com/CliMA/Oceananigans.jl/blob/af21542ba01afe92e7fc4de6251dec55ed5182c7/test/test_implicit_free_surface_solver.jl#L17-L35; was setting a non-zero `u` velocity in the center of the domain at `k = 1`, but that was inside the immersed boundary. I changed the [`set_simple_divergent_velocity!`](https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/test/test_implicit_free_surface_solver.jl#L17-L46) function to address that. However, still there is an issue... I managed to pinpoint it down to the step:. https://github.com/CliMA/Oceananigans.jl/blob/f585ef8a3ccd80d1418d9fed5d573ed7d3ecb4d3/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl#L140. Here's a demonstration... (not a MWE). I have a model with non-zero `u` velocity:. ```; julia> model.velocities.u; 129×1×5 Field{Face, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Open, east: Open, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 135×7×11 OffsetArray(::Array{Float64, 3}, -2:132, -2:4, -2:8) with eltype Float64 with indices -2:132×-2:4×-2:8; └── max=0.1, min=0.0, mean=0.000159236. julia> model.velocities.u[imid, 1, 3]; 0.1; ```. ```Julia; julia> ∫ᶻQ = model.free_surface.barotropic_volume_flux; NamedTuple with 2 Fields on 128×1×5 ImmersedBoundaryGrid{Float64, Bounded, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── u: 129×1×1 Field{Face, Center, Nothing} reduced over dims = (3,) on ImmersedBoundaryGrid on CPU; └── v: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2723:869,down,down,869,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2723,1,['down'],['down']
Availability,"There is some issue when we pick up from a checkpoint and we start with an `AveragedTimeInterval`. If we, e.g., start with `AveragedTimeInterval(Xdays)` but the pick up time was not a multiple of `Xdays` then the first average does not carry on for the correct time interval. There may be more issues related to this. I just noticed this and thought I put it out there. [found with @glwagner]",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2226:43,checkpoint,checkpoint,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2226,1,['checkpoint'],['checkpoint']
Availability,"There seems to be an issue with running on GPUs with the latest master branch. Specifically one gets errors with launch, which could be due to GPUify loops requiring a specific version of cuda native. See for example,. <img width=""1670"" alt=""Screen Shot 2020-06-20 at 5 23 11 PM"" src=""https://user-images.githubusercontent.com/22668662/86287910-b266b300-bbae-11ea-96a0-7b1e4fa6d250.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/784:101,error,errors,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/784,1,['error'],['errors']
Availability,"There was a bug in the earlier v4 releases so Oceananigans won't work with them (this has come up as CUDAv4.0 is the final version compatible with CUDA 10.2). ```julia; julia> using Oceananigans; ┌ Warning: The NVIDIA driver on this system only supports up to CUDA 10.2.0.; │ For performance reasons, it is recommended to upgrade to a driver that supports CUDA 11.2 or higher.; └ @ CUDA ~/.julia/packages/CUDA/ZdCxS/src/initialization.jl:71; julia> grid = RectilinearGrid(GPU(); size = (128, 128, 128), extent = (1, 1, 1)); mo128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0078125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0078125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0078125. julia> model = NonhydrostaticModel(; grid); ERROR: UndefVarError: `CUDABackend` not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:31 [inlined]; [2] device(#unused#::GPU); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/f5Cpw/src/Architectures.jl:39; [3] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Oceananigans.Utils.KernelParameters{:xy, (0, 0)}, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; include_right_boundaries::Bool, r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3402:852,ERROR,ERROR,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402,1,['ERROR'],['ERROR']
Availability,"There was a. ```Julia; x, y, z = node(...); ```. but only `z` was needed. And `node` returns a different-size tuple depending on how many dimensions of `grid` are non-flat. Thus there was issues sometimes. Now that part of the code became. ```Julia; z = znode(...); ```. which is much more robust!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3530:290,robust,robust,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3530,1,['robust'],['robust']
Availability,"There's a bug in `adapt_advection_order` (or the constructor for `HydrostaticFreeSurfaceModel`, since this code:. ```julia; using Oceananigans; grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); tracer_advection = (b=nothing, c=WENO()); model = HydrostaticFreeSurfaceModel(; grid, tracer_advection); ```. fails with. ```; ERROR: LoadError: MethodError: no method matching adapt_advection_order(::@NamedTuple{…}, ::Int64, ::RectilinearGrid{…}). Closest candidates are:; adapt_advection_order(::Nothing, ::Int64, ::Oceananigans.Grids.AbstractGrid); @ Oceananigans ~/Projects/Oceananigans.jl/src/Advection/adapt_advection_order.jl:60; adapt_advection_order(::UpwindBiased{B}, ::Int64, ::Oceananigans.Grids.AbstractGrid) where B; @ Oceananigans ~/Projects/Oceananigans.jl/src/Advection/adapt_advection_order.jl:74; adapt_advection_order(::WENO{B, FT, XT, YT, ZT}, ::Int64, ::Oceananigans.Grids.AbstractGrid) where {B, FT, XT, YT, ZT}; @ Oceananigans ~/Projects/Oceananigans.jl/src/Advection/adapt_advection_order.jl:92; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3863:346,ERROR,ERROR,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3863,1,['ERROR'],['ERROR']
Availability,"This PR ""enhances"" `JLD2OutputWriter` so it first _checks_ whether an iteration number exists in the file it's about to save to. If the iteration number does exist, it emits warning, but does not fail. Previously, it would fail. This helps when restoring a simulation from a checkpoint when output is saved at higher frequency than the simulation is checkpointed. TODO: probably test makes sense.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2537:275,checkpoint,checkpoint,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537,2,['checkpoint'],"['checkpoint', 'checkpointed']"
Availability,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704:193,error,error,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704,1,['error'],['error']
Availability,"This PR addresses issue https://github.com/CliMA/Oceananigans.jl/issues/3670, focusing on a problem likely caused by floating-point errors; https://github.com/CliMA/Oceananigans.jl/blob/088f9738877f0aeef7aa4038cf788f69ee102019/src/OutputWriters/windowed_time_average.jl#L91; Similar to https://github.com/CliMA/Oceananigans.jl/blob/a18b81d4c8776987d3cf619521941ba85000a1cb/src/Utils/schedules.jl#L58-L63; Implementing actuation time helps prevent floating-point errors, ensuring the correct execution of statements in; `advance_time_average!` https://github.com/CliMA/Oceananigans.jl/blob/56dbae31bb54c1293e12b6ccc88f77976cc1103f/src/OutputWriters/windowed_time_average.jl#L271-L335. There is still an issue for post-checkpoint when checkpoint interval is _not_ an integer multiple of the `AveragedTimeInterval`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3717:132,error,errors,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3717,4,"['checkpoint', 'error']","['checkpoint', 'errors']"
Availability,This PR adds `last_Δt` to `Clock` to make `Δt` available in more places (particularly in boundary condition halo fills addressing a challenge in #3482).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3508:47,avail,available,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3508,1,['avail'],['available']
Availability,"This PR adds a GPU-enabled `CompressibleModel`, developed with @thabbott and @RaphaelRR in a separate repository (https://github.com/ali-ramadhan/Atmosfoolery.jl). This is a large PR and I'm not even sure if it makes sense to merge it into Oceananigans.jl. The main purpose of opening this PR is to document progress made and ultimately decide on what to do with this feature. I don't think I can continue working on it. # Description. The compressible model implements the conservative Scheme by Satoh (2003), suitable for compressible non-hydrostatic models with moist processes, and is valid in the limit of a condensable gas/atmosphere with multiple moist species. Two choices of prognostic thermodynamic variables are available, internal energy and entropy, although in the Oceananigans spirit adding new thermodynamic variables is pretty easy!. @thabbott implemented the Satoh (2003) equation set. I initially implemented the Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:723,avail,available,723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['avail'],['available']
Availability,"This PR adds a NaN checker that checks for NaNs in the `[1, 1, 1]` grid point of the velocity fields at every time step (which should be very cheap and not affect performance). When a NaN is detected, an `ErrorException` is thrown so when running in the REPL it'll error and return control to the REPL, while if running a script from the terminal, it will terminate the Julia session (seems like the behavior we all want). Resolves #938; Resolves #1196",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1198:205,Error,ErrorException,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198,2,"['Error', 'error']","['ErrorException', 'error']"
Availability,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/970:611,avail,available,611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970,1,['avail'],['available']
Availability,"This PR adds a field `erroring` to the `NaNChecker`, and also makes the `NaNChecker` mutable. This means that the default `NaNChecker` can be converted to an erroring `NaNChecker` by writing. ```julia; simulation.callbacks[:nan_checker].func.erroring = true; ```. or. ```julia; erroring_NaNChecker!(simulation); ```. TODO. - [x] Test. Resolves #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2087:22,error,erroring,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087,3,['error'],['erroring']
Availability,This PR adds a method to `mask_immersed_field!` for `SumOfArrays`. I was trying to make a model which has an auxiliary field which is a `SumOfArrays` but ran into the error that all of the prognostic and auxiliary fields in the `HydrostaticFreeSurfaceModel` get masked during the `update_state!` step. (Ran into the issue here: https://github.com/OceanBioME/OceanBioME.jl/pull/195),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676:167,error,error,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676,2,"['error', 'mask']","['error', 'masked']"
Availability,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463:997,down,download,997,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463,1,['down'],['download']
Availability,"This PR adds a new constructor for `RectilinearGrid` that looks something like. ```julia; grid = RectilinearGrid(Float64, size = (1, 1, 1), ...); ```. that defaults to `architecture = CPU()`. This avoids the error observed on #2103. Since users _rarely_ change the floating point type, this alternative constructor probably won't be used all that much. So it's not crucial, but might help a few people. If others (@navidcy, @simone-silvestri ?) think this is a good idea, I'll add the same for other grid constructors. If we don't merge this PR, we should probably still validate the positional inputs to grid constructors to make sure they are valid (eg `architecture` needs to be `AbstractArchitecture`, etc).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2110:208,error,error,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2110,1,['error'],['error']
Availability,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:541,down,down,541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['down'],['down']
Availability,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1090:241,checkpoint,checkpoint,241,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090,3,"['checkpoint', 'down']","['checkpoint', 'down']"
Availability,This PR adds a new submodule `Oceananigans.CubedSpheres` that implements new grid and field types for running `HydrostaticFreeSurfaceModel` with a fully connected cubed sphere (should eventually also be flexible enough to just use 1 < n < 6 faces but I'm just testing 6 faces for now). This PR is still a work-in-progress and is quite messy with some pretty horrible code (please don't judge :sob:). I'll be adding to it and refactoring it over the next few days. Compile times have increased significantly with `grid::ConformalCubedSphereGrid` which has slowed down development but should be pretty close to being able to time step. EDIT: This might only be on Julia 1.6...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522:562,down,down,562,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522,1,['down'],['down']
Availability,"This PR adds a step in the outer `Field` constructor that validates boundary conditions. We check three things:. 1. That boundary conditions are compatible with the topology. Namely, we are restricted to default choices in `Periodic` or `Flat` directions; anything but default throws an error. 2. If a topology is `Bounded`, we check that boundary conditions are compatible with field location. Mostly we cannot support flux, value, or gradient boundary conditions for fields at faces, and we only support `nothing` for fields in `Flat` directions. 3. That boundary condition arrays are on the right architecture. TODO:. - [x] Test. Resolves #419; Resolves #890. Supercedes #1732",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2163:287,error,error,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2163,1,['error'],['error']
Availability,This PR adds an informative error when a grid with non-regularly spaced $x$ or $y$ dimensions is provided in the `NonhydrostaticModel`. Closes #2940,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2946:28,error,error,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2946,1,['error'],['error']
Availability,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1371:742,error,errors,742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371,1,['error'],['errors']
Availability,"This PR adds model setup documentation describing all the possible options the user has when setting up a model. Right now it's still a mega-page work-in-progress but the more useful parts will describe how to set up different kinds of boundary conditions with several examples, how diagnostics work and how flexible they are, and also output writers including finally a little guide on how to checkpoint and restore from a checkpoint. I think this PR is the last piece of work we agreed is needed before a JOSS submission.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/534:394,checkpoint,checkpoint,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/534,2,['checkpoint'],['checkpoint']
Availability,"This PR adds one main feature and one bug fix. 1) Zonal and Volume Averages have been added to diagnostics; 2) Some checkpointing fixes have been added to allow for more flexible: specifically, CPU to GPU (visa versa is now possible) restarts are now possible and velocity / tracer fields are still checkpointed if they use function boundary conditions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/783:116,checkpoint,checkpointing,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/783,2,['checkpoint'],"['checkpointed', 'checkpointing']"
Availability,"This PR adds support for ""cleaning up"" previous checkpoints. Setting `cleanup=true` will cause the checkpointer to delete all previous checkpoints after the latest one has been written. Pair programmed with @qwert2266.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1341:48,checkpoint,checkpoints,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1341,3,['checkpoint'],"['checkpointer', 'checkpoints']"
Availability,"This PR adds support for time step alignment and NetCDF output with `DateTime` (from `Base.Dates`) and `TimeDate` (from TimesDates.jl). Confusing names but `DateTime` is a base Julia type, has millisecond accuracy, and is understood by NCDatasets.jl while `TimeDate` comes from TimesDates.jl, has nanosecond accuracy, and must be converted to a `DateTime` to be written to NetCDF by NCDatasets.jl. Interestingly the way NetCDF stores dates and times is by storing a floating point value and some metadata describing it as e.g. ""seconds since 2000-01-01 00:00:00"". Could be minutes, hours, days, since 1900, etc. Not sure if we'll need the nanosecond accuracy but millisecond accuracy can cause an error on the order of a day after ~100 million iterations which could matter if used to compare Oceananigans.jl against ocean reanalysis products?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1396:697,error,error,697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1396,1,['error'],['error']
Availability,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1082:52,Checkpoint,Checkpointer,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082,6,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint', 'checkpointed', 'checkpointer']"
Availability,"This PR aims to add the lid-driven cavity as a verification experiment (first) and as a simple example (second) that is very well-known in the CFD world. It's set up as a 2D problem in the _yz_ plane. It also tests that horizontal/channel boundary conditions work. The verification experiment aims to reproduce the results detailed by [Ghia, Ghia, & Shin (1982)](https://doi.org/10.1016/0021-9991(82)90058-4). Unfortunately right now it seems to blow up no matter what I do. Once the top plate is set in motion a vorticity anomaly makes its way along the top plate then down to the bottom plate at which point blow up seems to occur no matter the time step or Reynolds number. A [Physics StackExchange post](https://physics.stackexchange.com/questions/461782/clarification-on-the-lid-driven-cavity-problem-in-cfd) suggested that quiescent initial conditions should be fine ""although if the wall Mach number is large, the sudden impulse could be numerically destabilizing"" which would only make sense for compressible models. I tried with vortical initial conditions too but no luck.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/572:570,down,down,570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/572,1,['down'],['down']
Availability,"This PR attempts to use `adapt_structure` for `Oceananigans.Fields` so that they can be used as arguments in kernels on the GPU. After fixing a few related issues, attempts at compilation on the GPU fail with the error. ```; CUDA error: a PTX JIT compilation failed (code 218, ERROR_INVALID_PTX); ptxas application ptx input, line 6381; error : Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; Stacktrace:; [1] CUDAdrv.CuModule(::String, ::Dict{CUDAdrv.CUjit_option_enum,Any}) at /data5/glwagner/.julia/packages/CUDAdrv/mCr0O/src/module.jl:41; [2] macro expansion at /data5/glwagner/.julia/packages/CUDAnative/wdJjC/src/execution.jl:423 [inlined]; [3] #cufunction#195(::String, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(cufunction),; ```. I don't have too much hope that I can solve this (the burden on the compiler is too great?), but I'm opening this PR as a way to record what I've done. Resolves #722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746:213,error,error,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746,4,['error'],"['error', 'errors']"
Availability,"This PR builds on #3319 to give a slightly more accurate message that checks if a coordinate is sorted (thus checking all values of a coordinate, rather than merely the end points). . I also moved the location of the error message. Possibly we should remove some of the error messages, @navidcy can you advise?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3331:217,error,error,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331,2,['error'],['error']
Availability,"This PR cherry-picks a commit from #2253 . Before this PR:. ```julia; julia> grid = RectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [-7.51279e-18, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [-7.51279e-18, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z; ```. after:. ```julia; julia> grid = RectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)); 128×128×1 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 3×3×0 halo; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ├── Periodic y ∈ [0.0, 6.28319) regularly spaced with Δy=0.0490874; └── Flat z; ```. Basically, this PR computes the location of the _first halo point_ more accurate, which in turn means that the location of the _right interior boundary_ is computed more accurately, without round-off error (which pollutes `main` at the moment). I think our method could be slightly improved. Here we first truncate to `Float32`, and then expand to `BigFloat` for subsequent arithmetic. The truncation is important, but also means that the _input_ is limited to single-precision accurate. Is that inevitable, or is there another way to achieve this outcome that doesn't lose precision?. PS we may need to do something similar with precision / round-off error for `align_time_step`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499:986,error,error,986,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499,2,['error'],['error']
Availability,"This PR completes the output_helpers.jl to support different output_writers: ; - NetCDFOutputWriter; - Checkpointer. Additionally, it ensures that the output of `NetCDFOutputWriter` and `JLD2OutputWriter` are created during the simulation `run!` instead of when the writer is instantiated. . I don't particularly like the fact that the `NetCDFOutputWriter` struct requires to parametric value for the dataset, which requires to open a dataset to instantiate it. I solved this by opening a temporal netCDF the first time it's called (""a hack""), i.e. `Dataset(Base.Filesystem.tempname(),""c"")`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3820:103,Checkpoint,Checkpointer,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3820,1,['Checkpoint'],['Checkpointer']
Availability,"This PR continues #1085 the work that started on a fork long ago. @siddharthabishnu feel free to continue working on this Oceananigans branch now ;). Some of the things we discussed to do:. - [ ] convert to lat-lon grid; - [ ] add some bathymetry, e.g., bathtub-type of domain prescribed by some analytical function; - [ ] use Ri-based diffusivity for BL closure; - [ ] remove horizontal viscosities/diffusivities; - [ ] potentially run long, save checkpoint, and then resume to run for 6-12 months in the docs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087:448,checkpoint,checkpoint,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087,1,['checkpoint'],['checkpoint']
Availability,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2048:1327,error,error,1327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048,1,['error'],['error']
Availability,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128:311,down,down,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128,1,['down'],['down']
Availability,"This PR ensures enough things are exported by Oceananigans that all the examples can get by with just `using Oceananigans`. The purpose of this PR is to make the package more user friendly as missing names, e.g. `ComputedField`, have become a large source of errors for new users. As this is a large change to the user interface, I've bumped v0.52.0. Resolves #1075; Resolves #1131; Resolves #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1406:259,error,errors,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1406,1,['error'],['errors']
Availability,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/999:1220,error,error,1220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999,4,"['error', 'robust']","['error', 'error-prone', 'robust']"
Availability,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628:29,checkpoint,checkpointer,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628,1,['checkpoint'],['checkpointer']
Availability,"This PR fixes a bug where `last_Δt` was incorrect for RK3. This bug was found by @tomchor, cc @jagoosw . Also it removes `previous_Δt` from the QuasiAdamsBashforth2 time-stepper. Note, this affects checkpointing. I also correctly restore `last_Δt` from the checkpoint. I also updated some docstrings just so we have uniform language, replacing ""previous"" with ""last"" in a few places.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3595:198,checkpoint,checkpointing,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3595,2,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,This PR fixes a sign error in the implicit dissipative buoyancy flux. We're also recalibrating parameters and will update them here before merging the PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3484:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3484,1,['error'],['error']
Availability,This PR fixes a sign error in the implicit dissipative buoyancy flux. We're also recalibrating parameters and will update them here before merging the PR. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3474:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3474,1,['error'],['error']
Availability,"This PR fixes an ""ambiguous method"" error that happens when trying to calculate an `Average()` (probably any reduction) with a given `condition` on `ImmersedBoundaryGrids`. Thanks to @glwagner for helping me find the proper method definition. Closes https://github.com/CliMA/Oceananigans.jl/issues/3439",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3440:36,error,error,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3440,1,['error'],['error']
Availability,This PR fixes an error in the Adams-Bashforth time-stepping algorithm so that tendencies from time-step `n-1` are computed correctly. This PR also computes tendencies after a time-step is complete rather than at the beginning of a time-step. This change causes the regression tests to fail. We should merge this change and correct the regression tests in a subsequent PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/664:17,error,error,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/664,1,['error'],['error']
Availability,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/839:19,checkpoint,checkpointer,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839,6,"['Checkpoint', 'checkpoint']","['Checkpointing', 'checkpoint', 'checkpointer', 'checkpointing']"
Availability,"This PR fixes the rendering of a LaTeX string and changes `eos = RoquetSeawaterPolynomial(:Freezing)` -> `eos = RoquetEquationOfState(:Freezing)` in the documentation for `buoyancy models and equation of state.md`. The reason for this change is that with the `eos` set as a `RoquetSeawaterPolynomial`,. ```julia; julia> using SeawaterPolynomials.SecondOrderSeawaterPolynomials. julia> eos = RoquetSeawaterPolynomial(:Freezing); 0.7718 Sᴬ - 0.0491 Θ + 0.0 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² - 0.005027 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3035:719,error,error,719,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035,1,['error'],['error']
Availability,This PR fixes. 1. A sign error in the momentum kernels associated with the Stokes drift tendency terms for surface waves and. 2. Interpolation (or lack thereof) error in the surface wave pseudovorticity term.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/571:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/571,2,['error'],['error']
Availability,"This PR follows up on PR #337 . Should help with adding noise to initial conditions as `rand` and `randn` aren't available in CUDAnative.jl. So we can use arrays to initialize with noise. @glwagner you had issues with generating random numbers on the GPU in the past?. Looks like a ridiculously simple kernel lol but it means you just supply an` Nx*Ny*Nz` sized array and not have to worry about halos, or broadcasting over views of non-contiguous views (which results is slow CuArray scalar operations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/341:113,avail,available,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/341,1,['avail'],['available']
Availability,"This PR implements a primitive immersed boundary scheme that is ""fitted"" to the grid. The scheme is specified with a function of `(x, y, z)` that is true when ""solid"" and false when ""fluid"". (A better name for the model kwarg than `immersed_boundary` might be `immersed_solid`.) It only supports no flux boundary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we nee",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654:468,Mask,Masking,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654,2,"['Mask', 'mask']","['Masking', 'masking']"
Availability,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1373:295,down,download,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373,1,['down'],['download']
Availability,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945:1049,checkpoint,checkpointing,1049,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945,3,"['Checkpoint', 'checkpoint']","['Checkpointing', 'checkpointer', 'checkpointing']"
Availability,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/968:61,redundant,redundant,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968,1,['redundant'],['redundant']
Availability,"This PR implements automatically-generated function signatures with DocStringExtensions. I think this will avoid human errors when creating docstrings and also making documenting stuff easier, which hopefully will ultimately help users and novice developers. Starting this as a draft since I wanna see what effects this will have on the docs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2879:119,error,errors,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2879,1,['error'],['errors']
Availability,"This PR implements closure functions that permit the user to specify a tuple of two closures, rather than a single closure. I attempted to do the arbitrary `N`-closure case, but had issues in getting the tuple length available at compile time on the GPU. This may be a problem with Cassette, or some other issue. For now, we have an implementation for 2-tuples, and we can easily add 3-tuples if we need to (though I suspect 2-tuples of closures is as far as most users will need to go until we have more sophisticated closures to choose from). This PR should be merged after #515.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/517:217,avail,available,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/517,1,['avail'],['available']
Availability,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1423:1227,down,down,1227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423,1,['down'],['down']
Availability,"This PR improves the currently implemented split explicit surface solver in serial mode; (partially using the algorithm in Shchepetkin & McWilliams, Ocean Modelling 9, 2005 albeit with a linear free surface) and implements single-node parallel (`MultiRegion`), and multi-node parallel (`Distributed`) split explicit free surface. In addition, quite some improvements have been made to the distributed module to allow a distributed `LatitudeLongituteGrid` and `IBG` and various comments in the `MultiRegion` module. Edit: MPI does not exploit CUDA-aware message passing for CuArray views, so this PR also implements buffered Halo communication for distributed models, unifying a bit of the code for Distributed and MultiRegion. This is a fundamental step to achieve the goals of the next PR which will deal with heterogenous distributed - shared models (i.e. a MultiRegionGrid of a DistributedGrid) . Edit Edit: apparently CUDA-aware MPI allows passing views of CuArrays. Buffers are still implemented for those architectures where CUDA-aware MPI is not available. Edit Edit Edit: apparently for Oceananigans that sends strided memory, buffers are crucial because; > Note that derived datatypes, both contiguous and non-contiguous, are supported. However, the non-contiguous; > datatypes currently have high overhead because of the many calls to cuMemcpy to copy all the pieces of the; > buffer into the intermediate buffer. (from [openmpi-link](https://www.open-mpi.org/faq/?category=runcuda#mpi-cuda-support)). Edit: This PR adds the possibility of distributing along a `Bounded` direction, and the possibility of having correct 2D parallelization with Coriolis. Previously it was not possible because corners were not communicated correctly. Doesn't have to be merged now. (Validation cases are not necessary and will be deleted prior to merging)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888:1053,avail,available,1053,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888,1,['avail'],['available']
Availability,"This PR initializes `u` and `v` separately and in a way that's more robust to user changes to the script (for example, if users change the grid topology). Resolves #1656 . Thanks @jmbeckers for pointing out this issue (apologies it took so long to resolve!)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1917:68,robust,robust,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1917,1,['robust'],['robust']
Availability,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290:725,mask,masks,725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290,1,['mask'],['masks']
Availability,"This PR introduces a new steady-state test case tailored for the cubed sphere. It initializes surface elevation and velocities using a steady-state solution, aiming to study the temporal evolution arising from the numerical discretization errors. Smooth spatial and temporal error increments are expected. However, if the errors escalate at an unprecedented rate between panels with non-trivial connectivities, it indicates a potential bug, such as improperly filled halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302:239,error,errors,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302,3,['error'],"['error', 'errors']"
Availability,"This PR is a first, explorational, attempt to introduce higher order (upwind and WENO) schemes in a Vector Invariant formulation (following chapter 7 of https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.705.7543&rep=rep1&type=pdf). To test them, this PR also revamps some test cases implemented by @sandreza in #1570 and new ones from the test set of Williamson et al 1992. Here a comparison between the 2nd order vector invariant scheme and the WENO vector invariant scheme on the Rossby-Haurwitz wave test case implemented in #1570 with an Implicit free surface formulation (`g = 900 ms⁻²`) and no dissipation. The video shows contours of vertical vorticity. https://user-images.githubusercontent.com/33547697/156962391-77527d5d-a059-450e-b3bb-a517237e485c.mp4. This is a first exploration. I am not completely convinced WENO interpolation can be used for vorticity onto curvilinear coordinates without a proper coordinate transform (although this is what we do for tracers...). Indeed, I am not completely sure about the correctness of the solution showed in the videos above... The scheme is for sure more stable, but I think it's just the byproduct of numerical diffusion being too high (there is no viscosity!). The same was happening when using uniform WENO on a stretched grid. It actually seems that a coordinate transformation should be applied and WENO weights should be different in case of a curvilinear grid (https://arxiv.org/pdf/1711.06212.pdf). . Applying WENO one dimension at a time instead of doing a full 2D/3D interpolation might also be incorrect for FV... (This might also impact how we do tracer advection with WENO on curvilinear grids)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317:191,down,download,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317,1,['down'],['download']
Availability,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:1249,error,error,1249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,1,['error'],['error']
Availability,"This PR is motivated by the need to specify higher order operators on `ImmersedBoundaries` #2209 . Since all operators we use depend on first order derivatives, it is enough to cancel all derivatives inside the immersed domain, but, to do that, all operators have to specify a 3D location. So the changes that this PR introduces are: ; - fully 3D metric functions (i.e., `Δ, A, V` for each 3D combination of `ᶜ` and `ᶠ`). 1D and 2D spacings are still defined (as well as 2D areas for grids that support them) but are not explicitly exported by `Oceananigans.Operators`. This is because maybe we want to use them in the future but they should be used only when _strictly_ necessary. As an example, in a function which is known to be 2D or 1D (as a function exclusive to reduced fields); - Operators are now _only_ 3D with an exception of interpolations and differences that do not involve metric terms (I would also remove the `ᵃ` on the interpolations because it does not make much sense in my opinion, what do you think?); - I removed `Ax_u, Ax_v, Ax_ζ` and so on in favour of a general `Ax_q` (q for quantity) as the different character did not add anything to the operator so in my opinion it was a bit redundant and confusing (all information is stored in the direction of the area and the location) Let me know if you prefer something different (like maybe `Ax_mul_q` or `Ax_var`) or if you liked the `Ax_u, Ax_v, Ax_ζ` formulation; - Last point (which motivated all this): derivatives are canceled if either of the points in the stencil are fully immersed. closes #2209; closes #2218",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2214:1206,redundant,redundant,1206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214,1,['redundant'],['redundant']
Availability,"This PR is part 1 of _n_ implementing halo regions (originally PR #167). Here I just replace Arrays and CuArrays with OffsetArrays containing an Array or CuArray. . An important change is the introduction of the `data(::Field)` function which returns the data stored by the field, i.e. without halo data. Lots of refactoring had to happen but it was mostly in updating the tests to use the `data` function. The Poisson solver had to be refactored because FFTW and cuFFT won't work properly on an offset array containing halos. The Poisson solver now keeps track of the right-hand-side, Fourier coefficients, and solution using `solver.storage` which is a regular `Array` or `CuArray`. This cuts down memory usage as well. Works on #104. Resolves #45; Resolves #122; Resolves #177",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250:695,down,down,695,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250,1,['down'],['down']
Availability,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627:200,checkpoint,checkpointer,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627,3,['checkpoint'],"['checkpointer', 'checkpointing']"
Availability,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1404:610,error,error,610,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404,1,['error'],['error']
Availability,"This PR makes several improvements to CATKE:. 1. We add parameters to the TKE dissipation rate model, which is `ep = CD * e^(3/2) / L`. Previously `CD` was a constant; this PR makes `CD(Ri)` a function of the Richardson number `Ri`. We can interpret this physically as a relaxation of the assumption that the TKE dissipation length scale is equal (or scales identically with) the TKE transport mixing length. . 2. We simplify the stability function (cc @adelinehillier). Previously we used tanh; now we use piecewise linear, which is simpler and more performant (we are unsure if this matters, but we can use all the help we can get for performance). @adelinehillier also simplifies the formulation of the stability function. 3. We improve the numerics of implicit time-stepping for the TKE equation. Following [Patankar 1980](https://www.taylorfrancis.com/books/mono/10.1201/9781482234213/numerical-heat-transfer-fluid-flow-suhas-patankar) (a good summary can be found in [Burchard et al. 2003](https://reader.elsevier.com/reader/sd/pii/S0168927403001016?token=44F9FAFB8D6BF56C3B72B35E65525AE9851D1C87699B6AE41218916A030C54351702E29AA5E58EC81B8EF1F687777D4C&originRegion=us-east-1&originCreation=20220901171212)), we treat the buoyancy flux term in the TKE equation implicitly _when buoyancy flux is a sink of TKE_. In other words, when N^2 > 0 (stable stratification), buoyancy mixing reduces TKE. Treating the buoyancy flux implicitly in this case greatly reduces negative TKE due to temporal discretization errors (but does not solve it completely). More generally, treating _sink_ terms implicitly in a tracer conservation equation reduces the possibility of negative tracer concentrations. The possibility does not seem to be entirely eliminated, unfortunately, I think because of the complicating effects of implicit diffusion. We'll be recalibrating parameters as part of https://github.com/CliMA/ParameterEstimocean.jl/pull/291 and will report the results here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2597:1511,error,errors,1511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2597,1,['error'],['errors']
Availability,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1888:8,mask,masks,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888,3,['mask'],"['masked', 'masks']"
Availability,"This PR propagates the eltype of the ""3D grid"" into the horizontal grid that's used by the FFT-based implicit free surface solver. Should help down the line with one of the issues that cropped up on #3288. @jagoosw",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3293:143,down,down,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3293,1,['down'],['down']
Availability,"This PR puts some code into the `IncompressibleModel` constructor that adjusts the halos in `grid` so that they're valid for the specified `advection` scheme and turbulence `closure`. The changes went a little deep because of the fact that we allow fields to be passed directly to `IncompressibleModel`. We now check whether such fields have the correct grid and throw an error if they don't. I decided not to validate the `pressure_solver` input. This isn't commonly provided by users (and wasn't previously checked). There's a new function in `Solvers` that could be modified if such a check becomes desirable. Here's what happens if you use a high-order advection scheme now:. ```julia; using Oceananigans, Oceanaingans.Advection. grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)). # output --- note that halos are (1, 1, 1); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. but,. ```julia; model = IncompressibleModel(advection=WENO5(), grid=grid). model.grid. # output --- halos are (3, 3, 3); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. This PR relies on #1003 . Resolves #941",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1012:372,error,error,372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1012,1,['error'],['error']
Availability,"This PR redoes the work of #701, except it adds a few more methods to make it even more robust. After this is merged we should revisit #707.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/708:88,robust,robust,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/708,1,['robust'],['robust']
Availability,"This PR refactors the FieldBoundaryConditions constructor to allow a consistent user API for specifying field locations. Field locations are specified with _uninstantiated_ types: in other words, a location is . ```julia; (Face, Cell, Cell); ```. rather than. ```julia; (Face(), Cell(), Cell()); ```. The latter form was deemed too much `()`. This is open to debate of course. I am slightly worried the former form is non-Julian. But it seems fairly unequivocal that it's easier to read. I also took the opportunity to clean up field constructors a bit. We now have the concept of _default_ boundary conditions; mostly, this is useful when a user wants to build a field that will never call `fill_halo_regions` and therefore its boundary conditions are irrelevant. I changed the `two_dimensionsional_turbulence.jl` example to use this default. The constructor shenanigans aren't perfect, and there is still a constructor that actually does accept instantiated locations (despite that we officially discourage it, and instantiated field locations are not supported for boundary conditions or abstract operations). It seems the checkpointer needs this special constructor. Resolves #659 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698:1126,checkpoint,checkpointer,1126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698,1,['checkpoint'],['checkpointer']
Availability,"This PR refactors the `NetCDFOutputWriter` constructor by getting rid of the `write_grid_and_attributes` function and by changing the boolean `clobber` keyword argument to `mode`, which is passed to NCDatasets.jl and takes on the values `""c""` for create/clobber or `""a""` for append. Passing `mode=""a""` allows you to append to an existing NetCDF file. I added some tests for this. This is important if we want to keep using the same NetCDF file after restoring from a checkpoint. cc @suyashbire1 . Resolves #913",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/915:467,checkpoint,checkpoint,467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915,1,['checkpoint'],['checkpoint']
Availability,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1575:300,toler,tolerance,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575,2,['toler'],['tolerance']
Availability,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:751,checkpoint,checkpointing,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,2,['checkpoint'],"['checkpointer', 'checkpointing']"
Availability,This PR reformulates TKEBasedVerticalDiffusivity simply through a redefinition of parameters. It also makes a more important change to the code that passes `model.closure` and `model.buoyancy` to the kernels that evaluate boundary fluxes. This is necessary to make `TKEBasedVerticalDiffusivity` models robust against changes to parameters after model construction. The changes are made in a way that have no affect on the API or other models. Resolves #1695 . cc @adelinehillier,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1883:302,robust,robust,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1883,1,['robust'],['robust']
Availability,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326:21,checkpoint,checkpointing,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326,10,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint', 'checkpointed', 'checkpointer', 'checkpointing']"
Availability,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711:572,error,error,572,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711,7,['error'],"['error', 'errors']"
Availability,"This PR removes some of the warnings that output writers throw when trying to save or serialize functions to disk. These warnings are outdated in a way because they are really aimed at users trying to restore models from a checkpoint. Previously, we used to require that an entire model could be deserialized from disk when restoring from a checkpoint. This created special headaches for models that involved user-defined functions. . But now we have a much better and simpler way for restoring models from a checkpoint. As a result we rarely care whether or not boundary conditions are serialized to disk if they are functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2375:223,checkpoint,checkpoint,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2375,3,['checkpoint'],['checkpoint']
Availability,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616:20,mask,masking,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616,10,['mask'],"['masked', 'masking', 'masks']"
Availability,This PR removes the now out-of-date `restore_from_checkpoint` function and updates the docs. Unfortunately the checkpointer test that was commented out in PR https://github.com/CliMA/Oceananigans.jl/pull/1639 is failing again now when uncommented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1670:111,checkpoint,checkpointer,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1670,1,['checkpoint'],['checkpointer']
Availability,This PR restructures the Physics section of the Docs so that equations solved by each model are written down. Preview of the docs: http://clima.github.io/OceananigansDocumentation/previews/PR1690. Closes #1460.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1690:104,down,down,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690,1,['down'],['down']
Availability,"This PR simplifies and generalizes the model constructor, which is a major change to the API. Except for `initialize_tracers` and `float_type`, all of the keyword arguments to `Model` now correspond semantically to the fields of model. In addition to clarifying the arguments of the model constructor, this will make checkpointing easier. . In addition, model fields that contain arrays, and thus are involved with large amounts of memory allocation, can be initialized through the model constructor. This should enable upgrades to the checkpointer that make it possible to checkpoint very large models that fill GPU memory. Finally, we add three new convenience constructors that retain the legacy behavior of model, and provide convenient ways to initialize particular models: `BasicModel`, `BasicChannelModel`, and `NonDimensionalModel`. `BasicModel` and `BasicChannelModel` closely resembles the original model constructor, while `NonDimensionalModel` allow parameters to be set by specifying non-dimensional numbers, rather than dimensional constants. Resolves #372.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/401:317,checkpoint,checkpointing,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401,3,['checkpoint'],"['checkpoint', 'checkpointer', 'checkpointing']"
Availability,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894:909,recover,recovered,909,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894,1,['recover'],['recovered']
Availability,"This PR stops generating the regression test data in-CI, and instead downloads regression data from `OceananigansArtifacts.jl` to compare against the CI-generated data. With @simone-silvestri . Resolves #2031",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2036:69,down,downloads,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2036,1,['down'],['downloads']
Availability,"This PR tries to improve the GPU efficiency of the WENO algorithm by; - using fast math for smoothness calculation (this should not be a problem since weights are normalized); - resorting the WENO algorithm to enforce register reuse by accumulating the solution instead of computing all the stencils at tge same time. WENO-Z weights are calculated as $$\alpha_s = C_s \left( 1 + \left(\frac{\tau}{\beta_s +\varepsilon}\right)^2 \right)$$; and the interpolation is calculated as $$\psi =\frac{1}{\sum \alpha_s} \sum \psi_s \alpha_s$$; so if we reorder we can calculate $\psi$ as $$\psi = \frac{ \tau^2 \hat{\psi}_1 + \hat{\psi}_2}{ \tau^2 \sum \alpha^{\star}_s + 1}$$; where $$\hat{\psi}_1 = \sum\psi_s \alpha^{\star}_s$$ and $$\hat{\psi}_2 = \sum \psi_s C_s$$ and $\alpha^{\star}_s$ are the WENO-JS coefficients that depend only on the local stencil: $$\alpha^{\star}_s = \frac{C_s}{(\beta_s + \varepsilon)^2}$$; We can then calculate stencils one by one by accumulating the results and ""throwing away"" registers we don't need after the computation. This PR is a draft because, despite it works, everything is written down manually unrolled and maybe there is a way to express the same concept with metaprogramming",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3518:1118,down,down,1118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3518,1,['down'],['down']
Availability,"This PR tweaks `initialize_simulation!` so that the schedules get called when `iteration == 0` --- in addition to running diagnostics, executing callbacks, and writing output. This is a tiny step in the direction of having a robust initialization procedure. I think we still need to work on the abstractions a bit though, since it'd be nice to initialize schedules / callbacks more explicitly rather than implicitly relying on `iteration == 0`. This change will affect `SpecifiedTimes` and `WallTimeInterval` the most, I think. TODO:. - [ ] Test for initialization of `SpecifiedTimes`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2268:225,robust,robust,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2268,1,['robust'],['robust']
Availability,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2316:383,Error,Error,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,This PR updates the grid metrics used by `ShallowWaterModel` and adds a masking step to `update_state!` so that `ShallowWaterModel`s can be run on `ImmersedBoundaryGrid`. Co-authored by @francispoulin . Supercedes #1663,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1718:72,mask,masking,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1718,1,['mask'],['masking']
Availability,"This PR uses a view into the underlying array of grid spacings rather than a view into the OffsetArray of grid spacings in `Base.show` for `VerticallyStretchedRectilinearGrid`. This should allow `maximum` and `minimum` to run without errors and allow `VerticallyStretchedRectilinearGrid` to be printed on the GPU. Would be best to add a test, cc @navidcy. Closes #1637 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1638:234,error,errors,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1638,1,['error'],['errors']
Availability,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744:744,down,download,744,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744,5,"['Checkpoint', 'checkpoint', 'down']","['Checkpointing', 'checkpoint', 'download']"
Availability,"This allows us to implement ""divergence damping"" for large scale ocean models via `ScalarDiffusivity`:. ```julia; using Oceananigans.TurbulenceClosures: HorizontalDivergenceFormulation; divergence_damping = ScalarDiffusivity(HorizontalDivergenceFormulation(), ν=1); ```. We probably also want vorticity damping. There also might be other names, for vorticity damping the coefficient is often referred to as the ""rotational viscosity"". A few other things:. * Possibly one should throw an error if users specify kappa, since this closure has no tracer diffusion.; * I added an abstract type for the formulations; * Should we use flux=0 fallbacks? We have a substantial amount of code devoted to emitting zero fluxes for many cases (eg zero tracer flux in this case).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2440:487,error,error,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2440,1,['error'],['error']
Availability,"This also makes `data_summary` and `Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interacti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750:270,mask,masking,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750,1,['mask'],['masking']
Availability,"This came up on #2235. The idea is to support syntax like. ```julia; outputs = (ζ = ∂x(v) - ∂y(u), U = Average(u, dims=1)); output_writer = JLD2OutputWriter(model, outputs, ... ); ```. rather than requiring things to be wrapped in `Field` to work. This wasn't easy to support previously, before we consolidate all the `Field` implementations (we had `ComputedField`, `Field`, `AveragedField`...). But now we can support it and it would reduce boilerplate (eg everything is `Field(this)`, `Field(that)` by quite a bit for the majority of use cases. I think the downside is that users aren't immediately exposed to `Field` infrastructure. A good ""Fields tutorial"" in the docs might help with that though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2242:560,down,downside,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2242,1,['down'],['downside']
Availability,"This code:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (128, 128, 1),; halo = (4, 4, 1),; x = (0, 2π),; y = (0, 2π),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). momentum_advection = VectorInvariant(vorticity_scheme = WENO(order=5),; vertical_scheme = Centered(),; divergence_scheme = WENO(order=5)); buoyancy = nothing; tracers = nothing; free_surface = ExplicitFreeSurface(gravitational_acceleration=10); model_args = (; momentum_advection, buoyancy, tracers, free_surface). model = HydrostaticFreeSurfaceModel(; grid, model_args...); ```. throws an error:. ```julia; julia> include(""hydrostatic_turbulence.jl""); ERROR: LoadError: ArgumentError: The grid halo (4, 4, 1) must be at least equal to (4, 4, 4).; Note that an ImmersedBoundaryGrid requires an extra halo point in all; non-flat directions compared to a non-immersed boundary grid.; Stacktrace:; [1] validate_model_halo; @ ~/.julia/packages/Oceananigans/OMBY0/src/Models/Models.jl:55 [inlined]; ```. This seems like a bug to me, because a `Centered()` scheme in the vertical should only require one halo point.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3699:581,error,error,581,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3699,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"This code:. ```julia; using Oceananigans; using Oceananigans.Grids: with_halo. underlying_grid = RectilinearGrid(size=(3, 3, 3), x=(0, 2), y=(0, 1), z=(0, 1)); grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom((x, y) -> x)). with_halo((4, 4, 4), grid); ```. produces. ```; ERROR: LoadError: ArgumentError: The dimensions of the immersed boundary (9, 9) do not match the grid size (11, 11); Stacktrace:; [1] validate_ib_size; @ ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:92 [inlined]; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ib::GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/.julia/packages/Oceananigans/QYJpb/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:85; [3] with_halo(halo::Tuple{Int64, Int64, Int64}, ibg::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2988:285,ERROR,ERROR,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2988,1,['ERROR'],['ERROR']
Availability,"This error may not be consequential for any work we've done so far because it amounts to changing an irrelevant 'gauge condition' on the pressure in many cases. It does impact set-ups with vertically stretched grids, and it may impact set-ups that specify a horizontal buoyancy gradient at the surface. None of the regression tests deal with such scenarios.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612:5,error,error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612,1,['error'],['error']
Availability,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:38,checkpoint,checkpoint,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,8,"['Checkpoint', 'checkpoint', 'error']","['Checkpointer', 'checkpoint', 'checkpointer', 'error']"
Availability,"This fixes a bug in which halo regions were not filled for subgrid-scale LES diffusivities. . To do this robustly for various diffusivity structures with different nesting hierarchies, a recursive halo region filling functionality is implemented that dispatches on `bcs::NamedTuple{(:x, :y:, :z)}`, corresponding to a `FieldBoundaryCondition`. Thus, when `fill_halo_regions!(fields, bcs, grid)` is called with matching tuples for *both* `fields` and `bcs`, a simultaneous loop is done over the members of the two tuples. However, when `fill_halo_regions!(fields, bcs, grid)` is called and `bcs` is a `FieldBoundaryCondition`, a loop is performed over the members of `fields` *only*, and `bcs` is reused for every member of `fields`. Thus halo regions for fields embedded in nested structures (like diffusivities in `AnisotropicMinimumDissipation`) are all filled with a single call to `fill_halo_regions!`. For now, the code uses temperature boundary conditions to determine the diffusivity boundary conditions. This will work until we implement the changes proposed in #371.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/385:105,robust,robustly,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/385,1,['robust'],['robustly']
Availability,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865:15,error,error,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865,1,['error'],['error']
Availability,"This happens after a number of time steps; ```julia; CUFFTError(code 2, cuFFT failed to allocate GPU or CPU memory). Stacktrace:; [1] macro expansion at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/error.jl:59 [inlined]; [2] _mkplan(::UInt8, ::Tuple{Int64,Int64,Int64}, ::Array{Int64,1}) at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/wrappers.jl:27; [3] plan_fft! at /home/gridsan/aramadhan/.julia/packages/CuArrays/PD3UJ/src/fft/highlevel.jl:10 [inlined]; [4] fft! at /home/gridsan/aramadhan/.julia/packages/AbstractFFTs/7WCaR/src/definitions.jl:51 [inlined]; [5] solve_poisson_3d_ppn_gpu!(::Int64, ::Int64, ::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float32}, ::CellField{CuArray{Complex{Float64},3}}, ::CellField{CuArray{Complex{Float64},3}}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Float64,1}, ::CuArray{Complex{Float64},3}, ::CuArray{Complex{Float64},3}) at /home/gridsan/aramadhan/Oceananigans.jl/src/spectral_solvers.jl:426; [6] time_step_kernel!(::Model, ::Int64, ::Int64) at /home/gridsan/aramadhan/Oceananigans.jl/src/time_steppers.jl:375; [7] deep_convection_3d_gpu() at /home/gridsan/aramadhan/Oceananigans.jl/examples/deep_convection_3d_gpu.jl:17; [8] top-level scope at In[5]:1; ```. Or if you just save output to disk every ~10 time steps, the garbage collector has a chance to catch up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/68:216,error,error,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/68,1,['error'],['error']
Availability,"This is a minimum working example that shows how we (@writingindy and I) have tried to use closure in the `VectorInvariantFormulation` of the `ShallowWaterModel` but get a `TaskFailedException` error, copied below. @simone-silvestri , do you have any idea as to how this can be fixed?. ```; using Oceananigans; using Oceananigans.Models.ShallowWaterModels: VectorInvariantFormulation; using Oceananigans.Advection: VelocityStencil, VorticityStencil; using Oceananigans.TurbulenceClosures. grid = RectilinearGrid(size = (16, 16), x = (0, 1), y = (0, 1), ; topology = (Periodic, Periodic, Flat)). model = ShallowWaterModel(grid = grid,; momentum_advection = WENO5(vector_invariant = VelocityStencil()),; tracers = (:A),; closure = HorizontalScalarBiharmonicDiffusivity(κ=1e-6),; gravitational_acceleration = 1.0,; formulation = VectorInvariantFormulation(); ). set!(model, h=1); simulation = Simulation(model, Δt = 0.001, stop_time = 10.0). run!(simulation); ```. Error: ; ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching getindex(::Nothing, ::Int64); Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] diffusive_flux_x(::Int64, ::Int64, ::Int64, ::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606:194,error,error,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606,4,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'error']"
Availability,"This is a rather minimal example that tries to use `PrescribedVelocityFields` in the `ImmersedBoundaryMethod`,. ```; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(16, 8),; y=(-1, 1), z=(-1, 0), ; topology=(Flat, Periodic, Bounded)). seamount(x, y, z) = z < - 1 + 0.1*exp(-y^2/0.25^2) . grid_with_seamount = ImmersedBoundaryGrid(grid, GridFittedBoundary(seamount)). U(x, y, z) = 0.; V(x, y, z) = 0.; W(x, y, z) = 0. velocities = PrescribedVelocityFields(u=U, v=V, w=W). model = HydrostaticFreeSurfaceModel(architecture = CPU(), ; grid = grid_with_seamount,; momentum_advection = CenteredSecondOrder(), ; free_surface = ImplicitFreeSurface(),; closure = nothing, ; tracers = :b,; velocities = velocities,; buoyancy = BuoyancyTracer()); ```. Unfortunately, it fails with the following error,. ```; ERROR: LoadError: MethodError: no method matching device(::Nothing); Closest candidates are:; device(::Oceananigans.Architectures.AbstractCPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:50; device(::Oceananigans.Architectures.AbstractGPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:51; Stacktrace:; [1] device_event(arch::Nothing); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:75; [2] mask_immersed_field!(field::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, grid::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:873,error,error,873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"This is a summary of the current salient issues discussed on #1241. Much of that discussion is out of date; however one issue that remains is that complex GPU AbstractOperations can produce PTX code with function signatures that consume too much ""parameter space"". To reproduce this issue:. ```julia; using Oceananigans; model = NonhydrostaticModel(architecture=GPU(), grid=RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))); u, v, w = model.velocities; ```. and then. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_IGwXuE.ptx, line 1951; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE14_gpu__compute_16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES5_I9_1__1__1_ES5_I9_1__1__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity5vv22RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEES9_E5Int6410_identity110_identity2vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:567,ERROR,ERROR,567,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['ERROR'],['ERROR']
Availability,"This is a temporary fix for #1280 (time stepping a model with `pickup=true` -> it blows up) until schedules can be probably checkpointed. While this is a temporary fix, it has affected a number of people already (@qwert2266, @suyashbire1, @sandreza, and now @sam12396 in #1300) so would be good to merge this and tag a new release.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1303:124,checkpoint,checkpointed,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303,1,['checkpoint'],['checkpointed']
Availability,This is important for writing robust and readable code in our time-stepping algorithm.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2909:30,robust,robust,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2909,1,['robust'],['robust']
Availability,"This is related to [this PR](https://github.com/CliMA/Oceananigans.jl/pull/2029). To summarize:. - I have a production-ready research code (that's far too complicated to post here) that does sines/cosines calculations for a background field; - If these sine/consine calculations are performed inside the background field function the code is about 100x slowed than if I perform these calculations outside the function, and just pass the pre-calculated sine and cosine; - I tried making a MWE to reproduce this behavior but failed, which indicates that it's not _just_ the trig functions that are causing the slowdown. It's the trig functions plus something else (I have no idea what). So that's the state of things. I'll try to start from my code and cut down on things one by one to try and post a small MWE whenever I have time. CC: @glwagner @navidcy @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2034:755,down,down,755,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2034,1,['down'],['down']
Availability,"This is related to https://github.com/CliMA/Oceananigans.jl/pull/2432. I'm trying to run the [`distributed_nonhydrostatic_model_mpi.jl` benchmark](https://github.com/CliMA/Oceananigans.jl/blob/9eb055064e68f6a725cebcf9973a3ebf1cbad16b/benchmark/distributed_nonhydrostatic_model_mpi.jl) but I'm running into problems. It seems to be something silly but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2433:734,error,error,734,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433,1,['error'],['error']
Availability,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:191,error,errors,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,5,"['ERROR', 'Error', 'error']","['ERROR', 'Error', 'errored', 'errors']"
Availability,"This is what's keeping tests in https://github.com/tomchor/Oceanostics.jl/pull/151 from passing. Here's the simplest MWE I could come up with:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1));. julia> model = NonhydrostaticModel(; grid,);. julia> test(i, j, k, grid, auxiliary_fields,) = 1.0;. julia> a = KernelFunctionOperation{Center, Center, Center}(test, model.grid, model.auxiliary_fields);. julia> compute!(Field(a)); ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:466; [2] isregional(t::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:105; [3] _findfirst_rec (repeats 2 times); @ ./tuple.jl:414 [inlined]; [4] findfirst(f::Function, t::Tuple{Tuple{DataType, DataType, DataType}, NamedTuple{(), Tuple{}}}); @ Base ./tuple.jl:421; [5] #construct_regionally#52; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:146 [inlined]; [6] construct_regionally; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:143 [inlined]; [7] #construct_regionally#51; @ ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139 [inlined]; [8] construct_regionally(::Function, ::Tuple{DataType, DataType, DataType}, ::NamedTuple{(), Tuple{}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/pbNSE/src/Utils/multi_region_transformation.jl:139; [9] indices(κ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3232:477,ERROR,ERROR,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3232,1,['ERROR'],['ERROR']
Availability,"This is work in progress to solve #2866 so I would apprciate some advice:. 1. I added a specific constructor of Checkpointer for when the model is a ShallowWater model; 2. I added a set! function for when the model is a shallow water model (the difference of these two and the other ones is that they do not require the ""particles"" property.; 3. I added a low-res test case . Is OutputWriters/checkpointer a good place to put these methods in, or should they go somewhere in models/?; Is it okay to no add a new docstring to the new constructor and instead modify the existing one mentioning the difference with the ShallowWater case? If I add new one, the docs of Checkpointer will be huge.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2868:112,Checkpoint,Checkpointer,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2868,3,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointer']"
Availability,"This isn't a huge issue but I've noticed recently that often the shallow water regression tests on GPU fail with the following error:. ```; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93;   | Expression: all(test_fields.v .≈ truth_fields.v);   | Stacktrace:;   | [1] macro expansion;   | @ /net/ocean/home/data44/data5/glwagner/julia-1.8.5/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined];   | [2] run_shallow_water_regression(arch::GPU, formulation::ConservativeFormulation; regenerate_data::Bool);   | @ Main /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-6/clima/oceananigans/test/regression_tests/shallow_water_bickley_jet_regression.jl:93; ```. Sometimes I need to restart the test twice for it to pass. Like I said, it's not a huge issue, but do we understand why that's happening? Is there anything we can do to prevent that behavior?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922:127,error,error,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922,1,['error'],['error']
Availability,"This issue appears on v1.8.0-rc1 so I understand if it is not a priority.; Oceananigans version: So far reproduced in v0.76.6 and v0.76.5; To reproduce, in the REPL:; *The error does not prevent the fields from been created* but it is a pain to do interactive work with it.; ```julia; pkg> activate --temp; pkg> add NetCDF_jll@400.802.103, Oceananigans ; #NCDatasets latest release does not work with v1.8.0-rc1; julia> using Oceananigans; julia> grid = RectilinearGrid(CPU(),size = (10, 10),; x = (0, 100), y = (0, 100),; topology = (Periodic, Periodic, Flat), halo = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663:172,error,error,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663,2,"['Error', 'error']","['Error', 'error']"
Availability,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1732:206,error,error,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732,1,['error'],['error']
Availability,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1893:130,checkpoint,checkpoint,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893,5,"['checkpoint', 'down', 'error']","['checkpoint', 'checkpointer', 'downside', 'error-prone']"
Availability,"This may be harmless as all tests passed anyways, e.g. see the log from the last test of PR #3847: https://buildkite.com/clima/oceananigans/builds/18103#0192adf8-82f6-48e6-b72e-131502fdfcfc/26-746. But maybe there are some performance implications?. Output when running `using Oceananigans`:; ```; julia> using Oceananigans; Precompiling Oceananigans; Info Given Oceananigans was explicitly requested, output will be shown live ; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; ? Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition _advective_tracer_flux_x(Any, Any, Any, Oceananigans.ImmersedBoundaries.ImmersedBoundaryGrid{FT, TX, TY, TZ, G, I, M, S, Arch} where Arch where S where M where I where G where TZ where TY where TX where FT, Oceananigans.Advection.FluxFormAdvection{N, FT, A, B, C} where C where B where A where FT where N, Any...) in module Advection at /home/alir/atdepth/Oceananigans.jl/src/Advection/immersed_advective_fluxes.jl:79 overwritten at /home/alir/atdepth/Oceananigans.jl/src/Advection/tracer_advection_operators.jl:11.; ERROR: Method overwriting is not permitted during Module precompilation. Use `__precompile__(false)` to opt-out of precompilation.; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851:1081,ERROR,ERROR,1081,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851,2,['ERROR'],['ERROR']
Availability,"This optional positional argument can be used to mask a field with a value other than 0. The syntax is supposed to be. ```julia; mask_immersed_field!(c, NaN); ```. to mask a field to `NaN`, for example. cc @francispoulin @fadaie91",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1970:49,mask,mask,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1970,2,['mask'],['mask']
Availability,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2738:392,down,downstream,392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1673:459,down,downstream,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2517:400,down,downstream,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517,2,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3070:390,down,downstream,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1474:435,down,downstream,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1102:421,down,downstream,421,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2124:400,down,downstream,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2123:404,down,downstream,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2539:401,down,downstream,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1475:431,down,downstream,431,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/898:439,down,downstream,439,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/751:451,down,downstream,451,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751,2,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3366:396,down,downstream,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366,1,['down'],['downstream']
Availability,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1563:443,down,downstream,443,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563,1,['down'],['downstream']
Availability,"This really depends where we want to take this abstraction. One possibility is to develop ""four-dimensional fields"". This is sort of what the design reflects now (ie we subtype `AbstractField`, etc). Another possibility is to ditch that and cement `Fields` as 3 dimensional and less, and commit the `FieldTimeSeries` abstraction to look like a 1D vector of 3D fields. It seems like a subtle distinction, but is has some important consequences. For example, what should. ```julia; first(fts::FieldTimeSeries); ```. return? If `FieldTimeSeries` is 4D then this is either `parent(fts)[1, 1, 1, 1]` or `fts.data[1, 1, 1 ,1]`. But if `FieldTimeSeries` is 1D this is `fts[1]` --- the first _Field_. I think it's nice to have `first(fts)` and `last(fts)` return fields --- we use stuff like that _a lot_, but right now we are forced to write stuff like. ```julia; Nt = length(fts.times); fts[Nt]; ```. kind of annoying. Right now the API is hybrid; ie we have `getindex(fts, i)` _and_ `getindex(fts, i, j, k, n)`. But we use the ""vector"" abstraction more than the ""4D field mode"" a lot more I think. One downside is that this might preclude defining a `∂t` abstract operation. I don't think this impacts support for reductions, but I have to think about that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2492:1097,down,downside,1097,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2492,1,['down'],['downside']
Availability,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272:275,failure,failures,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272,3,"['ERROR', 'error', 'failure']","['ERROR', 'errored', 'failures']"
Availability,"This test is to stop the error below from reappearing (once the test is fixed!). . ```; nested task error: MethodError: no method matching (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}})(::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1928:25,error,error,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928,2,['error'],['error']
Availability,This test occasionally fails as I set the tolerance a little low.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/400:42,toler,tolerance,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/400,1,['toler'],['tolerance']
Availability,This tests also fails intermittently due to being slightly above the tight tolerance: https://buildkite.com/clima/oceananigans/builds/2660#fdbc1bf9-350b-4051-9977-5ec4683ca080/22-534,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1688:75,toler,tolerance,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1688,1,['toler'],['tolerance']
Availability,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1273:147,ERROR,ERROR,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273,1,['ERROR'],['ERROR']
Availability,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:140,error,error,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,7,"['Error', 'error']","['Error', 'error', 'errors']"
Availability,"This:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=128, z=(-100, 0), halo=3, topology=(Flat, Flat, Bounded)); 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [-100.0, 0.0] regularly spaced with Δz=0.78125. julia> fake_model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 1×1×128 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: b; ├── closure: Nothing; ├── buoyancy: BuoyancyTracer with -ĝ = ZDirection; └── coriolis: Nothing. julia> real_model = HydrostaticFreeSurfaceModel(; grid,; velocities = fake_model.velocities,; tracers = fake_model.tracers,; buoyancy = BuoyancyTracer()); ```. gives. ```julia; ERROR: MethodError: no method matching HydrostaticFreeSurfaceVelocityFields(::NamedTuple{(:u, :v, :w), ...; ```. I believe this is supported by `NonhydrostaticModel` so we should probably support it for the hydrostatic model too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2341:1027,ERROR,ERROR,1027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2341,1,['ERROR'],['ERROR']
Availability,Throw error if CUDA-aware MPI is not found for distributed GPU architecture,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3883:6,error,error,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3883,1,['error'],['error']
Availability,Throw error if halo size is inappropriate for NonhydrostaticModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2827:6,error,error,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2827,1,['error'],['error']
Availability,Throw error if nodes given by function/array generators are not sorted,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3331:6,error,error,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331,1,['error'],['error']
Availability,Throw helpful error if `times[n]` cannot be located when constructing `FieldTimeSeries`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2234:14,error,error,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2234,1,['error'],['error']
Availability,Throws error when size of dimension is mismatched when constructing RectilinearGrid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550:7,error,error,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550,1,['error'],['error']
Availability,"To be merged once #1093 and #1099 are in. Release notes:. * Adds support for ""picking up"" a simulation from a checkpoint via the keyword `pickup=true`, `pickup=checkpoint_iteration::Int` and `pickup=checkpont_filepath::String` in `run!(simulation)` (#1082). * Adds a function `set!(model, checkpoint_filepath)` for ""setting"" a model state to the state recorded in a checkpoint file (#1082). * Adds support for ""field-dependent"" boundary conditions similar to field-dependent forcing terms (#1093). * Beautifies and cleans up many of the examples, including getting them to build faster on Travis (#1099)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1103:110,checkpoint,checkpoint,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1103,2,['checkpoint'],['checkpoint']
Availability,"To do:. - [ ] Add docs for `UpwindBiased` reconstruction; - [ ] Refactor `UpwindBiased` to get rid of ""coeffs"" for stretched grids; - [ ] Fix up docs for `WENO`; - [ ] Clean up constructors for advection schemes; - [ ] Throw errors in advection scheme constructors if the grid halo is too small. Resolves #2717",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2972:225,error,errors,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2972,1,['error'],['errors']
Availability,"To enable checkpoint restoration for large models, we need to revise the model constructor so that `velocities` and `tracers` can be passed as keyword arguments. In addition, I think it might make sense to remove `N`, `L`, and the viscosities from keyword arguments, so that all of the constructor arguments in the *base* model constructor correspond to subfields of `Model`. At the same time and for user convenience, we should add new constructors (perhaps something like `SimpleModel` or `BasicModel`) that *do* have keyword arguments for `N`, `L`, etc. . Through this method we can provide both convenience for users looking for simple and basic functionality while also cleaning up the *base* model constructor for the purpose of checkpointing, code cleanliness, and easier usage for advanced users. We will probably want to remove `N` and `L` from the model constructor anyways when we have more than one type of grid for a user to choose.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/372:10,checkpoint,checkpoint,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/372,2,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,To make sure that the code does not slow down in between merges it would be useful to have a standard case and test that the time stepping is not significantly increased between different PRs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2176:41,down,down,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2176,1,['down'],['down']
Availability,Tries to generalize checkpointer to work for `HydrostaticFreeSurfaceModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2224:20,checkpoint,checkpointer,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2224,1,['checkpoint'],['checkpointer']
Availability,Try debugging failures,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2906:14,failure,failures,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2906,1,['failure'],['failures']
Availability,"Trying to use OceanScalingTest.jl from @simone-silvestri as a benchmark for TTFTS (Time-To-First-Time-Step) I came across this delightful error:. ```; ERROR: LoadError: Evaluation into the closed module `Grids` breaks incremental compilation because the side effects will not be permanent. This is likely due to some other module mutating `Grids` with `eval` during precompilation - don't do this.; Stacktrace:; [1] eval; @ ./boot.jl:428 [inlined]; [2] allocate_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Oceananigans.DistributedComputations.Distributed{Oceananigans.Architectures.GPU, false, Oceananigans.DistributedComputations.Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/kBe5X/src/Grids/latitude_longitude_grid.jl:554; [3] with_precomputed_metrics(grid::Oceananigans.Grids.LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Nothing, Nothing, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555:138,error,error,138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1619:81,error,error,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619,2,['error'],['error']
Availability,Type Error using ImmersedBoundaries on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:5,Error,Error,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,1,['Error'],['Error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4389,error,error,4389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4295,error,error,4295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4201,error,error,4201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4107,error,error,4107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:4013,error,error,4013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Ty",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:3919,error,error,3919,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:3825,error,error,3825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:3731,error,error,3731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:3637,error,error,3637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Sta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:3543,error,error,3543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:2415,error,error,2415,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,12,['error'],['error']
Availability,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:850,error,error,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Unexpected Simulation checkpointing frequency behavior,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/661:22,checkpoint,checkpointing,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/661,1,['checkpoint'],['checkpointing']
Availability,"Unfortunately I don't have an example of this on hand (and our tests don't catch it), but I've noticed occasional irregularities in output writing that are presumably due to rounding artifacts when aligning a time-step for `TimeInterval`. One common case is that I run a parameter sweep and one of the files is one iteration shorter than another. This is often at the end of a long run. I think the culprit might be round-off error when computing `align_time_step` or `schedule_aligned_Δt`. Maybe using `Base.TwicePrecision` for some of the calculations would solve the problem?. Here's some of the code involved:. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Simulations/run.jl#L43-L58. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L51. https://github.com/CliMA/Oceananigans.jl/blob/6a7ab79fc116612d8c156b069cbb60b06416bfa8/src/Utils/schedules.jl#L152",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321:426,error,error,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321,1,['error'],['error']
Availability,"Unifies interfaces in `NetCDFOutputWriter`, `JLD2OutputWriter` and `Checkpointer`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2416:68,Checkpoint,Checkpointer,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2416,1,['Checkpoint'],['Checkpointer']
Availability,Until we figure out why v1.3 and DEV jobs time out on GitLab CI we can just allow v1.3 to fail. v1.3 hasn't been released yet so makes sense to allow failures anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/467:150,failure,failures,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/467,1,['failure'],['failures']
Availability,Update CUDA packages to get rid of CUDA errors on CPU and use CUDAapi.has_cuda(),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/378:40,error,errors,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/378,1,['error'],['errors']
Availability,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296:39,down,downgraded,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296,1,['down'],['downgraded']
Availability,Use `FFTW.set_num_threads` if more than 1 thread is available,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/868:52,avail,available,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/868,1,['avail'],['available']
Availability,User interface for masking output on `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3061:19,mask,masking,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3061,1,['mask'],['masking']
Availability,"Using Julia 1.7.3 and Oceananigans 0.77.1, this code:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(1, 1, 2), extent=(1, 1, 1)); buoyancy_bottom_bc = GradientBoundaryCondition(1e-5); buoyancy_bcs = FieldBoundaryConditions(bottom=buoyancy_bottom_bc); model = NonhydrostaticModel(; grid, tracers=:b, buoyancy=BuoyancyTracer(),; boundary_conditions=(; b=buoyancy_bcs)); simulation = Simulation(model; Δt=1, stop_iteration=2); run!(simulation); ```. produces:. ```julia; julia> include(""simple_model.jl""); ERROR: LoadError: InvalidIRError: compiling kernel #gpu__fill_bottom_and_top_halo!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, NTuple{4, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Gradient, Float64}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Tuple{Tuple{Face, Center, Center}, Tuple{Center, Face, Center}, Tuple{Center, Center, Face}, Tuple{Center, Center, Center}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, In",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2709:523,ERROR,ERROR,523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2709,1,['ERROR'],['ERROR']
Availability,"Using `min_Δz(grid::VerticallyStretchedRectilinearGrid)` on GPU fails. The reason is that. ```julia; julia> minimum(view(grid.Δzᵃᵃᶜ, 1:grid.Nz)); ERROR: scalar getindex is disallowed; ```; fails on the GPU. The line should be `minimum(view(parent(grid.Δzᵃᵃᶜ), 1:grid.Nz))`. This error had been there all along but I guess no one caught it. This commit should fix it, but should we also include a test that would catch it?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751:146,ERROR,ERROR,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"Using a variable grid spacing like the [Ocean wind mixing and convection example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/) in a direction other than `z` raises a `MethodError` when creating a `NonhydrostaticModel`. Modified from OWM&C:; ```; using Oceananigans; Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. # Normalized height ranging from 0 to 1; h(k) = (k - 1) / Nz. # Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. # Bottom-intensified stretching function; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). # Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, Nz, 32),; x = (0, 64),; y = z_faces,; z = ( 0, 64 )). model = NonhydrostaticModel( grid = grid ); ```. I get the following error if I try to use the above code or put the variable grid spacing in the x-direction; ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191:996,error,error,996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,Verbose flag for checkpointer,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/382:17,checkpoint,checkpointer,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/382,1,['checkpoint'],['checkpointer']
Availability,"WE:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(3, 3, 1), x=(0, 1), y=(0, 1), z=(0, 1));. julia> model = HydrostaticFreeSurfaceModel(; grid,; momentum_advection = nothing,; free_surface = ExplicitFreeSurface(; gravitational_acceleration = 10),; closure = nothing,; tracers = nothing,; buoyancy = nothing); HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; ├── free surface: ExplicitFreeSurface with gravitational acceleration 10.0 m s⁻²; ├── advection scheme:; │ └── momentum: Nothing; └── coriolis: Nothing. julia> Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz; (2, 4, 1). julia> model.free_surface.η[1:Hc, 1:Nc, Nz+1:Nz+1] .= 1; ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [4:6, 4:6, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:248; [5] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:316; [6] maybeview; @ ./views.jl:148 [inlined]; [7] dotview(::Field{…}, ::UnitRange{…}, ::UnitRange{…}, ::UnitRange{…}); @ Base.Broadcast ./broadcast.jl:1244; [8] top-level scope; @ REPL[40]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. The error occurs because",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572:918,ERROR,ERROR,918,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572,1,['ERROR'],['ERROR']
Availability,WIP: Adding checkpointer for ShallowWaterModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2868:12,checkpoint,checkpointer,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2868,1,['checkpoint'],['checkpointer']
Availability,Warning/error if Julia version is too low,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/193:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/193,1,['error'],['error']
Availability,"Was accidently running on the Caltech cluster. Also, now it only downloads Julia if the server version is newer than an existing local file (`wget -N`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1038:65,down,downloads,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1038,1,['down'],['downloads']
Availability,"We _do_ check that intervals are increasing:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=2, z=(0, -1), topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=(0, -1) should be an increasing interval.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Tuple{Int64, Int64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:73; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[4]:1; ```. However, if we use explicit interfaces rather than an interval, the constructor seems to be happy:. ```julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. This grid is invalid but was able to be constructed. We should check that and throw an appropriate error so users don't get confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3307:165,ERROR,ERROR,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3307,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"We currently have a `Timeseries` diagnostic which accumulates the output of `some_function(model)` in a vector `data`. . It'd be nice to have a simple way to save a timeseries to file. The problem is that we don't want to duplicate data; eg we want to periodically append data to an array that was previously saved in a file. . Note that it is not possible to, for example, delete data within a `JLD2` file and replace it with something else:. https://github.com/JuliaIO/JLD2.jl/issues/38. @ali-ramadhan @suyashbire1 is this possible in NetCDF / `NCDatasets.jl`?. There are two other possibilities. One is to ""unspool"" the time series into a `group` within a `JLD2` file and write the data from each time stamp individually in the file. This allows new data to be appended to the group easily. I'm not sure how performant this would be, but perhaps its fine. The second is to simply delete the old file and replace it with a new one with the updated time series. This is the hack that I've been using so far. The downside is that we have to save each timeseries in their own file. Curious to hear if there are any other ideas for solving this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/502:1013,down,downside,1013,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/502,1,['down'],['downside']
Availability,"We currently have no checkpointing anymore. We need a barebones checkpointer that only checkpoints and saves the essentials. Should be more transparent than serializing the `Model` to disk, which also comes with multiple issues. Should also be useful for long runs (e.g. seasonal cycle simulations) and more rigorous regression tests that actually test the dynamics.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/324:21,checkpoint,checkpointing,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/324,3,['checkpoint'],"['checkpointer', 'checkpointing', 'checkpoints']"
Availability,"We have a minimum working example that tries to use a nonlinear equation of state, but when we define the model, we get an error saying, the following,. ```; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::typeof(SeawaterPolynomials.TEOS10.TEOS10EquationOfState)); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/Software/Oceananigans.jl/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.SecondOrderSeawaterPolynomials.SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/JiuSX/src/SecondOrderSeawaterPolynomials.jl:64; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/JiuSX/src/TEOS10.jl:186; ```. We are following the documentation shown [here](https://clima.github.io/OceananigansDocumentation/stable/model_setup/buoyancy_and_equation_of_state/). . Can someone help us fix this? . The code is copied below. ```; using Oceananigans; using SeawaterPolynomials. grid = RectilinearGrid(CPU();; size = (10, 10), ; x = ( 0, 1),; z = (-1, 0),; topology = (Periodic, Flat, Bounded)); ; eos = SeawaterPolynomials.TEOS10EquationOfState; buoyancy = SeawaterBuoyancy(equation_of_state=eos). model = NonhydrostaticModel(; grid, buoyancy, tracers = (:T, :S),); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2916:123,error,error,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2916,2,['error'],['error']
Availability,"We now have an infrastructure for embedding fields that require computation like `AveragedField` and `ComputedField` within abstract operations. We currently use a robust, but expensive strategy for ensuring that a computation is correct: immediately prior to evaluating an `AbstractOperation`, we call `compute!` on all of its nodes. This ensures that all data used in the `AbstractOperation` is up to date. A downside to this strategy is that it is more expensive than it needs to be in many common cases. An example is the calculation of three-dimensional buoyancy fluxes `u * b`, `v * b`, and `w * b`, where `b = BuoyancyField(model)`. Evaluating these three expressions will each trigger an evaluation of the model buoyancy. Two of those evaluations are unnecessary. We should brainstorm ways to avoid superfluous recalculation of `ComputedField`s and `AveragedField`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955:164,robust,robust,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955,2,"['down', 'robust']","['downside', 'robust']"
Availability,"We should allow different advection schemes for velocities and tracers. This requires doing something similar to what we do for closures. Perhaps we can allow. ```julia; model = IncompressibleModel(advection=(velocities=CenteredFourthOrder(), tracers=WENO5())); ```. We also probably want to allow different advection schemes for every tracer. We can support something like. ```julia; model = IncompressibleModel(advection=(velocities=CenteredFourthOrder(), T=WENO5(), S=CenteredSecondOrder())); ```. Let's discuss whether the syntax proposed above is acceptable or if we want a different design. PS we need to write down a list of `forbidden_tracer_names` and throw an error if they are provided. Right now these are `:u, :v, :w` and any possible property of `diffusivities`. The above design would also preclude `:velocities` and `:tracers`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1015:617,down,down,617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1015,2,"['down', 'error']","['down', 'error']"
Availability,We should document the advection schemes that are available.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318:50,avail,available,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318,1,['avail'],['available']
Availability,"We should pick a symbol to denote interpolation that we're all happy with. This is proving to be quite difficult unfortunately... So right now `Oceananigans.Operators` uses `avg_` to denote an interpolation operator which will be wrong once #283 is merged, but is also too verbose. `closure_operators.jl` uses `▶` (`\blacktriangleright`) which @glwagner likes but @christophernhill does not. I also don't really like it as it takes a while to type, and is actually quite hard to figure out and remember `\blacktriangleright`. I also think it's too much bold and sticks out too much when reading through the code. In PR #283 I went with `ϊ` (`\iota\ddot`) which I now agree isn't great, so @thabbott and @RaphaelRR suggested `ι` (`\iota`) for interpolation, which I quite like. But @glwagner isn't a huge fan. I've spent a lot of time looking through the unicode tables to try and find something else but to no avail. My favorite find is `↪` (`\hookrightarrow`) but it's reserved for binary operations. Apologies to anyone who thinks this is the most pedantic issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/469:911,avail,avail,911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/469,1,['avail'],['avail']
Availability,We should use CI to test that examples and verification tests run without errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/415:74,error,errors,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/415,1,['error'],['errors']
Availability,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:341,mask,mask,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,3,['mask'],['mask']
Availability,"When I click on the link to the documentation/try finding the documentation on Google, it seems like the link https://clima.github.io/OceananigansDocumentation/stable automatically downloads a text file that contains the version number, and nothing more. Here's also a screenshot of clicking on the documentation page on Google:; ![Screenshot 2023-11-05 205429](https://github.com/CliMA/Oceananigans.jl/assets/50624521/ae495f16-51f8-4e9b-bd5c-a3606bc9dcbf). But I suppose the `dev` version of the documentation works:; https://clima.github.io/OceananigansDocumentation/dev/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3377:181,down,downloads,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3377,1,['down'],['downloads']
Availability,"When I run the following MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lz = 50; grid_base = RectilinearGrid(size=(50, 50, 6), x=(-2000, 2000), y=(-1500, 2500), z=(0, Lz)). bathymetry(x, y) = Lz/2 * exp(-(x/500)^2 - (y/500)^2); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). const cᴰᶻ = 3e-3; @inline τˣᶻ_drag(x, y, z, t, u, v, w) = -cᴰᶻ * u * √(u^2 + v^2); τˣᶻ_BC = FluxBoundaryCondition(τˣᶻ_drag, field_dependencies = (:u, :v, :w)). u_bcs = FieldBoundaryConditions(immersed=ImmersedBoundaryCondition(bottom = τˣᶻ_BC)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u=u_bcs)). simulation = Simulation(model, Δt=1, stop_iteration=10); run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException; ; nested task error: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711:818,error,error,818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"When I try to get `DiffusiveCFL` for a simulation with a `VerticallyStretchedGrid` and an LES closure I get the following error message:. ```julia; julia> using Oceananigans. julia> Nx = Ny = Nz = 32; 32. julia> S = 0.8 # Stretching factor; 0.8. julia> hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); hyperbolically_spaced_nodes (generic function with 1 method). julia> Lz = 32; 32. julia> grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz),; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 64.0], y ∈ [0.0, 64.0], z ∈ [-32.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (2.0, 2.0, [min=0.6847479408200634, max=1.2045016342496169]). julia> model = IncompressibleModel(grid=grid, closure=AnisotropicMinimumDissipation()); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: AnisotropicMinimumDissipation{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Nothing}; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> wizard = TimeStepWizard(cfl=1.0, Δt=10.0, max_change=1.1, max_Δt=1minute, min_Δt=0.1second); TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}(1.0, Inf, 1.1, 0.5, 60.0, 0.1, 10.0, Oceananigans.Utils.cell_advection_timescale, Oceananigans.Simulations.infinite_diffusion_timescale). julia> simulation = Simulation(model, Δt=wizard, stop_time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1749:122,error,error,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1749,1,['error'],['error']
Availability,"When I try to write a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:89,error,error,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"When I use a function to set an `OpenBoundaryCondition` on a `HydrostaticFreeSurfaceModel` I get an error and I don't understand why. Here's a MWE:. ```julia; using Oceananigans; grid = RectilinearGrid(topology = (Bounded, Flat, Bounded), size = (4, 4), extent = (1, 1)). u₀ = 1; @inline u_func(z, t) = u₀. u_bcs = FieldBoundaryConditions(east = OpenBoundaryCondition(u_func), west = OpenBoundaryCondition(u_func)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u = u_bcs,)); set!(model, u = u₀); time_step!(model, 0.1); ```. This gives me the error:. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: objects of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(u_func), Nothing, Tuple{}, Tuple{}, Tuple{}} are not callable; Stacktrace:; [1] getbc; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/boundary_condition.jl:115 [inlined]; [2] _fill_west_halo!; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions_open.jl:34 [inlined]; [3] #25; @ ~/.julia/packages/Oceananigans/OHYQj/src/BoundaryConditions/fill_halo_regions.jl:260 [inlined]; [4] ntuple; @ ./ntuple.jl:50 [inlined]; [5] cpu__fill_west_and_east_halo!; @ ~/.julia/packages/KernelAbstractions/HAcqg/src/macros.jl:287 [inlined]; [6] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:115; [7] (::KernelAbstractions.var""#18#21""{…})(); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/HAcqg/src/cpu.jl:90; ```; which points to this line https://github.com/CliMA/Oceananigans.jl/blob/d4bcc095be66c7b5c98a462106285a6f6d341fe1/src/BoundaryConditions/boundary_condition.jl#L115; which is a fallback method.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628:100,error,error,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628,4,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"When `NaNChecker` (included as a diagnostic in simulations by default) finds a `NaN`, it throws an error. In turn this produces a huge stack trace leading all the way to `src/Diagnostics/nan_checker.jl`. But this huge stacktrace isn't really necessary: NaNs are usually due to issues with the numerical / physical setup (too-long time-step, etc). The stacktrace is inconvenient because it requires scrolling / investigation to deduce that the problem is a NaN, rather than some other julia error associated with a script (or source code). What we really want is to do when we discover a NaN is to `stop(simulation)`. This would also allow code that occurs after `run!(simulation)` to be executed (often desired, if it contains analysis that would help deduce the cause of the NaN). This could be related to #1095; if we use exceptions in place of `stop(simulation)` then throwing an error after finding a NaN is the right thing to do.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1734:99,error,error,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1734,3,['error'],['error']
Availability,"When attempting to run after checkpoint, it seems to think that the last iteration it wrote to output writers was time=0, so it tries to take an enormous negative timestep so that it can write before the next time it was supposed to. Obviously this causes an error, in this case it gave a ""illegal memory access"" in a CUDA array",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1280:29,checkpoint,checkpoint,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280,2,"['checkpoint', 'error']","['checkpoint', 'error']"
Availability,"When creating a background field, I can add it to its respective perturbations to create a total field. However, this fails when writing to file. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: compute!; using Oceananigans.Utils; using Oceananigans.OutputWriters. grid = RegularCartesianGrid(size=(16, 1, 16), extent=(1, 1, 1)). U(x, y, z, t) = 0.2 * z. model = IncompressibleModel(grid = grid, background_fields = (u=U,)). U_tot = model.background_fields.velocities.u + model.velocities.u. simulation = Simulation(model, Δt=2,; iteration_interval=5,; stop_iteration=5,). outputs = (u = model.velocities.u, U_tot = U_tot,); simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, outputs,; filepath = ""mwe.nc"",; schedule = TimeInterval(20minutes),; mode = ""c""); run!(simulation); ```. This fails in the last line with. > ERROR: LoadError: type BinaryOperation has no field data. Is this expected behavior? It would be very nice to be able to do this!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1308:871,ERROR,ERROR,871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308,1,['ERROR'],['ERROR']
Availability,"When running a relatively complex, but small simulation, I'm getting errors on the GPU that I can't make sense of. It's hard to come up with a minimum working example that's truly small because the error seems to pop up only when there's some level of complexity, but here's what I have so far:. ```julia; using Oceananigans; arch = GPU(). z_faces = collect(0:1:6); grid = RectilinearGrid(arch, size=(8, 8, 6),; x=(0, 1), y=(0, 1), z=z_faces). @inline b_bg(x, y, z, t) = x; B_field = BackgroundField(b_bg). @inline sponge_u(x, y, z, t, u, p) = -p.σ * (u - p.α*p.u₀); @inline sponge_v(x, y, z, t, v, p) = -p.σ * (v - p.α*p.u₀); @inline sponge_w(x, y, z, t, w, p) = -p.σ * (w - p.α*p.u₀); @inline sponge_b(x, y, z, t, b, p) = -p.σ * (b - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5)). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:69,error,errors,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,2,['error'],"['error', 'errors']"
Availability,"When running the Tilted Bottom Boundary Layer example code on the latest version of Oceananigans and Julia 1.9.2, I found the following error popped up:; ```MethodError: no method matching constant_stratification(::Float64, ::Float64, ::Float64, ::Float64, ::NamedTuple{(:ĝ, :N²), Tuple{Vector{Float64}, Float64}}). Closest candidates are:; constant_stratification(::Any, ::Any, ::Any, ::Any); @ Main In[7]:1. Stacktrace:; [1] call_func; @ ~/.julia/packages/Oceananigans/0y15B/src/Fields/function_field.jl:54 [inlined]; [2] getindex; @ ~/.julia/packages/Oceananigans/0y15B/src/Fields/function_field.jl:63 [inlined]; [3] inner_left_biased_interpolate_xᶠᵃᵃ; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/upwind_biased_reconstruction.jl:114 [inlined]; [4] left_biased_interpolate_xᶠᵃᵃ; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/reconstruction_coefficients.jl:11 [inlined]; [5] _left_biased_interpolate_xᶠᵃᵃ; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/topologically_conditional_interpolation.jl:56 [inlined]; [6] advective_tracer_flux_x; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/upwind_biased_advective_fluxes.jl:106 [inlined]; [7] _advective_tracer_flux_x; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/tracer_advection_operators.jl:4 [inlined]; [8] δxᶜᵃᵃ; @ ~/.julia/packages/Oceananigans/0y15B/src/Operators/difference_operators.jl:20 [inlined]; [9] div_Uc; @ ~/.julia/packages/Oceananigans/0y15B/src/Advection/tracer_advection_operators.jl:31 [inlined]; [10] tracer_tendency; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:258 [inlined]; [11] cpu_compute_Gc!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:276 [inlined]; [12] cpu_compute_Gc!(__ctx__::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(64, 1, 64)}, KernelAbstractions.NDIteration.NoDynamicCheck, CartesianIndex{3}, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstrac",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3412:136,error,error,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412,1,['error'],['error']
Availability,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/779:119,checkpoint,checkpoint,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779,4,['checkpoint'],"['checkpoint', 'checkpointing']"
Availability,"When trying to run a LES with a Tuple closure (such as `closure = (ScalarDiffusivity(), SmagorinskyLilly())`), the calculation of a diffusive timescale fails on main:. ```; julia> cell_diffusion_timescale(model.closure, model.diffusivity_fields, model.grid); ERROR: type Tuple has no field νₑ; Stacktrace:; [1] getproperty; @ ./Base.jl:38 [inlined]; [2] cell_diffusion_timescale(closure::SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:b,), Tuple{Float64}}}, diffusivities::Tuple{Nothing, NamedTuple{(:νₑ,), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.Off",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2945:259,ERROR,ERROR,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2945,1,['ERROR'],['ERROR']
Availability,When trying to use multi-region on multiple GPUs I get a `CUDA Irrecoverable` error on the main branch. I will post it here but I suspect that it is due to the streams allocation on multiple GPUs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2930:78,error,error,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2930,1,['error'],['error']
Availability,"Where is a reduced field located in the `Nothing` direction?. It is natural to locate the free surface at the surface, (`k = grid.Nz`), but for other fields which are Averages or sums the choice is not that natural. This is important in the context of Immersed boundaries to check if a Reduced Field is immersed or not (and eventally mask it). For the free surface it is enough to check `solid_interface(i, j, grid.Nz, grid)`, for averaged fields it might be necessary to check the whole column `all(solid_interface(i, j, 1:grid.Nz, grid))`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2177:334,mask,mask,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2177,1,['mask'],['mask']
Availability,"While running tests on the new boundary condition implementation on an immersed boundary I encountered a CUDA error that appears to only pop up when using an immersed boundary. I repeated the error on two machines (Satori and my personal machine). I am running on Julia 1.7.2 with Nvidia Driver Version: 510.60.02 and CUDA Version: 11.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(jo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:110,error,error,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,6,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"While we have a few examples / tutorials that demonstrate how Oceananigans can be used to model the ocean surface boundary layer, we have nothing comparable for a ocean bottom boundary layer / atmospheric boundary layer where the action goes down at rough / no-slip boundary. It might be nice to provide a bottom boundary layer example with a wall model appropriate for LES. There's a number of people interested in using Oceananigans to model the bottom boundary layer (cc @tomchor, @raphaelouillon). It'd be nice to think of some way to make it fun and interesting. A few ideas are:. * Implement a wall model appropriate for rough boundaries, and atmospheric / bottom boundary layer LES; * Model sediment-turbulence interaction, perhaps with an effect on buoyancy?; * Use the TEOS10 equation of state (not used in any examples); * Use a gravitational acceleration that's not aligned with z, once #1151 is resolved; * Drive turbulence with tides (eg perhaps reproduce @bekaiser's work in an LES setting). Could do all at once... Others might have better or more reasonable ideas.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1183:242,down,down,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1183,1,['down'],['down']
Availability,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241:265,error,error,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241,1,['error'],['error']
Availability,"With @writingindy, we are trying to learn how to specify a forcing function that depends on the derivatives of a tracer. We have looked at the convecting plantkon example, and tried modifying the forcing function as follows:. ```; growing_and_grazing(x, y, z, t, P, params) = (params.μ₀ * exp(z / params.λ) - params.m) * ∂x(P). ```. When we define the model with this new forcing function, this is not a problem. However, when we run the simulation, we get the following error, that it does not have the correct method,. How can we define the forcing function to depend on derivatives?. ```; julia> run!(simulation); [ Info: Initializing simulation...; Iteration: 0, time: 0 seconds, Δt: 2 minutes; [ Info: ... simulation initialization complete (5.216 seconds); [ Info: Executing initial time step...; ERROR: TaskFailedException. nested task error: MethodError: no method matching ∂x(::Float64); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:46; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:63; ∂x(::Oceananigans.Fields.AbstractField{LX, LY, LZ, G, T, N} where {G<:Union{Nothing, Oceananigans.Grids.AbstractGrid}, T, N}) where {LX, LY, LZ} at /home/fpoulin/Software/Oceananigans.jl/src/AbstractOperations/derivatives.jl:90; Stacktrace:; [1] call; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:456 [inlined]; [2] fallback; @ ~/.julia/packages/Cassette/34vIw/src/context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [4] overdub; @ ~/.julia/packages/Cassette/34vIw/src/overdub.jl:586 [inlined]; [5] growi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2586:471,error,error,471,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2586,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"With a student, we are trying to initialize `IncompressibleModel` with a flow that is in thermal wind balance. We specify the velocity and then compute the buoyancy using the package `QuadGK`. The lines that we use are the following:. ```; parms = (f₀ = Coriolis.f, # s⁻¹, Coriolis parameter; N² = 1e-4, # s⁻¹, buoyancy frequency; D = grid.Lz, # m, ocean depth; L_y = Ly/2, # m, jet width scale; L_z = Lz/2, # m, jet depth scale; σz = 2, # jet width parameter; σy = 5, # jet depth parameter; γ = 1/2, # jet skew parameter; U_max = 2) # jet velocity scale. ū(x, y, z, t, p) = p.U_max * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. dudz(x, y, z, t, p) = 2*p.U_max/p.L_z * (2*p.γ*p.σy * (y/p.L_y + p.γ * z/p.L_z) - p.σz) * tanh(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2) * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. b̄(x, y, z, t, p) = quadgk(yp -> p.N² * (z + p.D) - p.f₀*dudz(x, yp, z, t, p), -Ly/2, y)[1]; ```. It doesn't give any errors but seems to freeze when running the simulation. In the case of a 16x16 grid my student waited 4 hours and nothing. Any idea what the problem is?. There are a bunch of other ways for numerical integration that we can use but this does seem attractive. Any other suggestions would be appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1826:979,error,errors,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826,1,['error'],['errors']
Availability,Would be good to have a feature that splits JLD2 files by size (e.g. maximum file size of 50 GiB or 100 outputs per file). Running large simulations right now is risky because the JLD2 files keeps getting appended to so it keeps growing in size (especially since JLD2 does not compress by default) and if the simulation stops/errors/is killed during IO the JLD2 file and all output is corrupted. We should probably also add an `info=false` flag to `JLD2OutputWriter` that is `false` by default in case a user does not want any JLD2 timings/statistics.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/344:326,error,errors,326,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/344,1,['error'],['errors']
Availability,Would be good to set this up with Slurm CI (PR #280) and start doing continuous performance testing to ensure we don't make mistakes that slow the model down.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/380:153,down,down,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/380,1,['down'],['down']
Availability,"Would be nice to have a nice and user-friendly API for setting boundary conditions. What boundary conditions should we be supporting? What should this API look like? Just starting a discussion around this that I've had with @SandreOuza and @glwagner. @glwagner made the point that the user should just have to specify whether they'd like Dirchlet, Neumann, or Robin boundary conditions. Periodic should be another option. We don't have to support all combinations. But in finite volume boundary conditions are converted into conditions on the fluxes. Right now we have something like this; ```julia; model.boundary_conditions = BoundaryConditions(x=:periodic, y=:periodic, top=:free_slip, bottom=:free_slip); ```; and all the ugliness is swept under the rug. This may involve refactoring some of the difference and interpolation operators as they might have been implicitly assuming that free-slip is being imposed. Will have to confirm with @jm-c. PS: Assigning multiple people as I don't have much experience around this (just to get your attention) Would be good to talk and figure out what kind of API works for all of us. Pinging: @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86:1127,Ping,Pinging,1127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86,1,['Ping'],['Pinging']
Availability,"Would be very useful as it's a pretty common use case. Could probably be very short since it's not a complex procedure. With PR # #1082 merged, maybe now is a good time to consider adding such an example/tutorial since we think the checkpointing/pickup API won't change too much?. X-Ref: #779",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1136:232,checkpoint,checkpointing,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1136,1,['checkpoint'],['checkpointing']
Availability,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:790,Avail,Available,790,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,1,['Avail'],['Available']
Availability,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:571,Error,Error,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Error', 'error']","['Error', 'error']"
Availability,"Yesterday, with @glwagner, we discovered that using higher order advection schemes gave larger error when you don't set the halo to be the large size. . How about we check the halo size we give an error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2106:95,error,error,95,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106,2,['error'],['error']
Availability,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:16766,error,errors,16766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['errors']
Availability,"_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_ALK_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS33_S34_S30_S31_S32_S33_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:9573,error,errors,9573,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['errors']
Availability,"_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _Li3ES5_IS4_Li3ELi1EEEEE12_DOM_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_DIC_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_S11_ES19_IS34_S30_S31_S32_S33_S34_S30_S31_S32_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:16993,error,error,16993,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['error']
Availability,"_S34_S30_S31_EES27_IS28_S28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___Rd_phy___Rd_dom___Rd_chl_____caco3___Rd_oxy___Rd_nit___f_z___f_d_____dom___PAR_S19_IS4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S4_S11_S11_S4_S4_S4_S4_S4_S4_S4_S4_S4_S3_IS4_Li3ES5_IS4_Li3ELi1EEEEE12_OXY_forcingvS19_IS11_S11_S11_S11_S11_S11_S11_S11_ES19_IS32_S33_S34_S30_S31_S32_S33_S34_EEEES3_IS4_Li3ES5_IS4_Li3ELi1EEES18_I27__time___iteration___stage_S19_IS4_S11_S11_EE' uses too much parameter space (0x19a8 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; If you think this is a bug, please file an issue and attach /tmp/jl_4JwMaF.ptx; in expression starting at /nfs/st01/hpc-atmos-jrt51/js2430/OceanBioME.jl/examples/subpolar.jl:223; (stacktrace); (user); > Base; + error ./error.jl:33; CUDA; + cufunction_compile ~/.julia/packages/CUDA/DfvRa/src/c; + [inlined]; GPUCompiler; + JuliaContext ~/.julia/packages/GPUCompiler/N98un/src/; v CUDA; _w_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEES18_I57__b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_IS3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEES3_IS4_Li3ES5_IS4_Li3ELi1EEEEEvS18_I69__u___v___w___b___NO____NH____P___Z___D___DD___DOM___DIC___ALK___OXY_S19_I12_zeroforcingS26_S26_S26_17ContinuousForcingI6CenterS28_S28_S18_I291__p____g_z___K_z___k_r0___k_b0_____rp_____bp___e_r___e_b___r_pig___K_par_______K_no____K_nh____v_dd_min___v_dd_max___V_d___V_dd_________p___a_z___m_z_____z___m_p_____d_____dd_________n_____p_____z_____d_____dd___",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:9800,error,error,9800,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['error']
Availability,"_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:2151,down,down,2151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['down'],['down']
Availability,"_color::Bool); @ REPL /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:229; [42] (::REPL.var""#do_respond#61""{Bool, Bool, REPL.var""#72#82""{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:798; [43] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [44] invokelatest; @ ./essentials.jl:706 [inlined]; [45] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [46] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [47] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:417; ```. The error comes from `show()` and in particular from `maximum` that's being called in `data_summary`. Similarly for a field on `(Center, Face, Center)`! However, not on a ``(Center, Center, Face)`:. ```julia; julia> w = Field((Center, Center, Face), grid); 128×128×65 Field{Center, Center, Face} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: Nothing, top: Nothing, immersed: ZeroFlux; └── data: 136×136×73 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:69) with eltype Float64 with indices -3:132×-3:132×-3:69; └── max=0.0, min=0.0, mean=0.0. julia> maximum(abs, w); 0.0; ```. Also, no problems when using a regularly spaced grid --- things look OK then!. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lx, Ly, Lz = 500, 600, 3. Nx, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:26365,error,error,26365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['error'],['error']
Availability,"_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ ~/Downloads/julia-1.5.4/bin/julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> st; Status `/glade/scratch/tomasc/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `/glade/scratch/tomasc/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # THINGS HAPPEN HERE THAT I'LL SKIP. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. ```. The complete session is [here](https://pastebin.com/9frpW70Z). Everything here is pretty much same, with the only difference being that now the REPL hangs after `using Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:2272,Down,Downloads,2272,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,1,['Down'],['Downloads']
Availability,"_v(x, y, z, t, v, p) = -p.σ * (v - p.α*p.u₀); @inline sponge_w(x, y, z, t, w, p) = -p.σ * (w - p.α*p.u₀); @inline sponge_b(x, y, z, t, b, p) = -p.σ * (b - p.α*p.u₀). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; σ=1, u₀=1, α=4e-5)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; σ=1, u₀=1, α=4e-5)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; σ=1, u₀=1, α=4e-5)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; σ=1, u₀=1, α=4e-5)). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:1536,ERROR,ERROR,1536,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""$(FILE_DIR)/instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=1). simulation.output_writers[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./tes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:1493,checkpoint,checkpoint,1493,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,1,['checkpoint'],['checkpoint']
Availability,`@apply_regionally` errors when wrapping a function with a return value and `args...` in the function signature,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2914:20,error,errors,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2914,1,['error'],['errors']
Availability,"`FieldBoundaryConditions` has two constructors: one for ""prognostic"" fields and one for ""auxiliary"" fields:. 1. `FieldBoundaryCondition(; kwargs...)` for prognostic fields;; 2. `FieldBoundaryCondition(grid, location; kwargs...)` for auxiliary fields.; ; The distinction is that boundary conditions on _prognostic_ fields are ""regularized"" within a model constructor, and can be complex (can depend nonlinearly on other fields). Boundary conditions on auxiliary fields must be simpler and are not regularized, which is why `grid` and `location` are required for auxiliary boundary conditions. It's easy for a user to mistakenly apply prognostic boundary conditions to an auxiliary field by using the wrong constructor. To help users fix this issue, we should throw a nice error when `fill_side_halo!` (where `side = (east, west, north, south, top, bottom))` is called with the ""specification"" type `DefaultPrognosticFieldBoundaryCondition` rather than a ""real"" (regularized or simple) `BoundaryCondition`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1968:771,error,error,771,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968,1,['error'],['error']
Availability,`Fields()` throws an error when `indices` keyword is used,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2391:21,error,error,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391,1,['error'],['error']
Availability,"`GridFittedImmersedBoundary` uses a masking technique to immerse a grid-fitted boundary into some primary grid. For this purpose it elides diffusive fluxes across immersed interfaces (and soon will elide advective fluxes via #1719). This permits simulations that conserve tracers and momentum. However, users typically want to enforce boundary conditions across immersed boundaries. The simplest boundary condition to support is `FluxBoundaryCondition`. But there are a number of complications. Our current boundary condition API really bakes in the assumption of directionally-aligned boundaries, since fluxes are defined in the x, y, z direction, according to the boundary in question. This only makes sense for boundaries that are aligned with x, y, z, respectively. For boundaries that can point in any direction, it probably makes more sense to define fluxes _normal_ to the boundary. But then if we want to have a consistent API for specifying boundary conditions for both immersed boundaries and grid boundaries, we need to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720:36,mask,masking,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720,1,['mask'],['masking']
Availability,"`InterpolatedField` for Lagrangian particle tracking, output on custom grids, and restoring from checkpoint to a new grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/975:97,checkpoint,checkpoint,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/975,1,['checkpoint'],['checkpoint']
Availability,`JLD2OutputWriter` and `Checkpointer` don't work when `max_filesize` and `part` are specified.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:24,Checkpoint,Checkpointer,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,1,['Checkpoint'],['Checkpointer']
Availability,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1369:1290,error,error,1290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369,2,"['error', 'failure']","['error', 'failure']"
Availability,"`NetCDFOutputWriter` constructor says that ""`outputs` (which can be a; `Dict` or `NamedTuple`)"" but this line does not work on named tuples. https://github.com/climate-machine/Oceananigans.jl/blob/a511fdd2fedc9aae49a76905be24fdc60c2d60b0/src/OutputWriters/netcdf_output_writer.jl#L162. ```julia; julia> nt = (a=2, b=4, c=8); (a = 2, b = 4, c = 8). julia> for (i, j) in nt; @show i, j; end; ERROR: BoundsError: attempt to access Int64; at index [2]; Stacktrace:; [1] indexed_iterate(::Int64, ::Int64, ::Nothing) at ./tuple.jl:72; [2] top-level scope at ./REPL[4]:1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/553:390,ERROR,ERROR,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/553,1,['ERROR'],['ERROR']
Availability,`NetCDFOutputWriter` errors when given `outputs` as named tuple,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/553:21,error,errors,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/553,1,['error'],['errors']
Availability,`NetCDFOutputWriter` leaves file open if the constructor errors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/555:57,error,errors,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/555,1,['error'],['errors']
Availability,"`Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware M",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:2783,down,down,2783,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['down'],['down']
Availability,"``. Broadcasting also works with `AbstractOperations`:. ```julia; julia> d = Field(Face, Center, Center, CPU(), grid); Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (4, 4, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> dx_c = ∂x(c); Derivative at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ∂xᶠᶜᵃ at (Face, Center, Center) via identity;    └── Field located at (Center, Center, Center). julia> d .= 2 .* dx_c. julia> interior(d); 2×2×1 view(OffsetArray(::Array{Float64,3}, 0:3, 0:3, 0:2), 1:2, 1:2, 1:1) with eltype Float64:; [:, :, 1] =; 4.36713 3.46522; -1.988 4.13932; ```. Under the hood we launch kernels, so broadcasting is multithreaded and works on the GPU as well as the CPU. This is just the beginning I think. This PR only implements in-place broadcasting, but out-of-place (allocating) broadcasting would be useful for analysis of data via `AbstractField`. For this I think we need to define `Base.copy` in addition to `copyto!` (but this is simple since we already have `similar`...) ~~We also need to write a lot more code to make broadcasting robust: for example, we should check that broadcasted objects have the same location. We might also be able to implement interpolation correctly. This PR shows that all of this is possible.~~. This PR implements interpolated broadcasting by transforming `Base.Broadcast.Broadcasted` to `AbstractOperation`. Note: it also defines some new helper functions for `BinaryOperation` that should help with type inference and GPU compilation. This was necessary to get some of the broadcasting tests work (since broadcasting also uses `AbstractOperation`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1596:1884,robust,robust,1884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1596,1,['robust'],['robust']
Availability,"```; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); ```. Might have something to do with the new tuple/named tuple syntax but I thought Julia 1.4 -> 1.5 wasn't supposed to introduce any breaking changes? https://julialang.org/blog/2020/08/julia-1.5-highlights/#implicit_keyword_argument_values. # Julia 1.4.2. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:5,ERROR,ERROR,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['ERROR'],['ERROR']
Availability,"```Julia. julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> model = IncompressibleModel(grid = RegularCartesianGrid(topology=(Periodic, Periodic, Flat), size=(16, 16), extent=(2π, 2π))); IncompressibleModel{CPU, Float64}(time = 0.000 s, iteration = 0); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Flat}(Nx=16, Ny=16, Nz=1); ├── tracers: (:T, :S); ├── closure: IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> model.velocities.u; Error showing value of type Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}}:; ERROR: MethodError: no method matching bctype_str(::Nothing); Closest candidates are:; bctype_str(::BoundaryCondition{Flux,Nothing}) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:29; bctype_str(::BoundaryCondition{var""#s63"",T} where T where var""#s63""<:Flux) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:24; bctype_str(::BoundaryCondition{var""#s63"",T} where T where var""#s63""<:Oceananigans.BoundaryConditions.Periodic) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:25; ...; Stacktrace:; [1] short_show(::Nam",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1026:615,Error,Error,615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026,1,['Error'],['Error']
Availability,"```Julia; [ Info: Running the simulation...; ERROR: LoadError: KeyError: key ""timestepper/Gⁿ/w"" not found; Stacktrace:; [1] pathize(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String, create::Bool); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/groups.jl:70; [2] getindex(g::JLD2.Group{JLD2.JLDFile{JLD2.MmapIO}}, name::String); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/groups.jl:95; [3] getindex(f::JLD2.JLDFile{JLD2.MmapIO}, name::String); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/JLD2.jl:379; [4] set_time_stepper_tendencies!(timestepper::Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:45,ERROR,ERROR,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['ERROR'],['ERROR']
Availability,"```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(; panel_size = (3, 3, 3),; z = (-1, 0),; horizontal_direction_halo = 6); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on CPU():; ├── grids: 3×3×3 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 6×6×6 halo and with precomputed metrics; ├── partitioning: CubedSpherePartition with (1 region in each panel); ├── connectivity: CubedSphereConnectivity; └── devices: (CPU(), CPU(), CPU(), CPU(), CPU(), CPU()). julia> model = HydrostaticFreeSurfaceModel(; grid, momentum_advection = VectorInvariant()); ERROR: UndefVarError: `rotation_from_panel_index` not defined; Stacktrace:; [1] with_halo(new_halo::Tuple{Int64, Int64, Int64}, csg::ConformalCubedSphereGrid{Float64, FullyConnected, ....; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/multi_region_cubed_sphere_grid.jl:431; [2] Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver(grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl:47; [3] build_implicit_step_solver(#unused#::Val{:Default}, grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.MultiRegion ~/Research/OC8.jl/src/MultiRegion/unified_implicit_free_surface_solver.jl:67; [4] FreeSurface(free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:95; [5] HydrostaticFreeSurfaceModel(; grid::ConformalCubedSphereGrid{Float64, ...; @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Research/OC8.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:169; [6] top-level scope; @ REPL[63]:1; ```. cc @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3295:658,ERROR,ERROR,658,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3295,1,['ERROR'],['ERROR']
Availability,```julia; ERROR: LoadError: cannot write a pointer to JLD file; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/420:10,ERROR,ERROR,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/420,1,['ERROR'],['ERROR']
Availability,"```julia; using Oceananigans, Oceananigans.Diagnostics, Oceananigans.AbstractOperations; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=CPU(), grid=grid) # Same with GPU(); u, v, w = model.velocities; ∫uv = Average(u*v, dims=(1, 2), return_type=Array); ```. ```; ERROR: MethodError: no method matching architecture(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}); Closest candidates are:; architecture(::Array) at /home/alir/Oceananigans.jl/src/Architectures.jl:46; architecture(::CUDA.CuArray) at /home/alir/Oceananigans.jl/src/Architectures.jl:47; architecture(::Field) at /home/alir/Oceananigans.jl/src/Fields/field.jl:167; ...; Stacktrace:; [1] Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims::Tuple{Int64,Int64}, iteration_interval::Nothing, time_interval::Nothing, return_type::Type{T} where T) at /home/alir/Oceananigans.jl/src/Diagnostics/average.jl:52; [2] top-level scope at REPL[17]:1. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/857:323,ERROR,ERROR,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/857,1,['ERROR'],['ERROR']
Availability,"```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=128, z=(-128, 0), topology=(Flat, Flat, Bounded)). closure = (VerticalScalarDiffusivity(VerticallyImplicitTimeDiscretization(), κ=1e-4),; CATKEVerticalDiffusivity()). model = HydrostaticFreeSurfaceModel(; grid, closure,; tracers = (:b, :e),; buoyancy = BuoyancyTracer()). bᵢ(z) = 1e-5 * z; set!(model, b = bᵢ); simulation = Simulation(model, Δt=1minute, stop_iteration=10). run!(simulation); ```. generates the error. ```julia; julia> include(""tupled_vertical_diffusion.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (2.367 seconds); [ Info: Executing initial time step...; ERROR: LoadError: type Tuple has no field κe; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] time_step_catke_equation!(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl:25; [3] compute_diffusivities!(diffusivities::@NamedTuple{…}, closure::CATKEVerticalDiffusivity{…}, model::HydrostaticFreeSurfaceModel{…}; parameters::Symbol); @ Oceananigans.TurbulenceClosures.TKEBasedVerticalDiffusivities ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:197; [4] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/catke_vertical_diffusivity.jl:181 [inlined]; [5] #compute_diffusivities!#24; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:79 [inlined]; [6] compute_diffusivities!; @ ~/Projects/Oceananigans.jl/src/TurbulenceClosures/closure_tuples.jl:76 [inlined]; [7] update_state!(model::HydrostaticFreeSurfaceModel{…}, grid::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3804:560,error,error,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3804,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"``julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.TTY}, X::AbstractVecOrMat, rows::Vector{Int64}, cols::Vec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:1489,error,errorscalar,1489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['error'],['errorscalar']
Availability,`benchmarks/Manifest.toml` had CUDA updated to 3.7 which caused problems when benchmarking Oceananigans restricted to 3.3.6. This PR adds a `compat` to `benchmarks/Project.toml` and downgrades `CUDA`. I think maybe a better solution would be to add Oceananigans explicitly to `benchmarks/Project.toml`. But then to run the benchmarks on the current repo we'd have to update the environment every time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2417:182,down,downgrades,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2417,1,['down'],['downgrades']
Availability,"`closure = nothing` is effectively the same thing as `closure = IsotropicDiffusivity(ν=0, κ=0)` so maybe this issue isn't worth thinking about. ```julia; using Oceananigans; grid = RegularCartesianGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid, closure=nothing); ```. ```; ERROR: MethodError: no method matching with_tracers(::Tuple{Symbol,Symbol}, ::Nothing); Closest candidates are:; with_tracers(::Any, ::NamedTuple, ::Any; with_velocities) at /home/alir/Oceananigans.jl/src/Utils/with_tracers.jl:10; with_tracers(::Any, ::Tuple) at /home/alir/Oceananigans.jl/src/TurbulenceClosures/TurbulenceClosures.jl:150; with_tracers(::Any, ::IsotropicDiffusivity) at /home/alir/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:38; ...; Stacktrace:; [1] IncompressibleModel(; grid::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, architecture::CPU, float_type::Type{T} where T, clock::Clock{Float64}, advection::Oceananigans.Advection.CenteredSecondOrder, buoyancy::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, coriolis::Nothing, surface_waves::Nothing, forcing::NamedTuple{(:u, :v, :w),Tuple{typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}}, closure::Nothing, boundary_conditions::NamedTuple{(:u, :v, :w),Tuple{NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}},NamedTuple{(:x, :y, :z),Tupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/939:304,ERROR,ERROR,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/939,1,['ERROR'],['ERROR']
Availability,`device kernel image is invalid` error when running relatively complex simulation on GPUs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:33,error,error,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['error'],['error']
Availability,`fkeep` error for `HydrostaticFreeSurfaceModel` with a `HeptadiagonalIterativeSolver`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184:8,error,error,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184,1,['error'],['error']
Availability,"`run!(simulation, pickup=true)` should work even with zero checkpoints",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1159:59,checkpoint,checkpoints,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159,1,['checkpoint'],['checkpoints']
Availability,`run!` does not need `Glob` + fix the docstring of `checkpointer`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3172:52,checkpoint,checkpointer,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3172,1,['checkpoint'],['checkpointer']
Availability,"`target_times` is not passed to the correct architecture before interpolation, leading to errors like [this one](https://buildkite.com/clima/climaocean-ci/builds/1251#0191774b-12c6-4f07-9b7f-35119ef4e639). This happens when `target_times` is a range, then `map` creates a vector which is not isbits.; This PR corrects this bug.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3723:90,error,errors,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3723,1,['error'],['errors']
Availability,`test/test_*.jl` is a redundant naming scheme,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/871:22,redundant,redundant,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/871,1,['redundant'],['redundant']
Availability,`with_halo` throws an error for VerticallyStretchedRectilinearGrid,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1605:22,error,error,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1605,1,['error'],['error']
Availability,`with_halo` throws an error for `VerticallyStretchedRectilinearGrid`:. https://github.com/CliMA/Oceananigans.jl/blob/6ff1f69e2bc5d66a0889fb3c62fb2a3b633ab535/src/Grids/vertically_stretched_rectilinear_grid.jl#L227-L231. despite that the stretched `z_faces` / `zF` kwarg can be inferred from `grid.zᵃᵃᶠ`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1605:22,error,error,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1605,1,['error'],['error']
Availability,a little change to run checkpointers with IBG,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2094:23,checkpoint,checkpointers,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2094,1,['checkpoint'],['checkpointers']
Availability,"a> ν = model.closure.ν; 1.0e-6. julia> using Oceananigans.AbstractOperations: KernelFunctionOperation. julia> using Oceananigans.Operators. julia> @inline fψ_plus_gφ²(i, j, k, grid, f, ψ, g, φ) = @inbounds (f(i, j, k, grid, ψ) + g(i, j, k, grid, φ))^2; fψ_plus_gφ² (generic function with 1 method). julia> function isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, ν); Σˣˣ² = ∂xᶜᵃᵃ(i, j, k, grid, u)^2; Σʸʸ² = ∂yᵃᶜᵃ(i, j, k, grid, v)^2; Σᶻᶻ² = ∂zᵃᵃᶜ(i, j, k, grid, w)^2; Σˣʸ² = ℑxyᶜᶜᵃ(i, j, k, grid, fψ_plus_gφ², ∂yᵃᶠᵃ, u, ∂xᶠᵃᵃ, v) / 4; Σˣᶻ² = ℑxzᶜᵃᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, u, ∂xᶠᵃᵃ, w) / 4; Σʸᶻ² = ℑyzᵃᶜᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, v, ∂yᵃᶠᵃ, w) / 4; ϵ[i, j, k] = ν[i, j, k] * 2 * (Σˣˣ² + Σʸʸ² + Σᶻᶻ² + 2 * (Σˣʸ² + Σˣᶻ² + Σʸᶻ²)); end; isotropic_viscous_dissipation_rate_ccc (generic function with 1 method). julia> ε_operation = KernelFunctionOperation{Center, Center, Center}(isotropic_viscous_dissipation_rate_ccc, grid;; computed_dependencies=(u, v, w, ν)); Error showing value of type KernelFunctionOperation{Center, Center, Center, Nothing, CPU, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, typeof(isotropic_viscous_dissipation_rate_ccc), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryCo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1761:3028,Error,Error,3028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1761,1,['Error'],['Error']
Availability,"adError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/AbstractOperations/conditional_operations.jl:96; condition_operand(func::Function, op::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, cond, mask); @ Oceananigans.ImmersedBoundaries /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/ImmersedBoundaries/immersed_reductions.jl:18. Possible fix, define; condition_operand(::Function, ::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, ::AbstractArray, ::Any). Stacktrace:; [1] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:2293,mask,mask,2293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['mask'],['mask']
Availability,"ages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:38244,error,error,38244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['error'],['error']
Availability,"alculation that reproduces the issue:. ```julia; using Oceananigans; using CUDA: has_cuda_gpu. arch = has_cuda_gpu() ? GPU() : CPU(); grid_base = RectilinearGrid(arch,; size=(4, 4, 4),; extent = (1, 1, 1),; halo=(4, 4, 4)). bathymetry(x, y) = 1; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). model = NonhydrostaticModel(; grid). @inline function vector_projection_aaa(i, j, k, grid, ϕˣ, ϕᶻ, params); return @inbounds ϕˣ[i,j,k]*params.xdirection + ϕᶻ[i,j,k]*params.zdirection; end. using Oceananigans.AbstractOperations: ∂x, ∂y, ∂z; u, v, w = model.velocities; dudx_tilt = ∂x(u) + 1e-7; dudz_tilt = ∂z(u). using Oceananigans.Grids: Center, Face; dudz_op = KernelFunctionOperation{Center, Center, Face}(vector_projection_aaa, model.grid,; dudx_tilt, dudz_tilt,; (xdirection=0.9,; zdirection=0.1)); dudz = Field(Average(dudz_op, dims=(1,2))); compute!(dudz); ```. This gives me:. ```; ERROR: LoadError: Failed to compile PTX code (ptxas exited with code 255); Invocation arguments: --generate-line-info --verbose --gpu-name sm_70 --output-file /glade/scratch/tomasc/jl_6zqZEpG5Yv.cubin /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx; ptxas /glade/scratch/tomasc/jl_uD0VONe1Cz.ptx, line 3031; error : Entry function '_Z22partial_mapreduce_grid8identity7add_sumv16CartesianIndicesILi3E5TupleI5OneToI5Int64ES3_IS4_ES3_IS4_EEES1_ILi3ES2_IS3_IS4_ES3_IS4_ES3_IS4_EEE3ValILitrueEE13ReshapedArrayI7Float64Li4E8SubArrayIS7_Li3E13CuDeviceArrayIS7_Li3ELi1EES2_I9UnitRangeIS4_ES10_IS4_ES10_IS4_EELinfalseEES2_I27SignedMultiplicativeInverseIS4_ES11_IS4_EEE20ConditionalOperationI6CenterS13_4Face15BinaryOperationIS13_S13_S14_1_S15_IS13_S13_S14_S16_23KernelFunctionOperationIS13_S13_S14_20ImmersedBoundaryGridIS7_8PeriodicS19_7Bounded15RectilinearGridIS7_S19_S19_S20_S7_S7_S7_11OffsetArrayIS7_Li1E12StepRangeLenIS7_14TwicePrecisionIS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EES22_IS7_Li1ES23_IS7_S24_IS7_ES24_IS7_ES4_EEvE16GridFittedBottomIS22_IS7_Li2ES9_IS7_Li2ELi1EEE23CenterImmerse",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:1133,ERROR,ERROR,1133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['ERROR'],['ERROR']
Availability,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:1949,down,down,1949,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,1,['down'],['down']
Availability,"angeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:4; [4] jldopen; @ /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:2 [inlined]; [5] set!; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:193 [inlined]; [6] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCon",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:28525,checkpoint,checkpointer,28525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['checkpoint'],['checkpointer']
Availability,"anigans.BoundaryConditions, Oceananigans.Grids, Oceananigans.AbstractOperations; using Oceananigans.TurbulenceClosures; using Oceananigans.Advection: CenteredFourthOrder; using Oceananigans.Utils: TimeInterval; using CUDA. # # Making grid; Nx = 32; Ny = 32; Nz = 30; Δy = 250.0; Δx = 250.0; Δz = 2.5; Lx = Δx*Nx; Ly = Δy*Ny; Lz = Δz*Nz; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = (0, Lz)). kappaH = 5e5 # [m4/s]; kappaV = 5e-5 # [m2/s]; vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = HorizontalScalarBiharmonicDiffusivity(κ=kappaH, ν=kappaH); closures = (vertical_closure, horizontal_closure). model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; closure = closures,; ); ; # Running; Δt = 60.; simulation = Simulation(model, Δt=Δt, stop_iteration=0); simulation.stop_iteration += 1; run!(simulation). ```. and get the following error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 30)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 30)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, CenteredFourthOrder, FPlane{Float64}, Nothi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2591:1130,error,error,1130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2591,1,['error'],['error']
Availability,"anigans.jl/blob/2e4ba6b36bf012d5dcb89ddc7160a10f774aadbe/src/TurbulenceClosures/turbulence_closure_diagnostics.jl#L67-L69. CATKE should also have an infinite cell diffusion timescale with the default implicit time discretization. When CATKE is run with explicit time discretization I suppose the cell diffusion timescale should be computed from the maximum viscosity/diffusivity in `model.diffusivity_fields`. Happy to add these `cell_diffusion_timescale` methods. I know `CATKEVerticalDiffusivity` is not exported so I'm just opening the issue to document. ---. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = RectilinearGrid(size=(12, 12, 12), extent=(1, 1, 1)); closure = CATKEVerticalDiffusivity(); buoyancy = SeawaterBuoyancy(); tracers = (:T, :S, :e). model = HydrostaticFreeSurfaceModel(; grid, closure, buoyancy, tracers). DiffusiveCFL(1.23)(model); ```. Error:. ```; ERROR: MethodError: no method matching cell_diffusion_timescale(::CATKEVerticalDiffusivity{…}, ::@NamedTuple{…}, ::RectilinearGrid{…}). Closest candidates are:; cell_diffusion_timescale(::Nothing, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:22; cell_diffusion_timescale(::ScalarBiharmonicDiffusivity{Dir}, ::Any, ::Any) where Dir; @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:40; cell_diffusion_timescale(::SmagorinskyLilly, ::Any, ::Any); @ Oceananigans ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:47; ... Stacktrace:; [1] cell_diffusion_timescale(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.TurbulenceClosures ~/atdepth/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:21; [2] (::CFL{…})(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.Diagnostics ~/atdepth/Oceananigans.jl/src/Diagnostics/cfl.jl:25; [3] top-level scope; @ REPL[24]:1; Some type information wa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3772:976,ERROR,ERROR,976,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3772,1,['ERROR'],['ERROR']
Availability,"are initialized within the domain and without any dynamics the particles should stay perfectly still. So I'm not sure where the illegal memory access is happening, but should be easy to debug on the CPU?. MWE:. ```julia; using Oceananigans; using Oceananigans.Architectures: on_architecture. arch = GPU(). H = 100. Nλ = 100; Nφ = 200; Nz = 60. grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (Nλ, Nφ, Nz),; longitude = (0.79, 1.23),; latitude = (-1.96, -1.12),; z = (-H, 0),; halo = (4, 4, 4); ). Np = 100 # Number of particles. particles = LagrangianParticles(; x = on_architecture(arch, 1 * ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-do",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:1425,fault,fault,1425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['fault'],['fault']
Availability,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036:2454,mask,masking,2454,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036,1,['mask'],['masking']
Availability,"ast.jl:556 [inlined]; [3] instantiate; @ ./broadcast.jl:297 [inlined]; [4] materialize!; @ ./broadcast.jl:884 [inlined]; [5] materialize!; @ ./broadcast.jl:881 [inlined]; [6] materialize!(dest::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{UnitRange{Int64}, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, UnitRange{Int64}}, false}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{1}, Nothing, typeof(identity), Tuple{OffsetArrays.OffsetVector{Float64, Vector{Float64}}}}); @ Oceananigans.Fields ~/Research/OC7.jl/src/Fields/broadcasting_abstract_fields.jl:36; [7] top-level scope; @ REPL[5]:1; ```. While the size of the slices are _exactly_ the same, we we get an error that `ERROR: DimensionMismatch: array could not be broadcast to match destination`. If instead we try to broadcast to the `parent` arrays then things work as expected. ```Julia; julia> parent(c1[1, :, 1]) .= parent(c2[2, :, 3]); 9-element Vector{Float64}:; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; ```. (found with @siddharthabishnu)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361:3425,error,error,3425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"ative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CU; DAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnat; ive.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.C; uDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDeviceArray{Float64,3,CUDAnative.AS.Global}, CUDAnative.CuDevi; ceArray{Float64,3,CUDAnative.AS.Global}, Forcing{typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oce; ananigans.zero_func),typeof(Oceananigans.zero_func),typeof(Oceananigans.zero_func)}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f__apply); Stacktrace:; [1] overdub at /data5/glwagner/.julia/packages/Cassette/xggAf/src/context.jl:260; [2] ν_ccc at /data5/glwagner/Projects/Oceananigans.jl/src/closures/constant_smagorinsky.jl:109; [3] ν_Σᵢⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:405; [4] ∂x_faa at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:64; [5] ∂x_2ν_Σ₁₁ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:409; [6] ∂ⱼ_2ν_Σ₁ⱼ at /data5/glwagner/Projects/Oceananigans.jl/src/closures/closure_operators.jl:432; [7] calculate_interior_source_terms! at /data5/glwagner/Projects/Oceananigans.jl/src/time_steppers.jl:152; [8] #12 at /data5/glwagner/.julia/packages/GPUifyLoops/hBRid/src/context.jl:136; Reason: unsupported dynamic function invocation (call to Cassette.overdub); ```. I think this is specific to the package upgrades. I also got this error when running the `rayleigh_benard_passive_tracer.jl` script (associated with the function that forces salinity). Mysteriously, it does not throw this error when it runs the tests. Not sure where to raise an issue (if this is an issue)... _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/pull/245#issuecomment-496472606_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248:2150,error,error,2150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248,2,['error'],['error']
Availability,"be good to suppress them somehow. This package might help: https://github.com/JuliaIO/Suppressor.jl. What I see on a CPU:; ```; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:550 overwritten in module GPUifyLoops at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:550.; WARNING: Method definition overdub(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:537 overwritten in module GPUifyLoops at /home/alir/.julia/packages/Cassette/IwsFs/src/overdub.jl:537.; ERROR: LoadError: Could not find CUDA driver library; Stacktrace:; [1] top-level scope at /home/alir/.julia/packages/CUDAdrv/ADRHQ/src/CUDAdrv.jl:33; [2] top-level scope at none:2; in expression starting at /home/alir/.julia/packages/CUDAdrv/ADRHQ/src/CUDAdrv.jl:27; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ┌ Warning: Replacing docs for `Core.nothing :: Union{}` in module `Oceananigans`; └ @ Base.Docs docs/Docs.jl:223; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/366:1511,ERROR,ERROR,1511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/366,1,['ERROR'],['ERROR']
Availability,"bstractOperations; using Oceananigans.TurbulenceClosures; using Oceananigans.Advection: CenteredFourthOrder; using Oceananigans.Utils: TimeInterval; using CUDA. # # Making grid; Nx = 32; Ny = 32; Nz = 30; Δy = 250.0; Δx = 250.0; Δz = 2.5; Lx = Δx*Nx; Ly = Δy*Ny; Lz = Δz*Nz; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = (0, Lz)). kappaH = 5e5 # [m4/s]; kappaV = 5e-5 # [m2/s]; vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = HorizontalScalarBiharmonicDiffusivity(κ=kappaH, ν=kappaH); closures = (vertical_closure, horizontal_closure). model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; closure = closures,; ); ; # Running; Δt = 60.; simulation = Simulation(model, Δt=Δt, stop_iteration=0); simulation.stop_iteration += 1; run!(simulation). ```. and get the following error:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 30)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 30)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, CenteredFourthOrder, FPlane{Float64}, Nothing, Tuple{ScalarBiharmonicDiffusivity{Oceananigans.TurbulenceCl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2591:1143,ERROR,ERROR,1143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2591,1,['ERROR'],['ERROR']
Availability,"but I haven't been able to figure it out. First off, here's the command I'm using to run the script:. ```; $ /glade/work/tomasc/.julia/bin/mpiexecjl --project -n 2 julia --project distributed_nonhydrostatic_model_mpi.jl 8 8 8 1 2 1; ```. Which should (if I understand correctly) create a simulation on an 8x8x8 grid that partitioned into 2 in the y direction. However, I always get this error:. ```; [2022/04/12 16:43:26.454] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 0...; [2022/04/12 16:43:26.473] INFO Setting up distributed nonhydrostatic model with N=(8, 8, 8) grid points and ranks=(1, 2, 1) on rank 1...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/04/12 16:43:56.216] INFO Warming up distributed nonhydrostatic model on rank 1...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 8 and 4""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(shape::_bcs(shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3, P",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2433:1201,ERROR,ERROR,1201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433,2,['ERROR'],['ERROR']
Availability,"c/OutputWriters/output_writer_utils.jl:65; ┌ Warning: Cannot serialize timeseries/v/serialized/boundary_conditions as it contains functions. Will replace with missing. Function boundary conditions must be restored manually.; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:65; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (36.847 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; TaskFailedException. nested task error: TaskFailedException; ; nested task error: UndefKeywordError: keyword argument p not assigned; Stacktrace:; [1] Qᵘ(::Float64, ::Float64, ::Float64, ::NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}); @ ./In[3]:1 [inlined]; [2] overdub; @ ./In[3]:1 [inlined]; [3] overdub; @ ~/.julia/packages/Oceananigans/CuznF/src/BoundaryConditions/continuous_boundary_function.jl:122 [inlined]; [4] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 20, typeof(Qᵘ), NamedTuple{(:cᴰ, :ρₐ, :ρₒ, :L, :H, :Ny, :Nx, :Nz), Tuple{Float64, Float64, Int64, Float64, Float64, Int64, Int64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, ::Int64, ::Int64, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336:2304,error,error,2304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336,2,['error'],['error']
Availability,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:1777,avail,available,1777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,1,['avail'],['available']
Availability,"cc @glwagner . When calculating PV from previously calculating fields, I get an error that comes from an interpolation I have to do. For example, this code, which I believe is the correct code, produces the wrong result:. ```julia; using Oceananigans.Operators: ℑxyzᶜᶜᶠ; @kernel function compute_pv_from_Ro_Ri!(PV, grid, Ri, Ro, N², f₀); i, j, k = @index(Global, NTuple). Ro_int = ℑxyzᶜᶜᶠ(i, j, k, grid, Ro). @inbounds PV[i, j, k] = N²[i, j, k]*f₀ * (1 + Ro_int - 1/Ri[i, j, k]); end. Ri_kern = KernelComputedField(Center, Center, Face, compute_richardson_number!, model;; field_dependencies=(u_tot, v, b_tot, 0, 0, 0)). Ro_kern = KernelComputedField(Face, Face, Center, compute_rossby_number!, model;; field_dependencies=(u_tot, v, 0, 0, f0)). PV_kern = KernelComputedField(Center, Center, Face, compute_pv_from_Ro_Ri!, model;; field_dependencies=(Ri_kern, Ro_kern, N2_inf, f0)); ```. In the above code, `f0`, `N2_inf` are constants and `u_tot` is an `AbstractOperation`. Ri and Ro get calculated correctly. However, when I change the PV calculation so as to not interpolate, I get the correct result:. ```julia; @kernel function compute_pv_from_Ro_Ri!(PV, grid, Ri, Ro, N², f₀); i, j, k = @index(Global, NTuple). @inbounds PV[i, j, k] = N²[i, j, k]*f₀ * (1 + Ro[i, j, k] - 1/Ri[i, j, k]); end; ```. The code above produces the right numerical result (although it's ""wrong"" because I'd need to interpolate). This feels weird because `Ro` is constant everywhere, so interpolating it shouldn't make any difference. Am I doing something wrong here? Also I'm attaching a [Minimum Working Example](https://pastebin.com/gH7CPNTA) just in case it's useful.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1324:80,error,error,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1324,1,['error'],['error']
Availability,"cePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:4; [8] jldopen; @ /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:2 [inlined]; [9] set!; @ /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:199 [inlined]; [10] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:80500,checkpoint,checkpointer,80500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['checkpoint'],['checkpointer']
Availability,"cise with Oceananigans I am trying to simulate some high salinity, low temperature water above low salinity, high temperature water (with a bit of random noise), with a small initial westward velocity component and a 10 second time step. The documentation was quite helpful (thanks for that), and the simulation works as expected until about t=50s, when small water parcels at the density interface heat up or cool down to unnatural levels (see attached gifs at bottom), and occasionally the entire temperature matrix fills with NaN's. I've tried removing all my boundary conditions to see if they were the problem, but the issue persisted. For reference, I am using Julia v1.5 with Oceananigans 0.44.1, with this platform:; OS: macOS (x86_64-apple-darwin18.7.0); CPU: Intel(R) Core(TM) i5-6360U CPU @ 2.00GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake). And here is a minimal example, along with code to gif-ify the output. Lowering the timestep down to 1 second from the current 10 seconds also does not fix anything. Also using a time step wizard with initial del_t at 1 second and cfl=0.3 still generates unrealistic temperatures; however, it then seems to freeze before converting entirely to NaN's and would not progress given an extra (real-life) hour to run compared to the fixed timestep. ```; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)). @inline thermoc(x, y, z) = 16-12*tanh((z+250)/10)+rand(Float64); @inline sal(x, y, z) = 16+12*tanh((z+250)/10)+rand(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1190:1143,down,down,1143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190,1,['down'],['down']
Availability,"ckages/CUDA/35NC6/src/compiler/execution.jl:106 [inlined]; [20] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:271; [21] mapreducedim!(f::typeof(identity), op::typeof(max), R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:169; [22] mapreducedim!(f::Function, op::Function, R::SubArray{…}, A::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:10; [23] #maximum!#860; @ Base ./reducedim.jl:1034 [inlined]; [24] maximum!(f::Function, r::Field{…}, a::Oceananigans.AbstractOperations.ConditionalOperation{…}; condition::Nothing, mask::Float64, kwargs::@Kwargs{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2023-12-25 18:01 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × Intel(R) Xeon(R) Silver 4214 CPU @",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:3969,mask,mask,3969,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['mask'],['mask']
Availability,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:2687,ERROR,ERROR,2687,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"ckend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOptions); @ Base ./client.jl:322; [31] _start(); @ Base ./client.jl:522; LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); in expression starting at /rds/user/js2430/hpc-work/Eady/eady.jl:133; > (stacktrace); (user); CUDA; + throw_api_error ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; + [inlined]; CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; v CUDA; + cuOccupancyMaxPotentialBlockSize ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26; + #launch_configuration#875 ~/.julia/packages/CUDA/35NC6/lib/cudadrv/occupancy.jl:63; + [inlined]; CUDA; + #mapreducedim!#1119 ~/.julia/packages/CUDA/35NC6/src/mapreduce.jl:236; + [inlined]; GPUArrays; > + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; v + [inlined]; GPUArrays; + #_mapreduce#31 ~/.julia/packages/GPUArrays/5XhED/src/host/mapreduce.jl:69; + [inlined]; Oceananigans.Solvers; + solve! ~/.julia/packages/Oceananigans/mwXt0/src/Solvers/fourier_tridiagonal_poisson_s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:2086,error,error,2086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['error'],['error']
Availability,"ctor{Float64, Vector{Float64}}, arch::CPU, N::Int64; order::Int64); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:278; [33] #calc_reconstruction_coefficients#35; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:268 [inlined]; [34] top-level scope; @ none:1; [35] eval; @ ./boot.jl:360 [inlined]; [36] #compute_reconstruction_coefficients#26; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:227 [inlined]; [37] WENO(FT::DataType; order::Int64, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, zweno::Bool, vector_invariant::Nothing, bounds::Nothing); @ Oceananigans.Advection ~/.julia/packages/Oceananigans/W63bs/src/Advection/weno_reconstruction.jl:133; [38] top-level scope; @ ~/repos/convddvs/simulations/mwe.jl:12; [39] include(fname::String); @ Base.MainInclude ./client.jl:444; [40] top-level scope; @ REPL[2]:1; [41] top-level scope; @ ~/.julia/packages/CUDA/DfvRa/src/initialization.jl:52; ```. Some useful notes:. - When I increase the halo to 4 on the `z` direction the error disappears. Interestingly this code runs even with `halo=(1,1,4)`. (Is the WENO order decreasing as you approach the boundary? Should we throw a warning about this?); - This behavior is the same if decrease the WENO order and the halo size in the `z` direction, as expected.; - When I run the same code with the stretched grid (e.g. with `z=(0,1)`) the error disappears, which seems to point to a bug. If this isn't a bug and is instead expected behavior, maybe a more useful error would be helpful here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:6252,error,error,6252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,3,['error'],['error']
Availability,"d over dims = (1, 2) on RectilinearGrid on CPU; ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 4); ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── operand: mean! over dims (1, 2) of 4×4×4 Field{Face, Center, Center} on RectilinearGrid on CPU; └── status: time=0.0. julia> fcc_scratch = Field{Face, Center, Center}(model.grid); 4×4×4 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 10×10×10 OffsetArray(::Array{Float64, 3}, -2:7, -2:7, -2:7) with eltype Float64 with indices -2:7×-2:7×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> Field(Average(u, dims=(1,2)), data=fcc_scratch.data); ERROR: ArgumentError: Cannot construct field at (Nothing, Nothing, Center) with size(data)=(10, 10, 10). `data` must have size (1, 1, 10).; Stacktrace:; [1] validate_field_data(loc::Tuple{DataType, DataType, DataType}, data::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, grid::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, indices::Tuple{Colon, Colon, Colon}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/field.jl:43; [2] #apply_regionally!#27; @ ~/repos/Oceananigans.jl/src/Utils/multi_region_transformation.jl:96 [inlined]; [3] apply_regionally!; @ ~/repos/Oceananigans.jl/src/Utils/multi_region_transformation.jl:94 [inlined",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2659:2133,ERROR,ERROR,2133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2659,1,['ERROR'],['ERROR']
Availability,"d x ∈ [0.0, 1.0e6] regularly spaced with Δx=7812.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-400.0, 0.0] regularly spaced with Δz=80.0. julia> model_pcg = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> model_mat = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> typeof(model_pcg.free_surface.implicit_step_solver.right_hand_side); Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Bounded, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2184:1710,toler,tolerance,1710,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184,1,['toler'],['tolerance']
Availability,"dary doesn't throw the error.; ```; using CUDA; using Oceananigans. arch = has_cuda_gpu() ? GPU() : CPU(); topo = [Flat, Periodic, Bounded] ; underlying_grid = RectilinearGrid(arch, size = (1,1), ; extent = (1, 1),; topology = topo). @inline slope(x, y) = -2.0*y; immersed_grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(slope)). z₀ = 1e-2 # Charnock roughness; κ = 0.4 # Von Karman constant; @inline Cᴰ(Δz) = (κ / log(Δz / 2z₀))^2; const dz = 0.1. @inline bottom_drag_v(x, y, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); @inline bottom_drag_v(x, y, z, t, v, w, Cᴰ) = - Cᴰ * v * sqrt(v^2 + w^2); v_drag_bc = FluxBoundaryCondition(bottom_drag_v, field_dependencies=(:v, :w), parameters=Cᴰ(dz)); v_bcs = FieldBoundaryConditions(bottom=v_drag_bc, immersed=v_drag_bc). boundary_conditions = (; v = v_bcs,). model = NonhydrostaticModel(grid = immersed_grid, ; boundary_conditions = boundary_conditions). simulation = Simulation(model, Δt = 0.1, stop_time = 1.0); run!(simulation); ```; Error, truncated stack trace for length:. ```; GPU compilation of kernel gpu_calculate_Gv!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gv!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:1183,Error,Error,1183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,1,['Error'],['Error']
Availability,"daryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}; condition::Nothing, mask::Float64, kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:init,), Tuple{Bool}}}); @ Oceananigans.Fields /g/data/v45/nc3020/Oceananigans.jl/src/Fields/field.jl:581; [24] maximum(f::Function, c::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:17184,mask,mask,17184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['mask'],['mask']
Availability,"discussions with @glwagner that have over time convinced me that adding some native post-processing and data analysis capabilities to Oceananigans.jl by relying on `Oceananigans.AbstractOperations` under the hood would be a killer feature. This would eventually allow users to compute new/complex terms, close budgets, etc. on any grid without worrying about the staggered grid. So it might finally fulfill the dream of going from idea -> model/simulation -> analysis -> paper purely in Julia and (most importantly) without needing to know anything about the staggered grid. Since the interface remains very similar between the different models and grid, this could potentially allow future users to easily switch between different equation sets and grids while keeping the same analysis script. I thought we opened an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with Dimension",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493:1064,down,down,1064,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493,1,['down'],['down']
Availability,"discussions/3423#discussioncomment-8115603 and I dug into it a bit more since then but so far haven't been able to solve it. ```julia; using Oceananigans. grid_base = RectilinearGrid(CPU(), size = (4, 4, 4), extent = (1,1,1)). # The lines immediately below work; using Oceananigans.Grids: boundary_node; boundary_node_ccf = KernelFunctionOperation{Center, Center, Face}(boundary_node, grid_base, Center(), Center(), Face()); c = CenterField(grid_base); compute!(Field(Average(c, condition=(boundary_node_ccf .== true)))). # The last line here doesn't work; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1/2)); c_ib = CenterField(grid); compute!(Field(Average(c_ib, condition=(boundary_node_ccf .== true)))); ```. The first computation above (which doesn't use any immersed boundaries) works, although it's odd that I have to set `condition=(boundary_node_ccf .== true)`, since it fails if I simply set `condition=boundary_node_ccf`. However, the last line, which does use `ImmersedBoundaryGrid`s, fails with the following error:. ```; ERROR: LoadError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Functio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:1261,error,error,1261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['error'],['error']
Availability,"ditions.Flux, Nothing}}, Nothing}; indices=(Colon(), Colon(), 1)); Closest candidates are:; Field(::Field) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Fields/field.jl:160 got unsupported keyword argument ""indices""; Field(::Any, ::String, ::String, ::Any; grid, architecture, indices, boundary_conditions) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/OutputReaders/field_time_series.jl:150; Field(::Tuple, ::Oceananigans.Grids.AbstractGrid{FT, TX, TY, TZ, var""#s139""} where {FT, TX, TY, TZ, var""#s139""<:Oceananigans.Distributed.MultiArch}, ::Any, ::Any, ::Tuple, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Distributed/distributed_fields.jl:4 got unsupported keyword argument ""indices""; ...; Stacktrace:; [1] top-level scope; @ REPL[18]:1; ```. If I pass an abstract operation I get a different error:. ```julia; julia> Field(model.velocities.u^2; indices=(:,:,1)); ERROR: MethodError: no method matching offset_indices(::Type{Center}, ::Type{Bounded}, ::Int64, ::Int64, ::Int64); Closest candidates are:; offset_indices(::Any, ::Any, ::Any, ::Any, ::Colon) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:29; offset_indices(::Any, ::Any, ::Any, ::Any) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:16; offset_indices(::Any, ::Any, ::Any, ::Any, ::UnitRange) at /home/tomas/.julia/packages/Oceananigans/WaO9L/src/Grids/new_data.jl:30; ...; Stacktrace:; [1] _broadcast_getindex_evalf(::typeof(Oceananigans.Grids.offset_indices), ::Type, ::Type, ::Int64, ::Int64, ::Int64); @ Base.Broadcast ./broadcast.jl:648; [2] _broadcast_getindex; @ ./broadcast.jl:621 [inlined]; [3] (::Base.Broadcast.var""#19#20""{Base.Broadcast.Broadcasted{Base.Broadcast.Style{Tuple}, Nothing, typeof(Oceananigans.Grids.offset_indices), Tuple{Tuple{DataType, DataType, DataType}, Tuple{DataType, DataType, DataType}, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Tuple{Colon, Colon, Int64}}}})(k::Int64); @ Base.Broadcast ./broa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2391:2862,ERROR,ERROR,2862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2391,1,['ERROR'],['ERROR']
Availability,"dition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w),Tuple{typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3}}},Nothing},Nothing}:; ERROR: BoundsError: attempt to access (); at index [1]; Stacktrace:; [1] getindex(::Tuple, ::Int64) at ./tuple.jl:24; [2] has_velocities(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:101; [3] tracernames(::Tuple{}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:105; [4] tracernames(::NamedTuple{(),Tuple{}}) at /home/gong/.julia/packages/Oceananigans/XWBSD/src/Fields/field_tuples.jl:106; [5] show(::IOContext{REPL.Terminals.TTYTerminal}, ::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/707:9375,ERROR,ERROR,9375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/707,1,['ERROR'],['ERROR']
Availability,"down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:1189,Error,Error,1189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['Error'],['Error']
Availability,"drostaticModel(; ; grid = grid,; timestepper = :RungeKutta3,; advection = WENO(order=9),; particles = lagrangian_particles; ). u, v, w = model.velocities. simulation = Simulation(model, Δt=0.1, stop_iteration=2). wall_clock = [time_ns()]. function print_progress(sim); @printf(""i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, next Δt: %s\n"",; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; prettytime(sim.Δt)); @info ""x(particle): $(round.(lagrangian_particles.properties.x, digits=2)), y(particle): $(round.(lagrangian_particles.properties.y, digits=2)), z(particle): $(round.(lagrangian_particles.properties.z, digits=2))\n"". wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progress, IterationInterval(1)). run!(simulation); ```. which gives an error output of. ```julia; ERROR: BoundsError: attempt to access Tuple{Float64, Float64} at index [3]; Stacktrace:; [1] getindex(t::Tuple, i::Int64); @ Base .\tuple.jl:31; [2] fractional_z_index; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:110 [inlined]; [3] fractional_indices; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Fields\interpolate.jl:133 [inlined]; [4] advect_particle; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:75 [inlined]; [5] macro expansion; @ c:\Users\xinle\MIT\lagrangian_particles_rightmost_cell\Oceananigans.jl\src\Models\LagrangianParticleTracking\lagrangian_particle_advection.jl:145 [inlined]; [6] cpu__advect_particles!; @ C:\Users\xinle\.julia\packages\KernelAbstractions\WoCk1\src\macros.jl:276 [inlined]; [7] cpu__advect_particles!(__ctx__::KernelAbstractions.CompilerMetadata{…}, pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3632:1659,error,error,1659,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3632,1,['error'],['error']
Availability,"e tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:2279,checkpoint,checkpoint,2279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpoint']
Availability,"e value anyway). This appears to be occurring in the pressure correction step. For example:; ```julia; julia> using Oceananigans; julia> grid = RectilinearGrid(size = (128, 128, 128), extent = (1000, 1000, 1000));; julia> model = NonhydrostaticModel(; grid);; julia> uᵢ(x, y, z) = (1-tanh((x-500)/10));; julia> set!(model, u = uᵢ). julia> model.velocities.u; 128×128×128 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 134×134×134 OffsetArray(::Array{Float64, 3}, -2:131, -2:131, -2:131) with eltype Float64 with indices -2:131×-2:131×-2:131; └── max=1.00781, min=1.00781, mean=1.00781. julia> set!(model, u = uᵢ, enforce_incompressibility=false). julia> model.velocities.u; 128×128×128 Field{Face, Center, Center} on RectilinearGrid on CPU; ├── grid: 128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 134×134×134 OffsetArray(::Array{Float64, 3}, -2:131, -2:131, -2:131) with eltype Float64 with indices -2:131×-2:131×-2:131; └── max=2.0, min=0.0, mean=1.00781; ```. I initially spotted this issue after time-stepping a model and the same thing occurs, presumably after the pressure correction, so this isn't isolated to `set!`. This is occurring in all of my julia projects where Oceananigans is in various versions and I know Nonhydrostatic models have worked correctly in before, downgrading is also not working so perhaps this is similar to https://github.com/CliMA/Oceananigans.jl/issues/3381 with a broken dependency. I will try updating to 1.10 to see if that fixes the issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3397:1982,down,downgrading,1982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3397,1,['down'],['downgrading']
Availability,"e()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1349,Error,Error,1349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,2,['Error'],['Error']
Availability,"e:; ```julia; # this is a MWE for reproducing errors from using AveragedTimeInterval; using Oceananigans; using Printf; using Plots. """""" Set up a simple simulation to test picking up from a checkpoint. """""". function test_simulation(stop_time, Δt, δt, overwrite); grid = RectilinearGrid(size=(2), z = (-1,1), topology=(Oceananigans.Flat, Oceananigans.Flat, Oceananigans.Bounded)); uᵢ(z) = 0; T=2; u_forcing(z, t) = 10*sin(2*pi/T*t). model = NonhydrostaticModel(; grid, ; forcing = (u = u_forcing,),; timestepper = :RungeKutta3). ; set!(model, u=uᵢ). simulation = Simulation(model; Δt, stop_time); u = model.velocities.u. progress_message(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress_message, TimeInterval(δt)). simulation.output_writers[:timeavg] = NetCDFOutputWriter(model, (u=u,),; filename = ""timeavg.nc"",; schedule = AveragedTimeInterval(δt, window=δt),; # schedule = TimeInterval(δt),; overwrite_existing = overwrite); ; checkpointer = Checkpointer(model,; schedule = TimeInterval(stop_time),; prefix = ""test"",; cleanup = true). simulation.output_writers[:checkpointer] = checkpointer. return simulation; end. run(`sh -c ""rm test_iteration*.jld2""`). Δt = .01 # timestep (s); T1 = 5 # first simulation stop time (s); T2 = 2T1 # second simulation stop time (s); δt = .06 # progress message interval and output saving interval. # Run a simulation that saves data to a checkpoint; simulation = test_simulation(T1, Δt, δt, true); run!(simulation). # Now try again, but picking up from the previous checkpoint; N = iteration(simulation); checkpoint = ""test_iteration$N.jld2""; simulation = test_simulation(T2, Δt, δt, false); run!(simulation, pickup=checkpoint). using NCDatasets; file = ""timeavg.nc""; ds = Dataset(file); t = ds[""time""][:]; z = ds[""zC""][:]; u = dropdims(ds[""u""][:,:,:,:],dims = (1,2)); ln = Plots.plot(t[:],u[end,:],xlabel=""time"", ylabel=""u"",legend=nothing); Plots.savefig(""ln.png""); close(ds); ```; <img",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670:1706,checkpoint,checkpointer,1706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670,2,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpointer']"
Availability,"eSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation);",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:2236,error,error,2236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,1,['error'],['error']
Availability,"ectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 0.210526] variably spaced with min(Δz)=0.0526316, max(Δz)=0.0526316. julia> grid.zᵃᵃᶜ; 10-element OffsetArray(::Vector{Float64}, -2:7) with eltype Float64 with indices -2:7:; -0.13157894736842105; -0.07894736842105263; -0.02631578947368421; 0.02631578947368421; 0.07894736842105263; 0.13157894736842105; 0.18421052631578946; 0.23684210526315788; 0.2894736842105263; 0.3421052631578947. julia> collect(grid.xᶜᵃᵃ); 10-element Vector{Float64}:; -0.625; -0.375; -0.125; 0.125; 0.375; 0.625; 0.875; 1.125; 1.375; 1.625; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 6 threads. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); ERROR: ArgumentError: `length(z)` must be equal to size passed to `size` argument.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::LinRange{Float64}, dir::Symbol, size_dir::Int64, FT::Type); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:108; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}, FT::Type, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/rectilinear_grid.jl:284; [4] RectilinearGrid(architecture::CPU, FT::Type; size::Tuple{Int64, Int64, Int64}, x::Tuple{Int64,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550:1247,ERROR,ERROR,1247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550,1,['ERROR'],['ERROR']
Availability,"ectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 8×9×10 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, -2:7) with eltype Float64 with indices -2:5×-2:6×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> c2 = CenterField(grid); 2×3×4 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 2×3×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 8×9×10 OffsetArray(::Array{Float64, 3}, -2:5, -2:6, -2:7) with eltype Float64 with indices -2:5×-2:6×-2:7; └── max=0.0, min=0.0, mean=0.0. julia> c1[1, :, 1] .= c2[2, :, 3]; ERROR: DimensionMismatch: array could not be broadcast to match destination; Stacktrace:; [1] check_broadcast_shape; @ ./broadcast.jl:553 [inlined]; [2] check_broadcast_axes; @ ./broadcast.jl:556 [inlined]; [3] instantiate; @ ./broadcast.jl:297 [inlined]; [4] materialize!; @ ./broadcast.jl:884 [inlined]; [5] materialize!; @ ./broadcast.jl:881 [inlined]; [6] materialize!(dest::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{UnitRange{Int64}, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, Base.Slice{Base.One",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361:1583,ERROR,ERROR,1583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361,1,['ERROR'],['ERROR']
Availability,"ed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:1475,error,error,1475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,2,['error'],['error']
Availability,"ed) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1569,error,error,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"ee #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a day? Or manually if there's a PR that changes core functionality.; 2. Run the tests in parallel. I think the main Julia repo does this. We might have to roll our own parallel solution (see [this thread](https://discourse.julialang.org/t/run-pkg-test-with-several-processors/6917)). This would also require expensive paid CI plans (but very much worth it in my opinion).; 3. Thinking long-term, if we had a multi-CPU multi-GPU machine available we could probably roll our own CI solution for these distributed architectures. Ideally we'd want to see if we can get this through a service although it would probably cost $$$$$. cc @christophernhill @jm-c @glwagner: I know we all care about testing. cc @charleskawczynski @simonbyrne: Just wondering if this is a problem you guys are anticipating for CliMA.jl? We might be able to share some common solutions?. Resources:; * [Nvidia slides on building a GPU-focused CI solution](http://on-demand.gputechconf.com/gtc/2018/presentation/s8563-building-a-gpu-focused-ci-solution.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:2435,avail,available,2435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['avail'],['available']
Availability,"eld(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_IGwXuE.ptx, line 1951; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE14_gpu__compute_16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES5_I9_1__1__1_ES5_I9_1__1__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity5vv22RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEES9_E5Int6410_identity110_identity2vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:668,error,error,668,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['error'],['error']
Availability,"elds ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:618; [25] maximum(f::Function, c::Field{…}; condition::Nothing, mask::Float64, dims::Function); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:648; [26] maximum(f::Function, c::Field{…}); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/r28zw/src/Fields/field.jl:637; [27] top-level scope; @ ~/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; [28] include(fname::String); @ Base.MainInclude ./client.jl:489; [29] top-level scope; @ REPL[19]:1; [30] top-level scope; @ ~/.julia/packages/CUDA/35NC6/src/initialization.jl:190; in expression starting at /home/xinkai/SaltyOceanParameterizations.jl/CUDA_MWE.jl:20; Some type information was truncated. Use `show(err)` to see complete types.; ```; Note that line 20 is the last line of the code snippet above (`maximum(abs, v)`). Here's the Julia version info:; ```; Julia Version 1.10.0; Commit 3120989f39b (2023-12-25 18:01 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, cascadelake); Threads: 1 on 48 virtual cores; ```. Here's the CUDA runtime version:; ```; CUDA runtime 11.8, artifact installation; CUDA driver 11.8; NVIDIA driver 520.61.5. CUDA libraries:; - CUBLAS: 11.11.3; - CURAND: 10.3.0; - CUFFT: 10.9.0; - CUSOLVER: 11.4.1; - CUSPARSE: 11.7.5; - CUPTI: 18.0.0; - NVML: 11.0.0+520.61.5. Julia packages:; - CUDA: 4.4.1; - CUDA_Driver_jll: 0.5.0+1; - CUDA_Runtime_jll: 0.6.0+0. Toolchain:; - Julia: 1.10.0; - LLVM: 15.0.7; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0, 7.1, 7.2, 7.3, 7.4, 7.5; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80, sm_86. 1 device:; 0: NVIDIA TITAN V (sm_70, 9.027 GiB / 12.000 GiB available); ```. In Julia 1.9 this does not seem to be a problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:5778,avail,available,5778,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['avail'],['available']
Availability,"entials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA er",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:9408,error,error,9408,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['error'],['error']
Availability,"ently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(args), inds...)...); @inline column_args(args::Tuple{Any}, inds...) = (column(args[1], inds...),); @inline column_args(args::Tuple{}, inds...) = (); ```. cc @jakebolewski",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2101:1477,error,error,1477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101,1,['error'],['error']
Availability,"er without piracy. ---. MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(12, 12, 12), x=(0, 1), y=(0, 1), z=k->√k). znodes(grid, Center(), Center(), Center()); ```. produces this error when trying to show the result. ```; 12-element view(OffsetArray(::CuArray{Float64, 1, CUDA.DeviceMemory}, -2:15), 1:12) with eltype Float64:; Error showing value of type SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] errorscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:155; [3] _assertscalar(op::String, behavior::GPUArraysCore.ScalarIndexing); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:128; [4] assertscalar(op::String); @ GPUArraysCore ~/.julia/packages/GPUArraysCore/GMsgk/src/GPUArraysCore.jl:116; [5] getindex; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/indexing.jl:50 [inlined]; [6] getindex; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:438 [inlined]; [7] isassigned(A::OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, i::Int64); @ Base ./multidimensional.jl:1587; [8] isassigned; @ ./subarray.jl:386 [inlined]; [9] isassigned(::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.DeviceMemory}}, Tuple{UnitRange{Int64}}, true}, ::Int64, ::Int64); @ Base ./multidimensional.jl:1582; [10] alignment(io::IOContext{Base.TTY}, X::AbstractVecOrMat,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3770:1472,error,error,1472,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3770,1,['error'],['error']
Availability,"erImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:1929,error,error,1929,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['error'],['error']
Availability,"er` on an immersed boundary grid with a vertically stretched underlying grid on the GPU. For example:. ```Julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lx, Ly, Lz = 500, 600, 3. Nx, Ny, Nz = 128, 128, 64. σ = 1.04 # linear stretching factor; linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz). underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)). const H_deep = H = underlying_grid.Lz; const H_shelf = h = 0.5; const width_shelf = 100. shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); bathymetry(x, y) = shelf(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```. then just creating a `u` field gives:. ```julia; julia> u = Field((Face, Center, Center), grid); Error showing value of type Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCond",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:1018,Error,Error,1018,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,1,['Error'],['Error']
Availability,error in `baroclinic_adjustment.jl`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543:0,error,error,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543,1,['error'],['error']
Availability,"es); # the initialization shouldn't matter?. struct CustomParticle; x::Float64 # x-coordinate; y::Float64 # y-coordinate; z::Float64 # z-coordinate; T::Float64 # Temperature; end. particles = StructArray{CustomParticle}((x₀, y₀, z₀, T));. # Define tracked fields as a NamedTuple; tracked_fields = (T=particles.T,). # Initialize LagrangianParticles with the StructArray and tracked fields; lagrangian_particles = LagrangianParticles(particles; tracked_fields=tracked_fields). #include in the model setup; model = NonhydrostaticModel(grid = grid, ; particles=lagrangian_particles,; advection = WENO(grid=grid, order=5),; timestepper = :QuasiAdamsBashforth2, ; tracers = (:T, :S),; buoyancy = Buoyancy(model=SeawaterBuoyancy(equation_of_state=LinearEquationOfState(thermal_expansion = 3.87e-5,; haline_contraction = 7.86e-4)), gravity_unit_vector=(-sind(θ),0,-cosd(θ))),; coriolis = FPlane(0e-4),; closure = closure,; forcing = forcing,; boundary_conditions = boundary_conditions,; ). ```. I get the following error:. ```Julia. LoadError: MethodError: _fractional_indices(::Tuple{Float64, Float64, Float64}, ::RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, ::Nothing, ::Nothing, ::Nothing) is ambiguous. Candidates:; _fractional_indices(::Any, grid, ℓx, ::Nothing, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:187; _fractional_indices(::Any, grid, ::Nothing, ℓy, ::Nothing); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/17XSY/src/Fields/interpolate.jl:195; _fractional_indices(::Any, grid, ℓx, ℓy, ::Nothing); @ Oceananigans.Fi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:1899,error,error,1899,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['error'],['error']
Availability,"es. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thing for my research, and I know @whitleyv does this too, but maybe we're the exception?. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:2048,down,downsides,2048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,1,['down'],['downsides']
Availability,"ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:2026,ERROR,ERROR,2026,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"f experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); 22. Physics and numerical implementation; 23. References; 24. Appendix. It will take a few PRs to resolve this issue. It'd be great to incorporate feedback on the plan too before making any moves.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852:1290,down,down,1290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852,1,['down'],['down']
Availability,"faceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 3×3×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×1 halo; ├── timestepper: QuasiAdamsBashforth2TimeStepper; ├── tracers: (); ├── closure: Nothing; ├── buoyancy: Nothing; ├── free surface: ExplicitFreeSurface with gravitational acceleration 10.0 m s⁻²; ├── advection scheme:; │ └── momentum: Nothing; └── coriolis: Nothing. julia> Hc, Nc, Nz = grid.Hx, grid.Nx, grid.Nz; (2, 4, 1). julia> model.free_surface.η[1:Hc, 1:Nc, Nz+1:Nz+1] .= 1; ERROR: BoundsError: attempt to access 9×9×1 Array{Float64, 3} at index [4:6, 4:6, 3:3]; Stacktrace:; [1] throw_boundserror(A::Array{Float64, 3}, I::Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}); @ Base ./abstractarray.jl:737; [2] checkbounds; @ ./abstractarray.jl:702 [inlined]; [3] view; @ ./subarray.jl:184 [inlined]; [4] offset_windowed_data(data::OffsetArrays.OffsetArray{…}, Loc::Tuple{…}, grid::RectilinearGrid{…}, indices::Tuple{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:248; [5] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/main/src/Fields/field.jl:316; [6] maybeview; @ ./views.jl:148 [inlined]; [7] dotview(::Field{…}, ::UnitRange{…}, ::UnitRange{…}, ::UnitRange{…}); @ Base.Broadcast ./broadcast.jl:1244; [8] top-level scope; @ REPL[40]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. The error occurs because the parent array of `model.free_surface.η` takes the z-halo into consideration, which does not exist for the ssh field. Generally, when dealing with 1D or 2D fields, the parent array should consider halos only in the dimensions along which the field is defined, rather than in all dimensions as currently implemented. PR #3573 aims to close this issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3572:2005,error,error,2005,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3572,1,['error'],['error']
Availability,"fined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:1054,error,error,1054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,2,['error'],['error']
Availability,"first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then out",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:1424,error,error,1424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,2,['error'],['error']
Availability,"following MWE:. ```julia; using Oceananigans; using Oceananigans.Units; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Lz = 50; grid_base = RectilinearGrid(size=(50, 50, 6), x=(-2000, 2000), y=(-1500, 2500), z=(0, Lz)). bathymetry(x, y) = Lz/2 * exp(-(x/500)^2 - (y/500)^2); grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). const cᴰᶻ = 3e-3; @inline τˣᶻ_drag(x, y, z, t, u, v, w) = -cᴰᶻ * u * √(u^2 + v^2); τˣᶻ_BC = FluxBoundaryCondition(τˣᶻ_drag, field_dependencies = (:u, :v, :w)). u_bcs = FieldBoundaryConditions(immersed=ImmersedBoundaryCondition(bottom = τˣᶻ_BC)). model = HydrostaticFreeSurfaceModel(; grid, boundary_conditions = (; u=u_bcs)). simulation = Simulation(model, Δt=1, stop_iteration=10); run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: TaskFailedException. nested task error: TaskFailedException; ; nested task error: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ::NamedTuple{(:u, :v, :w, :T, :S, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711:882,error,error,882,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711,2,['error'],['error']
Availability,"forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing); @ Oceananigans.Models.IncompressibleModels ~/.julia/packages/Oceananigans/IxOwr/src/Models/IncompressibleModels/incompressible_model.jl:142; [28] top-level scope; @ REPL[4]:1; [29] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```julia; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); ```. ```julia; julia> CUDA.versioninfo(); CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; ┌ Warning: Could not find or load CUDNN; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:354; - CUDNN: missing; ┌ Warning: Could not find or load CUTENSOR; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:409; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 29.284 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 24.457 GiB / 31.749 GiB available); ```. ```julia; (@v1.6) pkg> st; Status `~/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.2.1; [13f3f980] CairoMakie v0.5.2; [9e8cae18] Oceananigans v0.58.1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:7680,avail,available,7680,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,2,['avail'],['available']
Availability,"forth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.cloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:1990,checkpoint,checkpoint-pickup,1990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['checkpoint'],['checkpoint-pickup']
Availability,"g at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:2321,error,error,2321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"g to set boundary conditions in a `ShallowWaterModel` example using `ImmersedBoundary`. The actual problem I want is more complicated then this but as a first step I thought I would just set the height to be a fixed value at the north and south boundaries. The immersed boundary creates a cap on the west. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow, Value. grid = RegularRectilinearGrid(size=(16, 16), x=(-10, 10), y=(0, 5), topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). @inline inflow(i, k, grid, clock, model_fields) = @inbounds model_fields.h[i, 1, 1]. @inline outflow(i, k, grid, clock, model_fields) = @inbounds model_fields.h[i, grid.Ny, 1]. h_bcs = TracerBoundaryConditions(grid;; north = BoundaryCondition(Value, 2.0),; south = BoundaryCondition(Value, 2.0),; ). model = ShallowWaterModel(grid=grid_with_bump, gravitational_acceleration=1, boundary_conditions=(h=h_bcs,)). set!(model, h=1); ```. The error that I get is copied below. Any one know why `set!` is trying to use `Δy`?. ```; ERROR: TaskFailedException. nested task error: MethodError: no method matching Δy(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}); Closest candidates are:; Δy(::Any, ::Any, ::Any, ::RegularRectilinearGrid{FT, TX, Flat, TZ, R} where {TZ, R}) where {FT, TX} at /home/fpoulin/software/Oceananigans.jl/src/Operators/spacings_and_areas_and_volumes.jl:58; Δy(::Any, ::Any, ::Any, ::AbstractRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Operators/spacings_and_areas_and_volumes.jl:35; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730:1196,error,error,1196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730,3,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"gging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500] OpenLibm_jll v0.8.1+2; [efcefdf7] PCRE2_jll v10.42.0+1; [bea87d4a] SuiteSparse_jll v7.2.1+1; [83775a58] Zlib_jll v1.2.13+1; [8e850b90] libblastrampoline_jll v5.8.0+1; [8e850ede] nghttp2_jll v1.52.0+1; [3f19e933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:11648,avail,available,11648,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['avail'],['available']
Availability,"ght?. I am trying to create an Oceananigans version for [iuryt/ocean_gyre_tank](https://github.com/iuryt/ocean_gyre_tank).; For the surface momentum flux I am using. ```; p = (; cᴰ = 2.5e-3, # dimensionless drag coefficient; ρₐ = 1.225, # kg m⁻³, average density of air at sea-level; ρₒ = 1026, # kg m⁻³, average density at the surface of the world ocean; L = 0.23meters,; H = 0.15meters,; Ny = 100,; Nx = 100,; Nz = 20,; ). radius(x,y) = sqrt(x^2 + y^2); U(x,y,L) = sin(π * radius(x,y) / L)*exp(1im*angle(x+y*1im)); Qᵘ(x,y,z,t,p) = radius(x,y)<p.L ? imag(p.ρₐ / p.ρₒ * p.cᴰ * U(x,y,p.L) * abs(U(x,y,p.L))) : 0 # m² s⁻²; Qᵛ(x,y,z,t,p) = radius(x,y)<p.L ? - real(p.ρₐ / p.ρₒ * p.cᴰ * U(x,y,p.L) * abs(U(x,y,p.L))) : 0 # m² s⁻². u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ, parameters=p)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵛ, parameters=p)); ```. Which returns the error below when I try to run the simulation: ; <details>; <summary>Click to expand!</summary>; ; ```; ┌ Warning: Cannot serialize timeseries/u/serialized/boundary_conditions as it contains functions. Will replace with missing. Function boundary conditions must be restored manually.; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:65; ┌ Warning: Cannot serialize timeseries/v/serialized/boundary_conditions as it contains functions. Will replace with missing. Function boundary conditions must be restored manually.; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:65; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (36.847 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336:1065,error,error,1065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336,1,['error'],['error']
Availability,"haven't been able to solve it. ```julia; using Oceananigans. grid_base = RectilinearGrid(CPU(), size = (4, 4, 4), extent = (1,1,1)). # The lines immediately below work; using Oceananigans.Grids: boundary_node; boundary_node_ccf = KernelFunctionOperation{Center, Center, Face}(boundary_node, grid_base, Center(), Center(), Face()); c = CenterField(grid_base); compute!(Field(Average(c, condition=(boundary_node_ccf .== true)))). # The last line here doesn't work; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom((x, y) -> 1/2)); c_ib = CenterField(grid); compute!(Field(Average(c_ib, condition=(boundary_node_ccf .== true)))); ```. The first computation above (which doesn't use any immersed boundaries) works, although it's odd that I have to set `condition=(boundary_node_ccf .== true)`, since it fails if I simply set `condition=boundary_node_ccf`. However, the last line, which does use `ImmersedBoundaryGrid`s, fails with the following error:. ```; ERROR: LoadError: MethodError: condition_operand(::typeof(identity), ::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}, ::Array{Bool, 3}, ::Int64) is ambiguous. Candidates:; condition_operand(func::Function, operand::Oceananigans.Fields.AbstractField, condition::AbstractArray, mask); @ Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:1274,ERROR,ERROR,1274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['ERROR'],['ERROR']
Availability,"heckpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:2120,checkpoint,checkpoint,2120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpoint']
Availability,"hello - I'm able to run the basic example in the docs under Quick start, but when I try to run the same code in VSCode by setting breakpoints in debug mode, I get the following error:. the line: `model = NonhydrostaticModel(; grid, advection=WENO())`. leads to the function `update_state!()` in the script `update_nonhydrostatic_model_state.jl`. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl. where it gets to Line 21 - `foreach(mask_immersed_field!, model.tracers)` after which I get the following error:. the debugger opens up this file:. ![jl_err_1](https://github.com/CliMA/Oceananigans.jl/assets/16384103/b957fdae-ab7f-490f-9179-ece64d7293e2). which then throws this error:. ```; @ Oceananigans.Models.NonhydrostaticModels . ~/Oceananigans.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:21; [20] NonhydrostaticModel(; grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, clock::Clock{Float64}, advection::WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{}, timestepper::Symbol, background",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3171:177,error,error,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3171,3,['error'],['error']
Availability,"hink about that anymore, we just click as fast as we can so we can move on with out lives... I think @Sbozzolo might have some idea for how to do this better. More or less I think the gist is that, rather than having a system where an output writer might have to delete a file, we instead create a directory system where new output is always saved in a unique directory. In other words, rather than saving user output at. ```julia; filepath = joinpath(dir, filename); ```. we would save output at the path. ```julia; filepath = joinpath(dir, unique_simulation_id, filename); ```. The upside of this system is that the output writers are relieved of any potential need to delete data. That onus is passed to the user instead, where the responsibility belongs. The downside is that we have to generate the directory name `unique_simulation_id`. No matter what we choose, its going to require effort from users to interpret and learn. It also has the major downside of ""hiding"" information from users: they'll run a script, and then hunt around for the data that was saved. No matter what naming system we choose for `unique_simulation_id`, I think it makes it harder for users to find their data. Finally, we should note of course that there's no reason why users can't do this themselves in their own scripts. We don't have to make directories for them, they can simply generate ID's themselves and `mkdir`. If the user is sophisticated enough to be running lots of experiments with highly valuable data, they can probably figure out how to create directories... We're also entering into dangerous territory I think --- trying to manage user's workflows. Workflow management tools are good in general, of course, but I just think its sort of hard to do well and in a general enough way that is uniformly useful to everyone. So by wading into this area, we risk doing a crap job and interfering / hindering at least some people, rather than helping. Anyways, after writing this out I'm a little wary of ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543:1905,down,downside,1905,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543,1,['down'],['downside']
Availability,"https://github.com/CliMA/Oceananigans.jl/blob/28dadbcc52a2badd242e89ba30c8cc34f9117327/src/Operators/vorticity_operators.jl#L1-L2. At the cubed sphere corners the grid is not actually orthogonal and so the vector-invariant formulation breaks down unless we compute the circulation carefully for each corner. ![image](https://user-images.githubusercontent.com/20099589/114737069-a8183e80-9d14-11eb-9a9c-07b5243af3c2.png). I've attached the appropriate reference (Adcroft et al., 2004):. [Adcroft et al, 2004, Monthly Weather Review, Implementation of an Atmosphere–Ocean General Circulation Model on the Expanded Spherical Cube.pdf](https://github.com/CliMA/Oceananigans.jl/files/6311899/Adcroft.et.al.2004.Monthly.Weather.Review.Implementation.of.an.Atmosphere.Ocean.General.Circulation.Model.on.the.Expanded.Spherical.Cube.pdf). Here is the MITgcm implementation: https://github.com/MITgcm/MITgcm/blob/master/pkg/mom_common/mom_calc_relvort3.F. Once this is fixed, the Rossby-Haurwitz test case in PR #1570 with momentum advection should stop blowing up at the corners.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1584:242,down,down,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1584,1,['down'],['down']
Availability,"i_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:1569,error,error,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['error'],['error']
Availability,"id`, `Oceananigans.jl` uses a convention in which indexing for the `z` coordinate in arrays is treated differently from `x` and `y`: the third index (call it `k`) *decreases* with increasing `z`, unlike the first and second indices which increase with increasing `x` and `y`. This means `z` derivative operators look different from `x` and `y` derivative operators. For example, a `z` differential is defined as positive for the difference between `k` and `k+1`. ```Julia; @inline function δz_e2f(f, Nz, i, j, k); if k == Nz; @inbounds return f[i, j, k]; else; @inbounds return f[i, j, k] - f[i, j, k+1]; end; end; ```. from [here](https://github.com/ali-ramadhan/Oceananigans.jl/blob/30150f965a1e0db95f239fa092ce33fe4ceedd29/src/operators/ops_regular_cartesian_grid_elementwise.jl#L38). I recognize that some users, especially oceanographers, appreciate this feature in their output --- in particular because `k=1` corresponds to the 'surface', which has a special status in (some) oceanographic applications. . However, I believe this 'reverse indexing' convention for the third direction is potentially confusing to developers and users with backgrounds in physics or engineering and may lead to bugs, slow down development, and stymie super-users who need to write code that indexes into arrays. I propose that we consider using the convention where indices increase with increasing coordinates in all directions (for all coordinate systems), so that for a Cartesian coordinate system `z` and `k` increase upwards, like 'x', 'y', 'i' and 'j'. I believe this behavior is probably expected for the majority of developers of fluid codes in general, and also for a large fraction of users. To satisfy users who prefer the oceanographic indexing convention in their output, we can provide users with the option (and make it default if we wish) to flip output and grids on their head before saving, so that `k=1` corresponds to the surface *in output*. @ali-ramadhan @christophernhill @jm-c @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/90:1233,down,down,1233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/90,1,['down'],['down']
Availability,"igans.Cell,A,G} where G where A(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/fields.jl:109; [3] VelocityFields(::Type, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}) at /home/alir/Oceananigans.jl/src/models.jl:177; [4] (::getfield(Core, Symbol(""#kw#Type"")))(::NamedTuple{(:architecture, :grid, :buoyancy, :tracers),Tuple{DataType,RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},DataType,Symbol}}, ::Type{Model}) at ./none:0; [5] top-level scope at REPL[7]:1; ```. Should be `BuoyancyTracer()` instead of `BuoyancyTracer` here:; ```julia; julia> model = Model(architecture=CPU(), grid=RegularCartesianGrid(N=(64, 64, 64), L=(1, 1, 1)), buoyancy=BuoyancyTracer, tracers=:b);. julia> time_step!(model, 1, 1); ERROR: MethodError: no method matching buoyancy_perturbation(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}, ::Type{BuoyancyTracer}, ::NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}) ; Closest candidates are:; buoyancy_perturbation(::Any, ::Any, ::Any, ::Oceananigans.AbstractGrid{FT}, ::Nothing, ::Any) where FT at /home/alir/Oceananigans.jl/src/buoyancy.jl:30; buoyancy_perturbation(::Any, ::Any, ::Any, ::Any, ::BuoyancyTracer, ::Any) at /home/alir/Oceananigans.jl/src/buoyancy.jl:46; buoyancy_perturbation(::Any, ::Any, ::Any, ::Any, ::SeawaterBuoyancy{FT,#s70} where #s70<:LinearEquationOfState where FT, ::Any) at /home/alir/Oceananigans.jl/src/buoyancy.jl:127; ...; Stacktrace:; [1] ▶z_aaf at /home/alir/Oceananigans.jl/src/TurbulenceClosures/closure_operators.jl:199 [inlined]; [2] update_hydrostatic_pressure!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::RegularCartesianGrid{Float64,StepRangeLen{Float64,Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/465:2040,ERROR,ERROR,2040,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/465,1,['ERROR'],['ERROR']
Availability,"ing ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1945,error,error,1945,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"ing `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS er",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1981,Error,Error,1981,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,2,['Error'],['Error']
Availability,"ing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 22.507 ms (7066 allocations: 1.09 MiB). julia> @btime cfl(model); 128.361 ms (257 allocations: 41.53 KiB); ```. Resol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:1591,avail,available,1591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['avail'],['available']
Availability,"ing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:1956,error,error,1956,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['error'],['error']
Availability,"ion(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NoFlux, top=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no ne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:2219,checkpoint,checkpoint,2219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['checkpoint'],['checkpoint']
Availability,"ion{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String})(file::JLD2.JLDFile{JLD2.MmapIO}); @ Oceananigans.OutputWriters /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:227; [7] jldopen(::Oceananigans.OutputWriters.var""#52#53""{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Fl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:54494,checkpoint,checkpointer,54494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['checkpoint'],['checkpointer']
Availability,"irst* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_energy); (Cell, Cell, Cell); ```. `kinetic_enegy` has a deep nested structure that is difficult to interrogate. Therefore one speculative possible item to add to this PR is to write a. - [x] better `show` method for `Operations`, using some kind of tree visualization?; ; For the purposes of this PR description, we hack together a visualization of the structure of `kinetic_energy`:. ```julia; julia> (kinetic_energy.op, typeof(kinetic_energy.a).name.wrapper, kinetic_energy.b); (/, Oceananigans.AbstractOperations.PolynaryOperation, 2); ```. We see that `kinetic_energy`, at the top level, is ` BinaryOperation` between a `PolynaryOperation` and an integer (2), involving division `/` (which is indeed, what we wrote). Delving into the `PolynaryOperation` one level down, . ```julia; julia> kinetic_energy.a.op; + (generic function with 185 methods). julia> names = [typeof(a).name.wrapper for a in kinetic_energy.a.args]; 3-element Array{UnionAll,1}:; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; Oceananigans.AbstractOperations.BinaryOperation; ```. we find that it consists of a sum of three `BinaryOperations`. Finally, we see that each `BinaryOperation`,. ```; julia> names = [(a.op, typeof(a.a).name.wrapper, a.b) for a in kinetic_energy.a.args]; 3-element Array{Tuple{typeof(^),UnionAll,Int64},1}:; (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); (^, OffsetArrays.OffsetArray, 2); ```. involves taking an `OffsetArray` (each of which holds the underlying data in `u, v, w`) to the power 2. Still, we index into it in the same way we index into other fields to obtain its data:. ```julia; julia> noise(x, y, z) = rand(). julia> [set!(ϕ, noise) for ϕ in (u, v, w)];. j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:2767,down,down,2767,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['down'],['down']
Availability,"is would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:976,Error,Error,976,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,2,['Error'],['Error']
Availability,"iters[:checkpointer] = Checkpointer(model, schedule=TimeInterval(100), prefix=""$(FILE_DIR)/model_checkpoint""). run!(simulation). # up until here most recent output file is instantaneous_fields_part4.jld2, but I want to continue running the simulation. simulation.stop_iteration = 400. simulation.output_writers[:jld2] = JLD2OutputWriter(model, outputs,; filename = ""instantaneous_fields.jld2"",; schedule = IterationInterval(1),; max_filesize=200e3,; part=4). run!(simulation, pickup=""model_checkpoint_iteration0.jld2""); ```. What I'm doing is creating a directory `test_outputwriter`, and then writing fields into it with a specified file size and starting part number.; After the first `run!(simulation)`, 4 output files were written, most recent being `instantaneous_fields_part4.jld2`, and a checkpoint file `model_checkpoint_iteration0.jld2` is written. . Let's say I want to keep running this model, so I increase `simulation.stop_iteration`. I pick up the model from the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:1687,checkpoint,checkpoint,1687,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,1,['checkpoint'],['checkpoint']
Availability,"ity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOpera",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1886:2417,error,errors,2417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886,1,['error'],['errors']
Availability,"l(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers)). outputs_full = (; wτ...). outputs_yavg = NamedTuple( Symbol(key, :_yavg)=>Average(val, dims=(2,)) for (key, val) in zip(keys(outputs_full), outputs_full) ). outputs_xz1 = merge(outputs_full, outputs_yavg); simulation.output_writers[:xz1_writer] = NetCDFOutputWriter(model, outputs_xz1;; filename = ""data/TEST.nc"",; schedule = TimeInterval(simulation.stop_time),; verbose=true,; indices = (:, 1, :),; overwrite_existing = true,; ); run!(simulation); ```. While the outputs should be the same (since the tracers and their advection are identical), I get different results for the y-averaged fluxes for different tracers:. ![image](https://user-images.githubusercontent.com/13205162/219516253-394a7e77-8c7e-4be1-be29-d2bdfadacdb3.png). Note that, while similar, tracers α=1,3,4 are different from α=2,5,6. The difference isn't large in this example, but can be made larger with more complexity in the calculations. A couple of notes:. - Changing the line `wτ = NamedTuple(Symbol(:w, key) => Field(w*τ) for (key,τ) in pairs(model.tracers))` to ; ```julia; wτ = NamedTuple(Symbol(:w, key) => w*τ for (key,τ) in pairs(model.tracers)); ```; gets rid of the issue. Although doing the above prevents a user from using `Field(op, data=scratch_data.data)` to save memory, which in some cases (my case for example) is very important. - Not passing the `indices` flag (i.e. writing 3D fields instead slices) apparently gets rid of this issue. Here, even though the obvious easy solution is to separate averages from slices when writing, a user wouldn't know that since this fails silently and the wrong results can be pretty subtle (as the example above hopefully illustrates). For example, it popped up in one of my simulations and it took me a while to even realize what was happening, let alone figure out the solution. My main question is: is this expected behavior? If so, should we somehow warn users (or even throw an error) do avoid mistakes?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931:2890,error,error,2890,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931,1,['error'],['error']
Availability,lid_driven_cavity & thermal_bubble: ERROR: LoadError: ArgumentError: length(size) must be 2.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507:36,ERROR,ERROR,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507,1,['ERROR'],['ERROR']
Availability,"ling process 104758, command: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36us 5 100.47us 94.015us 103.42us _Z25julia_gpu_ab2_step_field_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE20_gpu_ab2_step_field_16CompilerMe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912:1134,avail,available,1134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912,1,['avail'],['available']
Availability,"loat64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations /glade/work/tomasc/.julia/packages/Oceananigans/rtj1r/src/Simulations/run.jl:88; [24] top-level scope; @ /glade/scratch/tomasc/twake2/simulations/mwe_ibm.jl:28; [25] include(fname::String); @ Base.MainInclude ./client.jl:444; [26] top-level scope; @ REPL[1]:1; in expression starting at /glade/scratch/tomasc/twake2/simulations/mwe_ibm.jl:28; ```. (I deleted part of the error because it was too long...). This seems to be different from the other errors I've seen posted on issues here recently. Any ideas? It seems to be coming from the BC on `b`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558:31367,error,error,31367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558,2,['error'],"['error', 'errors']"
Availability,"locities`:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: KernelFunctionOperation; using Oceananigans.Fields: @compute. grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));. model = NonhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Also if I bypass tuples altogether the result seems to be correct:. ```julia; julia> @inline ufunc2(i, j, k, grid, u) = u[i, j, k];. julia> u′ = model.velocities.u - Field(Average(model.velocities.u));. julia> @compute f3 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc2, model.grid, u′));. julia> interior(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455:1318,error,error,1318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455,1,['error'],['error']
Availability,"m getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = 12 # domain extent; Lz = 1 # vertical domain extent; #y₀ = 2 # Initial source position; #δᴸ = 0.1 # thickness of lock transition. Re = 2000; Pe = Re; iRe = 1/Re; iPe = 1/Pe; nothing # hide. # ## Build the grid; #; # We use a domain that is bounded in y (north and south) and z (top and bottom),; # and periodic in x.; #; topology = (Bounded, Bounded, Bounded). grid = RegularCartesianGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz), topology=topology). # No-slip bottom, free-slip top and side walls through default boundary conditions; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789:1646,error,error,1646,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789,1,['error'],['error']
Availability,"m the most recent checkpoint, and specify `part=4` (the most recent file written). This creates a `instantaneous_fields.jld2` and keeps writing into it, while throwing a warning. ```; Warning: Failed to save and serialize [:grid, :coriolis, :buoyancy, :closure] in ./test_outputwriter/instantaneous_fields.jld2 because ArgumentError: ArgumentError: a group or dataset named Nx is already present within this group; ```. It never actually writes into `instantaneous_fields_part4.jld2`, and it keeps writing and rewriting into `instantaneous_fields.jld2` . If instead I specify `part=10` or any number larger than 4, the same problem occurs. If I use `part=1` in my 2nd spin up of the simulation, it throws. ```; ERROR: ArgumentError: '.\./test_outputwriter/instantaneous_fields_part1.jld2' exists. `force=true` is required to remove '.\./test_outputwriter/instantaneous_fields_part1.jld2' before moving.; ```. Not sure what the intended user experience but I was imagining that if for some reason the simulation stops and I want to rerun the simulation from a checkpoint, 2 potential options would be available:. 1. The model runs from the latest checkpoint, and continues writing into the most recent output file once it catches up to the latest unsaved iteration. Note that since the model is running from the checkpoint the saved iterations which the model is running at could be in earlier parts than the most recent output. But the simulation should know that and only starts writing into the latest part once it catches up to the latest saved iteration.; 2. I specify a part number that is larger than all the previous output files, and the simulation picks up from the checkpoint and writes into the new part number. This could mean that there are repetitive iterations saved when examining all output files (new and old). 1) is potentially the most important and common use case, but 2) might not be an unreasonable usage as well. However in the current implementation neither can be achieved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3399:2728,checkpoint,checkpoint,2728,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3399,5,"['avail', 'checkpoint']","['available', 'checkpoint']"
Availability,"mpt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:798; [22] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [23] invokelatest; @ ./essentials.jl:706 [inlined]; [24] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [25] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [26] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:406; ```. Digging a bit deeper, it seems that even showing the closure itself throws this error, but only if it's attached to a model:. ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model.closure; Error showing value of type SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] show; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:195 [inlined]; [8] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, x::SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretiz",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398:47007,Error,Error,47007,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398,1,['Error'],['Error']
Availability,"mulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:1461,error,error,1461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['error'],['error']
Availability,"my/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1329,error,error,1329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['error'],['error']
Availability,"n_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 6day,; iteration_interval = 1,; progress = progress_message; ); #Output; fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""DevangSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```. And the error message is following (I am pasting partially) -; ```; MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Dates\src\periods.jl:53; zero(::Colorant) at C:\Users\My Account\.julia\packages\ColorTypes\6m8P7\src\traits.jl:477; zero(::TaylorSeries.Taylor1) at C:\Users\My Account\.julia\packages\TaylorSeries\tveWm\src\arithmetic.jl:37; ... Stacktrace:; [1] iszero(x::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Base .\number.jl:40; [2] prettytime(t::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Oceananigans.Utils C:\Users\My Account\.julia\packages\Oceananigans\To7WB\src\Utils\pretty_time.jl:18; ```; I am attaching the file of Initial data whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1946:5468,error,error,5468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946,1,['error'],['error']
Availability,"nanigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/rigid_lid.jl) so I was curious whether `HydrostaticFreeSurfaceModel` can run with a free surface, presumably by passing `free_surface = nothing`. It does error (see MWE below) but with a couple of extra function definitions (see far below) it seems to time step. Are these fixes enough for a working rigid lid? If not, does it make sense to remove the `rigid_lid.jl` file?. Note: The documentation also mentions a rigid lid here: https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/elliptic_solvers/#Rigid-lid-pressure-operator. ---. Minimal working example to reproduce the error:. ```julia; using Oceananigans. grid = LatitudeLongitudeGrid(size=(10, 10, 10), longitude=(0, 1), latitude=(0, 1), z=(-1, 0)); model = HydrostaticFreeSurfaceModel(; grid, free_surface=nothing); time_step!(model, 1); ```. Error:. ```; ERROR: MethodError: no method matching materialize_free_surface(::Nothing, ::@NamedTuple{…}, ::LatitudeLongitudeGrid{…}). Closest candidates are:; materialize_free_surface(::ExplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/explicit_free_surface.jl:32; materialize_free_surface(::SplitExplicitFreeSurface, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:114; materialize_free_surface(::ImplicitFreeSurface{Nothing}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:93; ... Stacktrace:; [1] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::Nothing, tracers::Nothing, forcing::@NamedTuple{}, closure::Nothing, boundary_conditions::@NamedTuple{}, particle",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3735:1019,ERROR,ERROR,1019,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3735,1,['ERROR'],['ERROR']
Availability,"ndaries` is not yet there, but I am trying to use it to define the walls of a numerical rotating tank experiment. I am using `Oceananigans v0.73.1`. The model instantiation below. ```julia; model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; tracers = (:T, :S),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(),; closure = ScalarDiffusivity(ν=1e-6,κ=1e-6),; boundary_conditions = (u=u_bcs,v=v_bcs)). set!(model,T=25,S=0); ```. which only returns the following error while using `GPU()`. ```julia; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device ; CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS). Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/fG3xK/src/cache.jl:94; .; .; .; ```. The code runs when I use the `underlying_grid` instead or if I change to `CPU`.; The full code is available and can be run on Google Colab. https://github.com/iuryt/OceanGyreTank.jl/blob/main/OceanGyreTank.ipynb",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2367:1916,avail,available,1916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2367,1,['avail'],['available']
Availability,"nded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. This also means that operations between `ReducedField` and `Field` also end up at the right place, and we have no need to throw an error if a `BinaryOperation` has a `Nothing` location (in fact, this might be a useful abstraction for binary operations between `ReducedField`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599:5480,error,error,5480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599,1,['error'],['error']
Availability,"ng as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:1455,down,download,1455,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['down'],['download']
Availability,"ng.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4430,error,error,4430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['error'],['error']
Availability,"nge:. ```; #-----; Lx = Ly = 16_000; Lz = 1_000; topology = (Periodic, Periodic, Bounded); factor = 1; grid = RegularCartesianGrid(size=(2048÷factor, 1, 256÷factor),; x=(0, Lx),; y=(0, 1),; z=(-Lz/2, +Lz/2),; topology=topology); #-----. #-----; ubc = UVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); vbc = VVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); wbc = WVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Value, 0),; top = BoundaryCondition(Value, 0),; ); bbc = TracerBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, N2),; top = BoundaryCondition(Gradient, N2),; ); #-----. #-----; # Set-up sponge layer; bottom_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bottom_mask, target=0); #----. model = IncompressibleModel(; architecture = GPU(),; grid = grid,; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; coriolis = FPlane(f=f0),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; boundary_conditions = (b=bbc, u=ubc, v=vbc, w=wbc),; forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge),; ```. From the docs, I expected this to ; > relax velocity fields to zero [...] in the bottom 1/10th of the domain. which leads me to believe that there's some a sharp cut-off in the function mask so that velocities above the range `[-500, -400]`aren't affected. However, when I plot the vertical velocities (and other variables with zero mean) I get the results below, which indicate that the sponge layer is active in the approximate range `[-500, -200]`, which is around 3 times larger than what I (thought I) set up. ![Screenshot from 2020-11-24 08-45-47](https://user-images.githubusercontent.com/13205162/100126723-2e4dea00-2e33-11eb-8a80-f97c525c6e91.png). Am I missing something here?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203:1774,mask,mask,1774,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203,1,['mask'],['mask']
Availability,"nhydrostaticModel(; grid); simulation = Simulation(model; Δt=1.0, stop_iteration=3); simulation.output_writers[:jld2] =; JLD2OutputWriter(model, model.velocities, schedule=IterationInterval(1), indices=(:, 2, :), prefix=""test"", force=true); run!(simulation); wt = FieldTimeSeries(""test.jld2"", ""w""); # colon very important; ```. then. ```julia; julia> maximum(wt); ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```. well!. This affects `@show wt` since this attempts to compute statistics for a ""data summary"":. ```julia; julia> wt; Error showing value of type FieldTimeSeries{Center, Center, Face, InMemory, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 4, Array{Float64, 4}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Vector{Float64}}:; ERROR: BoundsError: attempt to access 3×1×4×4 OffsetArray(::Array{Float64, 4}, 1:3, 2:2, 1:4, 1:4) with eltype Float64 with indices 1:3×2:2×1:4×1:4 at index [1, 1, 1, 1]; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2424:1938,ERROR,ERROR,1938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2424,1,['ERROR'],['ERROR']
Availability,"nicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3816:1233,ERROR,ERROR,1233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816,4,['ERROR'],['ERROR']
Availability,"ns.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64...; ```. I'm not really sure what to make of this error. Because the simulation I need to run is necessarily complex, it's been hard to get rid of this error in my main simulation. Any ideas?. PS.: I ran this MWE in particular on an NVIDIA Quadro GP100 GPU, but I have gotten the same error (albeit with a longer MWE) on Tesla V100s. ```julia; julia> versioninfo(); Julia Version 1.8.3; Commit 0434deb161e (2022-11-14 20:14 UTC); Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 72 × Intel(R) Xeon(R) Gold 6140 CPU @ 2.30GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-13.0.1 (ORCJIT, skylake-avx512); Threads: 1 on 72 virtual cores; Environment:; JULIA_DEPOT_PATH = /glade/work/tomasc/.julia; LD_LIBRARY_PATH = /glade/u/apps/dav/opt/cuda/11.4.0/extras/CUPTI/lib64:/glade/u/apps/dav/opt/cuda/11.4.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/lib:/glade/u/apps/dav/opt/julia/1.8.3/lib/julia:/glade/u/apps/dav/opt/openmpi/4.1.1/gnu/10.1.0/lib:/glade/u/apps/dav/opt/ucx/1.11.0/lib:/glade/u/apps/dav/opt/gnu/10.1.0/lib64:/glade/u/apps/dav/opt/julia/1.8.3/../ncar/libglvnd/lib; JULIA_EDITOR = vim; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:23127,error,error,23127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,2,['error'],['error']
Availability,"ns.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:151; [8] JLD2OutputWriter(model::HydrostaticFreeSurfaceModel{…}, outputs::@NamedTuple{…}; filename::String, schedule::IterationInterval, dir::String, indices::Tuple{…}, with_halos::Bool, array_type::Type, file_splitting::Oceananigans.OutputWriters.NoFileSplitting, overwrite_existing::Bool, init::typeof(Oceananigans.OutputWriters.noinit), including::Vector{…}, verbose::Bool, part::Int64, jld2_kw::Dict{…}); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/jld2_output_writer.jl:185; [9] top-level scope; @ REPL[8]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```; It looks like there are problems also if trying to save the windowed field by itself; ```julia; julia> JLD2OutputWriter(model, (; c), filename = ""test1"", schedule = IterationInterval(1)); ERROR: ArgumentError: view indices (1:5, 1:5, 1:5) do not intersect field indices (Colon(), Colon(), 5:5); Stacktrace:; [1] view(f::Field{…}, i::UnitRange{…}, j::UnitRange{…}, k::UnitRange{…}); @ Oceananigans.Fields ~/development/Oceananigans.jl/src/Fields/field.jl:319; [2] Field; @ ~/development/Oceananigans.jl/src/Fields/field.jl:184 [inlined]; [3] construct_output(user_output::Field{…}, grid::RectilinearGrid{…}, user_indices::Tuple{…}, with_halos::Bool); @ Oceananigans.OutputWriters ~/development/Oceananigans.jl/src/OutputWriters/output_construction.jl:46; [4] (::Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticFreeSurfaceModel{…}})(name::Symbol); @ Oceananigans.OutputWriters ./none:0; [5] iterate; @ ./generator.jl:47 [inlined]; [6] merge(a::@NamedTuple{}, itr::Base.Generator{Tuple{…}, Oceananigans.OutputWriters.var""#28#29""{…}}); @ Base ./namedtuple.jl:361; [7] NamedTuple(itr::Base.Generator{Tuple{Symbol}, Oceananigans.OutputWriters.var""#28#29""{Tuple{…}, Bool, HydrostaticF",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3835:2225,ERROR,ERROR,2225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3835,1,['ERROR'],['ERROR']
Availability,"nt64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Cell,Face,Nothing,Relaxation{Float64,GaussianMask{:z,Float64},Irrational{:π}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},typeof(Oceananigans.Forcings.zeroforcing),typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] getindex at namedtuple.jl:94; [2] field_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:118; [3] forcing_func_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:139; [4] ContinuousForcing at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:156; [5] u_velocity_tendency at /archive1/glwagner/Projects/Oceananigans.jl/src/TimeSteppers/velocity_and_tracer_tendencies.jl:56; [6] macro expansion at /archive1/glwagner/Projects/Oceananigans.jl/src/TimeSteppers/calculate_tendencies.jl:124; [7] gpu_calculate_Gu! at /data5/glwagner/.julia/packages/KernelAbstractions/QQ583/src/macros.jl:80; [8] overdub at /data5/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:0; Reason: unsupported dynamic function invocation (call to getindex); ```. What's happening? The error comes from `continuous_forcing.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/src/Forcings/continuous_forcing.jl#L118-L119. the difference between the above two cases is that, in the first, `model_fields` contains only velocities and tracers. In the second, however, `model_fields` also contains `diffusivities`. For `AnisotropicMinimumDissipation`, `diffusivities` is a _nested_ `NamedTuple` with an eddy viscosity field and a tuple of eddy diffusivity fields for each tracer. This problem has affected some scripts I'm working with as well as @raphaelouillon",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:4771,error,error,4771,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['error'],['error']
Availability,"o = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); Closest candidates are:; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.add_sum), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::typeof(Base.mul_prod), ::Bool, ::AbstractArray) where T at reducedim.jl:80; initarray!(::AbstractArray{T}, ::Any, ::Union{typeof(Base._extrema_rf), typeof(max), typeof(min)}, ::Bool, ::AbstractArray) where T at reducedim.jl:84; ...; Stacktrace:; [1] initialize_reduced_field!; ```; I'm trying to figure out why would this fail in v1.8.0-rc1 but not on v1.7 but no luck so far.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663:1704,ERROR,ERROR,1704,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663,1,['ERROR'],['ERROR']
Availability,"o Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d127",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:1084,error,error,1084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['error'],['error']
Availability,"oat64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}); │ @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/i1inK/src/Fields/field.jl:606; │ [26] top-level scope; │ @ logging.jl:340; │ [27] include(mod::Module, _path::String); │ @ Base ./Base.jl:386; │ [28] exec_options(opts::Base.JLOptions); │ @ Base ./client.jl:285; │ [29] _start(); │ @ Base ./client.jl:485; └ @ Main /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; ```. Has someone encountered this behavior before? Is someone able to reproduce it? Downgrading CUDA to 3.9 solves this issue for me, which indicates that this might be a CUDA bug, but I can't reproduce it using only CUDA tools so it's hard for me to open an issue there. @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:19678,Down,Downgrading,19678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['Down'],['Downgrading']
Availability,"oat64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:74; [3] top-level scope; @ REPL[10]:1; ```. This seems counter-intuitive to me because we _had_ actually prescribed a `cfl`. We figured that the error was because `substeps` has a default value of 200 so when we also prescribe a `cfl` kwarg then . https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Ba",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:2775,error,error,2775,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,2,"['down', 'error']","['down', 'error']"
Availability,"ocs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> using Oceananigans.Units. julia> arch = CPU(). julia> grid = RectilinearGrid(arch, size = (128, 1, 5),; x = (0, 1000kilometers), y = (0, 1), z = (-400, 0),; topology = (Bounded, Periodic, Bounded)); 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Bounded x ∈ [0.0, 1.0e6] regularly spaced with Δx=7812.5; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-400.0, 0.0] regularly spaced with Δz=80.0. julia> model_pcg = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:PreconditionedConjugateGradient,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> model_mat = HydrostaticFreeSurfaceModel(grid = grid,; momentum_advection = nothing,; free_surface = ImplicitFreeSurface(solver_method=:HeptadiagonalIterativeSolver,; tolerance = 1e-15)); HydrostaticFreeSurfaceModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: 128×1×5 RectilinearGrid{Float64, Bounded, Periodic, Bounded} on CPU with 1×1×1 halo; ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: Buoyancy{SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}, Oceananigans.Grids.ZDirection}; └── coriolis: Nothing. julia> typeof(model_pcg.free_surface.implicit_step_solver.right_hand_side); Field{Center, Center, Nothing, Nothing, RectilinearGri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2184:1145,toler,tolerance,1145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2184,1,['toler'],['tolerance']
Availability,"of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't really know why there's an issue with type inference so we have to say wishy washy things like ""maybe, just maybe you did this but I don't really know sorry just trying to help... !""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:2813,error,error,2813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,2,['error'],['error']
Availability,"oint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 4] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; ```. One option to add safety is to modify `set!(model, filepath::AbstractString)` to take an option argument `skip_missing_variables = false` (or something), which would change the behavior from throwing a warning to throwing an error. @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:3966,error,error,3966,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['error'],['error']
Availability,"oject; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ ~/Downloads/julia-1.5.4/bin/julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> st; Status `/glade/scratch/tomasc/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `/glade/scratch/tomasc/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # THINGS HAPPEN HERE T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:1841,down,downloaded,1841,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,1,['down'],['downloaded']
Availability,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:3939,checkpoint,checkpointer,3939,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['checkpoint'],['checkpointer']
Availability,"op_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:1488,error,error,1488,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['error'],['error']
Availability,"opy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}, Oceananigans.BuoyancyModels.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780:1351,ERROR,ERROR,1351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780,1,['ERROR'],['ERROR']
Availability,"or{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/grid_metrics.jl:159; [6] Reduction(avg::Average, field::Field{Face, Face, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}; condition::Nothing, mask::Int64, dims::Tuple{Int64, Int64}); @ Oceananigans.AbstractOperations /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/metric_field_reductions.jl:38; [7] #Average#7; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/Bks9B/src/AbstractOperations/metric_field_reductions.jl:59 [inlined]; [8] top-level scope; @ REPL[26]:1; ```. And indeed, looking at `src/Operators/spacings_and_areas_and_volumes.jl`, I don't see `Ayᶠᶠᶠ` anywhere: https://github.com/CliMA/Oceananigans.jl/blob/e90b22bcfcf3cba53ed61e46024d3a759f35ef56/src/Operators/spacings_and_areas_and_volumes.jl#L93-L105",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2189:4496,mask,mask,4496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2189,1,['mask'],['mask']
Availability,"oundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing, NamedTuple{(), Tuple{}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/X0YQn/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:18; [10] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, architecture::CPU, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::CenteredSecondOrder, buoyancy::BuoyancyTracer, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Symbol, particles::Nothing, velocities::PrescribedVelocityFields{typeof(U), typeof(V), typeof(W), Nothing}, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/X0YQn/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:182; [11] top-level scope; @ ~/Downloads/test_prescribed.jl:19; [12] include(fname::String); @ Base.MainInclude ./client.jl:444; [13] top-level scope; @ REPL[1]:1; [14] top-level scope; @ ~/.julia/packages/CUDA/VGl9W/src/initialization.jl:66; in expression starting at /home/fpoulin/Downloads/test_prescribed.jl:19; ```. cc: @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1958:31229,Down,Downloads,31229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958,2,['Down'],['Downloads']
Availability,"ow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:1181,down,down,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['down'],['down']
Availability,"owWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1663,error,error,1663,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"pRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] closure_summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/TurbulenceClosures.jl:61 [inlined]; [8] show(io::IOContext{Base.TTY}, model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.Offse",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398:14830,ERROR,ERROR,14830,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398,1,['ERROR'],['ERROR']
Availability,"packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ``",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:2104,error,error,2104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['error'],['error']
Availability,"projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36us 5 100.47us 94.015us 103.42us _Z25julia_gpu_ab2_step_field_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE20_gpu_ab2_step_field_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912:1202,avail,available,1202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912,1,['avail'],['available']
Availability,"proved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR makes a significant contribution to `Oceananigans`' suite of operators: we introduce difference and interpolation operators that act on functions, thereby permitting the *composition* of such operations. The notation for a difference operator denoted by `δ` would be. `δx_caa` or `δx_faa` . where the three letters `caa` denote that differencing is performed at the location ""x cell, any y location, any z location"". The three letter format is an unambiguous specification of the location of a field in three dimensions on a staggered grid. Note that in this PR I have only defined partial derivative operators in this format, rather than difference operators, as we currently only accommodate regular grids. An interpolation operator is denoted by ""blacktriangleright"", so that. `▶x_caa`. denotes the interpolation of a field from `caa` to `faa`. Note that the destination of the operation is implied. Using composition, we also define double interpolations, such as. `▶xy_ffa`,. which interpolates a field located at `ffa` (x face, y face, and any z location) to `cca`. . There are 12 such double interpolation operators and they are essential for specifying eddy diffusivity closures based on strain rate. I think that using composition to its fullest will ultimately reduce the code length, make the code easier to maintain, and will probably make the code more robust by reducing the number of possible bugs. I think these should eventually be moved into `/src/operators/`, but I also think this should wait for a future PR. Ultimately I believe all the operators should be overhauled to match the pattern introduced in this PR. This PR partially partially solves #217 and will replace #218.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:3366,robust,robust,3366,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,1,['robust'],['robust']
Availability,"ptx, line 3031; error : Entry function '_Z22partial_mapreduce_grid8identity7add_sumv16CartesianIndicesILi3E5TupleI5OneToI5Int64ES3_IS4_ES3_IS4_EEES1_ILi3ES2_IS3_IS4_ES3_IS4_ES3_IS4_EEE3ValILitrueEE13ReshapedArrayI7Float64Li4E8SubArrayIS7_Li3E13CuDeviceArrayIS7_Li3ELi1EES2_I9UnitRangeIS4_ES10_IS4_ES10_IS4_EELinfalseEES2_I27SignedMultiplicativeInverseIS4_ES11_IS4_EEE20ConditionalOperationI6CenterS13_4Face15BinaryOperationIS13_S13_S14_1_S15_IS13_S13_S14_S16_23KernelFunctionOperationIS13_S13_S14_20ImmersedBoundaryGridIS7_8PeriodicS19_7Bounded15RectilinearGridIS7_S19_S19_S20_S7_S7_S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3140:1433,error,error,1433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3140,1,['error'],['error']
Availability,"ptx, line 4214; error : Entry function '_Z29julia_gpu_calculate_Gu__1315516CompilerMetadataI10StaticSizeI10_3__3__33_E12DynamicCheckvv7NDRangeILi3ES0_I10_1__1__33_ES0_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS4_Li3ELi1EEE15RectilinearGridIS4_8PeriodicS7_7BoundedS4_S4_S3_IS4_Li1ES5_IS4_Li1ELi1EEES3_IS4_Li1E12StepRangeLenIS4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700:1673,error,error,1673,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700,1,['error'],['error']
Availability,"quire(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [9] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [10] top-level scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4279,ERROR,ERROR,4279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['ERROR'],['ERROR']
Availability,"r = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:1976,checkpoint,checkpoint,1976,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpoint']
Availability,"r feature. This would eventually allow users to compute new/complex terms, close budgets, etc. on any grid without worrying about the staggered grid. So it might finally fulfill the dream of going from idea -> model/simulation -> analysis -> paper purely in Julia and (most importantly) without needing to know anything about the staggered grid. Since the interface remains very similar between the different models and grid, this could potentially allow future users to easily switch between different equation sets and grids while keeping the same analysis script. I thought we opened an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493:1225,avail,available,1225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493,1,['avail'],['available']
Availability,"r for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which is motivated more by internal considerations). But it's tradeoffs all the way down so good to discuss. I also did a little clean up and changed the internal function `TurbulenceClosures.DiffusivityFields` to `TurbulenceClosures.diffusivity_fields`. The code is inconsistent about the use of TitleCase (is it a constructor / struct? is it a function?) and there's a bit of clean up to do... Resolves #2422",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:1603,down,downside,1603,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,2,['down'],"['down', 'downside']"
Availability,"rBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: SecondOrderSeawaterPolynomial{Float64}; ```. you get an error (or at least I did, attached at the bottom of this PR) when setting `model(; ... buoyancy)`. Instead if we have the `eos` set as a `RoquetEquationOfState`,. ```julia; julia> eos = RoquetEquationOfState(:Freezing); BoussinesqEquationOfState{Float64}:; ├── seawater_polynomial: SecondOrderSeawaterPolynomial{Float64}; └── reference_density: 1024.6; ; julia> eos.seawater_polynomial # the density anomaly; ρ' = 0.7718 Sᴬ - 0.0491 Θ - 0.005027 Θ² - 2.5681e-5 Θ Z + 0.0 Sᴬ² + 0.0 Sᴬ Z + 0.0 Sᴬ Θ. julia> buoyancy = SeawaterBuoyancy(equation_of_state=eos); SeawaterBuoyancy{Float64}:; ├── gravitational_acceleration: 9.80665; └── equation of state: BoussinesqEquationOfState{Float64}; ```. we can then set this as the `buoyancy` in the model, `model(; buoyancy)`, without an error. As of SeawaterPolynomials.jl v0.3.2 another idealised nonlinear eos has been added so the number available has been updated in `buoyancy models and equation of state.md`to reflect this and the compat entry has been updated. ## Error from setting `buoyancy = SeawaterBuoyancy(equation_of_state= RoquetSeawaterPolynomial(:Freezing))`. ```julia; nested task error: MethodError: no method matching ρ′(::Float64, ::Float64, ::Float64, ::SecondOrderSeawaterPolynomial{Float64}); Closest candidates are:; ρ′(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Any) at ~/.julia/packages/Oceananigans/Zg9Bd/src/BuoyancyModels/nonlinear_equation_of_state.jl:27; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SecondOrderSeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/SecondOrderSeawaterPolynomials.jl:65; ρ′(::Any, ::Any, ::Any, ::SeawaterPolynomials.BoussinesqEquationOfState{<:SeawaterPolynomials.TEOS10.TEOS10SeawaterPolynomial}) at ~/.julia/packages/SeawaterPolynomials/ig7CR/src/TEOS10.jl:186; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3035:1598,avail,available,1598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3035,3,"['Error', 'avail', 'error']","['Error', 'available', 'error']"
Availability,"regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)); 4×4×4 ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo:; ├── immersed_boundary: GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}; ├── underlying_grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=0.25. julia> model = NonhydrostaticModel(grid = grid,; advection = WENO5(grid=grid),; ); ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:197; ERROR: MethodError: no method matching return_metrics(::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}}, CPU}); Closest candidates are:; return_metrics(::LatitudeLongitudeGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:215; return_metrics(::RectilinearGrid) at /home/tomas/repos/Oceananigans.jl/src/Advection/weno_fifth_order.jl:216; Stacktrace:; [1] compute_stretched_weno_coefficients(grid::ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2549:1252,ERROR,ERROR,1252,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2549,1,['ERROR'],['ERROR']
Availability,"ressure::Field{…}, solver::ConjugateGradientPoissonSolver{…}, Δt::Float64, Ũ::@NamedTuple{…}); @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/HPOLD/src/Models/NonhydrostaticModels/solve_for_pressure.jl:89; [16] calculate_pressure_correction!(model::NonhydrostaticModel{…}, Δt::Float64); @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/HPOLD/src/Models/NonhydrostaticModels/pressure_correction.jl:15; [17] set!(model::NonhydrostaticModel{…}; enforce_incompressibility::Bool, kwargs::@Kwargs{…}); @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/HPOLD/src/Models/NonhydrostaticModels/set_nonhydrostatic_model.jl:54; [18] top-level scope; @ ~/code/internal-tide-mixing/test_MWE_conjugate_gradient.jl:28; Some type information was truncated. Use `show(err)` to see complete types. ```. Here's a minimal working example (I tried to make it as minimal as possible, apologies if it's not minimal enough). I set the bottom topography to zero everywhere except for one grid cell, which is set to 0.2. Notably, when I change this value from 0.2 to 0.01, the error no longer appears. It is not clear to me what the issue might be.; ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Oceananigans.Solvers: ConjugateGradientPoissonSolver, fft_poisson_solver. underlying_grid = RectilinearGrid(size=(4, 4, 4), ; x = (0, 1),; y = (0, 1), ; z = [0, 0.2,0.4,0.6, 2],; halo = (2,2,2),; topology = (Oceananigans.Periodic, Oceananigans.Periodic, Oceananigans.Bounded); ); bottom = [0.0 0.0 0.0 0.0;; 0.0 0.0 0.0 0.0;; 0.0 0.0 0.2 0.0;; 0.0 0.0 0.0 0.0]. grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). uᵢ(x, y, z) = 0.1. model = NonhydrostaticModel(;; grid=grid,; pressure_solver = ConjugateGradientPoissonSolver(; grid; preconditioner = fft_poisson_solver(underlying_grid)),; advection = WENO(),; timestepper = :RungeKutta3,; ); set!(model, u=uᵢ); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3896:4359,error,error,4359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3896,1,['error'],['error']
Availability,"rg/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:1827,error,error,1827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['error'],['error']
Availability,"rics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(; grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{…}, tracers::Nothing, forcing::@NamedTuple{}, closure::Nothing, boundary_conditions::@NamedTuple{}, particles::Nothing,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806:1338,error,error,1338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806,1,['error'],['error']
Availability,"rking example in this case because the error doesn't happen every time, which slows down my investigation. Furthermore, the more I simplify the code, the less often the error manifests. In the example below, for example, the error happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:1135,error,error,1135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['error'],['error']
Availability,"ropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> model.velocities.u; Error showing value of type Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}}:; ERROR: MethodError: no method matching bctype_str(::Nothing); Closest candidates are:; bctype_str(::BoundaryCondition{Flux,Nothing}) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:29; bctype_str(::BoundaryCondition{var""#s63"",T} where T where var""#s63""<:Flux) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:24; bctype_str(::BoundaryCondition{var""#s63"",T} where T where var""#s63""<:Oceananigans.BoundaryConditions.Periodic) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:25; ...; Stacktrace:; [1] short_show(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1026:1356,ERROR,ERROR,1356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026,1,['ERROR'],['ERROR']
Availability,"ror: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:2227,error,error,2227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"rrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; [4] #39; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.Kerne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744:2500,ERROR,ERROR,2500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"rrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1350,error,error,1350,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['error'],['error']
Availability,"rror happens roughly 1 in every 5 runs:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. Nx=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0 [inlined]; │ [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndice",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:1327,error,error,1327,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['error'],['error']
Availability,"rs)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:2206,checkpoint,checkpointer,2206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpointer']
Availability,"rs); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:2365,checkpoint,checkpointer,2365,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpointer']
Availability,rsor_jll v0.1.4+0; [12413925] Xorg_xcb_util_image_jll v0.4.0+1; [2def613f] Xorg_xcb_util_jll v0.4.0+1; [975044d2] Xorg_xcb_util_keysyms_jll v0.4.0+1; [0d47668e] Xorg_xcb_util_renderutil_jll v0.3.9+1; [c22f9ab0] Xorg_xcb_util_wm_jll v0.4.1+1; [35661453] Xorg_xkbcomp_jll v1.4.6+0; [33bec58e] Xorg_xkeyboard_config_jll v2.39.0+0; [c5fb5394] Xorg_xtrans_jll v1.5.0+0; [3161d3a3] Zstd_jll v1.5.5+0; [35ca27e7] eudev_jll v3.2.9+0; [214eeab7] fzf_jll v0.43.0+0; [1a1c6b14] gperf_jll v3.1.1+0; [477f73a3] libaec_jll v1.1.2+0; [a4ae2306] libaom_jll v3.4.0+0; [0ac62f75] libass_jll v0.15.1+0; [2db6ffa8] libevdev_jll v1.11.0+0; [f638f0a6] libfdk_aac_jll v2.0.2+0; [36db933b] libinput_jll v1.18.0+0; [b53b4c65] libpng_jll v1.6.43+1; [f27f6e37] libvorbis_jll v1.3.7+1; [337d8026] libzip_jll v1.10.1+0; [009596ad] mtdev_jll v1.1.6+0; [1270edf5] x264_jll v2021.5.5+0; [dfaa095f] x265_jll v3.5.0+0; [d8fb68d0] xkbcommon_jll v1.4.1+1; [0dad84c5] ArgTools v1.1.1; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8ba89e20] Distributed; [f43a241f] Downloads v1.6.0; [7b1f6079] FileWatching; [9fa8497b] Future; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL v0.6.4; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions v1.2.0; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9abbd945] Profile; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA v0.7.0; [9e88b42a] Serialization; [6462fe0b] Sockets; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [4607b0f0] SuiteSparse; [fa267f1f] TOML v1.0.3; [a4e569a6] Tar v1.10.0; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll v1.1.0+0; [781609d7] GMP_jll v6.2.1+6; [deac9b47] LibCURL_jll v8.4.0+0; [e37daf67] LibGit2_jll v1.6.4+0; [29816b5a] LibSSH2_jll v1.11.0+1; [c8ffd9c3] MbedTLS_jll v2.28.2+1; [14a3606d] MozillaCACerts_jll v2023.1.10; [4536629a] OpenBLAS_jll v0.3.23+4; [05823500,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:10403,Down,Downloads,10403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Down'],['Downloads']
Availability,"ruction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1326:1475,error,error,1475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326,1,['error'],['error']
Availability,"ryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/IBMCode/Oceananigans.jl/src/Simulations/run.jl:88; [24] top-level scope; @ REPL[18]:1; [25] top-level scope; @ ~/.julia/packages/CUDA/qAl31/src/initialization.jl:52; ```; @tomchor has also seen the same error. Looking at past issues, I wondered if this related to #2558 at all?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:29865,error,error,29865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,1,['error'],['error']
Availability,"s branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: Could not restore tendencies for t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; ┌ Warning: Could not restore tendencies for t2 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:257; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (514.400 μs); [ Info: Executing initial time step...; [ Info: ... initial time step complete (41.614 seconds).; [ Info: Simulation is stopping after running for 41.750 seconds.; [ Info: Simulation time 20 seconds equals or exceeds stop time 20 seconds. julia> interior(model.tracers.b); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 2] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 3] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. [:, :, 4] =; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0. julia> interior(model.tracers.t1); 4×4×4 view(::Array{Float64, 3}, 4:7, 4:7, 4:7) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:2524,checkpoint,checkpointer,2524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpointer']
Availability,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389:1839,checkpoint,checkpointer,1839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389,2,['checkpoint'],['checkpointer']
Availability,"s/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:2083,error,error,2083,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['error'],['error']
Availability,"s?. ```; Testing checkpointing...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_0.jld; [Checkpointer] Reconstructing FFT plans...; WARNING: Forcing functions will not be serialized!; [Checkpointer] Serializing model to disk: ./test_model_checkpoint_5.jld; [Checkpointer] Reconstructing FFT plans...; Deserializing model from disk: test_model_checkpoint_5.jld; ┌ Warning: type Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; ┌ Warning: type OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}} not present in workspace; reconstructing; └ @ JLD ~/.julia/packages/JLD/1BoSz/src/jld_types.jl:703; Checkpointing: Error During Test at /home/alir/Oceananigans.jl/test/runtests.jl:293; Got exception outside of a @test; MethodError: Cannot `convert` an object of type getfield(JLD, Symbol(""##Oceananigans.FaceFieldX{OffsetArrays.OffsetArray{Core.Float64,3,Core.Array{Core.Float64,3}},Oceananigans.RegularCartesianGrid{Core.Float64,Base.StepRangeLen{Core.Float64,Base.TwicePrecision{Core.Float64},Base.TwicePrecision{Core.Float64}}}}#384"")) to an object of type FaceFieldX; Closest candidates are:; convert(::Type{T}, !Matched::T) where T at essentials.jl:154; Stacktrace:; [1] jlconvert(::Type{VelocityFields}, ::JLD.JldFile, ::Ptr{UInt8}) at /home/alir/.julia/packages/JLD/1BoSz/src/jld_types.jl:434; [2] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:398; [3] read(::JLD.JldDataset) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:370; [4] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at /home/alir/.julia/packages/JLD/1BoSz/src/JLD.jl:502; [5] jlconvert(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/177:1138,Checkpoint,Checkpointing,1138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/177,2,"['Checkpoint', 'Error']","['Checkpointing', 'Error']"
Availability,"scope; @ ~/.julia/packages/MPI/08SPr/deps/deps.jl:8; [11] include(mod::Module, _path::String); @ Base ./Base.jl:418; [12] include(x::String); @ MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:37",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4457,error,error,4457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['error'],['error']
Availability,"se information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:1325,checkpoint,checkpoint,1325,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,1,['checkpoint'],['checkpoint']
Availability,"stdlib/v1.6/REPL/src/REPL.jl:229; [21] (::REPL.var""#do_respond#61""{Bool, Bool, REPL.var""#72#82""{REPL.LineEditREPL, REPL.REPLHistoryProvider}, REPL.LineEditREPL, REPL.LineEdit.Prompt})(s::REPL.LineEdit.MIState, buf::Any, ok::Bool); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:798; [22] #invokelatest#2; @ ./essentials.jl:708 [inlined]; [23] invokelatest; @ ./essentials.jl:706 [inlined]; [24] run_interface(terminal::REPL.Terminals.TextTerminal, m::REPL.LineEdit.ModalInterface, s::REPL.LineEdit.MIState); @ REPL.LineEdit /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/LineEdit.jl:2441; [25] run_frontend(repl::REPL.LineEditREPL, backend::REPL.REPLBackendRef); @ REPL /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/REPL/src/REPL.jl:1126; [26] (::REPL.var""#44#49""{REPL.LineEditREPL, REPL.REPLBackendRef})(); @ REPL ./task.jl:406; ```. Digging a bit deeper, it seems that even showing the closure itself throws this error, but only if it's attached to a model:. ```julia; julia> closure; SmagorinskyLilly: C=0.16, Cb=1.0, Pr=1.0. julia> model.closure; Error showing value of type SmagorinskyLilly{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(), Tuple{}}}:; ERROR: ArgumentError: collection must be non-empty; Stacktrace:; [1] first(itr::NamedTuple{(), Tuple{}}); @ Base ./abstractarray.jl:387; [2] show(io::IOBuffer, ft::NamedTuple{(), Tuple{}}); @ Oceananigans.Fields ~/repos/Oceananigans.jl/src/Fields/show_fields.jl:67; [3] print(io::IOBuffer, x::NamedTuple{(), Tuple{}}); @ Base ./strings/io.jl:35; [4] print_to_string(::String, ::Vararg{Any, N} where N); @ Base ./strings/io.jl:135; [5] string; @ ./strings/io.jl:174 [inlined]; [6] summary; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl:194 [inlined]; [7] show; @ ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/sm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2398:46871,error,error,46871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2398,1,['error'],['error']
Availability,"t /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _requir",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1916,ERROR,ERROR,1916,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['ERROR'],['ERROR']
Availability,"t will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't really know why there's an issue with type inference so we have to say ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:2136,error,error,2136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['error'],['error']
Availability,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:118275,Error,Error,118275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,"['Checkpoint', 'Error']","['Checkpointer', 'Error']"
Availability,"t64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}; condition::Nothing, mask::Float64, dims::Function); │ @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/i1inK/src/Fields/field.jl:611; │ [25] maximum(f::Function, c::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:17595,mask,mask,17595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['mask'],['mask']
Availability,"tPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:508.; WARNING: Method definition recurse(Cassette.Context{N, M, T, P, B, H} where H<:Union{Cassette.DisableHooks, Nothing} where B<:Union{Nothing, Base.IdDict{Module, Base.Dict{Symbol, Cassette.BindingMeta}}} where P<:Cassette.AbstractPass where T<:Union{Nothing, Cassette.Tag{N, X, E} where E where X where N<:Cassette.AbstractContextName} where M where N<:Cassette.AbstractContextName, Any...) in module Cassette at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521 overwritten in module GPUifyLoops at /home/alir_mit_edu/.julia/packages/Cassette/xggAf/src/overdub.jl:521.; CUDA-enabled GPU(s) detected:; CuDevice(0): Tesla V100-SXM2-16GB; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Default,Nothing}, got BoundaryCondition{Flux,Float64}; Stacktrace:; [1] setbc!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Val{:left}, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:85; [2] setproperty!(::Oceananigans.CoordinateBoundaryConditions{BoundaryCondition{Default,Nothing},BoundaryCondition{Default,Nothing}}, ::Symbol, ::BoundaryCondition{Flux,Float64}) at /home/alir_mit_edu/Oceananigans.jl/src/boundary_conditions.jl:84; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] exec_options(::Base.JLOptions) at ./client.jl:267; [8] _start() at ./client.jl:436; in expression starting at /home/alir_mit_edu/Oceananigans.jl/newscript.jl:53; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/272:1469,ERROR,ERROR,1469,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/272,1,['ERROR'],['ERROR']
Availability,"tations.Permutation{(2, 1, 3), 3}, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}, Vector{ComplexF64}}}); @ Oceananigans.Distributed /glade/work/tomasc/.julia/packages/Oceananigans/9ZFqp/src/Distributed/distributed_fft_based_poisson_solver.jl:65; [10] solve_for_pressure!(pressure::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, MultiArch{CPU, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{HaloCommunication, Oceananigans.Distributed.HaloCommunicationRanks{Int64, Int64}}, BoundaryCondition{HaloCommunication, Oceananigans.Distributed.HaloCommunicationRanks{Int64, Int64}}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, solver::Base.Broadcast ./broadcast.jl:495; ```; ... and the error continues. Am I missing something obvious here? Is this script expected to work?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2433:10176,error,error,10176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2433,1,['error'],['error']
Availability,"tchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Vertical",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:1069,error,error,1069,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['error'],['error']
Availability,"tdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananiga",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3867,error,error,3867,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['error'],['error']
Availability,"ted by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17...; [ Info: Iteration 18...; [ Info: Iteration 19...; [ Info: Iteration 20...; [ Info: Iteration 21...; [ Info: Iteration 22...; [ Info: Iteration 23...; [ Info: Iteration 24...; [ Info: Iteration 25...; [ Info: Iteration 26...; [ Info: Iteration 27...; [ Info: Iteration 28...; [ Info: Iteration 29...; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.Dev",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:10295,ERROR,ERROR,10295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"tedComputations.HaloCommunicationRanks{Int64, Int64}}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{@NamedTuple{send::Array{Float64, 3}, recv::Array{Float64, 3}}, @NamedTuple{send::Array{Float64, 3}, recv::Array{Float64, 3}}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, v::Array{Float64, 3}); @ Oceananigans.DistributedComputations ~/Projects/Oceananigans.jl/src/DistributedComputations/distributed_fields.jl:53; [2] ImmersedBoundaryGrid(grid::RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Nothing, Nothing}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, ib::GridFittedBottom{Array{Float64, 3}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}); @ Oceananigans.ImmersedBoundaries ~/Projects/Oceananigans.jl/src/ImmersedBoundaries/grid_fitted_bottom.jl:89; [3] top-level scope; @ ~/Projects/Oceananigans.jl/mwe.jl:24; in expression starting at /Users/gregorywagner/Projects/Oceananigans.jl/mwe.jl:24; ```. I think `set!` should be able to understand whether an array has a global size or local size and do the right thing accordingly. It should only error if the array has neither of those sizes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3816:6459,error,error,6459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816,1,['error'],['error']
Availability,"tepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, ::Vararg{Any}; include_right_boundaries::Bool, reduced_dimensions::Tuple{}, location::Nothing, only_active_cells::Nothing, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:119; [18] launch!; @ ~/.julia/packages/Oceananigans/0y15B/src/Utils/kernel_launching.jl:90 [inlined]; [19] #compute_interior_tendency_contributions!#17; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:122 [inlined]; [20] compute_interior_tendency_contributions!; @ ~/.julia/packages/Oceananigans/0y15B/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:53 [inlined]; ```; Sorry for the length, I also had to remove some of the error message so GitHub would let me post it so feel free to let me know if you need to see more. I was able to fix the code by updating the function formatting from ; ``` @inline constant_stratification(x, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3]) ```; to; ``` @inline constant_stratification(x, y, z, t, p) = p.N² * (x * p.ĝ[1] + z * p.ĝ[3])```; after consulting colleagues and was told this was due to a Julia update. I just wanted to inform y'all of this bug.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3412:32213,error,error,32213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412,1,['error'],['error']
Availability,"ter range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common user interface by construction which makes it easy to switch between the two. I think this is a valueble feature. Most existing packages do not have compressibl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:3535,avail,available,3535,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['avail'],['available']
Availability,test Oceananigans returns CUDA error depsite being able to run examples on CPU and GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788:31,error,error,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788,1,['error'],['error']
Availability,"this line:. https://github.com/climate-machine/Oceananigans.jl/blob/8dacd119c2638d7034f8cb64a9ca56d721b9a7d7/src/models.jl#L57. throws . ```julia; ERROR: LoadError: ArgumentError: Cannot create a GPU model. No CUDA-enabled GPU was detected!; ```. when `HAVE_CUDA` is false. However, `HAVE_CUDA` is not really false when a device is 'not detected' (as far as I can tell), but rather throws an error when one of `CUDAdrv, CUDAnative, CuArrays` fails to load when `Oceananigans.jl` is built. A better error message might simply say that . ""One of `CUDAdrv, CUDAnative, CuArrays` threw an error at the time that `Oceananigans.jl` was built. If cuda is currently available, try running Pkg.build()."" . If that is, after all, the cause of the error. The issue is that its possible to have a device but not cuda, or to have a device but also some other issue with cuda libraries or julia packages that causes this error, or that cuda was not found *at some point in the past* when Oceananigans was built. We aren't actually detecting any device upon model instantiation, nor are we rechecking (however that would be done...) as far as I can tell.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/295:147,ERROR,ERROR,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/295,7,"['ERROR', 'avail', 'error']","['ERROR', 'available', 'error']"
Availability,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:2058,checkpoint,checkpointed,2058,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,6,"['Checkpoint', 'checkpoint']","['Checkpointer', 'checkpoint', 'checkpointed', 'checkpointer']"
Availability,"thub.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl#L305-L307. gets triggered. A solution was to add `substeps = nothing`. This is a bit counter-intuitive though. Is there a different way we should have done it? If not, perhaps a good idea is to add a note in the `SplitExplicitFreeSurface` dostring.... Moving on, we got another error down the road. Running this:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)); 								 ; free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7, substeps = nothing). model = HydrostaticFreeSurfaceModel(; grid, free_surface,; buoyancy = BuoyancyTracer(),; tracers = :b,; momentum_advection = WENO(),; tracer_advection = WENO()). simulation = Simulation(model, Δt=10, stop_time=3600). run!(simulation); ```. spits out . ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; Stacktrace:; [1] calculate_substeps; @ ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl:324 [inlined]; [2] iterate_split_explicit!(free_surface::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, UnitRange{Int64}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:3305,ERROR,ERROR,3305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,1,['ERROR'],['ERROR']
Availability,"tion_operand(::Function, ::Oceananigans.Fields.AbstractField{<:Any, <:Any, <:Any, <:ImmersedBoundaryGrid}, ::AbstractArray, ::Any). Stacktrace:; [1] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; condition::Array{Bool, 3}, mask::Int64, dims::Tuple{Int64, Int64, Int64}); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/hn2Ul/src/Fields/field.jl:643; [2] sum(c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Float64, typeof(Oceananigans.Operators.Vᶜᶜᶜ)}; kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol, Symbol}, N",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439:3723,mask,mask,3723,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439,1,['mask'],['mask']
Availability,"tional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/checkpointer.jl:218; ┌ Warning: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:1102,checkpoint,checkpointer,1102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,1,['checkpoint'],['checkpointer']
Availability,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1159:11900,checkpoint,checkpoints,11900,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159,6,"['checkpoint', 'error']","['checkpointed', 'checkpoints', 'error']"
Availability,"tion{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}); @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/CuznF/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:155; [4] calculate_tendencies!; @ ~/.julia/packages/Oceananigans/CuznF/src/Models/NonhydrostaticModels/calculate_nonhydrostatic_tendencies.jl:42 [inlined]; .; .; .; ```; </details>. Full code available at [OceanGyreTank.jl](https://github.com/iuryt/OceanGyreTank.jl/commit/5f132ac6b3ff0541d7f501a00d9560ec017651ea)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336:61038,avail,available,61038,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336,1,['avail'],['available']
Availability,"tively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://github.com/JuliaIO/JLD2.jl/pull/560. While this PR is still a draft I'm proposing the new defaults; - lossless compression with `compress=true` for JLD2, `deflatelevel=3` for netCDF; - bitrounding to keepbits ~20 (single precision-ish) whether you output in Float32/64 (doesn't matter when lossless compression is on); - a default `bitrounder` that rounds to the keepbits as suggested above that can be used instead of `bitrounder=nothing` (default). We can then independently tweak the precision (how many keepbits, ideally as a function of the vertical, see salinity) and the lossless compressor (Zlib -> Zstandard)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:2154,avail,available,2154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,1,['avail'],['available']
Availability,"to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:1488,checkpoint,checkpoint,1488,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['checkpoint'],['checkpoint']
Availability,"try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:1111,error,error,1111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['error'],['error']
Availability,trying to mask with a new immersed boundary method `PartialCellBottom`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2251:10,mask,mask,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2251,1,['mask'],['mask']
Availability,"tup"" part of the documentation. We've noticed that while our examples and docstrings seem to be useful, the ""model setup"" is less so, and also leaves out a lot of information necessary for running more complex simulations. ## What we have now. The basic idea is to flatten the current structure a bit. Right now it reads:. ```; - Home; - Quick start; - Examples > ; - Physics > ; - Numerical implementation > ; - Model setup > ; - <etc>; ```. ## What we propose. We propose to create top-level sections for important concepts such as `Grids`, `Fields`, `Simulations` etc. Then less important details would be subsumed into the `Models` section (which would overlap strongly with the current `Model setup` section). Here's an outline:. ```; - Home; - Quick start; - Examples >; - Grids, architectures, and number types; - Fields and operations; - Models; - Setting initial conditions; - Tracers; - Advection schemes; - Turbulence closures; - Buoyancy models and equations of state; - Rotation and Coriolis forces; - Turbulence closures; - Forcing functions; - Background fields; - Lagrangian particles; - Clocks; - Simulations; - Callbacks; - Output writers; - Checkpointing and picking up from a checkpoint; - Physics > ; - Numerical implementation > ; - <etc>; ```. The ordering of subjects is carefully chosen here, so please comment on that if you think it should be changed. To do this incrementally, I will open a PR that adds the `Grids` and `Fields` sections. Then we can build the `Models` section incrementally by porting material from `Model setup`. While we are working I will add the qualifer `Model setup (legacy)`. Related issues:. * https://github.com/CliMA/Oceananigans.jl/issues/3594; * https://github.com/CliMA/Oceananigans.jl/issues/3166; * https://github.com/CliMA/Oceananigans.jl/issues/2448; * https://github.com/CliMA/Oceananigans.jl/issues/2308; * https://github.com/CliMA/Oceananigans.jl/issues/1879; * https://github.com/CliMA/Oceananigans.jl/issues/1779; * https://github.c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3672:1223,Checkpoint,Checkpointing,1223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672,2,"['Checkpoint', 'checkpoint']","['Checkpointing', 'checkpoint']"
Availability,"ty_Re40_dx04_small_paper](https://user-images.githubusercontent.com/67593861/108130156-2f329880-707d-11eb-87db-6d519e2513be.gif); ; The barebones of this implementation is rather old at this point. Even though it has been updated to work with the current set up, I imagine there are things that might still need more updating or have become superfluous. All suggestions are appreciated!. ### Description:; Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. In practice, when your boundary conforms to the grids, creating a stair-step like boundary, this becomes much simpler to handle. Here, we replace the tendency terms in `correct_immersed_tendencies.jl` so that when you take the next Runge-Kutta step, you end up with U = 0. . Since this process occurs before the pressure correction, there is a small amount of error that seems to fit with the correction as seen here for various places within the cylinder where it should be zero:; ![Pcorrect_vs_velocity_inside_dx04](https://user-images.githubusercontent.com/67593861/108130321-7ae54200-707d-11eb-9101-273350597d8c.png); ; It would need more testing to truly verify that this is the case, but seems to fit the data so far. ### To Do/ Upcoming:; - Currently working on an arbitrary grid implementation, that can intersect the boundary however it wants. This involves a good amount of interpolation, but it well on the way. This implementation will easily handle Neumann and Dirichlet boundary conditions. It makes more sense for normal and tangential boundary conditions rather than specific (u,v,w) conditions, so we will also project the velocities along with interpolating.; - Need to add a way for the user to specify boundary conditions; - Add tracer capabilities. The implementation is slightly different for arbitrary grids, since tracers will be a scalar that is not rotated into normal and tangent",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1368:1527,error,error,1527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368,1,['error'],['error']
Availability,"type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}:; ERROR: MethodError: no method matching seamount2(::Float64, ::Float64); Closest candidates are:; seamount2(::Any, ::Any, ::Any) at REPL[6]:1; Stacktrace:; [1] is_immersed; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl:38 [inlined]; [2] solid_node; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/immersed_grid_metrics.jl:35 [inlined]; [3] solid_interface; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/immersed_grid_metrics.jl:38 [inlined]; [4] get_condition; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/immersed_fields_reductions.jl:28 [inlined]; [5] getindex; @ ~/Software/Oceananigans.jl/src/AbstractOperations/conditional_operations.jl:109 [inlined]; [6] getindex; @ ./subarray.jl:276 [inlined]; [7] _getindex; @ ./abstractarray.jl:1214 [inlined]; [8] getindex; @ ./abstractarray.jl:1170 [inlined]; [9] map!(f::typeof(identity), dest::Array{Float64, 3}, A::SubArray{Float64, 3, Oceananigans.AbstractOperations.ConditionalOperati; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2250:2409,ERROR,ERROR,2409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250,1,['ERROR'],['ERROR']
Availability,"unded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> seamount2(x, y, z) = z < - 1 + h0*exp(-y^2/L^2); seamount2 (generic function with 1 method). julia> grid_with_seamount2 = ImmersedBoundaryGrid(grid, GridFittedBottom(seamount2)); ┌ Warning: ImmersedBoundaryGrid is unvalidated and may produce incorrect results. Help validate ImmersedBoundaryGrid by reporting any bugs or unexpected behavior to https://github.com/CliMA/Oceananigans.jl/issues.; └ @ Oceananigans.ImmersedBoundaries ~/Software/Oceananigans.jl/src/ImmersedBoundaries/ImmersedBoundaries.jl:110; ImmersedBoundaryGrid on: ; architecture: CPU(); grid: 1×16×8 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; with immersed: GridFittedBottom{typeof(seamount2)}. julia> c2 = CenterField(grid_with_seamount2); Error showing value of type Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{typeof(seamount2)}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}:; ERROR: MethodError: no method matching seamount2(::Float64, ::F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2250:1382,Error,Error,1382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2250,1,['Error'],['Error']
Availability,"uple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, LagrangianParticles{StructVector{CustomParticle, NamedTuple{(:x, :y, :z, :T), NTuple{4, Vector{Float64}}}, Int64}, Float64, NamedTuple{(:T,), Tuple{Vector{Float64}}}, typeof(Oceananigans.Models.LagrangianParticleTracking.no_dynamics), Nothing}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Float64); @ Oceananigans.Models.LagrangianParticleTracking ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/update_lagrangian_particle_properties.jl:31; [10] step_lagrangian_particles!; @ ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:137 [inlined]; [11] step_lagrangian_particles!. ```. (2) I also ran (x,y,z) position tracking only while immersed boundary was active. There was a method error relating to cpu__advect_particle >>advect_lagrangian_particles:. ```Julia. ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(2000,)}, KernelAbstractions.NDIteration.DynamicCheck, CartesianIndex{1}, Nothing, KernelAbstractions.NDIteration.NDRange{1, KernelAbstractions.NDIteration.StaticSize{(8,)}, KernelAbstractions.NDIteration.StaticSize{(256,)}, Nothing, Nothing}}, ::StructVector{Oceananigans.Models.LagrangianParticleTracking.Particle, NamedTuple{(:x, :y, :z), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}}, Int64}, ::Float64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:31796,ERROR,ERROR,31796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['ERROR'],['ERROR']
Availability,"ure(::Array) at /home/alir/Oceananigans.jl/src/Architectures.jl:46; architecture(::CUDA.CuArray) at /home/alir/Oceananigans.jl/src/Architectures.jl:47; architecture(::Field) at /home/alir/Oceananigans.jl/src/Fields/field.jl:167; ...; Stacktrace:; [1] Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims::Tuple{Int64,Int64}, iteration_interval::Nothing, time_interval::Nothing, return_type::Type{T} where T) at /home/alir/Oceananigans.jl/src/Diagnostics/average.jl:52; [2] top-level scope at REPL[17]:1; ```. New error (more useful):; ```; ERROR: MethodError: no method matching Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims=(1, 2), return_type=Array); Closest candidates are:; Average(::Oceananigans.AbstractOperations.AbstractOperation, ::Oceananigans.Models.AbstractModel; dims, kwargs...) at /home/alir/Oceananigans.jl/src/AbstractOperations/computations.jl:98; Average(::Oceananigans.AbstractOperations.AbstractOperation, ::Any; dims, kwargs...) at /home/alir/Oceananigans.jl/src/AbstractOperations/computations.jl:86; Average(::F, ::D, ::P, ::I, ::T, ::Float64, ::R) where {F, R, D, P, I, T} at /h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/858:1941,error,error,1941,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:4309,Down,Downgrading,4309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,3,"['Down', 'down', 'error']","['Downgrading', 'down', 'errors']"
Availability,"ux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, typeof(abs), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Oceananigans.ImmersedBoundaries.NotImmersed{typeof(Oceananigans.AbstractOperations.truefunc)}, Float64, Float64}; condition::Nothing, mask::Float64, kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:init,), Tuple{Bool}}}); │ @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/i1inK/src/Fields/field.jl:581; │ [24] maximum(f::Function, c::Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, GPU}, Tuple{Colon,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:15888,mask,mask,15888,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['mask'],['mask']
Availability,"validation/barotropic/barotropic.jl currently errors when you try and run it. 1. The Flux() type is not imported; 2. The explicit stepper and timestep aren't in sync and code NaNs. The timestep is set for implicit free surface. . These two tweaks make it run and produce something ""reasonable"". ; It could be good to have it set so it runs as cloned?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1717:46,error,errors,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717,1,['error'],['errors']
Availability,"variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:1381,recover,recover,1381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,2,"['error', 'recover']","['error', 'recover']"
Availability,"w model that is identical to the previous one but with extra tracers, manually `set!()` the prognostic fields from the checkpoint file, and then run that model. This works as intended, but as I've realized since then it's got a few downsides. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest i",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:1334,down,downside,1334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,1,['down'],['downside']
Availability,"x, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Field{Center, Center, Face, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}}}}}, Float64}}:; ERROR: MethodError: no method matching operation_name(::KernelFunctionOperation{Center, Center, Center, Nothing, CPU, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, typeof(isotropic_viscous_dissipation_rate_ccc), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1761:5834,ERROR,ERROR,5834,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1761,1,['ERROR'],['ERROR']
Availability,"x=Ny=150; Nz=12; Lx=Ly=400; Lz=100. z_faces(k) = Lz * (k - 1)/Nz. grid_base = RectilinearGrid(GPU(),; size=(Nx, Ny, Nz),; x=(-Lx/2, Lx/2), y=(-Ly/2, Ly/2),; z=z_faces,; halo=(4,4,4),; ). bathymetry(x, y) = Lz/2; grid = ImmersedBoundaryGrid(grid_base, GridFittedBottom(bathymetry)). background_viscosity = ScalarDiffusivity(ν=1e-4, κ=1e-4); closure = (background_viscosity, SmagorinskyLilly(C=0.13, Pr=1)). model = NonhydrostaticModel(grid = grid, timestepper = :RungeKutta3,; advection = WENOFifthOrder(grid_base),; tracers = :b,; closure = closure,; ). @info maximum(abs, model.velocities.u); ```. The error happens in the last line of the script:. ```; ┌ Error: Exception while generating log record in module Main at /glade/scratch/tomasc/twake2/simulations/mwe2.jl:38; │ exception =; │ CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); │ Stacktrace:; │ [1] throw_api_error(res::CUDA.cudaError_enum); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:89; │ [2] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/error.jl:97 [inlined]; │ [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); │ @ CUDA /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/utils/call.jl:26; │ [4] #39; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:69 [inlined]; │ [5] macro expansion; │ @ /glade/work/tomasc/.julia/packages/CUDA/DfvRa/lib/cudadrv/execution.jl:33 [inlined]; │ [6] macro expansion; │ @ ./none:0 [inlined]; │ [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2756:1548,error,error,1548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2756,1,['error'],['error']
Availability,"yInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:1154,ERROR,ERROR,1154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,1,['ERROR'],['ERROR']
Availability,"ype that looks something like. ```julia; struct FunctionOperand{F, G, A}; func :: F; grid :: G; args :: A; end. @inline Base.getindex(o::FunctionOperand, i, j, k) = o.func(i, j, k, o.grid, o.args...); ```. This works because the kernel that computes a `ComputedField`'s data is. https://github.com/CliMA/Oceananigans.jl/blob/c5f47e01ef0fab0cd1e99260e578ace7ad04084c/src/Fields/computed_field.jl#L85-L88. Then with a bit of boilerplate we can define constructors for all the terms we might need, eg. ```julia; TendencyTermField(X, Y, Z, term_func, grid; args, data=nothing) =; ComputedField{X, Y, Z}(FunctionOperand(term_func, grid, args), data=data). using Oceananigans.Advection: momentum_flux_uu, momentum_flux_uw. uu = TendencyTermField(Cell, Cell, Cell, momentum_flux_uu, grid, args=(model.advection, model.velocities.u, model.velocities.u)); wu = TendencyTermField(Cell, Cell, Face, momentum_flux_uw, grid, args=(model.advection, model.velocities.w, model.velocities.u)); ```. We probably want to define aliases for all the terms that appear in our tendency equations, as well as the advective and diffusive fluxes, so that we can ensure they are correct and correctly located on the staggered grid. Unfortunately this does involve a lot of boiler plate and introduces a maintenance and testing burden. If we can push responsibility more to users I am open to that, but I'm not 100% how to make this process more programmatic. Ideas very welcome. If functions like `momentum_flux_uu` are going to emerge from darkness into users' scripts, we may want to have a discussion about whether our names / naming convention is sensible. By the way, `ComputedField` seems to assume that `operand` has a property called `grid`:. https://github.com/CliMA/Oceananigans.jl/blob/c5f47e01ef0fab0cd1e99260e578ace7ad04084c/src/Fields/computed_field.jl#L43-L47. We could create a type called `AbstractOperand`, of which `AbstractOperation` (and other concrete operands) are subtypes. cc @qingli411, @BrodiePearson",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1073:1867,mainten,maintenance,1867,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1073,1,['mainten'],['maintenance']
Availability,"ypes:. ```julia; julia> using Oceananigans, Oceananigans.Fields, Oceananigans.AbstractOperations. julia> arch = CPU(); grid = RegularCartesianGrid(size=(16, 16, 16), length=(1, 1, 1));. julia> c, d = (CellField(arch, grid) for i=1:2);. julia> e = @at (Face, Cell, Cell) c * d; BinaryOperation at (Face, Cell, Cell); ├── grid: RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}; │ ├── size: (16, 16, 16); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: . * at (Face, Cell, Cell) via ℑxᶠᵃᵃ; ├── OffsetArray{Float64, 3, Array{Float64,3}}; └── OffsetArray{Float64, 3, Array{Float64,3}}; ```. notice that the ""location"" is specified with `(Face, Cell, Cell)`. Boundary conditions are different:. ```julia; julia> bc = FieldBoundaryConditions(grid, (Cell, Cell, Cell), north=BoundaryCondition(Value, 1.0)); ERROR: MethodError: no method matching DefaultBoundaryCondition(::Bounded, ::Type{Cell}); Closest candidates are:; DefaultBoundaryCondition(::Bounded, ::Face) at /Users/gregorywagner/.julia/packages/Oceananigans/Pyzcd/src/BoundaryConditions/field_boundary_conditions.jl:20; DefaultBoundaryCondition(::Bounded, ::Cell) at /Users/gregorywagner/.julia/packages/Oceananigans/Pyzcd/src/BoundaryConditions/field_boundary_conditions.jl:19; DefaultBoundaryCondition(::Union{Flat, Periodic}, ::Any) at /Users/gregorywagner/.julia/packages/Oceananigans/Pyzcd/src/BoundaryConditions/field_boundary_conditions.jl:17; Stacktrace:; [1] (::Core.var""#kw#Type"")(::NamedTuple{(:north,),Tuple{BoundaryCondition{Value,Float64}}}, ::Type{NamedTuple{(:x, :y, :z),T} where T<:Tuple}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}, ::Tuple{DataType,DataType,DataType}) at ./none:0; [2] top-level scope at REPL[13]:1; ```. while this works:. ```julia; julia> bc = FieldBoundaryConditions(grid, (Cell(), Cell(), Cell()), nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/659:1046,ERROR,ERROR,1046,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/659,1,['ERROR'],['ERROR']
Availability,"zard, stop_time=40minutes, iteration_interval=10,); Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}): 10 seconds ; ├── Iteration interval: 10; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 40 minutes, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with no entries. julia> AdvectiveCFL(simulation.Δt)(model); NaN. julia> DiffusiveCFL(simulation.Δt)(model); ERROR: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(x::VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, f::Symbol); @ Base ./Base.jl:33; [2] min_Δxyz(grid::VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.TurbulenceClosures ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:12; [3] cell_diffusion_timescale(closure::AnisotropicMinimumDissipation{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Float; ```; and the error continues. . Basically I think we just need to define `min_Δxyz` for `VerticallyStretchedGrid`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1749:2910,ERROR,ERROR,2910,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1749,2,"['ERROR', 'error']","['ERROR', 'error']"
Availability,"{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}); @ Oceananigans.OutputWriters /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:246; [5] set_time_stepper!(timestepper::Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:14629,checkpoint,checkpointer,14629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['checkpoint'],['checkpointer']
Availability,"{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}); @ Oceananigans.OutputWriters /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:265; [6] (::Oceananigans.OutputWriters.var""#52#53""{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:28725,checkpoint,checkpointer,28725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['checkpoint'],['checkpointer']
Availability,"{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}, LagrangianParticles{StructVector{CustomParticle, NamedTuple{(:x, :y, :z, :T), NTuple{4, Vector{Float64}}}, Int64}, Float64, NamedTuple{(:T,), Tuple{Vector{Float64}}}, typeof(Oceananigans.Models.LagrangianParticleTracking.no_dynamics), Nothing}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, Δt::Float64); @ Oceananigans.Models.LagrangianParticleTracking ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/update_lagrangian_particle_properties.jl:31; [10] step_lagrangian_particles!; @ ~/.julia/packages/Oceananigans/17XSY/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:137 [inlined]; [11] step_lagrangian_particles!. ```. (2) I also ran (x,y,z) position tracking only while immersed boundary was active. There was a method error relating to cpu__advect_particle >>advect_lagrangian_particles:. ```Julia. ERROR: LoadError: MethodError: no method matching cpu__advect_particles!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(2000,)}, KernelAbstractions.NDIteration.DynamicCheck, CartesianIndex{1}, Nothing, KernelAbstractions.NDIteration.NDRange{1, KernelAbstractions.NDIteration.StaticSize{(8,)}, KernelAbstractions.NDIteration.StaticSize{(256,)}, Nothing, Nothing}}, ::StructVector{Oceananigans.Models.LagrangianParticleTracking.Particle, NamedTuple{(:x, :y, :z), Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}}}, Int64}, ::Float64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:31715,error,error,31715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['error'],['error']
Availability,"}, Tuple{UnitRange{Int64}}, true}, first::Int64, last::Int64); @ Base ./reduce.jl:638; [7] _mapreduce(f::typeof(identity), op::typeof(min), #unused#::IndexLinear, A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, Tuple{UnitRange{Int64}}, true}); @ Base ./reduce.jl:442; [8] _mapreduce_dim; @ ./reducedim.jl:365 [inlined]; [9] #mapreduce#765; @ ./reducedim.jl:357 [inlined]; [10] mapreduce; @ ./reducedim.jl:357 [inlined]; [11] #_minimum#787; @ ./reducedim.jl:999 [inlined]; [12] _minimum; @ ./reducedim.jl:999 [inlined]; [13] #_minimum#786; @ ./reducedim.jl:998 [inlined]; [14] _minimum; @ ./reducedim.jl:998 [inlined]; [15] #minimum#784; @ ./reducedim.jl:994 [inlined]; [16] minimum; @ ./reducedim.jl:994 [inlined]; [17] min_Δx; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653 [inlined]; ```. `min_Δx` triggers scalar indexing. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_compute_ri_based_diffusivities!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 2240, 69)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(64, 140, 69)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, NamedTuple{(:\u03ba\u1d9c, :\u03ba\u1d58), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded, LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:3484,ERROR,ERROR,3484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['ERROR'],['ERROR']
Availability,"λx, :λy, :λz), Tuple{Array{Float64, 3}, Array{Float64, 3}, Array{Float64, 3}}}, PencilArrays.ManyPencilArray{ComplexF64, 3, 3, Tuple{PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.NoPermutation, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(2, 1, 3), 3}, Vector{UInt8}}}, PencilArrays.PencilArray{ComplexF64, 3, Base.ReshapedArray{ComplexF64, 3, SubArray{ComplexF64, 1, Vector{ComplexF64}, Tuple{Base.OneTo{Int64}}, true}, Tuple{}}, 3, 0, PencilArrays.Pencils.Pencil{3, 2, StaticPermutations.Permutation{(3, 2, 1), 3}, Vector{UInt8}}}}, Vector{ComplexF64}}}); @ Oceananigans.Distributed ~/.julia/packages/Oceananigans/nqpMM/src/Distributed/distributed_fft_based_poisson_solver.jl:65; ```; ... the error continues. Also, this part of the distributed tests is currently passing 1.6: https://github.com/CliMA/Oceananigans.jl/blob/00c98a72943cfaaa3b034770561b7ed6a408de40/test/test_distributed_models.jl#L469-L473. But fails on Julia 1.7 with the same error that I get (part of the reason why https://github.com/CliMA/Oceananigans.jl/pull/2307 isn't ready): https://buildkite.com/clima/oceananigans/builds/6202#6f169fce-d4b4-43e6-947e-fade1e4c7ad3/19-1203. At first I thought this was a limitation of `PencilArrays.jl`, which is why I created https://github.com/jipolanco/PencilArrays.jl/issues/49. But from the answer I got there that doesn't seem to be the case. I don't fully understand [the answer](https://github.com/jipolanco/PencilArrays.jl/issues/49#issuecomment-1100907232), but it makes me think that something might be up with our distributed architecture implementation and it'd be nice to get some other eyes here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2445:14828,error,error,14828,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2445,2,['error'],['error']
Availability,"ᶜᶜᶜ()` is only defined for the AMD closure, so for every other closure it silently defaults to https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_utils.jl#L33. So one obvious thing is that we definitely should define `calc_κᶜᶜᶜ()` for other closures. A bigger question regards the use of multiple dispatch to create this ""default"" behavior for when the desired behavior isn't implemented yet. In this case, silently defaulting to `zero()` made be lose some hours of work because I thought there was something wrong with my script, when in reality `calc_κᶜᶜᶜ()` just wasn't defined for the closure I was using. Sure, this is a bit my fault for not checking the code thoroughly, but from a user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751:1167,error,error,1167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751,1,['error'],['error']
Deployability, /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 26236174 (Pool: 26209699; Big: ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:5383,release,release-,5383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['release'],['release-']
Deployability," Forcing(wonky_forcing). forcing = (; u=MultipleForcings((forcing1, forcing2))). model = HydrostaticFreeSurfaceModel(; grid, forcing); ```. produces this error:. ```; ERROR: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::LatitudeLongitudeGrid{…}, ::@NamedTuple{…}, ::Nothing, ::Nothing). Closest candidates are:; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:8; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{T, T} where T); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:4; field_arguments(::Any, ::Any, ::Any, ::Any, ::Any, ::Any, ::Tuple{Any}); @ Oceananigans ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:1; ... Stacktrace:; [1] user_function_arguments; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Utils/user_function_arguments.jl:21 [inlined]; [2] ContinuousForcing; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/continuous_forcing.jl:137 [inlined]; [3] MultipleForcings; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Forcings/multiple_forcings.jl:32 [inlined]; [4] hydrostatic_free_surface_u_velocity_tendency; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl:46 [inlined]; [5] cpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/3B1v2/src/macros.jl:291 [inlined]; [6] cpu_compute_hydrostatic_free_surface_Gu!(__ctx__::KernelAbstractions.CompilerMetadata{…}, Gu::Field{…}, grid::LatitudeLongitudeGrid{…}, map::Nothing, args::Tuple{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ./none:0; [7] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ Ker",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3736:1624,Continuous,ContinuousForcing,1624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736,1,['Continuous'],['ContinuousForcing']
Deployability," LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u"", backend = Chunked(chunk_size = 4)); 17×16×10×100 FieldTimeSeries{Chunked} located at (Face, Center, Center) on CPU; ├── grid: 16×16×10 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── indices: (Colon(), Colon(), Colon()); └── data: 23×22×16×4 OffsetArray(::Array{Float64, 4}, -2:20, -2:19, -2:13, 1:4) with eltype Float64 with indices -2:20×-2:19×-2:13×1:4; └── max=8.0, min=0.0, mean=1.67984; ```. This is not final and all open to suggestions/changes/improvement. maybe interesting for @yuchenma23",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:1766,update,update,1766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['update'],['update']
Deployability," OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}}, Nothing}, Float64}}}}}, NamedTuple{(:u, :v, :w, :b, :τ1, :τ2), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_u), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}, Oceananigans.Forcings.ContinuousForcing{Center, Face, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_v), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity4)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Face, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_w), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity5)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:σ, :u₀, :α), Tuple{Int64, Int64, Float64}}, typeof(sponge_b), Nothing, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}}}; name::String, kwargs::Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:299; [6] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:102 [inlined]; [7] (::KernelAbstractions.Kernel{CUDAKernels.CUDADevice, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!)})(::Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:9091,Continuous,ContinuousForcing,9091,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['Continuous'],['ContinuousForcing']
Deployability, advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2546,release,release-,2546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability," interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and `set!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1011:1957,Continuous,ContinuousForcing,1957,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011,1,['Continuous'],['ContinuousForcing']
Deployability," only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally acros",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:2096,integrat,integrate,2096,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['integrat'],['integrate']
Deployability,"### Discussed in https://github.com/CliMA/Oceananigans.jl/discussions/2527. Probably, there are some bugs related to update in CUDA from 3.3.6 to 3.9. <div type='discussions-op-text'>. <sup>Originally posted by **parfenyev** May 6, 2022</sup>; Hello,. I am trying to create model using GPU to play around. Below is my code:; ```; using Oceananigans, Statistics, Printf, Oceananigans.Units. grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)). # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); v_forcing(x, y, z, t) = -0.01*cos(5*x). # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); ```; It works when I change GPU to CPU in the `RectilinearGrid`, but fails in the current state:; ```; InvalidIRError: compiling kernel gpu__fill_south_and_north_halo!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1024, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(64, 1)}, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, Nothing, Nothing}}, Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}, Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530:117,update,update,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530,1,['update'],['update']
Deployability,(0.91.8) bug fix release,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3709:17,release,release,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3709,1,['release'],['release']
Deployability,(0.91.9) Bumps patch number,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3722:15,patch,patch,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3722,1,['patch'],['patch']
Deployability,(0.93.2) Update Adapt.jl compat and fix `Float32` CATKE on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876:9,Update,Update,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876,1,['Update'],['Update']
Deployability,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:77,upgrade,upgrade,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['upgrade'],['upgrade']
Deployability,"* ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2120,release,release-,2120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,"+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8810,release,release-,8810,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,", z) = T0(z) + dTdz * model.grid.Lz * 1e-6 * Ξ(z). ## `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=S₀); ```; When I tried to output `model.pressures.prapid`, I got:. ```julia; 100×100×48 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 100×100×48 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 106×106×54 OffsetArray(::Array{Float64, 3}, -2:103, -2:103, -2:51) with eltype Float64 with indices -2:103×-2:103×-2:51; └── max=NaN, min=NaN, mean=NaN; ```; The NaN value appears. But for $p_{NHS}$ and $p_{HY'}$, the results are reasonable. So any comments or ideas about this error? . Another issue is about the calculation of the pressure terms for which the boundary conditions are inhomogeneous Neumann boundary conditions ($p_b'$, $p_{st}'$ and $p_{sg}'$, see Appendix A for details in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). For this issue, I have checked the related issue #1232. I wanna ask do I need to subtly update the boundary values of $p_b'$, $p_{st}'$ and $p_{sg}'$ to convert the inhomogeneous Neumann problem to the homogeneous Neumann problem? If so, how do I determine the values the boundary should update?. I hope I've described this issue clearly, but please let me know if anything confuse you. In addition, this is my first attempt to make a possible contribution to an open source project, and I would like to ask what is the most efficient way to conduct the discussion? Should we talk about this here firstly or can I start with a PR to better let you know what specific changes I've made to the code?. Thank you very much for any comments, suggestions or ideas!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:9481,update,update,9481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,2,['update'],['update']
Deployability,"- `Docs/Physics/HydrostaticFreeSurfaceModel`; At the moment docs mention that we obtain $w(x, y, z, t)$ by integrating the mass conservation equation from bottom to top but we need to integrate from bottom to depth $z$. This PR fixes this. - `Docs/Physics/NonHydrostaticModel`; The rotation rate term due to surface waves was missing a sign.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3150:107,integrat,integrating,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3150,2,['integrat'],"['integrate', 'integrating']"
Deployability,-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8099,release,release-,8099,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5884,release,release-,5884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,".BuoyancyModels.ZDirection}, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing); @ Oceananigans.Models.IncompressibleModels ~/.julia/packages/Oceananigans/IxOwr/src/Models/IncompressibleModels/incompressible_model.jl:142; [28] top-level scope; @ REPL[4]:1; [29] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```julia; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); ```. ```julia; julia> CUDA.versioninfo(); CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; ┌ Warning: Could not find or load CUDNN; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:354; - CUDNN: missing; ┌ Warning: Could not find or load CUTENSOR; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:409; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 29.284 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 24.457 GiB / 31.749 GiB available); ```. ```julia; (@v1.6) pkg> st; Status `~/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:6852,install,installation,6852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['install'],['installation']
Deployability,".Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, ; ```. I'm not very familiar with hydrostatic models. Is this a bug o",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711:57195,Continuous,ContinuousBoundaryFunction,57195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,".Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, ImmersedBoundaryCondition{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(τˣᶻ_drag), Nothing, Tuple{Symbol, Symbol, Symbol}, Tuple{Int64, Int64, Nothing}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, Nothing}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2711:40216,Continuous,ContinuousBoundaryFunction,40216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2711,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,".LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, ::ScalarDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.ThreeDimensionalFormulation, Float64, NamedTuple{(:b,), Tuple{Float64}}}, ::Nothing, ::Nothing, ::Clock{Float64}, ::NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:7726,Continuous,ContinuousBoundaryFunction,7726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,".LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:10865,Continuous,ContinuousBoundaryFunction,10865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,".OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(drag_w), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.Fields.ZeroField{Int64, 3}}}}}}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/sZvJo/src/cpu.jl:82. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:63017,Continuous,ContinuousBoundaryFunction,63017,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,".c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Inf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8611,release,release-,8611,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,.jl/src/DistributedComputations/halo_communication.jl:317; #fill_south_and_north_halo!#50 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:263; fill_south_and_north_halo! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:250; unknown function (ip: 0x2aaac8afa8b6); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_event!#40 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:208; fill_halo_event! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:193; unknown function (ip: 0x2aaac8aefb2e); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:3126,release,release-,3126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['release'],['release-']
Deployability,/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_i,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6861,release,release-,6861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,"/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iterati",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8720,release,release-,8720,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,"/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17..",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:9016,release,release-,9016,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdc,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5992,release,release-,5992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,01/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4630,release,release-,4630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['release'],['release-']
Deployability,"096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────────┴─────────┴─────────┘. Shallow water model weak multithreading scaling speedup; ┌───────────────┬─────────┬──────────┬────────────┬─────────┬─────────┐; │ size │ threads │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼─────────┼──────────┼────────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 1024) │ 2 │ 2.01669 │ 0.495862 │ 15.7412 │ 562.205 │; │ (8192, 2048) │ 4 │ 1.45397 │ 0.687771 │ 11.9861 │ 406.533 │; │ (8192, 4096) │ 8 │ 1.51106 │ 0.661786 │ 13.0337 │ 425.838 │; │ (8192, 8192) │ 16 │ 1.52536 │ 0.655582 │ 13.4078 │ 397.94 │; │ (8192, 16384) │ 32 │ 1.79793 │ 0.556195 │ 17.7701 │ 481.816 │; └───────────────┴─────────┴──────────┴────────────┴─────────┴─────────┘. ```; They're not terrific, but they're decent. I am running these on 32 CPUs, so what I assume is 1 thread per CPU up to 32 threads. The slight increase in efficiency going from 2 to 4 threads is likely some flat overhead being overcome by actual efficiency increase of multithreading. ; @christophernhill @glwagner is there anything we can do to improve multithreading efficiency for Oceananigans? It might not be as simple as adding `@threads` in front of the main for loops but with just a little bit of improvement then multithreading efficiency might just match MPI efficiency.; As it is, multithreading is already a worthwhile option to achieve speedups on systems with multiple CPUs but no MPI. So far I've only run the scripts on one node up to 32 threads and CPUs. I'll update this issue with the result of running it on multiple nodes going up to 64 or maybe 128 CPUs just to see if efficiency is affected going from one node to more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861:3537,update,update,3537,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861,1,['update'],['update']
Deployability,0a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5041,release,release-,5041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,10-100x slowdown on CPU after upgrade to KernelAbstractions 0.8 (due to type inference failure?),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996:30,upgrade,upgrade,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996,1,['upgrade'],['upgrade']
Deployability,10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4071,release,release-,4071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,"6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite judiciously so we don't have to manually format as many references.; 3. Work on a general solution that integrates with Documenter. I'm leaning towards option 2. EDIT: @johncmarshall54 argues in favor of option 1, which I'm now leaning towards as well. ## Examples. Thanks @glwagner for writing all the examples, they generate beautiful tutorials that we can directly embed in the documentation!. 1. I had to modify the examples slightly as Documenter.jl will only show plots returned using `gcf()`.; 2. We should define a `show` function for `Model` as the current output pollutes all the examples.; 3. The two ocean convection examples take forever to compile to docs because they generate movies and Documenter might be trying to embed each frame as a separate image or something. It might be worth discussing whether we should just make all the examples Documenter/tutorial friendly, which means switching from movies to plotting a few frames. ## Some comments; 0. Unfortunately if we want to look at the docs, we have to build it locally for now =/; 1. Documenter uses KaTeX to render math, which",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:2105,integrat,integrates,2105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,1,['integrat'],['integrates']
Deployability,"64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_w), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑyzᵃᶜᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:T, :S), Tuple{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:17540,Continuous,ContinuousBoundaryFunction,17540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_v), NamedTuple{(:cᴰ,), Tuple{Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Value, Float64}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Bounded, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:16029,Continuous,ContinuousBoundaryFunction,16029,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Nothing, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑxzᶠᵃᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_u), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑxᶠᵃᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:6676,Continuous,ContinuousBoundaryFunction,6676,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,2,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"933] p7zip_jll v17.4.0+2; Info Packages marked with ⌃ and ⌅ have new versions available. Those with ⌃ may be upgradable, but those with ⌅ are restricted by compatibility constraints from upgrading.; Testing Running tests...; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:12221,Release,Release,12221,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Release'],['Release']
Deployability,": [003.75%] i: 135, time: 22.500 minutes, Δt: 10 seconds, wall time: 5.087 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [003.89%] i: 140, time: 23.333 minutes, Δt: 10 seconds, wall time: 5.226 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.03%] i: 145, time: 24.167 minutes, Δt: 10 seconds, wall time: 5.365 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.17%] i: 150, time: 25.000 minutes, Δt: 10 seconds, wall time: 5.504 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.31%] i: 155, time: 25.833 minutes, Δt: 10 seconds, wall time: 5.643 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.44%] i: 160, time: 26.667 minutes, Δt: 10 seconds, wall time: 5.782 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.58%] i: 165, time: 27.500 minutes, Δt: 10 seconds, wall time: 5.921 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.72%] i: 170, time: 28.333 minutes, Δt: 10 seconds, wall time: 6.060 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.86%] i: 175, time: 29.167 minutes, Δt: 10 seconds, wall time: 6.199 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; ```. While for Julia 1.6 this is the output after the same amount of wall time:. ```julia; [ Info: ---> Starting run!; [ Info: [000.14%] i: 5, time: 50.000 seconds, Δt: 10 seconds, wall time: 3.453 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [000.28%] i: 10, time: 1.667 minutes, Δt: 10 seconds, wall time: 4.388 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [000.42%] i: 15, time: 2.500 minutes, Δt: 10 seconds, wall time: 5.269 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [000.56%] i: 20, time: 3.333 minutes, Δt: 10 seconds, wall time: 6.150 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; ```. Has someone else experienced this?. Any ideas as to what might be causing it? I really would like to upgrade my production ready scripts but there's no way I can do it until this issue is resolved unfortunately :/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764:7096,upgrade,upgrade,7096,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764,1,['upgrade'],['upgrade']
Deployability,; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /h,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2823,release,release-,2823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,"; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:2633,release,release,2633,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['release'],['release']
Deployability,"</a></li>; </ul>; </details>; <br />. [![Dependabot compatibility score](https://dependabot-badges.githubapp.com/badges/compatibility_score?dependency-name=julia-actions/setup-julia&package-manager=github_actions&previous-version=1&new-version=2)](https://docs.github.com/en/github/managing-security-vulnerabilities/about-dependabot-security-updates#about-compatibility-scores). Dependabot will resolve any conflicts with this PR as long as you don't alter it yourself. You can also trigger a rebase manually by commenting `@dependabot rebase`. [//]: # (dependabot-automerge-start); [//]: # (dependabot-automerge-end). ---. <details>; <summary>Dependabot commands and options</summary>; <br />. You can trigger Dependabot actions by commenting on this PR:; - `@dependabot rebase` will rebase this PR; - `@dependabot recreate` will recreate this PR, overwriting any edits that have been made to it; - `@dependabot merge` will merge this PR after your CI passes on it; - `@dependabot squash and merge` will squash and merge this PR after your CI passes on it; - `@dependabot cancel merge` will cancel a previously requested merge and block automerging; - `@dependabot reopen` will reopen this PR if it is closed; - `@dependabot close` will close this PR and stop Dependabot recreating it. You can achieve the same result by closing it manually; - `@dependabot show <dependency name> ignore conditions` will show all of the ignore conditions of the specified dependency; - `@dependabot ignore this major version` will close this PR and stop Dependabot creating any more for this major version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this minor version` will close this PR and stop Dependabot creating any more for this minor version (unless you reopen the PR or upgrade to it yourself); - `@dependabot ignore this dependency` will close this PR and stop Dependabot creating any more for this dependency (unless you reopen the PR or upgrade to it yourself). </details>",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:9979,upgrade,upgrade,9979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,3,['upgrade'],['upgrade']
Deployability,"<a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""https://github.com/julia-actions/setup-julia/commit/f2258781c657ad9b4b88072c5eeaf9ec8c370874""><code>f225878</code></a> Add production dependenc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:5928,install,install,5928,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,1,['install'],['install']
Deployability,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:1751,configurat,configuration,1751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,2,['configurat'],['configuration']
Deployability,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1894#issuecomment-885979847_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895:295,integrat,integrator,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895,3,"['continuous', 'integrat']","['continuous', 'continuously', 'integrator']"
Deployability,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1075:147,update,update,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075,2,['update'],['update']
Deployability,@JuliaRegistrator register(). Bug fix #322 was pretty important so releasing a new patch.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/331:83,patch,patch,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/331,1,['patch'],['patch']
Deployability,@JuliaRegistrator register(). Bug fix in PR #337 is important for GPU usability so releasing a new patch.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/339:99,patch,patch,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/339,1,['patch'],['patch']
Deployability,@JuliaRegistrator register(). The sophisticated `set!` function introduced in PR #343 is important for usability so releasing a new patch that incorporates it.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/345:132,patch,patch,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/345,1,['patch'],['patch']
Deployability,"@christophernhill @glwagner @weymouth ; I have been looking into what is the best way to implement an immersed boundary method here, and I hope to be able to model complex topography and possibly moving boundaries with it, for at least Dirichlet and Neumann boundary conditions, within the next year. The immersed boundary method (IBM) is a way to deal with complex topography without a complicated mesh or coordinate transformations. Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning tow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036:817,Continuous,Continuous,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036,2,"['Continuous', 'continuous']","['Continuous', 'continuous']"
Deployability,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:293,update,update,293,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['update'],['update']
Deployability,"@glwagner and @simone-silvestri : . I updated the Overleaf document to include what form of viscosity we should be using. In summary, following [Gent (1993) ](https://www.cgd.ucar.edu/staff/gent/swe.pdf), I think the should choose the viscosity for `ShallowWaterModel` to be. ν/h ∇⋅ ( h ∇ 𝐯 ) . The reasons he states are as follows:. - h ∇ 𝐯 is a parameterization of the turbulent flux and therefore should be proportional to the depth.; - This ensures that the diffusion of momentum is in the form of the divergence of a stress tensor (Schar and Smith 1993); - It has a negative definite effect on the KE budget if the viscous boundary condition is either no slip or free slip. Of course a problem occurs where h=0 but I guess we just don't apply viscosity where there is no fluid. If we wanted to generalize this to biharmonic viscosity, I would guess the following, . ν/h ∇² ( h ∇² 𝐯) . but this is something that should be done later, of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403:38,update,updated,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403,1,['update'],['updated']
Deployability,@glwagner suggested that this test could pass at t=0 but fail for t>0 in certain situations (not yet isolated). We should upgrade this test to include some time dependence. https://github.com/climate-machine/Oceananigans.jl/blob/22088d335973553b298a67bacebfa80b32e66acf/test/test_diagnostics.jl#L1-L15,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/737:122,upgrade,upgrade,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/737,1,['upgrade'],['upgrade']
Deployability,@jm-c also pointed out that I forgot to update the indices in computing the friction velocity in `stratified_couette_flow.png` after the k index was reversed.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/597:40,update,update,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/597,1,['update'],['update']
Deployability,@simone-silvestri I tried to update this script but still it won't run. Could you have a look?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985:29,update,update,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985,1,['update'],['update']
Deployability,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684:66,update,updated,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684,1,['update'],['updated']
Deployability,A bug in the limiting by `maximum_diffusivity` caused this scheme to blow up in default configuration (and be generally incorrect). This PR fixes that and makes a few more tweaks: horizontal filtering can be optionally added (and we implement an interface for adding new horizontal filters). We also add a minimum entrainment buoyancy gradient. Closes #3283,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3510:88,configurat,configuration,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3510,1,['configurat'],['configuration']
Deployability,A few updates. Closes #2194.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2195:6,update,updates,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2195,1,['update'],['updates']
Deployability,"A lot of times the docs build fail. I notice that there are errors in the installation of deps and precompilation part of the docs build. I'm not totally sure that Manifest.toml is the culprit but shipping docs with its Manifest does require us to use non-conventional ways to build the docs. Specifically, we can't use `Pkg.develop` to install the required deps eg. ```; julia --project=docs/ -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'; ```. and instead we have to rely to. https://github.com/CliMA/Oceananigans.jl/blob/adb728c8f5bdcd24729b8b9282459fc0344bca5b/docs/make.jl#L5-L11. I would like to experiment whether removing docs/Manifest.toml and using proper compat entries in docs/Project.toml will alleviate some of the issues",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3520:74,install,installation,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3520,2,['install'],"['install', 'installation']"
Deployability,A more detailed session for installation instructions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312:28,install,installation,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312,1,['install'],['installation']
Deployability,"According to https://pkgdocs.julialang.org/v1/compatibility/, `MPICH_jll = ""4.0.1""` means `[4.0.1 - 5.0.0)` and it's not what we wanted!. (And indeed, when I called `using Pkg; Pkg.update()` MPICH_jll got updated to 4.0.2.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2488:181,update,update,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2488,2,['update'],"['update', 'updated']"
Deployability,"Add ""citing"" section and list of publications using Oceananigans.jl (also update README)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1518:74,update,update,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1518,1,['update'],['update']
Deployability,Add Buildkite CI pipeline,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1006:17,pipeline,pipeline,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1006,1,['pipeline'],['pipeline']
Deployability,Add `branch_previews` kwarg in `deploydocs`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2604:32,deploy,deploydocs,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2604,1,['deploy'],['deploydocs']
Deployability,Add a test to check surface bc continuous functions work with ImmersedBoundary,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1928:31,continuous,continuous,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928,1,['continuous'],['continuous']
Deployability,Add distributed test pipeline,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3326:21,pipeline,pipeline,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3326,1,['pipeline'],['pipeline']
Deployability,"Adding this before I forget. It could be useful to have builtin support for getting wall clock time spent in key ""blocks"" of code during any; simulation. . For example knowing how long is spent in iterative solver, how long in I/O, how long in time stepping, how long in initialization, how long in dynamics computations, how long in tracer computations, how long in communication etc.. can be a useful check and help see what is requiring resources in different configurations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862:463,configurat,configurations,463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862,1,['configurat'],['configurations']
Deployability,Adds FieldSlicer and integrates with JLD2OutputWriter and WindowedTimeAverage,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/932:21,integrat,integrates,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932,1,['integrat'],['integrates']
Deployability,Adds adapt_structure for ContinuousForcing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1016:25,Continuous,ContinuousForcing,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1016,1,['Continuous'],['ContinuousForcing']
Deployability,Adds diffusive criterion to dt update in TimeStepWizard,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/729:31,update,update,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/729,1,['update'],['update']
Deployability,Adds incompressiblity enforcement and state update to set!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1259:44,update,update,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1259,1,['update'],['update']
Deployability,All the arrays right now are of size `Nx*Ny*Nz` but technically there are `Nx` volumes in the _x_-direction and `Nx+1` faces so the output should match this and make sense. The easiest thing to do with the doubly periodic configuration we have right now is to have row `Nx+1` be a repeat of row `1` but writing out the fields at the very bottom (`k=Nz+1`) might require some extra computation?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/92:222,configurat,configuration,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/92,1,['configurat'],['configuration']
Deployability,Allow the default_bc to be a `ContinuousBoundaryFunction`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3196:30,Continuous,ContinuousBoundaryFunction,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3196,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,Allows field-dependent SimpleForcing. Updates plankton growth example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/744:38,Update,Updates,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/744,1,['Update'],['Updates']
Deployability,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2715:175,install,install,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715,1,['install'],['install']
Deployability,Another CATKE update,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2844:14,update,update,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2844,1,['update'],['update']
Deployability,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852:409,Install,Installation,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852,2,['Install'],['Installation']
Deployability,"As discussed with @jm-c, the organization of physical constants and parameters is somewhat confusing. Currently, constants are stored in three places:. 1. `PlanetaryConstants`, which stores a rotation rate, gravitational acceleration, and a Coriolis parameter used in an f-plane approximation; 2. `ModelConfiguration`, which stores anisotropic (potentially turbulent) viscosities and diffusivities; 3. `EquationOfState`, of which there is only one kind: `LinearEquationOfState`, which stores both parameters associated with the equation of state in addition to a reference density. I see a few problems:. * `f` is not a property of a planet.; * 'Model configuration' is an obscure name for turbulent or molecular transport coefficients.; * A reference density is not a parameter in an equation of state. I propose that we consolidate these three types into two, removing the reference density from `EquationOfState` and define a new type containing f, g, ρ0, ν, and κ. I'm not sure what to call the new type. One possibility is `FluidParameters` or `PhysicalParameters` or `PhysicalConstants`. I also propose that we cease support for anisotropic transport coefficients as parameters, defined generally, at least for the moment. We can support constant anisotropic transport coefficients as a type of LES closure in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217:652,configurat,configuration,652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217,1,['configurat'],['configuration']
Deployability,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536:563,configurat,configurations,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536,1,['configurat'],['configurations']
Deployability,At some point we'd need to revisit the benchmarks. (https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/). We might wanna discuss what to include there and how we could perhaps automate the procedure? It doesn't need to be completely automated but perhaps we should have a workflow that we could run every now and again that produces a set of figures that are stored in OceananigansArtifacts.jl or somewhere so the docs update automatically?. (Feel free to convert this to a Discussion if it's more appropriate.),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3166:445,update,update,445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3166,1,['update'],['update']
Deployability,At the moment it was there but never used. So only wasting time by installing and precompiling when building the docs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2070:67,install,installing,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2070,1,['install'],['installing']
Deployability,At the moment the docs only mention the uniform unidirectional Stokes drift implementation . https://clima.github.io/OceananigansDocumentation/stable/physics/surface_gravity_waves/. We need to update the docs to take into account the 3D Stokes implementation that was introduced with #3384. cc @BrodiePearson @glwagner @LeeAra0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3432:193,update,update,193,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3432,1,['update'],['update']
Deployability,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3112:107,deploy,deploying,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112,2,['deploy'],['deploying']
Deployability,"At the moment, the tendencies were updated at each call of `update_state!`. This PR makes it so that the tendencies are computed only inside the time-stepping where we need them. see [ClimaOcean#164](https://github.com/CliMA/ClimaOcean.jl/issues/164)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3741:35,update,updated,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3741,1,['update'],['updated']
Deployability,Avoid executing the lines to install dependencies within examples,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1316:29,install,install,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1316,1,['install'],['install']
Deployability,"Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64}}}}}, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(drag_u), NamedTuple{(:cᴰ, :V∞), Tuple{Float64, Float64}}, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3412:5952,Continuous,ContinuousBoundaryFunction,5952,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3412,3,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"Base.show` very slow since showing a `FieldTimeSeries` prints its min, mean, and max. So it's harder to work with `FieldTimeSeries` interactively. Seems fine when not on a `ImmersedBoundaryGrid`. I'm guessing it's slower because it's masking out the immersed values but I don't know if we expect it to be ~2000x slower than without an immersed boundary. It's those memory allocations... A quick quality-of-life fix could be to not call `data_summary` when showing a `FieldTimeSeries`. ## MWE. ```julia; using Oceananigans. arch = CPU(). L = 1; H = 1. underlying_grid = LatitudeLongitudeGrid(; arch;; topology = (Bounded, Bounded, Bounded),; size = (512, 512, 64),; latitude = (-L/2, L/2),; longitude = (-L/2, L/2),; z = (-H, 0),; halo = (4, 4, 4); ). h = L/2; w = L/5 ; mount(x, y) = h * exp(-x^2 / 2w^2) * exp(-y^2 / 2w^2); bottom(x, y) = -H + mount(x, y). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bottom)). model = HydrostaticFreeSurfaceModel(; grid). simulation = Simulation(model, Δt=1, stop_iteration=1). simulation.output_writers[:fields] =; JLD2OutputWriter(; model,; model.velocities;; filename = ""test.jld2"",; schedule = IterationInterval(1),; overwrite_existing = true; ). run!(simulation). u = FieldTimeSeries(""test.jld2"", ""u""); u2 = u[2]; ```. Reduction over the `FieldTimeSeries`:. ```julia; julia> @time minimum(u2); 20.954897 seconds (118.72 M allocations: 130.792 GiB, 25.74% gc time); 0.0; ```. Reduction over the underlying data:. ```julia; julia> @time minimum(u2.data); 0.011304 seconds (3 allocations: 1.562 KiB); 0.0; ```. or almost 2000x faster. ## Environment. Oceananigans.jl `main` branch with. ```; Julia Version 1.10.5; Commit 6f3fdf7b362 (2024-08-27 14:19 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3750:1793,release,release,1793,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3750,1,['release'],['release']
Deployability,"Based on the discussion with @iuryt on slack I realized that our ""Installation instructions"" session was a bit barebones. Here's attempt to re-write with a bit more explanation and ""hand-holding"", which I think will help users in general. Basically I think we need to touch on how to install Julia (both for personal computers and HPC systems), since that's often the hardest step, and also touch on running the simulations on HPC systems when you need GPUs (which basically means you have to deal with the job scheduler). This is only my first draft, but suggestions are welcome!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2312:66,Install,Installation,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2312,2,"['Install', 'install']","['Installation', 'install']"
Deployability,Been a lot of changes since v0.44.1 (including some bug fixes) but don't think there have been any breaking changes (or massive new features) so was thinking we should tag and release v0.44.2.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1200:176,release,release,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1200,1,['release'],['release']
Deployability,Better Buildkite CI pipeline,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1031:20,pipeline,pipeline,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031,1,['pipeline'],['pipeline']
Deployability,Better installation instructions.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/152:7,install,installation,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/152,1,['install'],['installation']
Deployability,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1310:515,integrat,integrating,515,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310,1,['integrat'],['integrating']
Deployability,Boundary condition API kernels should use dynamic launch configuration,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/363:57,configurat,configuration,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/363,1,['configurat'],['configuration']
Deployability,Build and test but do not deploy docs on Buildkite,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1018:26,deploy,deploy,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018,1,['deploy'],['deploy']
Deployability,Bump patch release,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3729:5,patch,patch,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3729,2,"['patch', 'release']","['patch', 'release']"
Deployability,Bump v0.36.0 (JOSS release),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/916:19,release,release,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916,1,['release'],['release']
Deployability,"Bumps [julia-actions/setup-julia](https://github.com/julia-actions/setup-julia) from 1 to 2.; <details>; <summary>Release notes</summary>; <p><em>Sourced from <a href=""https://github.com/julia-actions/setup-julia/releases"">julia-actions/setup-julia's releases</a>.</em></p>; <blockquote>; <h2>v2.0.0 - Update to Node20</h2>; <h2>What's Changed</h2>; <ul>; <li>update to node20 by <a href=""https://github.com/ranocha""><code>@​ranocha</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></li>; </ul>; <p>Note the rationale for the breaking change was discussed in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/209"">julia-actions/setup-julia#209</a></p>; <h3>Dependencies and misc</h3>; <ul>; <li>Bump nock from 13.5.1 to 13.5.4 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/224"">julia-actions/setup-julia#224</a></li>; <li>Bump <code>@​types/semver</code> from 7.5.6 to 7.5.8 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/222"">julia-actions/setup-julia#222</a></li>; <li>Bump <code>@​types/node</code> from 20.11.16 to 20.11.30 by <a href=""https://github.com/dependabot""><code>@​dependabot</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/226"">julia-actions/setup-julia#226</a></li>; <li>Bump the version number to <code>2.0.0</code> in <code>package.json</code> and <code>package-lock.json</code> by <a href=""https://github.com/DilumAluthge""><code>@​DilumAluthge</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/228"">julia-actions/setup-julia#228</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/ranocha""><code>@​ranocha</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:114,Release,Release,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,5,"['Release', 'Update', 'release', 'update']","['Release', 'Update', 'releases', 'update']"
Deployability,Bumps patch release after bug fixes via #1744,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1973:6,patch,patch,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1973,2,"['patch', 'release']","['patch', 'release']"
Deployability,Buoyancy update in linear time.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/172:9,update,update,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/172,1,['update'],['update']
Deployability,CATKE and GM in a near-global 1 degree simulation + updates Ri-based vertical diffusivity,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2786:52,update,updates,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2786,1,['update'],['updates']
Deployability,"Call them system tests, model verification tests, or end-to-end tests, that's what this PR is about. Currently a work in progress as I hit a roadblock with checkpointing so **the tests will fail**. See #141. BUT, for testing we can just set `model.forcings = nothing` and manually reconstruct the forcings as we know them. Tests implemented so far:; 1. Checkpointing integration test: Run two coarse rising thermal bubble simulations and make sure that when restarting from a checkpoint, the restarted simulation matches the non-restarted simulation numerically.; 2. NetCDF output integration test: Run a coarse thermal bubble simulation and save the output to NetCDF at the 10th time step. Then read back the output and test that it matches the model's state.; 3. Thermal bubble golden master test: Run the coarse thermal bubble simulation for 10 time steps and check that the model output matches a golden master output.; 4. Deep convection golden master test. @jm-c @christophernhill: do post any ideas for tests that should be implemented in this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/140:367,integrat,integration,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/140,2,['integrat'],['integration']
Deployability,Captures immersed boundary condition API #2437 docs update #2474,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2484:52,update,update,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2484,1,['update'],['update']
Deployability,"Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:3352,Continuous,ContinuousForcing,3352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:3179,Continuous,ContinuousForcing,3179,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invoc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:3006,Continuous,ContinuousForcing,3006,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"Center, Nothing, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:16275,Continuous,ContinuousBoundaryFunction,16275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,Checkpoint is never created after upgrade (both with Julia 1.5 and 1.6),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547:34,upgrade,upgrade,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547,1,['upgrade'],['upgrade']
Deployability,Choose 2-4 examples that are always updated and improved.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/221:36,update,updated,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/221,1,['update'],['updated']
Deployability,Circulation and vorticity operators need to be updated at the cubed sphere corners,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1584:47,update,updated,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1584,1,['update'],['updated']
Deployability,"Closes #1995 and closes #1996. (I'm not sure when the bug was introduced, so I capped the version up to 3.3.6. Feel free to change if there's a newer version that's also safe.). Also we need to remember to remove this after the bug gets put into a tagged release. (Can we exclude only version 3.4.2 using compat?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997:255,release,release,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997,1,['release'],['release']
Deployability,Closes #3309 . Breaking changes for 0.13 are listed here:. https://github.com/Alexander-Barth/NCDatasets.jl/releases/tag/v0.13.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3313:108,release,releases,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3313,1,['release'],['releases']
Deployability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3795 by changing the default configuration of `NonhydrostaticModel` to `hydrostatic_pressure_anomaly = CenterField(grid)`. The spurious large-scale flow is developed due to numerical noise in the buoyancy field when the hydrostatic pressure anomaly is treated explicitly. When hydrostatic pressure anomaly is computed using the implicit integral of the buoyancy field, no spurious kinetic energy is introduced.; Here's the MWE as in https://github.com/CliMA/Oceananigans.jl/issues/3795:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3796:84,configurat,configuration,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3796,1,['configurat'],['configuration']
Deployability,Completely trivial update to a comment about continguous CuArrays,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2561:19,update,update,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2561,1,['update'],['update']
Deployability,"Condition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .bottom is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}} which is not isbits.; .condition is of type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol, Symbol} which is not isbits.; .1 is of type Symbol which is not isbits.; .2 is of type Symbol which is not isbits.; .top is of type BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:8169,Continuous,ContinuousBoundaryFunction,8169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"Condition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IF",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:29622,Continuous,ContinuousForcing,29622,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,3,['Continuous'],['ContinuousForcing']
Deployability,Continuous CPU + GPU benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/67:0,Continuous,Continuous,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/67,1,['Continuous'],['Continuous']
Deployability,Continuous boundary functions don't use grids' native coordinates,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3073:0,Continuous,Continuous,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3073,1,['Continuous'],['Continuous']
Deployability,ContinuousForcing doesn't compile when diffusivities is not `nothing`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:0,Continuous,ContinuousForcing,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,1,['Continuous'],['ContinuousForcing']
Deployability,Convergence test and validation experiment Buildkite pipeline,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:53,pipeline,pipeline,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,1,['pipeline'],['pipeline']
Deployability,Convergence tests pipeline takes several hours to finish,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1420:18,pipeline,pipeline,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420,1,['pipeline'],['pipeline']
Deployability,Create central-pipeline.yml and add bors capability,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962:15,pipeline,pipeline,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962,1,['pipeline'],['pipeline']
Deployability,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971:1382,continuous,continuous,1382,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971,1,['continuous'],['continuous']
Deployability,"Currently the example tests are ""broken"", i.e. not run because having PyPlot as a dependency caused the Travis CI pipeline to frequently fail for different reasons. I still really like matplotlib and PyPlot but after playing around with Plots.jl I think it'll be worth switching over. As it doesn't get installed through conda it should be more stable on Travis. Would be really cool if Documenter.jl works with Plots.jl [animations](http://docs.juliaplots.org/latest/animations/). I'll give it a try.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/536:114,pipeline,pipeline,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/536,2,"['install', 'pipeline']","['installed', 'pipeline']"
Deployability,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:504,configurat,configuration,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,1,['configurat'],['configuration']
Deployability,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981:64,install,installed,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981,1,['install'],['installed']
Deployability,Delete leftover JLD2 files before deploying docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/558:34,deploy,deploying,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/558,1,['deploy'],['deploying']
Deployability,Delete validation-pipeline.yml,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3176:18,pipeline,pipeline,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3176,1,['pipeline'],['pipeline']
Deployability,Deploy docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1940:0,Deploy,Deploy,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940,1,['Deploy'],['Deploy']
Deployability,Deploy docs from Buildkite,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1209:0,Deploy,Deploy,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1209,1,['Deploy'],['Deploy']
Deployability,Deploy docs with `forcepush = true`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2243:0,Deploy,Deploy,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2243,1,['Deploy'],['Deploy']
Deployability,Deploy documentation through Buildkite.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1051:0,Deploy,Deploy,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1051,1,['Deploy'],['Deploy']
Deployability,Deploys docs to clima.github.com/OceananigansDocumentation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/801:0,Deploy,Deploys,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/801,1,['Deploy'],['Deploys']
Deployability,Do not install/load CUDA packages if no GPU is detected.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:7,install,install,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['install'],['install']
Deployability,"Do we want to update the one and two dimensional examples to include `Flat`? . If not then we can ignore this PR. . If yes, then this is my attempt to do so. The good news is that most of the one and two dimensional examples work very easily. Unfortunately, a couple of them, geostrophic adjustment and convecting plankton, do not. I don't know why at the moment and these should certainly be fixed before a merge happens. If it happens. The error get I get is `NaN` after (I believe) the first interval. So I suspect one of the tendencies is not being computed correctly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1513:14,update,update,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513,1,['update'],['update']
Deployability,Docker file for easy installation and CI testing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/151:21,install,installation,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/151,1,['install'],['installation']
Deployability,Docs don't build for tagged releases,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3191:28,release,releases,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3191,1,['release'],['releases']
Deployability,Docs/Bibliography patch,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1721:18,patch,patch,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1721,1,['patch'],['patch']
Deployability,Docstring did not match the actual constructor. They do now. @suyashbire1 Do you think `clobber` should be true or false by default?. Also updated the docstring to make it clear that `outputs` needs to be a `Dict` for now. Resolves #553,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556:139,update,updated,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556,1,['update'],['updated']
Deployability,Documenter.jl uses KaTeX by default but MathJax3 might be better for us. Will wait for Buildkite to build and deploy the docs to see 🤞 . Resolves #528 (hopefully),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530:110,deploy,deploy,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530,1,['deploy'],['deploy']
Deployability,Dynamically install packages like Plots.jl and ArgParse.jl for examples.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/195:12,install,install,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195,1,['install'],['install']
Deployability,Employ new halo-filling functions to update halos of prognostic variables on the cubed sphere,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570:37,update,update,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570,1,['update'],['update']
Deployability,Ensure that all `.jld2`/`.nc` files are deleted before docs deployment,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3109:60,deploy,deployment,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3109,1,['deploy'],['deployment']
Deployability,"EquationOfState{Float64},Nothing,Float64}, ::Nothing, ::AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, ::Clock{Float64}) at /home/ptuckman/.julia/packages/Oceananigans/KJCVx/src/TimeSteppers/time_stepping_kernels.jl:18; [22] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T),NTuple{4,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:pHY′, :pNHS),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:20113,Continuous,ContinuousForcing,20113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,Error in update,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1468:9,update,update,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468,1,['update'],['update']
Deployability,Error tagging new release,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/87:18,release,release,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/87,2,['release'],['release']
Deployability,Explicit install of deps in Examples,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1184:9,install,install,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1184,1,['install'],['install']
Deployability,"Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:2833,Continuous,ContinuousForcing,2833,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,Faster model with dynamic launch configuration by @maleadt,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302:33,configurat,configuration,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302,1,['configurat'],['configuration']
Deployability,"FittedBottom{OffsetArrays.OffsetMatrix{Float64, CuDeviceMatrix{Float64, 1}}}, Nothing}, CenteredSecondOrder, Nothing, Nothing, Nothing, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}}, NamedTuple{(), Tuple{}}}}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArrays.Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:3296,Continuous,ContinuousBoundaryFunction,3296,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,Fix `pipeline.yml`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1066:5,pipeline,pipeline,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1066,1,['pipeline'],['pipeline']
Deployability,Fix bug for horizontal diffusivity with Flat horizontal dimension + updates baroclinic adjustment validation script,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284:68,update,updates,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284,1,['update'],['updates']
Deployability,Fix deploying docs to OceananigansDocumentation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/804:4,deploy,deploying,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/804,1,['deploy'],['deploying']
Deployability,Fix implicit type conversions in Adams-Bashforth update kernel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/252:49,update,update,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/252,1,['update'],['update']
Deployability,Fix location of Integrated areas derivatives in the PCG solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2710:16,Integrat,Integrated,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2710,1,['Integrat'],['Integrated']
Deployability,Fixes #655. `convert_to_arch` was defined in two places. Will release patch v0.24.1 once merged.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/656:62,release,release,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/656,2,"['patch', 'release']","['patch', 'release']"
Deployability,Fixes off-by-one indexing error in hydrostatic pressure integrat…,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/612:56,integrat,integrat,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/612,1,['integrat'],['integrat']
Deployability,Fixing `AveragedField` and implementing `IntegratedField` using `GridMetricOperation`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2051:41,Integrat,IntegratedField,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051,1,['Integrat'],['IntegratedField']
Deployability,Following the discussion on testing infrastructure from a long time ago (PR #139) it would be good to convert any verification tests that result from #346 into an actual end-to-end test of the model. Not sure how the comparison with MITgcm would be implemented but maybe the others are good enough. `test/verification/` might be a good directory for them?. They can be run separately (separate pipeline) so they don't have to run quickly and can take a while so they can be comprehensive.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/347:394,pipeline,pipeline,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/347,1,['pipeline'],['pipeline']
Deployability,Following the reversal of the k index (PR #462) we need to regenerate all regression test data to correspond to the new convention. This PR does that. Had to update some of the tests as the output data format has changed (e.g. now has halos) and was originally generated a long time ago. I also increased code reuse among the regression tests for summarizing the result of each regression test. This PR is part of #471,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/526:158,update,update,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/526,1,['update'],['update']
Deployability,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:278,update,updated,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,1,['update'],['updated']
Deployability,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030:476,release,released,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030,1,['release'],['released']
Deployability,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:263,configurat,configurations,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['configurat'],['configurations']
Deployability,Forward Euler + 3rd order Runge-Kutta time-stepping (or integration with DifferentialEquations.jl),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/506:56,integrat,integration,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/506,1,['integrat'],['integration']
Deployability,"Friendly ""getting started"" section that encompasses installation + running examples for new users?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149:52,install,installation,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149,1,['install'],['installation']
Deployability,"Going to release a new version as quite a bit has been merged since v0.11.0, and arbitrary tracers (PR #452) will probably be the focus of v0.12.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/477:9,release,release,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/477,1,['release'],['release']
Deployability,Good to keep packages updated to avoid abrupt changes in dependencies.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/404:22,update,updated,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/404,1,['update'],['updated']
Deployability,"Had an earlier clone, was on master branch, everything was in order as ""git status"" ; ; nothing to commit, working tree clean. Then I updated my clone the usual way, just typing ""git pull"", but got plenty of warnings about; conflicts and so on. After that, ""git status"" reports:. On branch master; Your branch and 'origin/master' have diverged,; and have 1106 and 2212 different commits each, respectively.; (use ""git pull"" to merge the remote branch into yours); You have unmerged paths.; (fix conflicts and run ""git commit""); (use ""git merge --abort"" to abort the merge). so it looks like I am far from a clean update. My question: how to proceed when trying to update my Oceananigans local clone and; why the standard way does not work for this repos ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/598:134,update,updated,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/598,3,['update'],"['update', 'updated']"
Deployability,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1635:137,update,update,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635,6,"['Install', 'update']","['Installed', 'update']"
Deployability,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:42,install,installing,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,2,['install'],"['installation', 'installing']"
Deployability,"Hello,. I've been working with @johnryantaylor, and we've been using Lagrangian Particles but have come across an issue. To preface, the issue be my miss understanding of how to use tracked fields but I can't find an obvious solution. Essentially the problem seems to be that to define an tracked field for a tracer you have to already have the model defined, but to do that you have to have the particles defined. A work around for this was to make the model, then define the particles, then redefine the model. This would run and not error, but would result in the tracked field property of the particles not actually being updated. Running it yet again appears to fix it and make it; work. In order to fix this I've modified the `update_particle_properties!` function to explicitly use the models tracer fields when it is a tracer field being tracked. I've also updated the tests which seem to run. If you run the tests on the previous version of the code then the property t does not get updated (but will run with this set up). I hope this is the best place for me to make this pull request since you're updating particle tracking anyway!. Jago",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2662:626,update,updated,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2662,3,['update'],['updated']
Deployability,"Hello,; My [fork](https://github.com/matinraayai/Oceananigans.jl) of Oceananigans.jl is in the process of adding AMDGPU support for the code base. I've added a new architecture called ROCMGPU, and changed the name of the GPU architecture to CUDAGPU. ; Some of the operations are ported, and the tests are updated to use ROCMGPU as well. @christophernhill and I are in the process of running each test suite to see what other operations need to be tweaked for AMDGPU.; 1. I would like to push this work on a branch on the main codebase, called amdgpu for it to get more attention.; 2. Any help on getting the tests working would be much appreciated.; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2493:305,update,updated,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493,1,['update'],['updated']
Deployability,"Here are some profiling results that were done on Satori with nvprof. This is a GPU profile of the nonhydrostatic model.; ```; ==104758== NVPROF is profiling process 104758, command: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912:583,install,installation,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912,1,['install'],['installation']
Deployability,"Hi all, . I am currently working on a biogeochemistry modelling environment with @johnryantaylor using Oceananigans, and as part of this have have up with a scheme to have ""active"" particles that interact with tracers. How I currently have this set up: when the particle dynamics are run, the particles can increase/decrease the concentration of tracers in the cells surrounding them, but this only allows for explicit Euler integration. A better way todo this seems to be to have the particles uptake/exudation of tracers contribute to their tendencies during the time stepping as I have implemented here. I'm unsure if this is implemented in the best way throughout but I'm fairly satisfied that I have it working as desired. . Hope everyone is happy with this?. --------. To summaries what I have changed:. - Particle setup: particles can get a parameter called `active_properties` which is a tuple of named tuples of particle properties and tracers (e.g. `((property=:t, tracer=:x),).`) The idea being that the particle dynamics function (as already implemented) changes the particle property to set a rate of uptake/exudation of a tracer, and the below function would integrate this change to the specified tracer. - `calculate_particle_tendency_contributions!` added after each `calculate_tendencies!` call: function goes through each particle, finds its 8 nearest cells, and adds the relevant fraction of each particle property (divided by the cell volume) to the tracer tendencies so it can be integrated by the time stepper (like tracer forcing)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724:425,integrat,integration,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724,3,['integrat'],"['integrate', 'integrated', 'integration']"
Deployability,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:678,install,installing,678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['install'],['installing']
Deployability,"Hi all,. I run a 2D grid setup (y-z) for a while and I get advection terms through a kernel function below. ; With the recent upgrade, I switched the advection scheme from WENO5() to WENO(). ; However, the output of the u advection (fluctuation and background) becomes zero. And x-momentum is perfectly balanced between Coriolis force and viscosity.; The problem only happens in the flat direction and it remains with 5th order upwind too. I wonder if I write the function wrong, or the model really does not calculate the advection for the velocity in the flat direction. ```; @inline function _Duu_div(i,j,k,grid,dep,params); return div_𝐯u(i, j, k, grid,params.adv,params.vel,params.tracer);; end; Duu_div = Field(KernelFunctionOperation{Face, Center, Center}(_Duu_div,model.grid;parameters=(; adv = model.advection, vel = model.velocities, tracer = model.velocities.u),computed_dependencies = (1)));; ```. _My model Setup:_. ```; ## Grid ; L = 1e3;; H = 100;. Ny = 1024;; Nz = 128;. ## Streched Grid; hc = 1.37;; theta_s = 3.53;. @inline Space_z(k) = (hc*(k-Nz-1)/Nz + (H-hc)*sinh(theta_s*(k-Nz-1)/Nz)/sinh(theta_s));. grid = RectilinearGrid(GPU(); topology = (Flat, Periodic, Bounded),; size = (Ny, Nz),; y = (0, L),; z = Space_z,; );; ```. ```; model = NonhydrostaticModel(; grid, buoyancy = BuoyancyTracer(),; advection = WENO(; grid = grid),; timestepper = :RungeKutta3,; tracers = (:b), ; coriolis = FPlane(f=f),`; forcing = (b=b_force, u=u_force, v=v_force, w=w_force),; closure = (vertical_diffusive_closure, horizontal_diffusive_closure),; boundary_conditions = (u = u_bcs,),; background_fields = (u = U_bfield, b = B_bfield)); ```; Let me know if more information is needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2742:126,upgrade,upgrade,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2742,1,['upgrade'],['upgrade']
Deployability,Highlighting important breaking changes in releases,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147:43,release,releases,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147,1,['release'],['releases']
Deployability,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:11758,Continuous,ContinuousForcing,11758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,2,['Continuous'],['ContinuousForcing']
Deployability,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/exe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:6547,Continuous,ContinuousForcing,6547,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/sr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:17024,Continuous,ContinuousForcing,17024,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [10] macro expansion at ./lock.jl:183 [inlined]; [11] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.Fu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:9285,Continuous,ContinuousForcing,9285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1693:55,integrat,integrating,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693,1,['integrat'],['integrating']
Deployability,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1555:489,Configurat,Configuration,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555,1,['Configurat'],['Configuration']
Deployability,"I am using the master branch for nutrient tracers with a 3rd DST advection scheme. I found that the halo points don't have the same values as the boundaries in a periodic domain. Below is the configuration I use and a slice of u velocity. Not sure it's a bug or you intended to do so... Also, the fancy logger disappeared after I updated to 0.36.0. ```julia; grid = RegularCartesianGrid(size=(32, 2, 32), extent=(2*32, 2*2, 2*32), halo = (2, 2, 2)). RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 66.0], y ∈ [0.0, 6.0], z ∈ [-64.0, 2.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 2, 32); halo size (Hx, Hy, Hz): (2, 2, 2); grid spacing (Δx, Δy, Δz): (2.0, 2.0, 2.0); ```; ```julia; T_bcs = TracerBoundaryConditions(Ogrid, top = BoundaryCondition(Flux, Qᵀ), ; bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ); ```; ```julia; model.velocities.u.data.parent[:,:,3]; 36×6 Array{Float64,2}:; -0.0085938 -0.00844015 -0.0085938 -0.00844015 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.010009 -0.0104645 -0.010009 -0.0104645; -0.00859588 -0.00912747 -0.00829848 -0.00823567 -0.00859588 -0.00912747; -0.00742535 -0.00655195 -0.00594664 -0.00595502 -0.00742535 -0.00655195; -0.00536066 -0.0038463 -0.00437428 -0.00422142 -0.00536066 -0.0038463; -0.00241687 -0.00325761 -0.00216266 -0.00211736 -0.00241687 -0.00325761; 0.00258328 0.00188971 0.00159199 0.00141804 0.00258328 0.00188971; 0.00289388 0.00378436 0.00257106 0.00259916 0.00289388 0.00378436; 0.00363445 0.00407903 0.00342151 0.00360496 0.00363445 0.00407903; 0.00575018 0.00480254 0.00481157 0.00447708 0.00575018 0.00480254; 0.00667745 0.00577658 0.00495125 0.00499728 0.00667745 0.00577658; 0.00464067 0.00487611 0.00543163 0.00506227 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949:192,configurat,configuration,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949,2,"['configurat', 'update']","['configuration', 'updated']"
Deployability,"I believe that . https://github.com/CliMA/Oceananigans.jl/blob/b22057a49dfe25b1b091d4d4c9cdb0e126bc0c62/docs/make.jl#L1. should be replaced with. ```julia; push!(LOAD_PATH, joinpath(@__DIR__, ""."")); ```. Supposedly `docs/make.jl` from the repo's home directory, right? Thus going a level up is not appropriate?. But a better way to do it is to delete `push!(LOAD_PATH...` from within `docs/make.jl` completely and make sure we include it in our workflow when building the docs locally or on servers, e.g., see . https://github.com/JuliaGPU/CUDA.jl/blob/96d6e11259053573ad8164f462d9f9eb8e204893/.buildkite/pipeline.yml#L338-L342. cc: @ali-ramadhan, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1777:605,pipeline,pipeline,605,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1777,1,['pipeline'],['pipeline']
Deployability,I can't start Oceananigans normally anymore even starting from a fresh install,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1625:71,install,install,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625,1,['install'],['install']
Deployability,I created a clean branch from the latest version of master that passed the documentation buildkite test. Looking at my old updated `benchmarks.md` through a markdown viewer/editor and I saw that a table that's written in HTML might be causing trouble so I replaced it with a code block quote table.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1952:123,update,updated,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1952,1,['update'],['updated']
Deployability,"I don't know how relevant these changes are, but I found some more type instabilities in the split explicit free surface model's adams bashforth time integrator. Removing them similar to #3212 . Alternatively we could also hardcode the constants. https://github.com/CliMA/Oceananigans.jl/blob/9140a74536784396d368cf8205432433a9deea3d/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L11-L19. as Float32. ```julia; const β = 0.281105f0; const α = 1.5f0 + β; ```; etc. as this will directly upcast to Float64 if that's used, but not cause a type instability with Float32. But this will again cause problems if we ever want to use something else than Float32/64... Now just the `U★, η★` get a bit lengthier!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3213:150,integrat,integrator,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3213,1,['integrat'],['integrator']
Deployability,"I don't know what happened but yesterday I could type ""using Oceananigans"" after starting julia --project and it worked fine. This morning, after a software update on ubuntu, now I'm getting a CUDA ERROR. See below. Any ideas what I can do to try and fix this?. ```; julia> using Oceananigans; ┌ Warning: Recursion during initialization of CUDA.jl; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:41; ┌ Error: Could not initialize CUDA; │ exception =; │ CUDA error (code 803, CUDA_ERROR_SYSTEM_DRIVER_MISMATCH); │ Stacktrace:; │ [1] throw_api_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:157,update,update,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['update'],['update']
Deployability,"I don't think we should depend on a heavy package like Plots.jl, but we might want to automatically install and load it when someone runs an example like the rising thermal bubble one on the README. Might be related to #14 so Requires.jl would help but we also want to add/build the package too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/195:100,install,install,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195,1,['install'],['install']
Deployability,"I guess this is not something I was thinking of but John pointed out that it's crucial that the Fourier-spectral solver returns a nonhydrostatic pressure that when used to update the velocity field, produces a velocity field that is non-divergent at every grid point. Otherwise mass is being unphysically accumulated and tracer quantities will also be accumulated due to nonzero Q(∇·**u**) terms in the flux divergence operators ∇·(**u**Q) = Q(∇·**u**) + **u**·∇Q, leading to divergences and blowups. Right now the wavenumbers are computed as; ```; kx = 2π/Lx # DFT; ky = 2π/Ly # DFT; kz = 1π/Ly # DCT; ```; which should lead to a solver whose solutions converge spectrally. While it may solve for the pressure at the center of the cells very accurately, if ∇·**u** is non-zero this will be a big problem. This will require some testing on my part to see which solver best satisfies ∇·**u**. If we can satisfy it to machine precision, that would be amazing. If not, hopefully it can satisfy it better than the conjugate-gradient method and then we can use the continuity equation to enforce ∇·**u**=0. An alternative (not sure if this would work) is to discretize the derivative operators using a second-order centered-difference scheme (which I believe I've done for the 1D solver, and previous 3D solver) which explicitly places the discretization points on the center of the cells. Then the wavenumbers are; ```; kˣ² = (4 / Δx²) * sin(πl / Nˣ)² # DFT; kʸ² = (4 / Δy²) * sin(πm / Nʸ)² # DFT; kᶻ² = (2 / Δz²) * (cos(πn / Nᶻ) - 1) # DCT; ```; and of course you expect second-order convergence. But if it better satisfies ∇·**u**=0 then it might be the way to go. You can also derive wavenumbers for fourth-order discretization. EDIT: Fixed second-order wavenumbers.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8:172,update,update,172,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8,1,['update'],['update']
Deployability,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1205:141,install,installed,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205,1,['install'],['installed']
Deployability,"I have noticed an issue with immersed boundaries in the latest version of [Oceananigans](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.91.4). At the immersed boundaries we expect the default tracer flux boundary conditions to be zero. While doing energy analysis, I noticed that something seemed off with my simulation. After increasing the colorrange in my animation, I noticed that near my immersed boundaries, the minimum buoyancy was drifting to values much less than the minimum value prescribed by the surface value boundary conditions, suggesting that the tracer flux at the immersed boundary is non-zero. For context, I'm running a 2D Horizontal Convection simulation, in which the buoyancy is initialized as zero everywhere to start. I apply a buoyancy gradient at the surface, cooling half of the surface and warming the other half. The boundaries are insulated and I have a pair of gaussian hills at the bottom defined using the immersed boundary function. Link to my [simulation setup](https://github.com/ikeshwani/HorizontalConvection/blob/main/src/simulation.jl). . Here is an animation of topographically-constrained horizontal convection where the nonhydrostatic pressure is not separated:. https://github.com/user-attachments/assets/9fd054c9-f1da-4b8d-9d04-b99479dbe348. Notice there seems to be a source of dense fluid in the basin between the hills. . To address this issue @hdrake and I separated the hydrostatic and nonhydrostatic pressure components in the `NonHydrostaticModel` by changing https://github.com/CliMA/Oceananigans.jl/blob/406eb9c5c7a9fc86947747116128c8c1ba4c93d4/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L70. To `hydrostatic_pressure_anomaly = CenterField(grid)`. Here is the animation of topographically-constrained horizontal convection when the pressure components are separated:. https://github.com/user-attachments/assets/249e9814-335f-49bb-999e-73a6f95fcf37",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3677:130,release,releases,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3677,1,['release'],['releases']
Deployability,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1468:7,install,installed,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468,4,"['install', 'update']","['installed', 'update']"
Deployability,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2077:7,update,updated,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077,1,['update'],['updated']
Deployability,"I noticed some pages listed in library.mb didn't quite match the pages that are currently in `src`, mist notably (for me) `kernel_function_operation.jl`, so updated it. There probably are more discrepancies, but I also think we don't wanna list some of the more experimental features, so I left the rest as it was.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1943:157,update,updated,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1943,1,['update'],['updated']
Deployability,I noticed that `similar(::Field)` does not transfer boundary conditions. https://github.com/CliMA/Oceananigans.jl/blob/a86ef32581192d82a655e1b2ff4411e79917a379/src/Fields/field.jl#L217-L227. so we might need to update . https://github.com/CliMA/Oceananigans.jl/blob/c8a65a4fdeff25722104ced3a0c74d2d921ae1cf/src/Solvers/multigrid_solver.jl#L225-L244. and in particular . https://github.com/CliMA/Oceananigans.jl/blob/c8a65a4fdeff25722104ced3a0c74d2d921ae1cf/src/Solvers/multigrid_solver.jl#L230,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2882:211,update,update,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2882,1,['update'],['update']
Deployability,"I opened a wiki for Oceananigans:. https://github.com/CliMA/Oceananigans.jl/wiki. I think we should use the wiki to host practical information and tips for using Oceananigans on various hardware (laptops, CPUs, GPUs), clusters / high-performance computing system (HPCs), and more. Using the wiki this way will allow us to focus the docs on code and numerics, and alleviate the need to submit PRs to update details about using clusters. We need to provide an introduction to Oceananigans ""knowledge base"" (where to find useful information in the documentation, wiki, Github Discussions, and Github Issues) in the README, the docs, and the wiki.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2470:399,update,update,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2470,1,['update'],['update']
Deployability,"I think [Coordinate system and notation](https://clima.github.io/OceananigansDocumentation/stable/physics/notation/) page in the docs needs to be updated. . First, we don't only use a Cartesian grid anymore (we don't even use the word Cartesian for the `RegularRectilinearGrid` anymore). I'm not sure how you guys wanna adapt this page and notation for the spherical coordinate grid though. Second, a part of the math isn't rendering and I'm not sure why.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1779:146,update,updated,146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1779,1,['update'],['updated']
Deployability,"I think it's time to discuss the implementation of an abstraction for implementing drag forces on immersed boundaries. Curious to get feedback on this and also corrections if anything is wrong, plus additional considerations that I may be missing. ## Background. First a bit of background on why we impose quadratic drag boundary conditions on solid surfaces. Similarity theory supposes that shear is a function of only distance $d$ from a wall (here $d$ will also be a coordinate increasing away from the wall), such that in a simple 1D situation,. $$ \partial_d u = \frac{u_\star}{\varkappa d} $$. where $u_\star$ is the friction velocity defined such that $-u_\star^2 = \tau$ where $\tau$ is the kinematic stress, $\varkappa$ is the Von Karman constant. This expression can be integrated from an ""inner layer thickness"" $\ell$ (often called the roughness length, although the word ""roughness"" may be something of a misnomer) to obtain a model for the near-wall velocity profile:. $$ u(d) = \frac{u_\star}{\varkappa} \log \frac{d}{\ell} $$. This formula may then be _inverted_ to find the stress $\tau$ as a function of the near-wall velocity at some _particular distance_ $d = d_0$:. $$ \tau = - u_\star^2 = - c(d_0) u(d_0)^2 $$. where $c = \varkappa^2 / log(d_0/\ell)^2$ is often called the ""drag coefficient"" --- again a bit misleading since it actually depends on $d_0$, ie how far we are from the wall, and so it isn't really a ""coefficient"" in the context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often tak",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:780,integrat,integrated,780,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['integrat'],['integrated']
Deployability,I think the [docs](https://clima.github.io/OceananigansDocumentation/stable/) aren't being deployed correctly:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/80a31792-411f-4162-a4e2-d06a9757c86a),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3322:91,deploy,deployed,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3322,1,['deploy'],['deployed']
Deployability,I think we should tag a v0.37.0 release to ensure we have a code checkpoint before which we were recomputing w and after which we were not (since it's a change to the numerical methods). Might be good if we do this before merging in RK3.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/948:32,release,release,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/948,1,['release'],['release']
Deployability,"I tried running two examples in the docstring of `netcdf_output_writer.jl` and found something that I believe needs to be updated. [Line 274](https://github.com/CliMA/Oceananigans.jl/blob/2001a7fae296977608378223045bf46e24ea2853/src/OutputWriters/netcdf_output_writer.jl#L274), defines the nodes but this didn't work for me. I believe we should change it to the following:. `xC, yF = xnodes(Center, grid), ynodes(Face, grid)`. Also, it might helpful to add this line at the beginning, as otherwise, the example does not run,. `using Oceananigans.Grids: xnodes, ynodes, znodes`. If people agree with this I can make the changes but thought I would suggest it before creating a PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2986:122,update,updated,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2986,1,['update'],['updated']
Deployability,"I was thinking that it would be a good idea to make an integration with Python's [`xgcm`](https://github.com/xgcm/xgcm) package easier. The project is relatively new but I expect it to grow given that it has [Pangeo](https://pangeo.io/) support. In my mind, this is related to #1313, since the primary (only?) communication with Python is done through NetCDF files. So including some [grid metrics](https://xgcm.readthedocs.io/en/latest/grid_metrics.html) in the NetCDF output would be helpful. For now I'm not exactly sure what needs to be there since their docs [aren't very explanatory in that sense](https://github.com/xgcm/xgcm/issues/291), but it includes distances between `Face`s and `Center`s of the grids and other measures that should be straightforward. Any thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334:55,integrat,integration,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334,1,['integrat'],['integration']
Deployability,"I'm finding that simulations with `VerticallyStretchedGrid`s don't get picked up and instead throw an error saying that the grid doesn't match. Here's a MWE:. ```julia; using Oceananigans. grid = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). model = NonhydrostaticModel(grid=grid). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:862,update,updated,862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['update'],['updated']
Deployability,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794:1424,install,installed,1424,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794,1,['install'],['installed']
Deployability,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:93,update,updated,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,1,['update'],['updated']
Deployability,"I've noticed a few weeks ago that my scripts were much slower after the Julia 1.6 upgrade (which is preventing me from upgrading). I thought it was due to my Julia 1.6 installation but after some tests I now think it's an Oceananigans issue, specifically with the WENO5 scheme. I ran the MWE below in both Julia 1.5 (with Oceananigans version 0.57.1) and Julia 1.6 (tried several Oceananigans versions but specifically for this example I'm using Oceananigans version 0.58.5) using GPUs and the speed difference is pretty huge. The interesting part is that this difference only happens if I use WENO5 with a GPU. If I use the 2nd order centered scheme there is no significant difference in time (I haven't tried other schemes) and if I run the script on CPUs the time difference also appears to be small. Here's the script:. ```julia; using Oceananigans; using Oceananigans.Units; using CUDA: has_cuda; Nx, Ny, Nz = 128, 1600, 64. if has_cuda(); arch = GPU(); else; arch = CPU(); Nx = Int(Nx/4); Ny = Int(Ny/4); Nz = Int(Nz/4); end . topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(Nx, Ny, Nz),; x=(0, 200),; y=(0, 2000),; z=(-100, 0),; topology=topology); println(""\n"", grid, ""\n""). model = IncompressibleModel(architecture = arch,; grid = grid,; advection = WENO5(),; timestepper = :RungeKutta3,; tracers=nothing,; buoyancy=nothing,; closure=nothing,; ); println(""\n"", model, ""\n""). start_time = 1e-9*time_ns(); using Oceanostics: SingleLineProgressMessenger; simulation = Simulation(model, Δt=10seconds,; stop_time=10hours,; wall_time_limit=23.5hours,; iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; stop_iteration=Inf,). println(""\n"", simulation,""\n"",); @info ""---> Starting run!\n""; run!(simulation, pickup=false); ```. The output for Julia 1.5:. ```julia; [ Info: ---> Starting run!; [ Info: [000.14%] i: 5, time: 50.000 seconds, Δt: 10 seconds, wall time: 1.447 minutes, adv CFL: 0.00e+00, diff CFL: 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764:82,upgrade,upgrade,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764,2,"['install', 'upgrade']","['installation', 'upgrade']"
Deployability,Ideally all the tests we run on the CPU should be replicated with GPU models. This will mean more work for the JuliaGPU GitLab CI pipeline.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/78:130,pipeline,pipeline,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/78,1,['pipeline'],['pipeline']
Deployability,Improve function names and comments in Lagrangian particle update,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2685:59,update,update,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2685,1,['update'],['update']
Deployability,"In a supposedly quiescent flow with constant temperature and salinity, seeded with tiny random noise in `w`, a large-scale flow develops and is maintained. Thus the flow gains kinetic energy in an otherwise unforced configuration, creating a ""perpetual machine"". Here is a MWE:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; maximum(abs, sim.model.tracers.T),; maximum(abs, sim.model.tracers.S),; maximum(KE_total),; prettytime(sim.Δt)). wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3795:216,configurat,configuration,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795,1,['configurat'],['configuration']
Deployability,"In my last PR (#2335) I introduced tupled halo filling. . This PR required inferring the length of a Tuple of different element types on the GPU (which is not necessarily easy).; I found a hack to do it, but I was working in julia 1.7. Today, running a simulation with several different functional boundary conditions (in `discrete_form`) with julia 1.6, I found out that the compiler does not like my solution and does not infer the Tuple length (spitting out an `Invalid LLVM` error). This error is not there in julia-1.7. Unfortunately, I already merged my PR because I stupidly did not think to test all possible BC with julia-1.6. Now, to revert to a non-tupled halo filling which works across julia distribution it's a one-liner (in `field_tuples.jl`); ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; fill_halo_regions!(extract_field_data.(full_fields), extract_field_bcs.(full_fields), grid, args...; kwargs...); ```; to; ```; @inline fill_halo_regions_field_tuple!(full_fields, grid, args...; kwargs...) = ; for field in full_fields; fill_halo_regions!(field, args...; kwargs...); end; end; ```. What should we do? We could change this line and leave the infrastructure intact for when we update to julia-1.7 (then we would't have tupled halo filling till then) or find a completely different solution (which will require a lot of restructuring); Probably we also need more tests for boundary conditions with different BC on different sides. I see that the tests that run on julia-1.6 do not return an error though. Do other people encounter the same error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2358:1236,update,update,1236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2358,1,['update'],['update']
Deployability,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1077:35,continuous,continuous,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077,5,"['Continuous', 'Release', 'continuous', 'release']","['Continuous-Delivery-For-Julia-Packages', 'Release', 'continuous', 'release', 'release-right-now--dev-versions']"
Deployability,"In this PR I'll be updating the documentation, especially the model setup section, to reflect the many recent changes and additions to the API. To avoid this problem of documentation going out of date, I will also be converting and adding `jldoctest`s so we should actually get an error when documentation goes out of date. A lot of `@example` blocks don't run anymore and we even have a `jldoctest` failure but Travis CI seems to pass so I'll look into making Travis CI fail the doc build if a doctest fails. If we have a lot of doctests it might actually be easy to keep them updated: https://juliadocs.github.io/Documenter.jl/latest/man/doctests/#Fixing-Outdated-Doctests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/799:578,update,updated,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/799,1,['update'],['updated']
Deployability,Including installation of required packages in examples creates clutter in Docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1315:10,install,installation,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1315,1,['install'],['installation']
Deployability,Install TagBot as a GitHub Action,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/619:0,Install,Install,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/619,1,['Install'],['Install']
Deployability,"Instead of having us manually print a progress statement in a `while` loop, maybe we can pass a `progress_message(model)` function to `time_step!` that does this. This should help clean up the scripts a lot, and we could provide a couple of reasonable defaults instead of setting up this functionality in every script. Eventually the `progress_message(model)` function can be made fancy as we wish with unicode plots, a curses interface for complex progress output, or even email updates.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/432:480,update,updates,480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/432,1,['update'],['updates']
Deployability,Integrate LES functionality,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309:0,Integrat,Integrate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309,1,['Integrat'],['Integrate']
Deployability,Integrate finite volume operators,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529:0,Integrat,Integrate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529,1,['Integrat'],['Integrate']
Deployability,Integrate opening and closing of Netcdf outputwriters in simulation loop,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/650:0,Integrat,Integrate,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/650,1,['Integrat'],['Integrate']
Deployability,Integrating Oceananigans with Python-xgcm,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334:0,Integrat,Integrating,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334,1,['Integrat'],['Integrating']
Deployability,"It appears that CUDA 3.4 has a [bug](https://github.com/JuliaGPU/CUDA.jl/issues/1169), which apparently caused some trouble in https://github.com/CliMA/Oceananigans.jl/issues/1995 and https://github.com/CliMA/Oceananigans.jl/pull/1988. At the moment, however, adding Oceananigans still installs the latest CUDA version since CUDA's `compat` entry just specifies version 3:. https://github.com/CliMA/Oceananigans.jl/blob/73be08d708131a66402eb8fc0086c47ef80a2d0e/Project.toml#L36. It seems like the bug was merged upstream but they still haven't tagged a new release. Should we change the compat entry to protect users in the meantime? I'm not sure if the best way is to cap the version at 3.3 or if it's possible to exclude version 3.4.2 specifically, but I feel like it's best to act on this, no?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996:286,install,installs,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996,2,"['install', 'release']","['installs', 'release']"
Deployability,"It looks like KernelAbstractions.jl has added experimental support for AMD: https://github.com/JuliaGPU/KernelAbstractions.jl/releases/tag/v0.6.0. Should we try to make the code more GPU-architecture-agnostic based on that? From what I've heard, end-user level AMD GPUs are generally cheaper than Nvidia ones for similar performance. So running Oceananigans on AMD could potentially make it significantly easier for people to run simulations on their personal computer instead of a cluster.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1546:126,release,releases,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546,1,['release'],['releases']
Deployability,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2052:849,Integrat,Integrated,849,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052,1,['Integrat'],['Integrated']
Deployability,It's common for Buildkite jobs to fail intermittently and require a restart/retry. But so far it seems like we have to manually retry. Does every contributor have the permission to restart a Buildkite job?. Buildkite does support automatic retries. To improve the developer experience it's probably worth enabling automatic retries for jobs?. Happy to modify the Buildkite .yml to add retries!. Buildkite blog post: https://buildkite.com/blog/job-retries; Buildkite docs: https://buildkite.com/docs/pipelines/command-step#retry-attributes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3773:499,pipeline,pipelines,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3773,1,['pipeline'],['pipelines']
Deployability,"It's frustrating to encounter PyCall issues (as @sandreza and @qwert2266 already have) and it puts an extra burden on CI pipelines, so we should remove the SymPy dependency for now while the generated `WENO{N}` schemes are experimental.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/990:121,pipeline,pipelines,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/990,1,['pipeline'],['pipelines']
Deployability,It's time to update some dependencies :),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2966:13,update,update,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2966,1,['update'],['update']
Deployability,"Kind of a leftover relic I forgot to cleanup, but boundary condition API kernels still use the old `Tx, Ty` and `Bx, By, Bz` values to launch kernels. We should switch them to use dynamic launch configuration like all the other time stepping kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/363:195,configurat,configuration,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/363,1,['configurat'],['configuration']
Deployability,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1031:127,pipeline,pipeline,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031,2,"['install', 'pipeline']","['install', 'pipeline']"
Deployability,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1234:55,release,release,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234,2,['release'],['release']
Deployability,"L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ = Δᶠzᶜᶜᶜ = Δᶠ_ccc`?. 6. I could never find a symbol like `\cdot` for divergences that can be used in function names. What do you think of renaming function names like `∇_κ_∇c` to `div_κ_∇c`?. 7. `▶` is used in a lot of places in the `AbstractOperators` module. They should probably be changed to `ℑ` for consistency, but since it's all local to AbstractOperators, I'm leave the decision to @glwagner. Some changes we need to make for vertically stretched grids:; * I initially thought that we might need `apply_z_top_bc!` and `apply_z_bottom_bc!` to use ΔzC or ΔzF based on the field, but this would only apply to `w` for which you cannot use flux boundary conditions for z, so maybe it can always just use ΔzF (spacing between faces) and we can keep the one version.; * Same comment as above for `_fill_top_halo!` and `_fill_bottom_halo!`. I'll release v0.16 once this is merged as JULES.jl depends on these finite volume operators.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529:2848,release,release,2848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529,1,['release'],['release']
Deployability,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850:23,update,update,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850,2,['update'],"['update', 'updated']"
Deployability,"LatitudeLongitudeGrid{…}, callbacks::Vector{…}; compute_tendencies::Bool); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:50; [22] update_state!; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:31 [inlined]; [23] update_state!; @ ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:28 [inlined]; [24] update_state!(model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:28; [25] HydrostaticFreeSurfaceModel(; grid::LatitudeLongitudeGrid{…}, clock::Clock{…}, momentum_advection::Centered{…}, tracer_advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, free_surface::SplitExplicitFreeSurface{…}, tracers::Nothing, forcing::@NamedTuple{…}, closure::Nothing, boundary_conditions::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::@NamedTuple{}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/Hkk5J/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:204; [26] top-level scope; @ REPL[30]:1; Some type information was truncated. Use `show(err)` to see complete types.; ```. ---. Environment: Oceananigans.jl v0.91.11 and. ```; julia> versioninfo(); Julia Version 1.10.4; Commit 48d4fd48430 (2024-06-04 10:41 UTC); Build Info:; Official https://julialang.org/ release; Platform Info:; OS: Linux (x86_64-linux-gnu); CPU: 48 × AMD Ryzen Threadripper 7960X 24-Cores; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-15.0.7 (ORCJIT, znver3); Threads: 1 default, 0 interactive, 1 GC (on 48 virtual cores); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3736:7052,release,release,7052,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3736,1,['release'],['release']
Deployability,Linear equation of state should be upgraded to account for salinity and pressure.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/20:35,upgrade,upgraded,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/20,1,['upgrade'],['upgraded']
Deployability,Linux CPU+GPU tests are running on Buildkite so we can stop testing on GitLab CI. One less CI pipeline to maintain.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1049:94,pipeline,pipeline,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1049,1,['pipeline'],['pipeline']
Deployability,Low priority item. But no need to install CUDA packages if you're only going to run on a CPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/79:34,install,install,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/79,1,['install'],['install']
Deployability,"Matrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity2)}}}, Nothing, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:13953,Continuous,ContinuousBoundaryFunction,13953,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,Mid-Level Enzyme + Oceananigans Integration Test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3346:32,Integrat,Integration,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3346,1,['Integrat'],['Integration']
Deployability,"Might be because I updated the `Manifest.toml` which included an upgrade to OffsetArrays v1.3.0 but @qwert2266 ran into this issue on Oceananigans v0.37.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: MethodError: OffsetArrays.OffsetArray(::CUDA.CuArray{Float64,3}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) is ambiguous. Candidates:; (::Type{OffsetArrays.OffsetArray})(A::AbstractArray, inds...) in OffsetArrays at /home/alir/.julia/packages/OffsetArrays/CXQGe/src/OffsetArrays.jl:172; (::Type{OffsetArrays.OffsetArray})(underlying_data, grid::Oceananigans.Grids.AbstractGrid, loc) in Oceananigans.Fields at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:33; Possible fix, define; OffsetArrays.OffsetArray(::AbstractArray, ::Oceananigans.Grids.AbstractGrid, ::Any); Stacktrace:; [1] new_data(::Type{T} where T, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:70; [2] XFaceField(::DataType, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/991:19,update,updated,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991,3,"['release', 'update', 'upgrade']","['release', 'updated', 'upgrade']"
Deployability,"Might be good to start learning how to properly profile Oceananigans. It is slowing down a little bit as we add more things and develop stuff (see https://github.com/climate-machine/Oceananigans.jl/pull/147#issuecomment-479474578). We can easily profile it on a CPU to see where the code spends the most time and maybe find some easy things to optimize before profiling it on a GPU where things might be less obvious. Some useful links:; * https://docs.julialang.org/en/v1/manual/profile/index.html; * https://github.com/JuliaLang/julia/issues/4483 (might have to patch LLVM, could be a pain to get working).; * https://docs.nvidia.com/cuda/profiler-users-guide/index.html; * https://juliagpu.github.io/CUDAnative.jl/stable/man/performance.html#Optimizing-1; * https://discourse.julialang.org/t/writing-fast-stencil-computation-kernels-that-work-on-both-cpus-and-gpus/20200 (I pasted some commands where I use nvprof)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/162:564,patch,patch,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/162,1,['patch'],['patch']
Deployability,Minor updates in `Docs/simulation_tips`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3106:6,update,updates,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3106,1,['update'],['updates']
Deployability,Minor upgrades to reductions of fields and AbstractOperations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2039:6,upgrade,upgrades,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2039,2,['upgrade'],['upgrades']
Deployability,Miscellaneous updates to get ConformalCubedSphereGrid simulations running on the GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1608:14,update,updates,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1608,1,['update'],['updates']
Deployability,Moves masking fields from model update to output writers when using ImmersedBoundary,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616:32,update,update,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616,1,['update'],['update']
Deployability,Need to update README and docs to mention the new Julia 1.4+ requirement.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/765:8,update,update,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/765,1,['update'],['update']
Deployability,Need to update `ParameterizedForcing` constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/785:8,update,update,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/785,1,['update'],['update']
Deployability,"Not sure if this is the best place to post this, but I was thinking it would be good if, every time there is a breaking release (or a release that's particularly significant even if it's non-breaking), there is a small text in the release indicating the important/breaking features. (Or maybe even something on slack?). This is something that has implicitly come up in a few conversations I've had with Oceananigans users that don't also do development (and thus don't keep track of PRs, etc.). The advantages that I can see are:. - Users can have an idea if their code will break with updating, which might prompt them to update more often; (I think in practice lots of users don't update their code regularly since there's a looming possibility of their code to stop running and them having to deal with errors.); - If their code will break, users will have an idea as to what they should change in order to fix it (as opposed to running it and fixing the code error-by-error). The downside is that it requires someone to manually write something in most releases. But I think this is easy enough that it shouldn't be a problem. PS: Btw I should say, I mentioned non-developer users above, but I very much include myself in the group that would benefit from this. There's often a lot going on in Oceananigans and it's easy to get overwhelmed with research and lose track of important PRs. For example v0.83.0 just dropped, implying a breaking change, and I cannot figure out which was the breaking change. Curious to hear everyone's thoughts.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147:120,release,release,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147,6,"['release', 'update']","['release', 'releases', 'update']"
Deployability,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/916:47,release,release,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916,4,"['Release', 'release']","['Release', 'release']"
Deployability,"Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:νₑ, :κₑ),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, NamedTuple{(:u, :v, :w, :T, :S),Tuple{ContinuousForcing{Face,Cell,Cell,Nothing,Relaxation{Float64,GaussianMask{:x,Float64},LinearTarget{:x,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Face,Cell,Nothing,Relaxation{Float64,GaussianMask{:y,Float64},LinearTarget{:y,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Cell,Face,Nothing,Relaxation{Float64,GaussianMask{:z,Float64},Irrational{:π}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},typeof(Oceananigans.Forcings.zeroforcing),typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] getindex at namedtuple.jl:94; [2] field_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:118; [3] forcing_func_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:139; [4] ContinuousForcing at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:156; [5] u_velocity_tendency at /archive1/glwagner/Projects/Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1059:3100,Continuous,ContinuousForcing,3100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059,3,['Continuous'],['ContinuousForcing']
Deployability,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:93,Continuous,ContinuousForcing,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,2,['Continuous'],"['ContinuousBoundaryFunction', 'ContinuousForcing']"
Deployability,Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Mo,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2714,release,release-,2714,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['release'],['release-']
Deployability,Once we decide on a final draft on Google Docs I'll update `paper.md`. JOSS requires a Markdown paper to be available in the repository. X-Ref: https://github.com/openjournals/joss-reviews/issues/1965; X-Ref: https://github.com/openjournals/joss-reviews/issues/2018,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/564:52,update,update,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/564,1,['update'],['update']
Deployability,"Our suite of examples is fairly expensive; in recent runs the documentation build exceeds 90 minutes. If we're able to ""build"" the examples _first_, before calling `makedocs`:. https://github.com/CliMA/Oceananigans.jl/blob/8da72d122f887c1584d8c6f0bb5d4eea27e003d3/docs/make.jl#L155-L165. we can probably speed up the build. This is crucial now because we need to add new examples both for `HydrostaticFreeSurfaceModel` and for simulations in complex domains via `ImmersedBoundaryGrid`. We can also move some examples to the GPU and either speed them up, run them at higher resolution, or both. What I know now: we provide `.md` files to `makedocs`, which then expands code blocks and generates `.html`:. https://github.com/CliMA/Oceananigans.jl/blob/8da72d122f887c1584d8c6f0bb5d4eea27e003d3/docs/make.jl#L66. https://github.com/CliMA/Oceananigans.jl/blob/8da72d122f887c1584d8c6f0bb5d4eea27e003d3/docs/make.jl#L133. https://github.com/CliMA/Oceananigans.jl/blob/8da72d122f887c1584d8c6f0bb5d4eea27e003d3/docs/make.jl#L159. I think one solution is to generate the `.html` (by running code, which generates images and animations + links in the `html`) in separate buildkite jobs, and then somehow generate links to the pre-built `.html` in the ""primary"" `make.jl`call to `makedocs` before `deploydocs`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2309:1286,deploy,deploydocs,1286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2309,1,['deploy'],['deploydocs']
Deployability,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1011:43,continuous,continuous,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011,3,"['continuous', 'integrat']","['continuous', 'integrated']"
Deployability,"Over at [JULES.jl](https://github.com/thabbott/JULES.jl) @thabbott, @RaphaelRR, and I have been building a compressible non-hydrostatic model on top of Oceananigans.jl for atmospheric simulations. It follows the numerics of the Advanced Research WRF Model as described in Klemp et al. (2007) and Skamarock et al. (2019). With three qualitative verification experiments I think it's ready to be tagged as v0.1. I'm opening this issue to discuss the possibility of merging JULES.jl into Oceananigans.jl which would add a `CompressibleModel` type (discussed a bit in #566). The two models share a lot of the infrastructure we've already built for Oceananigans, and in integrating the two we will readily get a GPU-ready research-grade compressible atmosphere model. Verification experiments:; 1. Hydrostatic adjustment in an isothermal atmosphere [very qualitative, see Bannon (1995)]; 2. Dry rising thermal bubble: https://github.com/thabbott/JULES.jl/pull/31; 3. Nonlinear density current: https://github.com/thabbott/JULES.jl/pull/32. Dry rising thermal bubble can be compared with figure 5 of Wicker and Skamarock (1998), figure 7 of Jahn et al. (2015), and https://faculty.nps.edu/fxgirald/projects/mesoscale/rtb_movie.html. Nonlinear density current can be compared with figure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoust",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605:665,integrat,integrating,665,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605,1,['integrat'],['integrating']
Deployability,"PR for discussion of changes to main. There are some things that can go in soon, others may require more work. . Note . - Julia AMD GPU stack (AMDGPU.jl, KernelAbstractions.jl) needs 1.7 Julia at least.; - Currently AMDGPU.jl works against ROCM 4.2. More recent ROCM 5 has LLVM that is ahead of Julia 1.7, so that breaks things! ; - people who are working on relevant Julia support include @jpsamaroo @vchuravy @luraess and @matinraayai .... What fun! . A buildkite test is here ( https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/.buildkite/pipeline.yml#L496 ) which gives some clues on what is needed to run something on MI50.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2540:579,pipeline,pipeline,579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540,1,['pipeline'],['pipeline']
Deployability,"Patch release including bug fix for biogeochemistry fallbacks (#3685), `mask_immersed_field!` method for `BinaryOperations` (#3683), restricting lat/lon grid topologies (#3694), and more Makie recipe components (#3715).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3722:0,Patch,Patch,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3722,2,"['Patch', 'release']","['Patch', 'release']"
Deployability,Patch security loophole,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1225:0,Patch,Patch,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1225,1,['Patch'],['Patch']
Deployability,"Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity1), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity2), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Face, Center, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity3), typeof(Oceananigans.Operators.ℑyzᵃᶠᶜ)}}}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity4), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Face, Nothing, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_v), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.identity5), typeof(Oceananigans.Operators.ℑyᵃᶠᵃ)}}}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563:17066,Continuous,ContinuousBoundaryFunction,17066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746:992,configurat,configuration,992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746,2,['configurat'],['configuration']
Deployability,"Presently, applying differential operators to fields offline (as opposed to using diagnosing them online using using an `OutputWriter`) yields erroneous results because derivatives seem to be naively using output halo region values (which seem to be filled with zeroes by default) and not overwriting them to satisfy boundary conditions. One example impact of this is that the [Nusselt number calculation in the `horizontal_convection.jl` example script](https://clima.github.io/OceananigansDocumentation/stable/generated/horizontal_convection/#The-Nusselt-number) is totally meaningless because it is dominated by spuriously large buoyancy gradients in the boundary-adjacent cells. @ikeshwani and I demonstrate this bug in [this `horizontal_diffusion.jl` script](https://github.com/hdrake/HorizontalConvection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224:972,integrat,integrate,972,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224,1,['integrat'],['integrate']
Deployability,Prevents race condition from multiple builds attempting to use/delete the same julia install,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662:85,install,install,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662,1,['install'],['install']
Deployability,Probably important to tag and release a new version following #1228.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1231:30,release,release,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1231,1,['release'],['release']
Deployability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127:571,update,update,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127,1,['update'],['update']
Deployability,Problem installing and using Oceananigans,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:8,install,installing,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['install'],['installing']
Deployability,Quick test tells me everything works with latest CUDA packages which just got released but will have to refactor a bit to make use of GPUifyLoop's new `@launch` functionality (and remove the `@setup` calls).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153:78,release,released,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153,1,['release'],['released']
Deployability,"Recent calibration developments may have produced better defaults, e.g., here:; https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/CATKEVerticalDiffusivities.jl#L108; and; https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/mixing_length.jl#L69-L85. Should we update these values?. (I'd like to add CATKE closure to the channel...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2272:501,update,update,501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2272,1,['update'],['update']
Deployability,Reduce ContinuousBoundaryFunction location + features for auxiliary fields,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1859:7,Continuous,ContinuousBoundaryFunction,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,Reduce memory fetch for ContinuousBoundaryFunction BCs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3077:24,Continuous,ContinuousBoundaryFunction,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3077,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,Release notes:. * Fixes a major bug with `ImmersedBoundaryGrid` that elided all viscous fluxes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1844:0,Release,Release,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1844,1,['Release'],['Release']
Deployability,"Release notes:. * Tests and fixes for `FFTBasedPoissonSolver` for topologies with `Flat` dimensions (#1560); * Improved `AbstractOperations` that are much more likely to compile on the GPU, with better ""location inference"" for `BinaryOperation` (#1595, #1599)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1600:0,Release,Release,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1600,1,['Release'],['Release']
Deployability,"Release notes:. **Everyone should stop using Oceananigans v0.31.0 and upgrade to this version. Oceananigans now requires Julia 1.4 or later.**. This release fixes a major bug concerning a race condition making GPU simulation, especially large models, explode into NaNs in v0.31.0. It also restores the ""Examples"" section in the documentation and adds experimental support for higher order advection schemes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/821:0,Release,Release,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/821,3,"['Release', 'release', 'upgrade']","['Release', 'release', 'upgrade']"
Deployability,Release notes:. This is a bugfix release that disables CuArray scalar operations by default (to avoid surprise scalar operations that can cause huge slowdowns) and **fixes a related bug where writing GPU fields to NetCDF was very slow**. Also includes small updates to the documentation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/852:0,Release,Release,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/852,3,"['Release', 'release', 'update']","['Release', 'release', 'updates']"
Deployability,"Release notes:. This release adds new features to the `NetCDFOutputWriter` and fixes some bugs.; * The date the file was generated, the Julia version, and the Oceananigans version used are always written as global attributes (metadata) to all NetCDF files.; * Added `with_halos` and `verbose` keyword arguments to `NetCDFOutputWriter`.; * Fixed bug in writing grid coordinates to NetCDF (they were previously offset).; * Fixed bug in printing of grid coordinate ranges for `Bounded` dimensions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/825:0,Release,Release,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/825,2,"['Release', 'release']","['Release', 'release']"
Deployability,"Release notes:. This release adds some new features, fixes some bugs, and improves the API (so there are some breaking changes, listed below). Major changes:; * Triply periodic models are now available by passing the `topology = (Periodic, Periodic, Periodic)` keyword argument to grids.; * All 1D, 2D, and 3D averages are now available through the `Average` diagnostic with the `dims` keyword argument.; * Fixed some checkpointing bugs.; * **BREAKING:** Use `Average(..., dims=(1, 2))` instead of `HorizontalAverage(...)`.; * **BREAKING:** Use `iteration_interval` and `time_interval` instead of `frequency` and `interval` for diagnostics and output writers.; * **BREAKING:** Use `iteration_interval` instead of `progress_frequency` for simulations.; * **BREAKING:** Use `IsotropicDiffusivity` and `AnisotropicDiffusivity` instead of `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity`. Also, use `νz` instead of `νv` and `κz` instead of `κv`.; * **BREAKING:** To `restore_from_checkpoint`, pass model constructor arguments as you would to a normal constructor, e.g. `restore_from_checkpoint(""my_checkpoint.jld2"", boundary_conditions=custom_bcs)`. Previous behavior was to pass a dictionary which was less user friendly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/847:0,Release,Release,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/847,2,"['Release', 'release']","['Release', 'release']"
Deployability,"Release notes:. This release adds support for time averaging and field slicing to `NetCDFOutputWriter`. **Breaking changes**:; * `NetCDFOutputWriter` constructor: The `filename` keyword argument is now `filepath`.; * `NetCDFOutputWriter` constructor: To specify slices, pass a `FieldSlicer(i, j, k; with_halos)` instead of using the `xC`, `xF`, `yC`, `yF`, `zC`, and `zF` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1067:0,Release,Release,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1067,2,"['Release', 'release']","['Release', 'release']"
Deployability,Remove SymPy dependency in next release of Oceananigans,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/990:32,release,release,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/990,1,['release'],['release']
Deployability,Remove event system from KA and update to CUDA v4.1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924:32,update,update,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924,1,['update'],['update']
Deployability,Removes all support for <1.9 Julia versions and update `Project.toml`. Closes #3184,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3190:48,update,update,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3190,1,['update'],['update']
Deployability,"Reported by @sandreza. Not a problem yet but we should update `versioninfo_with_gpu()` in PR #860. I think we change `CUDA.context() |> CUDA.device |> CUDA.name` to just `CUDA.device() |> CUDA.name`. Even better, we could start making use of the new `CUDA.versioninfo()` which has lots more CUDA and GPU info. <img width=""1126"" alt=""Screen Shot 2020-08-21 at 10 11 58 PM"" src=""https://user-images.githubusercontent.com/20099589/91040039-92b2a080-e5db-11ea-8d72-d1bdfb2d7210.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/866:55,update,update,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/866,1,['update'],['update']
Deployability,"Requires https://github.com/EnzymeAD/Enzyme.jl/pull/1485 to release, which itself requires https://github.com/JuliaRegistries/General/pull/108556. Perhaps means we don't change the other varargs stuff, but we'll have to wait and see.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3618:60,release,release,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3618,1,['release'],['release']
Deployability,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799:112,toggle,toggle,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799,1,['toggle'],['toggle']
Deployability,Resolves #578 ; Updates runtests to use the ModelLogger; Updates tests to use @info instead of println,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/585:16,Update,Updates,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/585,2,['Update'],['Updates']
Deployability,Resume from checkpoint should be integrated with model constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/602:33,integrat,integrated,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/602,1,['integrat'],['integrated']
Deployability,"Revert ""Update CUDA packages to get rid of CUDA errors on CPU and use CUDAapi.has_cuda()""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/387:8,Update,Update,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/387,1,['Update'],['Update']
Deployability,"Rewrote the time stepping algorithm to perform operations element-wise which allows the MITgcm algorithm to fully utilize a GPU (for large enough problems). And the same code runs on the CPU. Essentially we have a massive triple for loop iterating over all the grid points and functions that e.g. calculate u-momentum advection at grid point (i,j,k). The code is ugly and unorganized right now but I just wanted to get something working. Now we can work on cleaning up the code and optimizing performance. You can see for yourselves how bad the native type element-wise operators are but the time stepping loop should clean up nicely. It's split up into 4-5 kernels as the GPU needs to synchronize between certain steps. I've had to make some compromises writing it for the GPU, mainly by stripping away all the abstractions as the GPU will only deal with native data types. But we can figure this stuff out, it can only get better from here. This time stepping will essentially replace what's already in place (and turn the code into a CPU/GPU capable package) so might as well merge and start working on integrating it (and getting some sort sort of GPU CI working). Resolves #49",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/54:1106,integrat,integrating,1106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/54,1,['integrat'],['integrating']
Deployability,"Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01 | 7.889e-03 | 8.798e-03 |; ```. (https://github.com/CliMA/OceananigansArtifacts.jl/pull/14). Everything is preliminary because we still need to upgrade to LESbrary 2.0 (with Stokes drift and more cases).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2423:2146,upgrade,upgrade,2146,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423,1,['upgrade'],['upgrade']
Deployability,"Right now GitLab CI fails on nightly/dev builds because CUDAapi isn't a package anymore. This PR updates the dependencies/packages in Project.toml to the latest version which should also fix this. There was some mix-up about a month ago that forced us to switch to the master branch of a lot of GPU packages, but things seem fine now. Sticking with GPUifyLoops v0.2.3 because of https://github.com/vchuravy/GPUifyLoops.jl/issues/66. Also removes CUDAapi which isn't a package anymore, and NNlib which was never supposed to be a direct dependency.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/244:97,update,updates,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/244,1,['update'],['updates']
Deployability,"Right now I'm just constructing grids with dimensions that are multiples of 16 so; ```julia; Tx, Ty = 16, 16 # Threads per block; Bx, By, Bz = Int(Nx/Tx), Int(Ny/Ty), Nz # Blocks in grid.; ```. @vchuravy suggested laying them out to fill out the _x_-direction first, then the _y_-direction, then the _z_-direction. That would also let us use grids with arbitrary sizes, i.e. not just multiples of 16. Not sure if it would affect performance for large problems. See https://github.com/vchuravy/GPUifyLoops.jl/pull/18#issuecomment-465150581. Update: Yeah I should have done this a long time ago. This issue is preventing us from running small grids (e.g. 1D column models) on the GPU and running certain tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/64:540,Update,Update,540,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/64,1,['Update'],['Update']
Deployability,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2051:268,integrat,integrate,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051,2,"['Integrat', 'integrat']","['IntegratedField', 'integrate']"
Deployability,"Right now all our tests are lumped into one (unit, integration, and model verification tests) and we run the tests on the CPU and the GPU (most tests are shared). This is not a high priority item right now, but it's already annoying that I have to wait several minutes for the GPU tests to run as I'm debugging. So just starting up a discussion around this topic. I can see us hitting some limitations soon:; 1. A comprehensive test suite will take time to run, long enough that we cannot keep running it during development and debugging.; 2. Comprehensive model verification tests (or system tests?) will take even longer to run and are absolutely crucial (see #81 #136), so this problem will get worse in the future.; 3. GPU tests take a while to run because of long compile time (#66) and they run on top of all the CPU tests. In general, setting up GPU models take more time so it's not ideal that we're setting up tons of tiny models for testing. Testing GPU stuff may also involve some expensive scalar CUDA operations (see #82). We will also need to run the test suite on the following architectures in the future:; 1. single-core CPU (Travis CI and Appveyor are fine here); 2. single GPU (JuliaGPU's GitLab CI pipeline works great here); 3. multi-core single CPU (MPI) (paid CI plans will probably work here); 4. multiple distributed CPU nodes (MPI) (no idea where to run this); 5. multiple GPUs (MPI) (no idea where to run this). Some ideas for things to do that will help:; 1. Explicitly split the tests up into 2-3 suites; 1.1. **Unit tests**: should run in a few minutes so we can run them during development and on every commit/PR/etc.; 1.2. **Integration tests**: can take a while to run so we don't want to run these locally all the time but probably on every PR. Shouldn't take much more than 1 hour to run so we don't have to wait forever to merge PR's.; 1.3. **Model verification tests** (also called _end-to-end_ tests): will probably take a long time to run. Maybe run this once a ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/139:51,integrat,integration,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/139,1,['integrat'],['integration']
Deployability,Right now it's done through Travis which is very slow. We can build and deploy docs much faster on Buildkite as Tartarus has lots of CPU resources.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1051:72,deploy,deploy,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1051,1,['deploy'],['deploy']
Deployability,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1086:707,pipeline,pipeline,707,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086,1,['pipeline'],['pipeline']
Deployability,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1056:370,pipeline,pipelines,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056,1,['pipeline'],['pipelines']
Deployability,"Right now we have monstrosities like (this one is a bit extreme); ```julia; Nx, Ny, Nz = model.grid.Nx, model.grid.Ny, model.grid.Nz; Lx, Ly, Lz = model.grid.Lx, model.grid.Ly, model.grid.Lz; Δx, Δy, Δz = model.grid.Δx, model.grid.Δy, model.grid.Δz. grid = model.grid; cfg = model.configuration; bcs = model.boundary_conditions; clock = model.clock. G = model.G; Gp = model.Gp; constants = model.constants; eos = model.eos; U = model.velocities; tr = model.tracers; pr = model.pressures; forcing = model.forcing; poisson_solver = model.poisson_solver. δρ = model.stepper_tmp.fC1; RHS = model.stepper_tmp.fCC1; ϕ = model.stepper_tmp.fCC2. gΔz = model.constants.g * model.grid.Δz; fCor = model.constants.f. uvw = U.u.data, U.v.data, U.w.data; TS = tr.T.data, tr.S.data; Guvw = G.Gu.data, G.Gv.data, G.Gw.data. # Source terms at current (Gⁿ) and previous (G⁻) time steps.; Gⁿ = G.Gu.data, G.Gv.data, G.Gw.data, G.GT.data, G.GS.data; G⁻ = Gp.Gu.data, Gp.Gv.data, Gp.Gw.data, Gp.GT.data, Gp.GS.data; ```. Would be nice to prettify or abstract away this unpacking. @charleskawczynski I noticed you used some @unpack macros in the code you showed on Monday, is it up on GitHub by any chance?. I think [Parameters.jl](https://github.com/mauro3/Parameters.jl) implements an @unpack macro, might be good to look at.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/155:281,configurat,configuration,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155,1,['configurat'],['configuration']
Deployability,"See, e.g., at https://github.com/Alexander-Barth/NCDatasets.jl/releases/tag/v0.13.0. Does anything of the above affect us? Should we take care before upgrading?. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3309:63,release,releases,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3309,1,['release'],['releases']
Deployability,Seems like there is some issue with SSH deploy keys and travis can't deploy the docs to [OceananigansDocumentation](https://github.com/CliMA/OceananigansDocumentation). See:; https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/362580712#L1729,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/808:40,deploy,deploy,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/808,2,['deploy'],['deploy']
Deployability,Set up Slurm pipeline for performance regression testing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/280:13,pipeline,pipeline,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/280,1,['pipeline'],['pipeline']
Deployability,Should at least help with detecting doctest failures and we want to build+deploy docs on Buildkite anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1018:74,deploy,deploy,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018,1,['deploy'],['deploy']
Deployability,"Should have instructions for:; * How to install the package as a user.; * How to `git clone`, `instantiate`, and `test` the package as a developer.; * CPU instructions.; * GPU instructions.; * When #151 is resolved, docker installation instructions. CPU and GPU instructions should not be separate but when #79 is solved, we should be able to run on the CPU without installing (and failing to build) all the CUDA packages.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/152:40,install,install,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/152,3,['install'],"['install', 'installation', 'installing']"
Deployability,Should probably tag a bugfix release v0.44.1 with this PR. Resolves #1141,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1142:29,release,release,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1142,1,['release'],['release']
Deployability,Should tag a new release once PRs #1014 and #997 are merged.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1032:17,release,release,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1032,1,['release'],['release']
Deployability,"Should we change to 1.5.4 and be on the ""bleeding edge""?; https://github.com/CliMA/Oceananigans.jl/blob/26ce05b232259f69a858a45fbcf62e3d778cb195/.buildkite/pipeline.yml#L2. cc @maleadt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1461:156,pipeline,pipeline,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1461,1,['pipeline'],['pipeline']
Deployability,"Simple Dockerfile to build a Docker image with Oceananigans installed, precompiled, and with dependencies built. Should be useful for debugging and maybe speeding up CI. Image can be built then just downloaded by CI server, but usually testing is done before Docker image is built... We also have a Dockerhub repository where images will be published: https://cloud.docker.com/repository/docker/aliramadhan/oceananigans. We can look into automated builds: https://docs.docker.com/docker-hub/builds/. For GPU-accelerated container we can look into: https://github.com/NVIDIA/nvidia-docker. cc @christophernhill we're finally in the 21st century!. Resolves #151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/316:60,install,installed,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/316,1,['install'],['installed']
Deployability,Slight terminology upgrade in eady example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1187:19,upgrade,upgrade,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1187,1,['upgrade'],['upgrade']
Deployability,Small bugfix for `ContinuousBoundaryFunction`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2634:18,Continuous,ContinuousBoundaryFunction,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2634,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,Small wording updates + missing `` added for correct rendering in horizontal convection example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3108:14,update,updates,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3108,1,['update'],['updates']
Deployability,"Some of the buildkite pipelines take way too long. Specifically the `time_stepping_2`, `regression` and `solver` tests. I suggest we further split them?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2139:22,pipeline,pipelines,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2139,1,['pipeline'],['pipelines']
Deployability,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202:1657,configurat,configuration,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202,1,['configurat'],['configuration']
Deployability,Some updates in Docs/Simulations tips,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2958:5,update,updates,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2958,1,['update'],['updates']
Deployability,Some updates in validation scripts: `AveragedField()` -> `Field(Average())`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2630:5,update,updates,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2630,1,['update'],['updates']
Deployability,"StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Oceananigans.Forcings.ContinuousForcing{Face, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_u), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity1)}}, typeof(Oceananigans.Forcings.zeroforcing), typeof(Oceananigans.Forcings.zeroforcing), Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_T), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity2)}}, Oceananigans.Forcings.ContinuousForcing{Center, Center, Center, NamedTuple{(:Lx, :Ly, :Lz, :Nx, :Ny, :Nz, :N²₀, :u₁_west, :ℓ₀, :σ, :u_b, :v_b, :u_out), Tuple{Int64, Int64, Int64, Int64, Int64, Int64, Vararg{Float64, 7}}}, typeof(sponge_S), Tuple{Symbol}, Tuple{Int64}, Tuple{typeof(Oceananigans.Operators.identity3)}}}}, WENO{3, Float64, Nothing, Nothing, Nothing, true, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, true, Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3609:23299,Continuous,ContinuousForcing,23299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3609,1,['Continuous'],['ContinuousForcing']
Deployability,"StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Open, Nothing}, ImmersedBoundaryCondition{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity4)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing, Center, Face, Oceananigans.BoundaryConditions.RightBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑzᵃᵃᶠ), typeof(Oceananigans.Operators.identity5)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center, Nothing, Face, Oceananigans.BoundaryConditions.LeftBoundary, typeof(bottom_drag_w), Float64, Tuple{Symbol, Symbol}, Tuple{Int64, Int64}, Tuple{typeof(Oceananigans.Operators.ℑxzᶜᵃᶠ), typeof(Oceananigans.Operators.identity1)}}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2860:13604,Continuous,ContinuousBoundaryFunction,13604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2860,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"Strange that we don't have this already but this PR refactors the operators to be truly finite volume. By using multiple dispatch we only have one operator rather than having a different operator for each grid. The beautiful ϊ (`\iota\ddot`) now denotes interpolation. Thanks @sandreza!. Need to switch to using the `caa`, `afa`, etc. notation and introduce some composite operators from `closure_operators.jl`. Just opening this PR early so people can see what the new operators look like, get some feedback, etc. Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like; ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```; but still thinking about the best way to dispatch on e.g. `DoublyPeriodicDomain`, `ChannelDomain`, `TriplyPeriodicDomain`, etc. I will also release v0.7.0 once this PR is merged. Resolves #115; Resolves #146 ; Resolves #469",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283:917,release,release,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283,1,['release'],['release']
Deployability,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:15038,Continuous,ContinuousForcing,15038,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:12277,Continuous,ContinuousForcing,12277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:310; [8] #87 at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDI",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:7066,Continuous,ContinuousForcing,7066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:298; [19] macro expansion at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:109 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, work",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:17543,Continuous,ContinuousForcing,17543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [10] macro expansion at ./lock.jl:183 [inlined]; [11] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_cal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:9804,Continuous,ContinuousForcing,9804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,Thanks for the heads up @vchuravy and @maleadt! Will remove the old deployment key from https://github.com/CliMA/OceananigansDocumentation and generate a new one (that'll actually stay a secret).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1225:68,deploy,deployment,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1225,1,['deploy'],['deployment']
Deployability,The README example uses old syntax for time-stepping a model forward and I don't think will run with #master. It needs to be updated to use the Simulation type.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/633:125,update,updated,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/633,1,['update'],['updated']
Deployability,"The `Diagnostics` docs need to be updated to use `AveragedField`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/diagnostics/. but perhaps more importantly, we should probably merge this page with `OutputWriters`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/output_writers/. We also need to add docs for `WindowedTimeAverage`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1062:34,update,updated,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1062,1,['update'],['updated']
Deployability,The `GITHUB_REPOSITORY` environment variable is used by GitHub actions. We deploy from Travis so the right environment variable is `TRAVIS_REPO_SLUG`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/804:75,deploy,deploy,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/804,1,['deploy'],['deploy']
Deployability,"The `validation` scripts have proved useful for code development since they essentially provide convenient scientific / integration tests which would be hard or expensive to implement in CI, but which are still useful when implementing or evaluating a new feature. They also help us share knowledge and code. Yet a major problem is that the `validation` scripts are not tested and therefore most of them are broken, since they aren't updated as Oceananigans syntax changes. I was talking with @siddharthabishnu and we realized that a possible solution would be to follow the convention used by Flux's ""model-zoo"": https://github.com/FluxML/model-zoo. With this pattern, every validation ""experiment"" is a directory that includes a collection of scripts and a `Project.toml`. The `Project.toml` indicates the version of Oceananigans. If people want to upgrade the scripts + environment they can submit a PR. We'd still be informally testing the validation scripts, but hopefully this would make them more useful in the future, especially to new users. We'll have to select a handful of cases that we want to keep around in the process of transitioning to the new system.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3076:120,integrat,integration,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3076,3,"['integrat', 'update', 'upgrade']","['integration', 'updated', 'upgrade']"
Deployability,"The current Manifest conflicts with FFMPEG v0.4 and thus enforces it to fallback to FFMPEG v0.2.; This, in principle, is not a problem since we don't depend on FFMPEG. But as soon as we try to use Makie/GLMakie which has FFMPEG as a dependency then it is forced to use FFMPEG v0.2. FFMPEG v0.2 cannot compile on Apple’s M1/M2 chips and this creates errors and inconvenience. . I tried to enforce installing `FFMPEG@v0.4` on the current environment and this resulted in downgrade of some `jll`s. ```; ⌅ [0234f1f7] ↓ HDF5_jll v1.14.0+0 ⇒ v1.12.2+2; ⌃ [7243133f] ↓ NetCDF_jll v400.902.208+0 ⇒ v400.902.5+1; ⌅ [458c3c95] ↓ OpenSSL_jll v3.0.9+0 ⇒ v1.1.21+0; ```. Informed by that, this PR ensures that those `jll`s satisfy `FFMPEG`s dep requirements so that people with Apple M1/2 chips (like myself) can still use Oceananigans + Makie for plotting. I've been troubling with this all morning along with @glwagner and @siddharthabishnu. Not sure if this is the best solution possible, but it does work. Hopefully this is something that it will be fixed from other packages moving forward.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3161:396,install,installing,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3161,1,['install'],['installing']
Deployability,"The discussion on https://github.com/CliMA/Oceananigans.jl/discussions/3098 had me thinking about how we might allow users to access more model data within forcing or boundary condition functions. The problem we encountered in the past (especially for diffusivity fields) is that dumping _everything_ into the forcing function often caused GPU compilation to fail. That's why forcing functions only have access (for example) to velocities, tracers, and auxiliary fields:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L62. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl#L74. A possible solution to this is a utility `with_auxiliary_fields` for ""rebuilding"" a model with new auxiliary fields. I think this would be relatively simple to implement, because the `auxiliary_fields` don't have any role within a model constructor. Thus we can develop something like. ```julia; model = with_auxiliary_fields(model, new_auxiliary_fields); ```. which is quite easy I think, something like... ```julia; function with_auxiliary_fields(model::NonhydrostaticModel, new_auxiliary_fields); model_properties = OrderedDict{Any, Any}(name => getproperty(model, name) for name in propertynames(model)); model_properties[:auxiliary_fields] = new_auxiliiary_fields; return NonhydrostaticModel(model_properties.values...); end; ```. Then users can run simulations with the ""updated"" model, putting any fields they like from the ""old"" model into `auxiliary_fields`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3099:1585,update,updated,1585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3099,1,['update'],['updated']
Deployability,The docs repo is running out of space. In an attempt to remedy that I'm trying here `forcepush = true` for deploying docs. https://juliadocs.github.io/Documenter.jl/stable/lib/public/#Documenter.deploydocs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2243:107,deploy,deploying,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2243,2,['deploy'],"['deploydocs', 'deploying']"
Deployability,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1046:21,install,install,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046,3,"['configurat', 'install']","['configuration', 'install', 'installed']"
Deployability,"The idea here is to minimize the amount of modifications required to the parent script when model is being restarted from a checkpoint. Currently, the script might look like this when the model is being run for the first time:; ```julia; model = Model(; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); # model = restore_from_checkpoint(path; kwargs); ```; When restarting from the checkpoint, we'll have to comment the first 9 lines and uncomment the following line. This gets annoying pretty quickly when running a large suite of experiments. So I thought it would be better to integrate the checkpoint specification with model constructor. . ```julia; model = Model(; restarter = ""/path/to/checkpoint/file"",; architecture = GPU(),; float_type = Float64,; grid = RegularCartesianGrid(size=(Nx, Ny, Nz), length=(Lx, Ly, Lz)),; coriolis = coriolis,; buoyancy = SeawaterBuoyancy(gravitational_acceleration=g_Europa),; closure = closure,; boundary_conditions = model_bcs,; forcing = forcing; ); ```; Modifications to parent script are minimized if restarting from checkpointer is integrated into model constructor. . The way I have implemented it currently, if restarter is specified in model constructor all other kwargs to `Model` are ignored. @ali-ramadhan thinks this doesn't cover all possible model specification cases. . Any thoughts on how to improve this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/603:812,integrat,integrate,812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/603,2,['integrat'],"['integrate', 'integrated']"
Deployability,"The installation instructions are helpful for users who have downloaded julia. However, to run examples one needs to know how to use git, and also to have a text editor. Neither of these is necessarily trivial so it might be nice both to provide some simple explanations about how to get started with running the examples, and also to link to info about text editing, IDEs, and using github.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149:4,install,installation,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149,1,['install'],['installation']
Deployability,The meridional velocity had the wrong sign in the vector rotation operator for switching from extrinsic to intrinsic coordinates in an `OrthogonalSphericalShellGrid`.; The test was also poorly designed (my bad) and conspired to hide the bug. This PR should fix the rotation and update the test to make sure everything is correct.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3744:278,update,update,278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3744,1,['update'],['update']
Deployability,"The metrics across panels don't seem to be continuous for a `ConformalCubedSphereGrid`. They seem a bit iffy between non-trivial panel connections (e.g. East->North, etc). See, e.g., below. Panel 1 East -> Panel 2 West seems OK; Panel 2 West -> Panel 4 South the metrics don't seem to coincide. ```Julia; using Oceananigans; using Oceananigans.MultiRegion: getregion; using GLMakie. Nx, Ny = 5, 5; H = 3. range_with_offset(N, H, offset::Int) = (-H + 1 + offset*N):(N + H + offset*N). grid = ConformalCubedSphereGrid(panel_size = (Nx, Ny, 1), z = (0, 1), horizontal_direction_halo = H). j_index = 2; i_index = Nx+1 - j_index. fig = Figure(resolution=(2200, 600), fontsize=30); ax = Axis(fig[1, 1]); lines!(ax, range_with_offset(Nx, H, 0), parent(getregion(grid, 1).Δxᶜᶜᵃ)[:, j_index+H], linewidth=4, color = (:green, 0.9), label=""panel 1""); lines!(ax, range_with_offset(Nx, H, 1), parent(getregion(grid, 2).Δxᶜᶜᵃ)[:, j_index+H], linewidth=8, color = (:red, 0.5), label=""panel 2""); lines!(ax, range_with_offset(Ny, H, 2), parent(getregion(grid, 4).Δyᶜᶜᵃ)[i_index+H, :], linewidth=4, color = (:blue, 0.5), label=""panel 4""); vlines!(ax, [1, Nx+1, 2Nx+1, 3Nx+1], linewidth=8, color=(:black, 0.3)); fig[1, 2] = Legend(fig, ax, framevisible = false); fig; save(""metrictest.png"", fig); ```. ![metrictest](https://github.com/CliMA/Oceananigans.jl/assets/7112768/9ed5be14-05b9-4f83-81f5-2d92def37ff5). (thanks to @simone-silvestri)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3254:43,continuous,continuous,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3254,1,['continuous'],['continuous']
Deployability,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308:121,configurat,configuration,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308,3,['configurat'],['configuration']
Deployability,"The typical example for this should be a linear bottom drag, e.g., for `u` a condition `- μ u`. Additionally, the `FieldBoundaryConditions` [docstring](https://github.com/CliMA/Oceananigans.jl/blob/42b2130b0945956632624a17b4d2d28631e1eee4/src/BoundaryConditions/field_boundary_conditions.jl#L103-L128) needs some update to include the `immersed` kwarg. cc @txs156, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2631:313,update,update,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2631,1,['update'],['update']
Deployability,"There have been 78 commits since the last release so I thought it would be good to put out a checkpoint release. Happy to close this PR if people think this is not necessary. Release notes could say:. Checkpoint release including very experimental support for curvilinear grids, a vertically-stretched rectilinear grid, and a preconditioned conjugate-gradient solver. (or nothing at all). There should be no breaking changes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1388:42,release,release,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388,4,"['Release', 'release']","['Release', 'release']"
Deployability,There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598:31,update,updates,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598,1,['update'],['updates']
Deployability,"There was a bug in the earlier v4 releases so Oceananigans won't work with them (this has come up as CUDAv4.0 is the final version compatible with CUDA 10.2). ```julia; julia> using Oceananigans; ┌ Warning: The NVIDIA driver on this system only supports up to CUDA 10.2.0.; │ For performance reasons, it is recommended to upgrade to a driver that supports CUDA 11.2 or higher.; └ @ CUDA ~/.julia/packages/CUDA/ZdCxS/src/initialization.jl:71; julia> grid = RectilinearGrid(GPU(); size = (128, 128, 128), extent = (1, 1, 1)); mo128×128×128 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0078125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0078125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.0078125. julia> model = NonhydrostaticModel(; grid); ERROR: UndefVarError: `CUDABackend` not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:31 [inlined]; [2] device(#unused#::GPU); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/f5Cpw/src/Architectures.jl:39; [3] launch!(::GPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, GPU}, ::Oceananigans.Utils.KernelParameters{:xy, (0, 0)}, ::typeof(Oceananigans.BoundaryConditions._fill_bottom_and_top_halo!), ::Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}}}, ::Vararg{Any}; include_right_boundaries::Bool, r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3402:34,release,releases,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3402,2,"['release', 'upgrade']","['releases', 'upgrade']"
Deployability,"This PR (part 3/3) upgrades the field abstraction so fields store their own boundary conditions. This simplifies the model boundary condition hierarchy and generalizes the field and boundary conditions abstractions so they can be used for a compressible model (and any other model we come up with in the future). All future fields will have boundary conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, nor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:19,upgrade,upgrades,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['upgrade'],['upgrades']
Deployability,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704:130,configurat,configurations,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704,1,['configurat'],['configurations']
Deployability,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/932:220,integrat,integration,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932,2,['integrat'],['integration']
Deployability,"This PR adds a `TurbulenceClosures` module to `Oceananigans`. At the moment nothing in the `Oceananigans` algorithm is touched --- the module is simply loaded and exported. I suggest that we keep it this way, given the size of this PR, and work on integrating the code into `Oceananigans` in a future PR. A simple incremental test in that future PR will be to replace the diffusive operators with the ones here and ensure that the regression tests still pass. Ultimately `TurbulenceClosures` will provide code for all the different diffusive terms we want to provide for `Oceananigans` users. The current design is that a 'closure' must provide a diffusive flux divergence term for `Oceananigans`. These diffusive flux terms are. * `∇_κ_∇ϕ(i, j, k, grid, ϕ, closure, u, v, w, T, S)` for a scalar `ϕ`; * `∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for x momentum; * `∂ⱼ_2ν_Σ₂ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for y momentum; * `∂ⱼ_2ν_Σ₃ⱼ(i, j, k, grid, closure, u, v, w, T, S)` for z momentum. This will have to be generalized if we wish to provide more sophisticated turbulence closures with, for example, backscatter. I am open to changing the name of the diffusive flux divergences. This PR introduces the closures:. * `ConstantSmagorinsky` (with no buoyancy modification --- yet); * `ConstantIsotropicDiffusivity`; * `DirectionalDiffusivity` (with different horizontal and vertical diffusivities --- for lack of a better term). There is also an abstraction --- we have `ScalarDiffusivity`s and `TensorDiffusivity`s. The `DirectionalDiffusivity` is an example of a tensor diffusivity. I would like to add docs before merging. Please review the code and let me know what can be improved while I work on docs, and suggest improvements to the doc strings. There are some unit tests included in this PR. Please take a look and suggest new ones. There is significant notation associated with this PR. I don't think we need to finalize the notation here, but comments are welcome. This PR m",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/234:248,integrat,integrating,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/234,1,['integrat'],['integrating']
Deployability,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:511,configurat,configuration,511,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['configurat'],['configuration']
Deployability,This PR adds a naive fifth-order advection scheme called `UpwindBiasedFifthOrder`. This primarily interesting to see the advantages of the WENO algorithm at the same order of accuracy. ![Square_RungeKutta3_UpwindBiasedFifthOrder_N64_CFL0 50_U+1](https://user-images.githubusercontent.com/15271942/94488260-49440b00-01b0-11eb-985f-ab8aed3892ab.gif). ![Square_RungeKutta3_UpwindBiasedFifthOrder_N64_CFL0 50_U-1](https://user-images.githubusercontent.com/15271942/94488252-46491a80-01b0-11eb-92c3-23b814e44f18.gif). Still need to. - [ ] update convergence tests to include `UpwindBiasedFifthOrder`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/994:534,update,update,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/994,1,['update'],['update']
Deployability,"This PR adds a near-global one degree setup to `validation/near_global_lat_lon`. This is mostly @sandreza and @simone-silvestri 's work. The setup spans -75S to 75N and is implemented on a regular `LatitudeLongitudeGrid` with 1 degree horizontal resolution and 50 vertical levels. It's WIP right now partly because @sandreza is still sorting out some difficulties with including a `IsopycnalSkewSymmetricDiffusivity` closure to this setup. In addition, I'm going to update the `closure_tuples.jl` implementation because this setup may require a tuple of 5 closures. As a teaser, the file `validation/near_global_lat_lon/one_degree_setups/plot_bathymetry.jl` produces. ![image](https://user-images.githubusercontent.com/15271942/164785636-5bbf0e2d-0e0c-458e-9c92-758afbaf96d3.png). The bathymetry file is small (not much larger than few dozen long text files), so I've uploaded it directly into the repo from this PR. If we don't want to do this, I can reopen this PR with the same `.jl` files and download the bathymetry from `OceananigansArtifacts.jl` instead. I'm thinking that we should add at least two one degree setups in this PR:. 1. A ""realistic"" setup with initial conditions and surface relaxation or fluxes loaded from file (which @sandreza is working on). 2. An ""idealized"" setup that uses idealized and constant momentum and temperature forcing (perhaps with `constant_salinity=35.0`). and possibly others. Based on this experience, we can go in a similar direction with the 1/4 degree setup.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463:466,update,update,466,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463,1,['update'],['update']
Deployability,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1090:1209,integrat,integrator,1209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090,1,['integrat'],['integrator']
Deployability,"This PR adds a new nonlinear equation of state, @sandreza's favorite 55-term polynomial approximation to TEOS-10 suitable for Boussinesq models as described in Roquet et al. (2014). The TEOS-10 polynomial approximation implemented in this PR has been translated into Julia from https://github.com/fabien-roquet/polyTEOS/blob/master/polyTEOS10.py (Thank you @fabien-roquet!). The Roquet et al. (2014) paper has some test/check values so I added some basic tests based on those, which pass. There are two things to figure out before merging:; 1. How to make `TEOS10` work with different float types. Right now the coefficients are defined as `const`s but then they're `Float64` by default. Perhaps it makes sense to define them as part of a `TEOS10` struct, but that will make the code a bit messier.; 2. Integrate `TEOS10` with `Oceananigans.Buoyancy` by defining `ρ′`, `thermal_expansion`, and `haline_contraction` functions. We can readily do this, just gotta convert geopotential depth `D` (which Oceananigans uses) to dbar (which `TEOS10` expects).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/731:803,Integrat,Integrate,803,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/731,1,['Integrat'],['Integrate']
Deployability,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1014:606,update,update,606,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014,3,['update'],['update']
Deployability,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1602:680,integrat,integrate,680,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602,1,['integrat'],['integrate']
Deployability,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1371:248,update,update,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371,1,['update'],['update']
Deployability,This PR adds explicit install of required packages for each example. This is related to the discussion in #1149.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1184:22,install,install,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1184,1,['install'],['install']
Deployability,"This PR adds grid topologies: `Periodic`, `Bounded`, and `Singleton`. We should finalize our choice of named before merging. As `topology` is now a required kwarg of all grid constructors tons of refactoring was needed. It also does a bit of cleanup: `AbstractGrid` is now defined in the Grids submodule, and grids no longer have the `Tx, Ty, Tz` property (total number of grid points). Documentation should be updated before this PR is merged. Resolves #446 ; Resolves #459; Resolves #489",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614:411,update,updated,411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614,1,['update'],['updated']
Deployability,"This PR adds the docs dependencies in the `docs/Project.toml` instead of them being added one-by-one via `.travis.yaml`. Furthermore:; - Adds `using Plots` in `docs/make.jl` so that precompilation statements are not captured by Literate.; - Sets `preview=true` in `deploydocs()`. This way, a preview version of what the docs will look like after merge is pushed by Documenter.; - Updates the repository's URL in the docs so that docs are deployed properly. For example, the docs failed to deploy after the recent commit 1e8704c.; .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/753:265,deploy,deploydocs,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753,4,"['Update', 'deploy']","['Updates', 'deploy', 'deploydocs', 'deployed']"
Deployability,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/936:169,Integrat,Integration,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936,1,['Integrat'],['Integration']
Deployability,"This PR aims to add the forced flow analytic test as a verification experiment. The test is described in section 6.1 of [Brown, Cortez, & Minion (2001)](https://doi.org/10.1006/jcph.2001.6715) and is used to test various projection methods for the incompressible Navier-Stokes equations. The reason for implementing this test is to investigate the accuracy of Oceananigans' projection (or fractional step) method following concerns brought up by @sandreza. In particular, we can test whether Oceananigans' time-stepping is indeed second-order accurate in velocity and pressure. A couple of points regarding the accuracy of projection methods for us:; 1. In the introduction to Brown et al. (2001), they heuristically suggest adding a correction term to the pressure update that is linearly proportional to the viscosity ν. To me this suggests that perhaps the accuracy of the projection method matters more at low Reynolds number. The forced flow test uses Re = 1 so it's probably in a regime where the accuracy of the projection method matters a lot.; 2. The entire paper seems to focus on the semi-implicit form of the discrete Navier-Stokes equations where diffusion is treated implicitly. It's unclear to me whether their paper matters to us since we currently treat diffusion completely explicitly. Right now the test blows up (no matter how small the time step). Not sure why. I'll have to investigate and plots things a bit. Most likely I just set things up incorrectly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/573:766,update,update,766,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/573,1,['update'],['update']
Deployability,"This PR aims to introduce and integrate Poisson solvers for vertically stretched grids developed by @christophernhill and @maleadt. Once this is merged alongside with PR #283 we should be able to support vertically stretched grid. For PPN boundary conditions, the system is solved for by eigenvalue-eigenvector factorization via FFTs in the horizontal and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reductio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306:30,integrat,integrate,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306,1,['integrat'],['integrate']
Deployability,"This PR bumps the patch version in order to deploy docs, now that the `DOCUMENTER_KEY` environment variable should be correctly set for the tartarus buildkite agent. Resolves #1909",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1940:18,patch,patch,18,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940,2,"['deploy', 'patch']","['deploy', 'patch']"
Deployability,"This PR changes the names of the `y` and `z` components of the rotation vector for the non-traditional f-plane to `fy` and `fz`. It updates the tests and documentation. It also adds a section about the non-traditional f-plane approximation to the ""physics"" section of the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/617:132,update,updates,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/617,1,['update'],['updates']
Deployability,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1223:29,pipeline,pipeline,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223,3,['pipeline'],['pipeline']
Deployability,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628:16,upgrade,upgrades,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628,1,['upgrade'],['upgrades']
Deployability,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1541:1436,Update,Update,1436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541,1,['Update'],['Update']
Deployability,"This PR fixes a bug where `last_Δt` was incorrect for RK3. This bug was found by @tomchor, cc @jagoosw . Also it removes `previous_Δt` from the QuasiAdamsBashforth2 time-stepper. Note, this affects checkpointing. I also correctly restore `last_Δt` from the checkpoint. I also updated some docstrings just so we have uniform language, replacing ""previous"" with ""last"" in a few places.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3595:276,update,updated,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3595,1,['update'],['updated']
Deployability,This PR fixes a sign error in the implicit dissipative buoyancy flux. We're also recalibrating parameters and will update them here before merging the PR.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3484:115,update,update,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3484,1,['update'],['update']
Deployability,This PR fixes a sign error in the implicit dissipative buoyancy flux. We're also recalibrating parameters and will update them here before merging the PR. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3474:115,update,update,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3474,1,['update'],['update']
Deployability,"This PR implements a field-dependent boundary conditions feature. This is an extension to the boundary conditions API that leaves existing functionality unchanged. The functionality is similar to that for `Forcing`. For quadratic bottom stress acting on the `u`-velocity we'd write. ```julia; u_bottom_stress(x, y, t, u, v, Cd) = - Cd * u * sqrt(u^2 + v^2). bottom_bc = BoundaryCondition(Flux, u_bottom_stress, field_dependencies=(:u, :v), parameters=1e-3); ```. Dealing with the wall-normal velocity components is a bit annoying. For now we don't interpolate them, which leads to different behavior at left and right boundaries (due to the fact that the wall-normal index is assumed to refer to cell centers). Right now this is not much of a practical issue --- it would only affect cases in which wall-normal velocities were non-zero _and_ those values were used in boundary conditions on other fields. One solution is to store ""wall-normal"" indices separately for each of the `field_dependencies`. Then we can correctly infer the boundary index in `regularize_boundary_condition` because we know field locations there. We still need to:. - [x] update boundary conditions docs; - [x] see if any examples can be simplified?. Resolves #897",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1093:1147,update,update,1147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1093,1,['update'],['update']
Deployability,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1373:304,update,updated,304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373,1,['update'],['updated']
Deployability,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2023:985,integrat,integrated,985,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023,1,['integrat'],['integrated']
Deployability,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:546,update,update,546,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['update'],['update']
Deployability,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639:44,integrat,integration,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639,3,"['integrat', 'upgrade']","['integration', 'upgrades']"
Deployability,This PR improves the GPU example on the README and adds some extra notes and warnings about installing Oceananigans and running the examples. I will also add movies (maybe gifs) of rising thermal bubbles so users can visually check that their movie/output matches what we get.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/196:92,install,installing,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/196,1,['install'],['installing']
Deployability,This PR improves the existing examples and updates them to work with the current version of the model. There were also a couple of minor changes:; * Output writer API: Filename suffix is now called a file extension. No more inserting underscores for empty names and filename_prefix. User should include underscore if they want one.; * Model metadata: Use `:CPU` and `:GPU` instead of `:cpu` and `:gpu`. This is so that Oceananigans.jl agrees with the symbols used in GPUifyLoops.jl.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/103:43,update,updates,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/103,1,['update'],['updates']
Deployability,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570:33,update,updates,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570,2,['update'],"['update', 'updates']"
Deployability,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910:133,integrat,integrating,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910,1,['integrat'],['integrating']
Deployability,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302:8,integrat,integrates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302,2,"['configurat', 'integrat']","['configurations', 'integrates']"
Deployability,"This PR integrates the `TurbulenceClosures` module into time stepping and boundary conditions. The need to abstractly deal with anisotropic transport coefficients for arbitrary boundaries introduces considerable complexity. This problem is solved by exporting `NamedTuples` that collect functions to calculate the diagonal components of viscosity and diffusivity at the necessary locations. The consequence of this implementation is viewed in the `apply_bcs!` function. Only the `ConstantAnisotropicDiffusivity`closure (corresponding to the former default) is currently tested. In the future, we should probably make `ConstantIsotropicDiffusivity` the default, and remove the option to set the horizontal and vertical diffusion tensor components in the `Model` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245:8,integrat,integrates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245,1,['integrat'],['integrates']
Deployability,"This PR integrates the finite volume operators introduced in PR #283. This includes merging `closure_operators.jl` into `Oceananigans.Operators`. All tests pass but there's quite a bit of cleanup to be done. @glwagner This PR affects a lot of code you've written so we should probably work on merging this PR together. Now that tests pass we can focus on cleanup. I still need to convert the biharmonic operators and `leith_enstrophy_diffusivity.jl` closure to finite volume. I'll also add a test for Leith. There are regression tests for constant diffusivty, Smagorinsky, and AMD, but not for other closures, so we should probably be careful that closures with no regression test remain unchanged. Some comments:. 1. The `norm` functions defined in `velocity_tracer_gradients.jl` https://github.com/climate-machine/Oceananigans.jl/blob/2bb32015e64bff830f2233d588360ccc6b8605b4/src/TurbulenceClosures/velocity_tracer_gradients.jl#L130-L154 all make use of functions like `Δᶠx_ffc` but they are defined in an `@eval` loop in in `verstappen_anisotropic_minimum_dissipation.jl`. We should probably make it clearer that these functions are closure-specific. 2. In `smagorinsky_lilly.jl`, the `κ_∂x_c`, `κ_∂y_c`, and `κ_∂z_c` functions use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ, closure)` however I'm pretty sure we can just use `ℑxᶠᵃᵃ(i, j, k, grid, νₑ)` here. If so, we can get rid of the `ℑxᶠᵃᵃ(i, j, k, grid::AG{FT}, c, args...)` function definitions. 3. Certain functions are shared between turbulence closures, e.g. `ΣᵢⱼΣᵢⱼᶜᶜᶜ` is used by both `smagorinsky_lilly.jl` and `blasius_smagorinsky.jl`. Should they be moved to `closure_operators.jl`?. 4. Also, VAMD uses `Δᶠxᶜᶜᶜ` for the filter widths while Rozema AMD uses `Δx` (which looks like the regular `Δx` used by `Oceananigans.Operators`). We should probably change all filter widths to use `Δᶠ`. 5. Smagorinsky-Lilly uses `Δᶠ_ccc` for filter widths. Switching to `Δᶠᶜᶜᶜ` is probably a bad idea as `ᶠ` is denotes face. Should we change them to `Δᶠxᶜᶜᶜ = Δᶠyᶜᶜᶜ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/529:8,integrat,integrates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/529,1,['integrat'],['integrates']
Deployability,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1614:161,configurat,configurations,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614,1,['configurat'],['configurations']
Deployability,"This PR introduces a new `ConformalMapping` type for the `OrthogonalSphericalShellGrid` and updates the grid construction to incorporate this type as a parameter. The goal is to enable dispatch over various conformal mapping types (e.g., cubed sphere and tripolar) and embed these mappings directly within the `OrthogonalSphericalShellGrid` structure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3832:92,update,updates,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3832,1,['update'],['updates']
Deployability,"This PR introduces a new reentrant channel model type, the `ChannelModel`, which is periodic in x, has walls in the y-direction, and has the usual rigid lid at the top. It's just a regular `Model` but with no-flux boundary conditions in the y-direction on all fields. The halo regions are filled in appropriately to apply the free-slip boundary conditions. This is nice as we get a channel without having to change the operators or time-stepping at all. @jm-c has pointed out that things could get complicated with this approach when we get to implementing e.g. positivity-preserving advection schemes with having to fill the halo regions very frequently, but we agreed to cross that bridge when we get there. At that point, masks may turn out to be a better approach. It would be nice to have a solid physics test before merging this. Perhaps https://github.com/climate-machine/Oceananigans.jl/issues/100#issuecomment-483255199 would work, although we've had some issues setting up a flow in thermal wind balance (see PR #179). It might still work as an eyeball test. I will release a new minor version once this PR is merged. Resolves #100. Helps with #242 ; Helps with #258",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/290:1076,release,release,1076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/290,1,['release'],['release']
Deployability,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:641,integrat,integrate,641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,1,['integrat'],['integrate']
Deployability,"This PR introduces full upwinding in vector invariant advection, which allows running eddy-permitting/resolving hydrostatic simulations without the need for an explicit viscous dissipation. In addition, it also refactors the whole vector scheme superseding PR #2820 . Examples of surface speed in modified neverworld configuration:. https://user-images.githubusercontent.com/33547697/206742914-d216ea2b-7cd2-4aa5-be70-a760b088698b.mp4. left: full upwinding 1/8th of a degree, no horizontal closure; center: full upwinding 1/4th of a degree, no horizontal closure; right: conservative vector invariant, biharmonic viscosity. Closes #2820",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2852:317,configurat,configuration,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2852,1,['configurat'],['configuration']
Deployability,"This PR investigates the possibility of using a convex combination of high-order stencils to calculate horizontal divergence. The goal is to use a stencil for horizontal divergence that tames the omnipresent grid-scale noise in the vertical velocity field in large-scale hydrostatic models. TODO:. - [ ] Add `divergence` property to `HydrostaticFreeSurfaceModel` and pass stencil info into kernels; - [ ] Update implicit free surface to use the vertical integral of horizontal divergence, rather than vertical integrating the velocity fields separately; - [ ] Fuse `Advection` module into `Operators`? The module `Advection` just defines stencils after all...; - [ ] Implement `UpwindWENO4` and `CenteredWENO5` horizontal divergence stencils",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388:405,Update,Update,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388,2,"['Update', 'integrat']","['Update', 'integrating']"
Deployability,This PR is a hotfix for https://github.com/CliMA/LESbrary.jl/issues/118 and https://github.com/CliMA/Oceananigans.jl/issues/1767. Seems to fix #1767 for me so we could use this branch temporarily if needed until we can actually fix #1767.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1768:13,hotfix,hotfix,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1768,1,['hotfix'],['hotfix']
Deployability,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:148,integrat,integration,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,2,"['integrat', 'update']","['integration', 'updated']"
Deployability,"This PR is part 2 of n implementing halo regions (originally PR #167). n = 2 probably. Here I actually start using the halos and integrate them with the code. This involves filling in the halo regions as needed to enforce the periodic boundary conditions. I also rewrite the operators to use `i-1` and `i+1` instead of `decmod1` and `incmod1`. Hopefully this will speed things up a bit, especially on the GPU. I will release v0.6 once this is merged. Resolves #104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/253:129,integrat,integrate,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253,2,"['integrat', 'release']","['integrate', 'release']"
Deployability,"This PR is still a work-in-progress but I'm opening it to make the future design of the pressure solver module more transparent as we will be adding some new pressure solvers soon, including a conjugate-gradient solver by @christophernhill. # Motivation. In PR #290 I implemented a pressure solver for the `(Periodic, Bounded, Bounded)` channel topology using the 2D fast cosine transform algorithm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmark",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:938,update,updated,938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['update'],['updated']
Deployability,"This PR is to add the basic implementation of immersed boundaries with grid-conforming coordinates #1036. This is still a work in progress, but so far it can handle forcing the velocity components to create an immersed boundary. It does not work with the tracer equations, yet, and it assumes a Dirichlet-zero boundary condition. The user must give a boolean function to the model, which returns `false` if the point is in the fluid. . This also includes a basic example for steady-state flow around a cylinder in 2D `flow_around_cylinder_lowRe.jl`, such as this:; ![velocity_Re40_dx04_small_paper](https://user-images.githubusercontent.com/67593861/108130156-2f329880-707d-11eb-87db-6d519e2513be.gif); ; The barebones of this implementation is rather old at this point. Even though it has been updated to work with the current set up, I imagine there are things that might still need more updating or have become superfluous. All suggestions are appreciated!. ### Description:; Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. In practice, when your boundary conforms to the grids, creating a stair-step like boundary, this becomes much simpler to handle. Here, we replace the tendency terms in `correct_immersed_tendencies.jl` so that when you take the next Runge-Kutta step, you end up with U = 0. . Since this process occurs before the pressure correction, there is a small amount of error that seems to fit with the correction as seen here for various places within the cylinder where it should be zero:; ![Pcorrect_vs_velocity_inside_dx04](https://user-images.githubusercontent.com/67593861/108130321-7ae54200-707d-11eb-9101-273350597d8c.png); ; It would need more testing to truly verify that this is the case, but seems to fit the data so far. ### To Do/ Upcoming:; - Currently working on an arbitrary grid implementation, that can intersect the boundary",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1368:795,update,updated,795,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368,1,['update'],['updated']
Deployability,"This PR just updates and cleans up the lid-driven cavity script. At some point I'd like to add all the validation experiments into CI and into the docs as advanced examples, but this will have to wait for now. The issue is that the script was using `Flat` back when it did nothing but now when using `Flat` you need to pass a 2-tuple for the grid size. I switched the script from `Flat` to `Bounded` until `Flat` is fully working. cc @maeckha. Resolves #1507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1516:13,update,updates,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516,1,['update'],['updates']
Deployability,"This PR makes a few small changes needed to use ContinuousBoundaryFunction with auxiliary fields, which have no notion of ""time"" or other model fields. For this case; we want to be able to write something like. ```julia; c_surface(x, y) = cos(pi * x); c_bcs = FieldBoundaryConditions(grid, (Center, Center, Center), top = ValueBoundaryCondition(c_surface)); c = CenterField(grid, c_bcs); fill_halo_regions!(c.architecture, c); ```. Prior to this PR this would fail (we only supported constant boundary conditions on auxiliary fields). This PR also ""reduces"" the location at which the boundary condition is applied, so that `ReducedField`s might use something like. ```julia; r_surface(x) = cos(pi * x); r_bcs = FieldBoundaryConditions(grid, (Center, Nothing, Center), top = ValueBoundaryCondition(r_surface)); r = ReducedField(Center, Nothing, Center, grid, r_bcs); fill_halo_regions!(r.architecture, r); ```. if we eventually set the location of fields in `Flat` dimensions to `Nothing` this will also have an impact on syntax used for building models. This PR needs a test or two before merging. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1859:48,Continuous,ContinuousBoundaryFunction,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"This PR makes tests and validations pipelines to run using Julia v1.7.; Furthermore, it updates `Manifest.toml` files from v1.0 to v2.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2090:36,pipeline,pipelines,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090,2,"['pipeline', 'update']","['pipelines', 'updates']"
Deployability,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1888:280,update,updates,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888,1,['update'],['updates']
Deployability,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:861,configurat,configuration,861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,1,['configurat'],['configuration']
Deployability,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1971:1353,update,updated,1353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971,2,['update'],['updated']
Deployability,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:492,continuous,continuous,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['continuous'],['continuous']
Deployability,"This PR provides a convenience constructor for building `UniformStokesDrift` with four `Field`s for the Stokes shear and tendency, rather than functions. It also adds kernel functions for the field case, so users now have the choice between functions of `(z, t)`, `Field`s, or `nothing`. This is useful when calculating the Stokes profile is a relatively expensive or involved computation (eg, involving integration over a spectrum of waves). This permits two optimizations:. 1. Stationary Stokes shear profiles can be precomputed.; 2. Time-dependent Stokes shear profiles and Stokes tendencies can be computed in a `Callback`. This saves computation time for 3D runs because the Stokes profiles are 1D.; ; co-authored with @qingli411. TODO: . - [x] add a test",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2320:404,integrat,integration,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2320,1,['integrat'],['integration']
Deployability,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570:559,Update,Updated,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570,1,['Update'],['Updated']
Deployability,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147:381,update,updated,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147,5,"['release', 'update']","['release', 'update', 'updated']"
Deployability,"This PR removes part of the time-stepping algorithm that uses the continuity equation to 'recompute' the vertical velocity at the end of a time-step, after using a fractional step to project the predictor velocity field onto an incompressible field.; This recomputation of vertical velocity relies on a discrete vertical integral of the continuity equation starting at the bottom of the domain and proceeding upwards. The reason for omitting ""w recomputation"" is primarily because vertically integrating the continuity equation _accumulates_ pressure projection round-off error into the vertical velocity field, biased towards the top of the domain. Most models are probably unaffected by this error accumulation and upward bias. However, accumulation of round-off error in a particular part of the domain may become a problem for models with high vertical resolution. The recomputation step also has a computational cost, and the top of the domain is crucial in many oceanographic contexts. The incompressibility of the flow field is still assured without this recomputation step, and it is probable that the velocity field errors are more isotropic and therefore probably more benign. We should note that the error in the _divergence_ is larger without recomputation. However, it probably still falls below acceptable limits, and it does not accumulate in time. With this change the regression tests fail. Also, an ""incompressibility test"" that relies on a measurement of the absolute magnitude of the divergence error fails. We probably simply need to relax the error requirement for the incompressibility test. The regression tests, on the other hand, will have to be regenerated. cc @sandreza @kburns. Resolves #338",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/711:492,integrat,integrating,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/711,1,['integrat'],['integrating']
Deployability,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279:404,configurat,configuration,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279,2,['configurat'],['configuration']
Deployability,"This PR removes the masking of tracers when using IBM. At the moment all tracers are masked inside immersed solids. It's my understanding that these masked values aren't being used in any calculations except for the pressure solver. ~The issue is that having active scalars masked can mess up the pressure solver and lead to some numerical artifacts in some cases. I've noticed some small effects like that in my simulation, but @whitleyv had some more serious spurious dynamics pop up as a result in her simulations that only went away by not masking buoyancy. I'll let @whitleyv herself explain/show what was happening.~. ~For now @whitleyv and I just commented out the lines doing the masking in the nonhydrostatic model, but if we do decide to move forward with this PR I'll clean the code more properly. I was hoping we could discuss a bit before doing that.~. Updated description:. When I originally opened this PR, the masking was creating an issue with the dynamics. However, this turned out to be a bug and was solved by #2603. Now the current situation is that masking is still done for all tracers and velocities in the main branch, but this has zero effect on the results. This PR removes masking when updating `NonhydrostaticModel` and instead masks each output field only when writing to disk, saving computational resources (although just a bit). CC @simone-silvestri @glwagner @wenegrat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2616:866,Update,Updated,866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2616,1,['Update'],['Updated']
Deployability,This PR removes the now out-of-date `restore_from_checkpoint` function and updates the docs. Unfortunately the checkpointer test that was commented out in PR https://github.com/CliMA/Oceananigans.jl/pull/1639 is failing again now when uncommented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1670:75,update,updates,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1670,1,['update'],['updates']
Deployability,"This PR rewrites much of the docs, adds a show function for `Model` and various boundary conditions structures (which fixes very long output in the docs), and updates many of the examples to be docs-friendly. The docs are still very much preliminary even after the updates in this PR. Once this PR is merged, I will open an issue to define a roadmap for getting the docs to the place we need them to be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488:159,update,updates,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488,2,['update'],['updates']
Deployability,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3596:43,integrat,integrating,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596,1,['integrat'],['integrating']
Deployability,"This PR simplifies and generalizes the model constructor, which is a major change to the API. Except for `initialize_tracers` and `float_type`, all of the keyword arguments to `Model` now correspond semantically to the fields of model. In addition to clarifying the arguments of the model constructor, this will make checkpointing easier. . In addition, model fields that contain arrays, and thus are involved with large amounts of memory allocation, can be initialized through the model constructor. This should enable upgrades to the checkpointer that make it possible to checkpoint very large models that fill GPU memory. Finally, we add three new convenience constructors that retain the legacy behavior of model, and provide convenient ways to initialize particular models: `BasicModel`, `BasicChannelModel`, and `NonDimensionalModel`. `BasicModel` and `BasicChannelModel` closely resembles the original model constructor, while `NonDimensionalModel` allow parameters to be set by specifying non-dimensional numbers, rather than dimensional constants. Resolves #372.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/401:520,upgrade,upgrades,520,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/401,1,['upgrade'],['upgrades']
Deployability,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697:880,release,release,880,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697,1,['release'],['release']
Deployability,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/872:112,integrat,integration,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872,3,"['integrat', 'pipeline']","['integration', 'pipelines']"
Deployability,This PR starts the processes of integrating LES functionality from glwagner/pass-tests into Oceananigans master. It is very much WIP at the moment.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/309:32,integrat,integrating,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/309,1,['integrat'],['integrating']
Deployability,This PR supersedes #2488. I have added a remark about installing/using Oceananigans with Julia v1.7 + Apple M1 chips at https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2496:54,install,installing,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2496,2,"['Install', 'install']","['Installation-and-getting-started-with-Oceananigans', 'installing']"
Deployability,"This PR toggles conditional differences with `immersed_inactive_node`, rather than `inactive_node`. The difference is that `inactive_node` returns `true` if the node is outside the domain (either immersed _or_ outside the domain in a `Bounded` direction). `immersed_inactive_node` only returns true if the node is within the immersed boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/ImmersedBoundaries/ImmersedBoundaries.jl#L220-L221. This matters for applying `ValueBoundaryCondition` or `GradientBoundaryCondition` across non-immersed boundaries, on `ImmersedBoundaryGrid`, because both of these are enforced by filling the halo regions on the other side of a `Bounded` direction. Thus we have to be able to correctly evaluate differences / interpolate across non-immersed `Bounded` boundaries. Closes #3208 . We might want to add a test so this doesn't break in the future. It'd also be great to make this code more understandable (suggestions welcome...). @hdrake",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3209:8,toggle,toggles,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209,1,['toggle'],['toggles']
Deployability,"This PR updates CATKE parameters, which was needed after the semi-implicit time-stepping for the TKE equation was introduced in #2426. This PR is all @adelinehillier's work!. The results were generated by training with a 2 minute time-step (previously we had to use time-steps as small as 1 second during training), and are pretty promising:. ![image](https://user-images.githubusercontent.com/15271942/164771409-22f836fc-6ccb-4432-b97b-74de87dbb825.png). The next step is to calibrate and test CATKE at different vertical resolutions. But this is a good start.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2461:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461,1,['update'],['updates']
Deployability,"This PR updates CATKE with an improved model for how the presence of shear modulates the mixing length and turbulent mixing. A few preliminary calibration results suggest that these changes are very promising, especially at coarse resolutions. A short summary is that, originally, CATKE was flexible enough to model both convection and shear-driven mixing --- just not at the same time (because TKE levels are much higher for shear-driven mixing). Adding a more explicit model for the modulation of the mixing length in the presence of shear allows CATKE to capture both convection and shear-driven regimes. We can update the default values for CATKE in this PR as well. This figure is a little out of context, but it shows agreement between LES (gray line) and the ""best parameters"" from a calibration run (blue line) at 8m resolution with five physical scenarios (from LESbrary's 4 day suite). The ""other line"" is the ""worst"" parameters in the calibration ensemble (so that one should be ignored). ![image](https://user-images.githubusercontent.com/15271942/155232297-9fa83269-0383-4f9e-a060-757b3632ce9d.png). Closes #2272",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2273:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273,2,['update'],"['update', 'updates']"
Deployability,"This PR updates PencilFFTs to 0.13.4, and fixes the DistributedFFTBasedPoissonSolver. Previously we were attempting to ""partition"" the eigenvalues manually, which produce an inconsistency between the layout of the spectral-space pressure and the eigenvalues. This PR uses `PencilFFTs.localgrid` to partition the eigenvalues instead, and furthermore correctly identifies `last(solver.storage)` (not `solver.storage[2]`) with the _outcome_ of the in-place spectral transform of pressure. Thanks @jlpolanco especially for patiently enduring my utter inability to read documentation. I believe this should resolve #2347 but we'll need to test that directly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502,1,['update'],['updates']
Deployability,"This PR updates `FieldTimeSeries` to be slightly ""backward compatible"" and capable of loading data from Oceananigans versions that did not have `Field.indices`, or which serialized stretched GPU grids with `CuArray`s. We might have to constantly maintain this... but hopefully eventually structures will be more stable, and eventually we can just delete the stuff added here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2419:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2419,1,['update'],['updates']
Deployability,"This PR updates `examples/ocean_wind_mixing_and_convection.jl` with a new grid generating function that produces a constant grid spacing near the surface. A visualization of the grid spacing is. ![image](https://user-images.githubusercontent.com/15271942/124339919-d3ba0080-db6e-11eb-96f2-999856d9556d.png). @tomchor proposed this idea in #1762, but we couldn't find a suitable generating function and so a grid that becomes ever more refined toward the surface was used instead. I think a grid with constant near-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1810:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810,1,['update'],['updates']
Deployability,"This PR updates `fill_halo_regions!` to pass location information into the kernels. We need location information to correctly assess distances across the wall (eg `Δx`, `Δy`, `Δz`) when filling halos for `ValueBoundaryCondition` and `GradientBoundaryCondition`. After this PR we should be able to use `ValueBoundaryCondition` and `GradientBoundaryCondition` on curvilinear grids and immersed boundary grids. Resolves #2430; Resolves #2369 ; Resolves #1730. There might be a few other issues on this...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2441:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2441,1,['update'],['updates']
Deployability,"This PR updates `fill_halo_regions!` to utilize `field.architecture` (so the `arch` requirement is no longer needed), and generalizes halo filling for `Value` and `Gradient` boundary conditions to curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1731:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1731,1,['update'],['updates']
Deployability,"This PR updates several sections of the Docs to add clarity. In particular:. - Physics/Boussinesq approximation; - Numerical Implementation/Elliptic Solvers/Implicit free surface pressure operator; - Numerical Implementation/Pressure decomposition; - Numerical Implementation/Time-stepping; - `HydrostaticFreeSurfaceModel` docstrings . Also, closes #2653 and closes #2656.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2639:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2639,1,['update'],['updates']
Deployability,This PR updates the Docs/Library section with latest docstrings. Closes #1713.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1714:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1714,1,['update'],['updates']
Deployability,This PR updates the HydrostaticFreeSurfaceModel RHS kernel functions to use the correctly-located pressure gradient for curvilinear grids.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1385:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1385,1,['update'],['updates']
Deployability,"This PR updates the Langmuir turbulence example to have an initial mixed layer 33 meters deep. This initial mixed layer was prescribed by [McWilliams et al. (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38), which escaped me when I first read that paper. Thanks to @qingli411 for alerting me to this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1129:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1129,1,['update'],['updates']
Deployability,"This PR updates the README and cleans it up a bit since it was out of date, and adds a section on ""citing"" Oceananigans.jl and a page with a list of publications using Oceananigans.jl. Open to suggestions if anyone thinks something is missing or could be better!. Resolves #973; Resolves #1101",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1518:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1518,1,['update'],['updates']
Deployability,"This PR updates the `Simulation tips` section in the Docs with the new `show()` methods and latest model constructor args. However, the following does not work and needs attention:. ```julia; julia> using CUDA; CUDA.allowscalar(true). julia> model.velocities.u.data; 3×3×3 OffsetArray(::CuArray{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2:; [:, :, 0] =; Error showing value of type OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}:; ERROR: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:53; [3] getindex(::CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays /g/data/v45/nc3020/.julia/packages/GPUArrays/umZob/src/host/indexing.jl:86; [4] getindex; @ /g/data/v45/nc3020/.julia/packages/OffsetArrays/I5Pfg/src/OffsetArrays.jl:412 [inlined]; [5] getindex; @ ./subarray.jl:276 [inlined]; [6] isassigned(::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, ::Int64, ::Int64); @ Base ./abstractarray.jl:513; [7] alignment(io::IOContext{Base.TTY}, X::SubArray{Float64, 2, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, Tuple{OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, OffsetArrays.IdOffsetRange{Int64, Base.OneTo{Int64}}, Int64}, false}, rows::UnitRange{Int64}, cols::UnitRange{Int64}, cols_if_complete::Int64, cols_otherwise::Int64, sep::Int64)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2316:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316,1,['update'],['updates']
Deployability,"This PR updates the `show()` method for `LatitudeLongitudeGrid` to denote which of the directions is latitude and which is longitude. It also updates the docstring to match the latest syntax. ### Before this PR. ```julia; julia> using Oceananigans. julia> LatitudeLongitudeGrid(size = (10, 4, 5),; latitude = (-40, 40),; longitude = (-20, 20),; z = (-2000, 0),; topology = (Periodic, Bounded, Bounded),; halo = (2, 2, 2)); 10×4×5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 2×2×2 halo and with precomputed metrics; ├── Periodic λ ∈ [-20.0, 20.0) regularly spaced with Δλ=4.0; ├── Bounded φ ∈ [-40.0, 40.0] regularly spaced with Δφ=20.0; └── Bounded z ∈ [-2000.0, 0.0] regularly spaced with Δz=400.0; ```. ### After this PR. ```Julia; julia> using Oceananigans. julia> LatitudeLongitudeGrid(size = (10, 4, 5),; latitude = (-40, 40),; longitude = (-20, 20),; z = (-2000, 0),; topology = (Periodic, Bounded, Bounded),; halo = (2, 2, 2)); 10×4×5 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 2×2×2 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-20.0, 20.0) regularly spaced with Δλ=4.0; ├── latitude: Bounded φ ∈ [-40.0, 40.0] regularly spaced with Δφ=20.0; └── z: Bounded z ∈ [-2000.0, 0.0] regularly spaced with Δz=400.0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2370:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2370,2,['update'],['updates']
Deployability,This PR updates the ancient `test_flux_budget` to be able to test all topologies and boundaries. I've also called it `test_incompressible_flux_budget` since it uses `IncompressibleModel`. This will allow us to generalize `apply_x_bcs` and `apply_y_bcs` to curvilinear grids without fear that we've broken something.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1486:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1486,1,['update'],['updates']
Deployability,This PR updates the baroclinic adjustment validations scripts. Closes #2291,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284,1,['update'],['updates']
Deployability,This PR updates the citation style reference according to changes by [DocumenterCitations.jl v1](https://github.com/JuliaDocs/DocumenterCitations.jl/blob/master/NEWS.md#breaking). Now we can use `(@citet)` and `(@cite)`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3186:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3186,1,['update'],['updates']
Deployability,"This PR updates the code to use kinematic (density normalized) hydrostatic pressure and buoyancy rather than density perturbation. Using kinematic pressure simplifies the code because the reference density no longer affects the algorithm. Using buoyancy instead of the density perturbation will ultimately simplify the code further because it is needed for turbulence closures (for example). The docs should be updated before merging. Also, the golden master tests should be updated elsewhere; then it can be confirmed here that these changes preserve the functioning of the code (these changes do not affect the outcome of the algorithm). I have also copy/pasted an interpolation operator that will become part of the code once #234 is merged. Prior to this PR, the interpolation of the buoyancy field to z faces was done manually. We need a function to calculate buoyancy for the turbulence closures; so I think we are better off deleting the density perturbation function, ultimately. After this change the reference density ceases to be used in the algorithm. I have also included salinity in the calculation of buoyancy.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/236:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/236,3,['update'],"['updated', 'updates']"
Deployability,"This PR updates the dissipation and surface TKE flux parameter for CATKE. These were _not_ updated in #2273, but they should have been. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2374:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2374,2,['update'],"['updated', 'updates']"
Deployability,"This PR updates the docs to provide stronger links to the [new wiki](https://github.com/CliMA/Oceananigans.jl/wiki). There's a few more updates I'd like to make, and perhaps we can completely migrate ""using GPUs"" and ""installation instructions"" over to the new wiki? @tomchor and @navidcy are the docs aficionados so let's see what they think. ~I'd also like to resolve #2471 .~. Closes #2471",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2474:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2474,3,"['install', 'update']","['installation', 'updates']"
Deployability,"This PR updates the examples to account for the fact that `field.data` returns the full offset array including all halos so you need to use `data(field)` which returns a view into the interior of the field with no halos. cc @navidcy internal wave example works for me now. Can you try on this branch?. In hindsight, maybe a more sophisticated fields API would avoid issues like this where we're so reliant on the `data(::Field)` function. Maybe things should ""just work"" for the user. Resolves #254",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/257:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/257,1,['update'],['updates']
Deployability,This PR updates the grid metrics used by `ShallowWaterModel` and adds a masking step to `update_state!` so that `ShallowWaterModel`s can be run on `ImmersedBoundaryGrid`. Co-authored by @francispoulin . Supercedes #1663,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1718:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1718,1,['update'],['updates']
Deployability,This PR updates the instructions for building docs locally. We should avoid `Pkg.develop()` since we are offering a `docs/Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707,1,['update'],['updates']
Deployability,"This PR updates the instructions for building the docs locally. @tomchor, @francispoulin: could you let me know if these new instructions do the job for you? Please try on a fresh clone of the repo. Closes #1542. (Or at least that's the hope....)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1772:8,update,updates,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772,1,['update'],['updates']
Deployability,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693:15,continuous,continuous,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693,1,['continuous'],['continuous']
Deployability,"This PR will implement support boundary conditions on immersed boundaries. The design is to add a new function to the tendency kernel function for each field that represents the contribution to the viscous / diffusive flux divergence in boundary-adjacent cells due to the user-defined immersed boundary condition. This PR will support `Flux` boundary conditions for sure. If it turns out to be simple, this PR will also support `Value` / `Gradient` boundary conditions for `ScalarDiffusivity`. There may be some challenges when `ScalarDiffusivity` is embedded in a closure tuple (ie the case we get for wall-resolved LES). Hopefully the solution to that is not too complicated. Another problem to solve is how to ""regularize"" `ContinuousBoundaryFunction`. Immersed boundary conditions are 3D, so function of `i, j, k`. Thus we need a slightly different interface for them. `discrete_form=true` will also have a different signature (`i, j, k, grid, ...` rather than `i, j, grid, ...`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437:727,Continuous,ContinuousBoundaryFunction,727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,This PR. - updates Docs/Grids page; - updates Docs/Architectures page; - updates Docs/Number types page; - resurrects the Docs/Callbacks page. Closes #3275; Closes #3456,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3454:11,update,updates,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3454,3,['update'],['updates']
Deployability,"This PR:; - The Langmuir example currently claims that the buoyancy flux in the 2021 paper is `2.307e-9 # m² s⁻³, surface buoyancy flux` and sets up the buoyancy flux accordingly. But the paper actually sets up a flux of `2.307e-8` so I changed that (I think it was a typo). @glwagner can you please confirm that I'm not missing anything?. - Updates the CPU -> GPU functionality done via grid constructor instead via model in the Ocean wind mixing example. Docs should render here: It should render here: https://clima.github.io/OceananigansDocumentation/previews/PR2646",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2646:342,Update,Updates,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2646,1,['Update'],['Updates']
Deployability,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744:597,update,updated,597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744,2,"['integrat', 'update']","['integrated', 'updated']"
Deployability,This bot automatically suggests updates of GitHub action workflows.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3149:32,update,updates,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3149,1,['update'],['updates']
Deployability,"This captures a few changes, such as updates to `show`, `Callback` `parameters`, new field types, and boundary condition validation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2172:37,update,updates,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2172,1,['update'],['updates']
Deployability,This draft PR is for bringing in support for AMD GPUs.; Status updates will be dropped in the comments.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468:63,update,updates,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468,1,['update'],['updates']
Deployability,"This fixes the error we were getting when writing `Field`s reduced over 3 dimensions to disk with `NetCDFOutputWriter` according to the upstream provided in a PR at NCDatasets: https://github.com/Alexander-Barth/NCDatasets.jl/issues/197. This PR also adds a test to catch this in the future. For now this is only working on the `master` branch of `NCDatasets` so tests should fail for now, but once a new version of NCDatasets is released I'll update the packages. Closes https://github.com/CliMA/Oceananigans.jl/issues/2857",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865:430,release,released,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865,2,"['release', 'update']","['released', 'update']"
Deployability,This has drifted a bit from latest APIs. . This updates to make validation cube sphere eddying aquaplanet great again. . Will allow to be used to start testing @simone-silvestri @jm-c @glwagner fixed up immersed boundaries with functioning implicit vertical terms plus working stretched grid 👍 awesomeness.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2170:48,update,updates,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2170,1,['update'],['updates']
Deployability,"This introduces `UpwindBiasedFirstOrder` advection, and is in part inspired by #1955. This scheme is first order accurate but has the advantage of preserving positivity and extrema. The plot for convergence is updated and we see that it does have the slope that is predicted from the theory. ![convergence_rates](https://user-images.githubusercontent.com/8239041/130524906-d3afbae0-651d-4c9a-aee8-b0fb4d9dc856.png). I set the `symmetric_interpolate`'s to zero, which I think is true, but not sure if anything else should be done here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1957:210,update,updated,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957,1,['update'],['updated']
Deployability,"This is a temporary fix for #1280 (time stepping a model with `pickup=true` -> it blows up) until schedules can be probably checkpointed. While this is a temporary fix, it has affected a number of people already (@qwert2266, @suyashbire1, @sandreza, and now @sam12396 in #1300) so would be good to merge this and tag a new release.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1303:323,release,release,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303,1,['release'],['release']
Deployability,This is a very minor update just to make the plotting command in the Ocean mixing and convection example a bit more general and self-contained. This makes it easier for people to copy-paste that snippet and have it work out of box (I do that frequently for example).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2238:21,update,update,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238,1,['update'],['update']
Deployability,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360:669,integrat,integration,669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360,2,['integrat'],['integration']
Deployability,This is an important tag/release because the model now has `k=1` at the bottom which effects post-processing and plotting scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/494:25,release,release,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/494,1,['release'],['release']
Deployability,"This is finishing up some work I started last October on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:901,integrat,integrate,901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,1,['integrat'],['integrate']
Deployability,This is mostly to fix the CUDA dependency issues we're currently getting on the CI pipelines. We will live dangerously on four `#master` dependencies!; ```; ] add CuArrays#master CUDAnative#master CUDAdrv#master NNlib#master; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/197:83,pipeline,pipelines,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/197,1,['pipeline'],['pipelines']
Deployability,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1634:616,update,updated,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634,2,['update'],"['update', 'updated']"
Deployability,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1930:31,update,updated,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930,1,['update'],['updated']
Deployability,"This issue appears on v1.8.0-rc1 so I understand if it is not a priority.; Oceananigans version: So far reproduced in v0.76.6 and v0.76.5; To reproduce, in the REPL:; *The error does not prevent the fields from been created* but it is a pain to do interactive work with it.; ```julia; pkg> activate --temp; pkg> add NetCDF_jll@400.802.103, Oceananigans ; #NCDatasets latest release does not work with v1.8.0-rc1; julia> using Oceananigans; julia> grid = RectilinearGrid(CPU(),size = (10, 10),; x = (0, 100), y = (0, 100),; topology = (Periodic, Periodic, Flat), halo = (3, 3)); julia> myfield = CenterField(grid); ```. Outputs:. ```julia; Error showing value of type Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}:; ERROR: MethodError: no method matching initarray!(::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, ::typeof(Base.add_sum), ::Bool, ::SubArray{Float64, 3, Array{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663:374,release,release,374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663,1,['release'],['release']
Deployability,"This issue is used to trigger TagBot; feel free to unsubscribe. If you haven't already, you should update your `TagBot.yml` to include issue comment triggers.; Please see [this post on Discourse](https://discourse.julialang.org/t/ann-required-updates-to-tagbot-yml/49249) for instructions and more details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1154:99,update,update,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1154,2,['update'],"['update', 'updates-to-tagbot-yml']"
Deployability,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551:955,continuous,continuous,955,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551,2,['continuous'],['continuous']
Deployability,"This issue will help to combine several outstanding issues involving the `ShallowWaterModel.jl`. I suggest the following in this order:. - [ ] Fix inconsistent tendencies in the two models (#2928); - [ ] Fix up shallow water regression tests (#3049); - [ ] Add viscosity; - [ ] Speed up shallow water example when building docs (#3151); - [ ] Make shallow water Bickley jet less expensive (#3169); - [ ] Update immersed bondaries validation scripts (#2985); - [ ] Introduce multi-layer shallow water model (#2507); - [ ] Validate positive preserving WENO schemes. For the first part, I put together this document that shows and derives the equations for the two different models. Next I will look at the tendencies. . Any suggestions on what else to do, or what to do differently, are welcome!. [ShallowWaterModel_eqns.pdf](https://github.com/CliMA/Oceananigans.jl/files/13393977/ShallowWaterModel_eqns.pdf)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3394:404,Update,Update,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3394,1,['Update'],['Update']
Deployability,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1893:594,update,updated,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893,1,['update'],['updated']
Deployability,This may resolve #1601 . We'll need to test manually I think since we don't want to update the whole `Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1621:84,update,update,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1621,1,['update'],['update']
Deployability,"This pull request sets the compat entry for the `AMGX` package to `0.1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2738:330,release,release,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2738,1,['release'],['release']
Deployability,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1673:397,release,release,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673,1,['release'],['release']
Deployability,"This pull request sets the compat entry for the `BenchmarkTools` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2517:338,release,release,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2517,2,['release'],['release']
Deployability,"This pull request sets the compat entry for the `CUDA` package to `4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3070:328,release,release,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3070,1,['release'],['release']
Deployability,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1474:383,patch,patch,383,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474,2,"['patch', 'release']","['patch', 'release']"
Deployability,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1102:369,patch,patch,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102,2,"['patch', 'release']","['patch', 'release']"
Deployability,"This pull request sets the compat entry for the `IncompleteLU` package to `0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2124:338,release,release,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2124,1,['release'],['release']
Deployability,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2123:342,release,release,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123,1,['release'],['release']
Deployability,"This pull request sets the compat entry for the `PencilArrays` package to `0.16`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2539:339,release,release,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2539,1,['release'],['release']
Deployability,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1475:379,patch,patch,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475,2,"['patch', 'release']","['patch', 'release']"
Deployability,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/898:387,patch,patch,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898,2,"['patch', 'release']","['patch', 'release']"
Deployability,"This pull request sets the compat entry for the `SeawaterPolynomials` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SeawaterPolynomials` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/751:399,patch,patch,399,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/751,4,"['patch', 'release']","['patch', 'release']"
Deployability,"This pull request sets the compat entry for the `Statistics` package to `1`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3366:334,release,release,334,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3366,1,['release'],['release']
Deployability,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1563:381,release,release,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563,1,['release'],['release']
Deployability,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/891:5,release,release,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891,3,"['Release', 'release', 'update']","['Release', 'release', 'updates']"
Deployability,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272:207,update,update,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272,1,['update'],['update']
Deployability,"This test is to stop the error below from reappearing (once the test is fixed!). . ```; nested task error: MethodError: no method matching (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}})(::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1928:174,Continuous,ContinuousBoundaryFunction,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,"This warning appears in the log when we run the simulation:. ```Julia; ┌ Warning: some parameters could not be resolved for type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,24,Main.__atexample__named__ocean_wind_mixing_and_convection.#Qˢ,Float64,Tuple{Symbol},Tuple{Int64},Tuple{typeof(Oceananigans.Operators.identity4)}}; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/1i6ZM/src/data/reconstructing_datatypes.jl:440; ```. See, e.g., https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/. Is this something we need to address or make the example better so that it does not appear? Users might be intimidated...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1775:161,Continuous,ContinuousBoundaryFunction,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1775,1,['Continuous'],['ContinuousBoundaryFunction']
Deployability,This was my last attempt to integrate the vertically stretched grid into Oceananigans. This branch is probably too old and stale to be rebased so I'm just opening it so we can see the state of the branch. Will probably start a new branch and copy paste a lot of this stuff into there.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1332:28,integrat,integrate,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332,1,['integrat'],['integrate']
Deployability,"This will be one big PR that merges in; 1. code/interface documentation from docstrings,; 2. high-level documentation about the continuous equations and numerical methods employed,; 3. documentation about the verification experiments, and; 4. generated Markdown tutorials from the Literate.jl examples. Once we're happy with the documentation, we'll be ready to submit an entry to the *Journal of Open Source Software*. High-level documentation can be found at: https://www.overleaf.com/project/5d73051a46be42000164d1ef. ## Documentation contents; 1. Documentation home page (+ package description); 2. Continuous equations; 3. Numerical methods; 	1. Overview of time-stepping algorithm; 	2. Finite volume method; 	3. Staggered grid; 	4. Fractional step method; 5. Time stepping; 6. Spatial operators; 7. Poisson solvers; 8. Boundary conditions; 9. Turbulence closures; 10. Large eddy simulation; 4. Model setup (description of all the options); 5. Examples; 	1. Simple diffusion; 2. Two-dimensional turbulence; 3. Ocean wind mixing and convection; 4. Ocean convection with plankton; 5. Internal wave; 6. Thermal rising bubble?; 7. Lid-driven cavity?; 8. Eddying channel?; 6. Verification experiments; 1. Taylor-Green vortex; 2. Lid-driven cavity?; 3. Stratified Couette flow; 4. Free convection (Split into ocean and Kato & Phillips?); 7. Gallery (movies!); 8. Performance benchmarks; 9. Documentation of public (+ private?) user interface; 10. References section (if we want to store them all on one page). ## References in the docs; Unfortunately there is no support for bibtex citations/references in Documenter.jl and we have a lot of them =/ This has been brought up by @simonbyrne and @charleskawczynski: https://github.com/climate-machine/CLIMA/issues/152. For now I've just copy pasted stuff from the LaTeX document and left in the `\citet` and `\citep` commands. But we have a few options:; 1. Painstakingly format all the citations and references by hand using Markdown footnotes.; 2. Cite ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/474:128,continuous,continuous,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/474,2,"['Continuous', 'continuous']","['Continuous', 'continuous']"
Deployability,This won't pass tests until https://github.com/CliMA/SeawaterPolynomials.jl/pull/20 is merged and registered. We also need to update `Manifest.toml`. Closes #2528. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2529:126,update,update,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2529,1,['update'],['update']
Deployability,"This would be nice because most people might first install Oceananigans on their laptop without a GPU or CUDA toolkit, and are greeted with error messages that e.g. CUDAdrv failed to build. While harmless errors, they don't look nice and make the package seem unstable. This would also speed up Travis CI and Appveyor builds. ---; Relevant bits from `Pkg.instantiate()`:; ```; ┌ Error: Error building `CUDAdrv`: ; │ Could not find CUDA driver library.; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAnative`: ; │ Dependent package CUDAdrv.jl has not been built successfully.; │ ; │ This is not a fatal error, but GPU functionality will be unavailable.; │ If you expected this to work, please open a thread on; │ https://discourse.julialang.org/c/domain/gpu; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; │ Dependent package CUDAdrv.jl has not been built successfully; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error buildin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:51,install,install,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['install'],['install']
Deployability,This would make building and deploying docs much faster and allow us to scale up to having higher-resolution examples (and more of them). X-Ref: #1051,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1053:29,deploy,deploying,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1053,1,['deploy'],['deploying']
Deployability,Time step should be updated before simulation callback/progress function,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1251:20,update,updated,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1251,1,['update'],['updated']
Deployability,"To asynchronously fill the halos of distributed fields, the code uses an incremental counter to track how many MPI requests are live and update the MPI send and receive tag. The counter is reset when communication is synchronized. As it is defined right now, the counter is always incremented at the end of a `fill_halo_regions!` on a distributed grid, irrespective of what happened in the `fill_halo_regions!`, with the assumption that all cores participate in the `fill_halo_regions!` so the counters are correctly synchronized. ; https://github.com/CliMA/Oceananigans.jl/blob/315e66bb330b44acc2a0daf74ae357ee66e801d1/src/DistributedComputations/halo_communication.jl#L117-L121. Unfortunately, I experienced a situation where this was not the case. ; In this case, I wanted to do different things on different cores, which is allowed when using the `only_local_halos = true` keyword argument (a very rare occurrence, but a possibility nonetheless). For example, if we execute this code on the main branch; ```julia; arch = Distributed(CPU()); grid = RectilinearGrid(size = (2, 2, 1), extent = (1, 1, 1)); c = Field(grid). if arch.local_rank == 0; fill_halo_regions!(c; only_local_halos = true); end; ```; The mpi_tag will be `1` on rank 0 and `0` on other ranks. This means that in subsequent halo passes, MPI will stall because it cannot match the tag between the send and receive operations of cores that communicate with rank 0. This PR fixes this issue by incrementing the counter _only_ if we have actually launched a mpi send or receive operation, that happens when at least one of the `bcs` is a distributed boundary condition _and_ `only_local_halos == false`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3714:137,update,update,137,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3714,1,['update'],['update']
Deployability,"To be merged once #1093 and #1099 are in. Release notes:. * Adds support for ""picking up"" a simulation from a checkpoint via the keyword `pickup=true`, `pickup=checkpoint_iteration::Int` and `pickup=checkpont_filepath::String` in `run!(simulation)` (#1082). * Adds a function `set!(model, checkpoint_filepath)` for ""setting"" a model state to the state recorded in a checkpoint file (#1082). * Adds support for ""field-dependent"" boundary conditions similar to field-dependent forcing terms (#1093). * Beautifies and cleans up many of the examples, including getting them to build faster on Travis (#1099)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1103:42,Release,Release,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1103,1,['Release'],['Release']
Deployability,"Today @qingli411 and I attempted to install `Oceananigans` on his laptop, but ran into a problem when the HDF5 compilation (through julia) stalled for something like 15 minutes. We were only able to proceed by completely removing the dependency of `Oceananigans` on HDF5 and NetCDF (after which we got the code to run!). I think we should consider moving heavy dependencies like HDF5 and NetCDF into separate packages (say, `OceananigansOutput.jl`) to make a simple barebones installation of `Oceananigans` quick, easy, and painless.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284:36,install,install,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284,2,['install'],"['install', 'installation']"
Deployability,Toggle immersed differences with immersed_inactive_node,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3209:0,Toggle,Toggle,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3209,1,['Toggle'],['Toggle']
Deployability,Travis can't deploy docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/808:13,deploy,deploy,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/808,1,['deploy'],['deploy']
Deployability,Triggers tagbot to register update to v0.53.1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1473:28,update,update,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1473,1,['update'],['update']
Deployability,"Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.For",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:2330,Continuous,ContinuousForcing,2330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Continuous'],['ContinuousForcing']
Deployability,"UG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:13307,Release,Release,13307,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Release'],['Release']
Deployability,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:103,update,update,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['update'],['update']
Deployability,Unexpected behavior in NetCDF writer after upgrade to 0.44.2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1227:43,upgrade,upgrade,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227,1,['upgrade'],['upgrade']
Deployability,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1552:70,update,updated,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552,1,['update'],['updated']
Deployability,Until we figure out why v1.3 and DEV jobs time out on GitLab CI we can just allow v1.3 to fail. v1.3 hasn't been released yet so makes sense to allow failures anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/467:113,release,released,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/467,1,['release'],['released']
Deployability,Update 3D matplotlib scripts to read NetCDF output.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/135:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/135,1,['Update'],['Update']
Deployability,Update Buildkite version on Tartarus and Sverdrup,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3751:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751,1,['Update'],['Update']
Deployability,Update CATKE numerics and implement MEWSVerticalDiffusivity for mesoscale interfacial form stress,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2864:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2864,1,['Update'],['Update']
Deployability,Update CATKE parameters for new implicit time-stepping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2461:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2461,1,['Update'],['Update']
Deployability,Update CUDA,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005,1,['Update'],['Update']
Deployability,Update CUDA and CUDAKernels take #2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2255:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2255,1,['Update'],['Update']
Deployability,Update CUDA packages,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/713:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/713,1,['Update'],['Update']
Deployability,Update CUDA packages (attempt 2),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/388:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388,1,['Update'],['Update']
Deployability,Update CUDA packages to get rid of CUDA errors on CPU and use CUDAapi.has_cuda(),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/378:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/378,1,['Update'],['Update']
Deployability,Update CUDA to v4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2902:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2902,1,['Update'],['Update']
Deployability,Update CUDAKernels and KernelAbstractions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1830:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1830,1,['Update'],['Update']
Deployability,Update Coord system and Notation page in docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1779:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1779,1,['Update'],['Update']
Deployability,Update CubedSpheres,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2506:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2506,1,['Update'],['Update']
Deployability,Update Docs authors,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2310:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2310,1,['Update'],['Update']
Deployability,Update Docs/API Library section,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1714:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1714,1,['Update'],['Update']
Deployability,Update Docs/Model setup pages + fix bug with `callsite=TendencyCallsite()` in Callbacks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3454:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3454,1,['Update'],['Update']
Deployability,Update Docs/Model/Output Writers to replace `FieldSlicer` -> `indices`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3350:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3350,1,['Update'],['Update']
Deployability,Update Docs/Simulation tips,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2316:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2316,1,['Update'],['Update']
Deployability,Update Documenter v0.26.2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1387:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1387,1,['Update'],['Update']
Deployability,Update GitLab CI to run GPU code coverage,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/278:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/278,1,['Update'],['Update']
Deployability,Update JLD2 to v0.2.4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1039:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1039,1,['Update'],['Update']
Deployability,Update Julia version warning,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3182:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3182,1,['Update'],['Update']
Deployability,Update LICENSE,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3033:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3033,1,['Update'],['Update']
Deployability,Update NCDatasets to v0.13,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3313:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3313,1,['Update'],['Update']
Deployability,Update OffsetArrays compat entry to v1.4+,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1240:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1240,1,['Update'],['Update']
Deployability,Update PencilArrays,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2552:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2552,1,['Update'],['Update']
Deployability,Update PencilArrays and PencilFFTs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2544:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2544,1,['Update'],['Update']
Deployability,Update PencilFFTs and GPUArrays and fix DistributedFFTBasedPoissonSolver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2502:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2502,1,['Update'],['Update']
Deployability,Update Performance Benchmarks in Docs and README,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1676:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1676,1,['Update'],['Update']
Deployability,Update Physics Docs for the various Models,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1690:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690,1,['Update'],['Update']
Deployability,Update README and fix broken links,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/608:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/608,1,['Update'],['Update']
Deployability,Update README badges,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1060:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1060,1,['Update'],['Update']
Deployability,Update README to use latest syntax,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2357:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2357,1,['Update'],['Update']
Deployability,Update README.md,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/681:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/681,2,['Update'],['Update']
Deployability,Update README: bitly to direct link,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/800:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/800,1,['Update'],['Update']
Deployability,Update README: installation instructions and development team,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/396:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/396,2,"['Update', 'install']","['Update', 'installation']"
Deployability,Update SWE immersed boundaries validation scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2985:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2985,1,['Update'],['Update']
Deployability,Update Smagorinsky-Lilly model,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908,1,['Update'],['Update']
Deployability,Update TARTARUS_HOME to `/storage5`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1920:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920,1,['Update'],['Update']
Deployability,Update TagBot.yml,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1158:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1158,1,['Update'],['Update']
Deployability,Update `DiffusiveCFL` docstring,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/554:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/554,1,['Update'],['Update']
Deployability,Update `ImplicitFreeSurface` & `HeptadiagonalIterativeSolver` docstrings,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2621:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2621,1,['Update'],['Update']
Deployability,Update `JLD2OutputWriter` calls,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2504:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2504,1,['Update'],['Update']
Deployability,Update `NetCDFOutputWriter` docstring and clobber default,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556,1,['Update'],['Update']
Deployability,Update `Oceananigans.CubedSpheres` to correctly import `error_if_nan_in_field`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2069:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2069,1,['Update'],['Update']
Deployability,Update `ShallowWaterModel` to use areas,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2612:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2612,1,['Update'],['Update']
Deployability,Update `TimeStepWizard`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248,1,['Update'],['Update']
Deployability,Update `TimeStepWizard` docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2920:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2920,1,['Update'],['Update']
Deployability,Update `Utils.versioninfo_with_gpu()`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/875:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/875,1,['Update'],['Update']
Deployability,Update `baroclinic_adjustment.jl` in validations exps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2545:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2545,1,['Update'],['Update']
Deployability,Update `near_global_quarter_degree.jl`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2593:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2593,1,['Update'],['Update']
Deployability,Update `pressure_correct_velocities` so that `NonhydrostaticModel.velocities` are divergence-free on `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2892:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2892,1,['Update'],['Update']
Deployability,Update `resting_stratified_bumpy_ocean.jl`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2993:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2993,1,['Update'],['Update']
Deployability,Update `time_step!` docstring for AB2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3674:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3674,1,['Update'],['Update']
Deployability,Update and test benchmarks,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/727:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/727,1,['Update'],['Update']
Deployability,Update architecture in distributed benchmark scripts,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338,1,['Update'],['Update']
Deployability,Update badges in README,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1092:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1092,1,['Update'],['Update']
Deployability,Update benchmarks for JOSS,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/850:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850,1,['Update'],['Update']
Deployability,Update benchmarks.md,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2680:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2680,1,['Update'],['Update']
Deployability,Update benchmarks.md - attempt 2.0,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1952:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1952,1,['Update'],['Update']
Deployability,Update boundary_conditions.md,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1687:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1687,2,['Update'],['Update']
Deployability,Update climacommon to 2024_04_05,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3541:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3541,1,['Update'],['Update']
Deployability,Update climacommon to 2024_04_30,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3571:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3571,1,['Update'],['Update']
Deployability,Update climacommon to 2024_05_27,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3608:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3608,1,['Update'],['Update']
Deployability,Update climacommon to 2024_10_09,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3838:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3838,1,['Update'],['Update']
Deployability,Update compat entries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1065:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1065,1,['Update'],['Update']
Deployability,Update compat for `SeawaterPolynomials`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2529:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2529,1,['Update'],['Update']
Deployability,Update contributing.md to use `main` not `master`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2994:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2994,1,['Update'],['Update']
Deployability,Update convecting plankton example to more closely resemble Taylor and Ferrari (2011),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128,1,['Update'],['Update']
Deployability,Update cubed sphere 32 grid file sha256 checksum,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1552:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552,1,['Update'],['Update']
Deployability,Update dependencies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/860:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/860,10,['Update'],['Update']
Deployability,Update dependencies + use Documenter v1,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3310:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3310,1,['Update'],['Update']
Deployability,Update dependencies and use Julia 1.9.3 for CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3258:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3258,1,['Update'],['Update']
Deployability,Update dependency packages,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2447:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2447,1,['Update'],['Update']
Deployability,Update deps,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2919:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2919,3,['Update'],['Update']
Deployability,Update deps versions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2368:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2368,1,['Update'],['Update']
Deployability,Update dissipation and surface TKE flux parameters for CATKE,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2374:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2374,1,['Update'],['Update']
Deployability,Update docs to change `FieldSlicer` to `indices`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3348:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3348,1,['Update'],['Update']
Deployability,"Update docs to point to discussions, wiki, etc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2474:0,Update,Update,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2474,1,['Update'],['Update']
